

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/MyInfo/%E5%A4%B4%E5%83%8F.jpg">
  <link rel="icon" href="/img/MyInfo/%E5%A4%B4%E5%83%8F.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yangtao">
  <meta name="keywords" content="">
  
    <meta name="description" content="引言在现代应用中，数据一致性与安全性常常由数据库事务来保障——只有当一系列操作（插入、更新、删除等）被当作一个不可分割的逻辑单元时，我们才能确保系统在面对并发和故障时依然保持可靠。MySQL 中，特别是 InnoDB 存储引擎，通过 Undo&#x2F;Redo 日志、MVCC、间隙锁与下一键锁（Next-Key Lock）、以及两阶段提交等机制实现了高效而灵活的事务管理。本文将从事务的定义及四大特性出发，">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL事务">
<meta property="og:url" content="http://example.com/2022/07/18/mysql-transaction/index.html">
<meta property="og:site_name" content="Yangtao&#39;s space">
<meta property="og:description" content="引言在现代应用中，数据一致性与安全性常常由数据库事务来保障——只有当一系列操作（插入、更新、删除等）被当作一个不可分割的逻辑单元时，我们才能确保系统在面对并发和故障时依然保持可靠。MySQL 中，特别是 InnoDB 存储引擎，通过 Undo&#x2F;Redo 日志、MVCC、间隙锁与下一键锁（Next-Key Lock）、以及两阶段提交等机制实现了高效而灵活的事务管理。本文将从事务的定义及四大特性出发，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/mysql.webp">
<meta property="article:published_time" content="2022-07-18T07:26:09.000Z">
<meta property="article:modified_time" content="2022-07-18T07:26:09.000Z">
<meta property="article:author" content="Yangtao">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="MySQL事务">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/mysql.webp">
  
  
  <title>MySQL事务 - Yangtao&#39;s space</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Programmer Yangtao</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                作者
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/mysql.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MySQL事务">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Yangtao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-18 15:26" pubdate>
        2022年7月18日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      26 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL事务</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：3 年前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代应用中，数据一致性与安全性常常由数据库事务来保障——只有当一系列操作（插入、更新、删除等）被当作一个不可分割的逻辑单元时，我们才能确保系统在面对并发和故障时依然保持可靠。MySQL 中，特别是 <code>InnoDB</code> 存储引擎，通过 <code>Undo/Redo</code> 日志、<code>MVCC</code>、间隙锁与下一键锁（<code>Next-Key Lock</code>）、以及两阶段提交等机制实现了高效而灵活的事务管理。本文将从事务的定义及四大特性出发，深入介绍 MySQL 事务的隔离级别与内部机制，并探讨在高并发场景下如何对事务进行调优，以保障数据库的正确性与性能。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>事务（<code>Transaction</code>）是数据库管理系统中一组被视为一个逻辑单元的操作序列，这些操作要么全部执行成功，要么在出现错误时全部撤销，确保数据库状态的一致性。事务主要用于确保数据库在面对并发访问和故障时能够保持数据的正确性和完整性。</p>
<ul>
<li><strong>逻辑单位</strong>：事务通常包含多个 SQL 语句，这些语句共同完成一个业务逻辑，例如转账操作需要同时扣款和存款，这两个操作必须同时成功才能保证数据正确。</li>
<li><strong>原子性</strong>：事务中的操作不可分割，要么全部执行成功，要么全部失败（即回滚）。</li>
<li><strong>应用场景</strong>：在银行、订单处理、库存管理等需要确保多步骤操作完整性的场景中，事务起到了关键作用。</li>
</ul>
<h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><p>事务的四大特性通常被称为 <code>ACID</code>，这四个字母分别代表：</p>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><ul>
<li><strong>定义</strong>：原子性指的是事务中的所有操作被视为一个原子操作单元。若其中某个操作失败，整个事务中的所有操作都必须回滚，使数据库返回到事务开始前的状态。</li>
<li><strong>实现机制</strong>：数据库通过日志（如 <code>Undo Log</code>）记录事务中每一步操作的反向操作，以便在事务失败时进行回滚。</li>
</ul>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><ul>
<li><strong>定义</strong>：一致性确保事务在执行前和执行后，数据库都处于一个合法的状态，即满足所有的完整性约束、业务规则和触发器规定。</li>
<li><strong>实现机制</strong>：数据库设计时定义的数据完整性约束（如主键、外键、唯一性约束等）以及业务逻辑能够保证一致性。当事务完成时，所有数据变更必须保持这些规则不被破坏。</li>
</ul>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><ul>
<li><strong>定义</strong>：隔离性指多个并发事务在执行过程中彼此独立，互不干扰。每个事务都应该感觉自己是数据库中唯一在运行的事务，不会受到其他并发事务的中间状态影响。</li>
<li><strong>具体问题</strong>：<ul>
<li><strong>脏读（Dirty Read）</strong>：一个事务读取了另一个未提交事务的数据。</li>
<li><strong>不可重复读（Non-Repeatable Read）</strong>：同一事务中，两次读取同一数据得到不同结果，因为其他事务修改并提交了该数据。</li>
<li><strong>幻读（Phantom Read）</strong>：在同一事务中，两次查询返回的记录集不同，通常是由于其他事务插入或删除了满足查询条件的记录。</li>
</ul>
</li>
</ul>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><ul>
<li><strong>定义</strong>：持久性保证一旦事务提交，对数据库的修改将永久保存下来，即使系统发生崩溃也不会丢失。</li>
<li><strong>实现机制</strong>：通过日志（如 <code>Redo Log</code>）和物理存储设备（磁盘）的数据同步（如刷盘策略），确保提交后的数据能够被恢复。</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>隔离级别决定了并发事务之间的相互影响程度。SQL 标准定义了四种隔离级别，MySQL（尤其是 <code>InnoDB</code> 存储引擎）也实现了这些隔离级别，同时做了一些细节优化。</p>
<h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><ul>
<li><strong>特点</strong>：最低的隔离级别，一个事务可以读取另一个事务未提交的数据。</li>
<li><strong>问题</strong>：会产生脏读问题，即读取到的数据可能最终回滚，导致不一致。</li>
<li><strong>适用场景</strong>：对数据一致性要求不高，但需要高性能和高并发场景。</li>
</ul>
<h3 id="READ-COMMITTED（读已提交）"><a href="#READ-COMMITTED（读已提交）" class="headerlink" title="READ COMMITTED（读已提交）"></a>READ COMMITTED（读已提交）</h3><ul>
<li><strong>特点</strong>：一个事务只能读取到其他事务已经提交的数据。每次查询时都会获取最新的已提交数据。</li>
<li><strong>问题</strong>：避免了脏读，但可能会出现不可重复读。例如，在同一事务中多次读取同一数据可能会看到不同的值。</li>
<li><strong>应用场景</strong>：大多数应用系统中使用较多，既保证了一定的数据正确性，又允许较高的并发性。</li>
</ul>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><ul>
<li><strong>特点</strong>：保证在同一事务中多次读取同一数据时结果一致。<code>InnoDB</code> 存储引擎默认采用这种隔离级别。</li>
<li><strong>问题</strong>：在经典的定义中，可能会存在幻读问题。但 <code>InnoDB</code> 通过 <code>MVCC</code> 和 <code>Next-Key Locking</code>（间隙锁）机制有效防止幻读现象。</li>
<li><strong>应用场景</strong>：适合对数据读取一致性要求较高的场景，同时在一定程度上也允许高并发。</li>
</ul>
<h3 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h3><ul>
<li><strong>特点</strong>：最高的隔离级别，事务按照严格的顺序执行，仿佛它们是串行执行的一样。所有并发事务都被强制排序，完全避免了脏读、不可重复读和幻读。</li>
<li><strong>问题</strong>：这种隔离级别需要更多的锁机制，可能大幅降低并发性能，增加锁竞争和等待时间。</li>
<li><strong>应用场景</strong>：主要用于对数据一致性要求极高、并发量较低的场景，或者某些关键操作。</li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="START-TRANSACTION-开启事务"><a href="#START-TRANSACTION-开启事务" class="headerlink" title="START TRANSACTION - 开启事务"></a>START TRANSACTION - 开启事务</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>与 <code>BEGIN</code> 作用相同，用于标识事务的开始。</li>
<li>可与 <code>SET TRANSACTION</code> 结合使用，指定事务的隔离级别及读写属性（须在事务开始后立即设置）。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>事务一旦启动，后续的修改操作不会立即生效，只有提交（<code>COMMIT</code>）后才会永久保存，若出现错误可使用 <code>ROLLBACK</code> 进行回滚。</li>
<li>请确保使用的存储引擎（如 <code>InnoDB</code>）支持事务操作。</li>
<li>长事务可能占用资源和锁定数据，建议尽快提交或回滚。</li>
</ul>
<h3 id="COMMIT-提交事务"><a href="#COMMIT-提交事务" class="headerlink" title="COMMIT - 提交事务"></a>COMMIT - 提交事务</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>无额外参数，直接提交当前事务中所有已执行的修改操作。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>COMMIT</code> 会使当前事务中的所有修改永久生效，无法回退，在执行前请确保数据正确性。</li>
<li>对于长事务，建议及时提交以减少锁等待和资源占用。</li>
<li>某些存储引擎（如 <code>InnoDB</code>）支持事务，而其他（如 <code>MyISAM</code>）则不支持，使用前请确认存储引擎类型。</li>
</ul>
<h3 id="ROLLBACK-回滚事务"><a href="#ROLLBACK-回滚事务" class="headerlink" title="ROLLBACK - 回滚事务"></a>ROLLBACK - 回滚事务</h3><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ROLLBACK;<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数-2"><a href="#常见参数-2" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>无额外参数，用于撤销当前事务中自上次 <code>COMMIT</code> 或事务开始以来的所有修改。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>-- 发现错误或业务逻辑有问题，执行回滚<br>ROLLBACK;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>ROLLBACK</code> 只能撤销当前事务内尚未提交的操作，一旦 <code>COMMIT</code> 后，无法使用 <code>ROLLBACK</code> 恢复。</li>
<li>在使用事务时，应结合应用逻辑判断错误场景，及时执行 <code>ROLLBACK</code> 以保持数据一致性。</li>
<li>某些复杂操作（例如涉及外部系统的数据同步）可能无法简单回滚，需谨慎设计事务边界。</li>
</ul>
<h3 id="SAVEPOINT-设置事务保存点"><a href="#SAVEPOINT-设置事务保存点" class="headerlink" title="SAVEPOINT - 设置事务保存点"></a>SAVEPOINT - 设置事务保存点</h3><h4 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数-3"><a href="#常见参数-3" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li><strong>savepoint_name</strong>：自定义的保存点名称，用于标识当前事务中一个中间状态。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>SAVEPOINT sp1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>-- 若后续操作出错，只回滚到保存点 sp1<br>ROLLBACK TO SAVEPOINT sp1;<br>COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>SAVEPOINT</code> 允许在事务中设置多个回滚点，便于部分撤销操作而非整个事务回滚。</li>
<li>保存点只在当前事务有效，事务结束后自动失效。</li>
<li><code>SAVEPOINT</code> 操作会增加事务管理的复杂度，使用时应明确各保存点对应的业务逻辑阶段。</li>
</ul>
<h3 id="RELEASE-SAVEPOINT-删除指定的保存点"><a href="#RELEASE-SAVEPOINT-删除指定的保存点" class="headerlink" title="RELEASE SAVEPOINT - 删除指定的保存点"></a>RELEASE SAVEPOINT - 删除指定的保存点</h3><h4 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">RELEASE SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数-4"><a href="#常见参数-4" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li><strong>savepoint_name</strong>：指定需要删除的保存点名称。</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE orders SET status = &#x27;processing&#x27; WHERE order_id = 123;<br>SAVEPOINT sp_order;<br>-- 执行部分操作后，确认不需要再回滚到该保存点时，释放它<br>RELEASE SAVEPOINT sp_order;<br>COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>RELEASE SAVEPOINT</code> 会删除指定保存点，释放与该保存点相关的资源，一旦释放，不能再回滚到该保存点。</li>
<li>删除保存点对事务后续操作没有影响，但应在确定不需要部分回滚后再执行。</li>
<li>释放保存点后，事务依然处于原来的状态，不会自动提交或回滚。</li>
</ul>
<h3 id="SET-TRANSACTION-设置事务隔离级别"><a href="#SET-TRANSACTION-设置事务隔离级别" class="headerlink" title="SET TRANSACTION - 设置事务隔离级别"></a>SET TRANSACTION - 设置事务隔离级别</h3><h4 id="语法格式-5"><a href="#语法格式-5" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION [transaction_option [, transaction_option] ...];<br></code></pre></div></td></tr></table></figure>

<h4 id="常见参数-5"><a href="#常见参数-5" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li><strong>transaction_option 主要包括</strong>：<ul>
<li><strong>ISOLATION LEVEL level</strong>：设置事务的隔离级别（如 <code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>、<code>SERIALIZABLE</code>）。</li>
<li><strong>READ WRITE 或 READ ONLY</strong>：指定事务是否允许写操作。</li>
</ul>
</li>
<li><code>SET TRANSACTION</code> 必须在事务开始之前（即在 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 之后立即执行，否则不会生效）。</li>
</ul>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE;<br>START TRANSACTION;<br>-- 执行事务操作...<br>COMMIT;<br></code></pre></div></td></tr></table></figure>

<h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>SET TRANSACTION</code> 的设置仅影响当前事务，事务结束后恢复默认设置。</li>
<li>不同隔离级别对并发控制、锁策略及性能有较大影响，选择时应根据业务需求权衡一致性和性能。</li>
<li>一般建议在事务开始后立即设置事务属性，以确保整个事务按照预期运行，否则可能需要重启事务。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>回滚支持</strong>：<code>Undo Log</code> 用于记录数据修改前的 “旧值”，当事务需要回滚时，可以根据 <code>Undo Log</code> 将数据恢复到修改之前的状态。</li>
<li><strong>MVCC 实现</strong>：为了实现多版本并发控制（<code>MVCC</code>），<code>Undo Log</code> 存储了数据的历史版本。查询操作可以根据事务的快照信息，从 <code>Undo Log</code> 中找出符合当前可见性的记录版本，从而避免读到未提交的数据。</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>在执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作时，<code>InnoDB</code> 会将原始数据写入 <code>Undo Log</code>。</li>
<li>每条数据记录内都有隐藏的字段（如 <code>DB_TRX_ID</code> 与 <code>DB_ROLL_PTR</code>），利用这些字段可以链接到对应的 <code>Undo Log</code> 条目。</li>
</ul>
<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>Undo Log</code> 占用额外的存储空间，长事务或频繁修改会导致 <code>Undo Log</code> 累积较多，因而需要定期的清理（<code>Purging</code>）以释放空间。</li>
<li>如果事务长时间未提交，可能会使旧版本数据长期存在，进而影响 <code>MVCC</code> 效率。</li>
</ul>
<h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>持久性保障</strong>：<code>Redo Log</code> 用于保证事务的持久性。通过写前日志（<code>WAL</code>，<code>Write-Ahead Logging</code>）机制，在事务提交前，所有数据变更会先记录到 <code>Redo Log</code> 中，这样即使发生系统崩溃，也能利用 <code>Redo Log</code> 对数据进行恢复。</li>
<li><strong>性能优化</strong>：将变更先写入内存中的 <code>Redo Log</code> 缓冲区，然后异步刷盘，可以减少每次写操作的磁盘 I/O 开销。</li>
</ul>
<h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>当事务执行更新操作时，数据修改先写入内存中的 Redo Log 缓冲区，并按照一定策略（由参数如 <code>innodb_flush_log_at_trx_commit</code> 决定）将日志刷入磁盘。</li>
<li>系统崩溃时，通过 <code>Redo Log</code> 可以重放事务操作，确保已提交的事务修改不会丢失。</li>
</ul>
<h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>Redo Log</code> 的刷盘策略对事务性能和数据安全有较大影响，合理设置参数（例如 <code>innodb_flush_log_at_trx_commit</code> 和 <code>sync_binlog</code>）非常重要。</li>
<li><code>Redo Log</code> 与 <code>Undo Log</code> 分工明确：前者侧重于故障恢复和持久性，后者则主要用于事务回滚和实现 MVCC。</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>MVCC</code>（<code>Multi-Version Concurrency Control</code>，多版本并发控制）是一种并发控制技术，它通过为数据库中的每条记录维护多个版本，允许不同事务在同一时间访问数据而不产生冲突，从而实现非阻塞的读取操作。</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>读一致性</strong>：当事务启动时，系统为其创建一个数据快照，使得该事务在整个执行过程中看到的数据保持一致，即使其他事务对数据做了修改。</li>
<li><strong>提高并发性</strong>：读操作无需加锁（或只需轻量级锁定），降低了读写之间的冲突，提高了系统的吞吐量。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h5 id="隐藏列和事务标识"><a href="#隐藏列和事务标识" class="headerlink" title="隐藏列和事务标识"></a>隐藏列和事务标识</h5><p><code>InnoDB</code> 在每个数据行中维护了两个隐藏列（除了用户定义的列之外）：</p>
<ul>
<li><strong>DB_TRX_ID</strong>：记录最后一次修改该行的事务 ID。</li>
<li><strong>DB_ROLL_PTR</strong>：指向 <code>Undo Log</code> 中该行之前版本的指针，用于回滚或查找旧版本数据。</li>
</ul>
<p>这些隐藏列为 <code>MVCC</code> 提供了版本管理的基本依据。</p>
<h5 id="Undo-Log-作用"><a href="#Undo-Log-作用" class="headerlink" title="Undo Log 作用"></a>Undo Log 作用</h5><ul>
<li><p><strong>记录旧版本</strong></p>
<p>当一条记录被更新或删除时，<code>InnoDB</code> 不会立即覆盖或删除原数据，而是将原有版本写入 <code>Undo Log</code>。这样，正在执行的事务就可以根据自己的 “快照” 来访问数据的历史版本。</p>
</li>
<li><p><strong>实现读一致性</strong></p>
<p>每个事务启动时会记录当前活动事务的快照信息，当执行查询操作时，<code>InnoDB</code> 会根据记录的 <code>DB_TRX_ID</code> 与 <code>Undo Log</code> 中保存的历史版本判断哪一版本对当前事务可见。</p>
<ul>
<li><p>如果行记录的修改事务在当前事务开始后提交，则当前事务不会看到这些新修改，依然读取 <code>Undo Log</code> 中保存的版本。</p>
</li>
<li><p>反之，如果该修改事务在当前事务启动前就已经提交，则新数据对当前事务可见。</p>
</li>
</ul>
</li>
</ul>
<h5 id="事务-ID-与版本控制"><a href="#事务-ID-与版本控制" class="headerlink" title="事务 ID 与版本控制"></a>事务 ID 与版本控制</h5><ul>
<li><p><strong>事务标识</strong>：每个事务在启动时都会分配一个全局唯一的事务 ID。通过比较事务 ID 与行记录中的 <code>DB_TRX_ID</code>，以及判断这些事务是否已提交，<code>InnoDB</code> 能决定当前事务应看到哪个版本的数据。</p>
</li>
<li><p><strong>版本判断规则</strong>：当前事务在执行查询时，会利用其事务快照信息，判断每一行记录的修改是否在它的可见范围内，从而选择合适的版本返回给用户。这样就实现了即使在并发修改情况下，每个事务依然能看到一个逻辑上一致的数据库状态。</p>
</li>
</ul>
<h5 id="旧版本清理"><a href="#旧版本清理" class="headerlink" title="旧版本清理"></a>旧版本清理</h5><ul>
<li><p><strong>Undo Log 累积</strong>：随着大量更新和删除操作的发生，<code>Undo Log</code> 中会积累许多旧版本数据，这些数据如果长期保留会占用大量存储资源。</p>
</li>
<li><p><strong>Purging 机制</strong>：<code>InnoDB</code> 内部有一个专门的后台线程定期扫描并清理不再被任何活动事务需要的旧版本数据，回收空间并确保 <code>Undo Log</code> 不至于无限增长。</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>非阻塞读取</strong>：<code>MVCC</code> 使得读取操作不必等待写锁释放，即便数据正在被修改，也可以读取到一个一致的快照版本，显著提高并发性能。</li>
<li><strong>高效的并发控制</strong>：由于读操作不加锁，事务之间的并发冲突减少了，降低了锁竞争和死锁风险，适合高并发场景。</li>
</ul>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul>
<li><strong>Undo Log 管理</strong>：需要额外的存储空间来保存历史版本，且随着系统运行 <code>Undo Log</code> 需要定期清理，管理不当可能影响性能。</li>
<li><strong>数据版本累积</strong>：如果长事务持续占用快照，可能导致大量旧版本数据不能及时被清理，从而增加系统的负担。</li>
<li><strong>写入开销</strong>：每次更新或删除操作不仅需要写入新数据，还需要保存旧数据到 <code>Undo Log</code>，增加了写操作的成本。</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>两阶段提交（<code>2PC</code>）是一种分布式事务协议，用于确保所有参与者（或多个数据页/日志）在提交时达成一致，保证事务的原子性和持久性。尽管 <code>InnoDB</code> 内部不是严格意义上的分布式事务，但在提交时也采用了类似 <code>2PC</code> 的流程，其内部 <code>Commit</code> 流程带有两阶段性质。</p>
<h4 id="阶段说明"><a href="#阶段说明" class="headerlink" title="阶段说明"></a>阶段说明</h4><h5 id="第一阶段（Prepare）"><a href="#第一阶段（Prepare）" class="headerlink" title="第一阶段（Prepare）"></a>第一阶段（Prepare）</h5><p>在这一阶段，所有参与者（例如各个数据页、日志缓冲区）会记录事务的修改并锁定必要资源，但不会正式提交。<code>InnoDB</code> 会先将 <code>Redo Log</code> 写入磁盘，并设置标记表示事务处于待提交状态。</p>
<h5 id="第二阶段（Commit）"><a href="#第二阶段（Commit）" class="headerlink" title="第二阶段（Commit）"></a>第二阶段（Commit）</h5><p>当所有资源确认无误后，系统会正式提交事务，将标记修改为 “已提交”，并释放锁资源。此时，事务的所有变更对外部客户端都可见。</p>
<h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>2PC</code> 可以确保在发生故障时不会出现部分提交的情况，但同时会增加事务提交的延时。</li>
<li>在 <code>InnoDB</code> 中，<code>2PC</code> 的实现主要依赖于 <code>Redo Log</code> 的先写入和事务提交标记的管理，合理调优日志参数有助于优化 <code>2PC</code> 的性能表现。</li>
</ul>
<h3 id="自增-ID-在事务中的处理"><a href="#自增-ID-在事务中的处理" class="headerlink" title="自增 ID 在事务中的处理"></a>自增 ID 在事务中的处理</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><code>InnoDB</code> 使用自动增长机制为自增字段分配连续或半连续的数值。每当插入新记录时，<code>InnoDB</code> 会分配一个新的自增值。</li>
</ul>
<h4 id="事务内的特点"><a href="#事务内的特点" class="headerlink" title="事务内的特点"></a>事务内的特点</h4><ul>
<li><strong>预分配与消费</strong>：当执行插入操作时，即使后续事务回滚，分配的自增值也不会回退。这就导致了可能出现序列中 “空洞” 的情况。</li>
<li><strong>锁机制保护</strong>：为了避免并发插入时产生重复值，自增列操作在内部使用一种特殊的 “自增锁”，确保同一时刻只有一个事务能够分配新的自增值。</li>
</ul>
<h4 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>应用在设计时要注意自增 ID 并非严格连续，而是保证唯一性。</li>
<li>长事务或频繁回滚会导致自增 ID 的浪费，但不会影响数据的正确性。</li>
</ul>
<h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><ul>
<li><strong>定义</strong>：间隙锁是锁住两个索引记录之间的空隙，而不锁定实际存在的记录。</li>
<li><strong>作用</strong>：防止其他事务在锁定的间隙内插入新记录，从而避免幻读现象。</li>
<li><strong>应用场景</strong>：通常在可重复读隔离级别下启用，用于保证同一查询在事务期间返回一致的结果集。</li>
</ul>
<h3 id="Next-Key-Lock（临键锁）"><a href="#Next-Key-Lock（临键锁）" class="headerlink" title="Next-Key Lock（临键锁）"></a>Next-Key Lock（临键锁）</h3><ul>
<li><strong>定义</strong>：<code>Next-Key Lock</code> 是一种组合锁，包括了对记录本身的锁定（记录锁）以及记录前空隙的锁定（间隙锁），主要应用于更新操作。</li>
<li><strong>作用</strong>：防止其他事务插入或修改可能影响当前事务查询结果的记录，从而完全杜绝幻读。</li>
<li><strong>工作方式</strong>：在查询或更新时，<code>InnoDB</code> 会自动对符合条件的记录及其前面的间隙加锁，确保在整个事务期间这些记录不会发生变化。</li>
<li><strong>注意事项</strong>：<ul>
<li><code>Next-Key Lock</code> 在提高数据一致性方面效果显著，但也可能引发较多的锁争用，特别是在高并发环境下。</li>
<li>对于某些特定场景，可以通过设置隔离级别或调整 SQL 语句来减轻锁竞争（例如合理使用索引、拆分查询范围等）。</li>
</ul>
</li>
</ul>
<h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><code>Binlog</code> 是 MySQL 服务器层记录数据修改操作的一种逻辑日志。与存储引擎内部的物理日志（如 <code>Redo Log</code>）不同，<code>Binlog</code> 记录的是 SQL 操作或行级变化的事件，以二进制格式存储。它不仅用于故障恢复，还作为主从复制、数据审计和点时间恢复（<code>Point-in-Time Recovery</code>，<code>PITR</code>）的重要依据。</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><code>Binlog</code> 以文件形式存储在服务器上，随着数据修改不断追加。当日志文件达到一定大小后，会自动进行日志轮转。</p>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>数据复制（Replication）</strong>：在主从复制架构中，主服务器的 <code>Binlog</code> 记录所有数据修改事件，从服务器通过读取和重放 <code>Binlog</code> 事件来保持数据同步。这使得数据在分布式系统间的复制变得可靠且高效。</li>
<li><strong>故障恢复与数据恢复</strong>：配合定期备份，<code>Binlog</code> 可以用于点时间恢复。当系统发生故障或数据误操作时，备份数据加上后续的 <code>Binlog</code> 事件可以将数据库恢复到某个精确的时间点。</li>
<li><strong>数据审计</strong>：由于 <code>Binlog</code> 记录了所有变更操作，管理员可以通过解析 <code>Binlog</code> 了解数据库中发生的所有数据修改，便于问题追踪和审计。</li>
</ul>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><strong>记录事件</strong>：每当事务提交时，MySQL 服务器会将该事务所引发的修改操作转换为一个或多个事件，写入 <code>Binlog</code>。这些事件可能包括 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等操作，也可能包含 <code>DDL</code> 操作（注意：某些 <code>DDL</code> 操作会隐式提交事务）。</li>
<li><strong>日志刷新与同步</strong>：<code>Binlog</code> 的写入并不是实时刷盘的，其刷新策略由参数 <code>sync_binlog</code> 控制。<ul>
<li>如果 <code>sync_binlog=1</code>，每次提交都会同步刷新 <code>Binlog</code> 文件，这样可以最大程度保证数据一致性，但可能会牺牲性能。</li>
<li>较高的 <code>sync_binlog</code> 值可以减少磁盘 I/O 次数，但在系统崩溃时可能会丢失部分未同步的日志。</li>
</ul>
</li>
<li><strong>日志轮转</strong>：当当前 <code>Binlog</code> 文件达到预设大小后，MySQL 会生成新的 <code>Binlog</code> 文件。管理员可根据需要设置日志保留策略，防止日志文件占用过多磁盘空间。</li>
</ol>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>MySQL 提供了三种 <code>Binlog</code> 格式，以适应不同场景和需求：</p>
<ul>
<li><strong>STATEMENT 模式（基于语句的日志）</strong>：记录执行的 SQL 语句。<ul>
<li><strong>优点</strong>：日志体积较小。</li>
<li><strong>缺点</strong>：某些 SQL 语句可能在不同环境下执行结果不同，复制时可能存在不一致性问题。</li>
</ul>
</li>
<li><strong>ROW 模式（基于行的日志）</strong>：记录每一行数据的实际变化（前后状态）。<ul>
<li><strong>优点</strong>：能够精确复制数据修改，避免因语句执行差异导致的复制错误；在复杂的 SQL 操作（如多表操作）时更为安全。</li>
<li><strong>缺点</strong>：日志文件通常较大，可能对存储和网络带宽产生更大压力。</li>
</ul>
</li>
<li><strong>MIXED 模式（混合模式）</strong><ul>
<li>根据具体操作自动选择使用 <code>Statement</code> 或 <code>Row</code> 模式。</li>
<li>目的是在性能与复制安全性之间取得平衡，但也需要对应用场景和 SQL 语句特性有清晰了解，避免潜在的不一致性。</li>
</ul>
</li>
</ul>
<h3 id="与-Redo-Log-的区别"><a href="#与-Redo-Log-的区别" class="headerlink" title="与 Redo Log 的区别"></a>与 Redo Log 的区别</h3><ul>
<li><strong>Redo Log</strong><ul>
<li>属于存储引擎内部日志，是一种物理日志，记录数据页的变化，用于崩溃恢复和保证事务的持久性。</li>
<li>由 <code>InnoDB</code> 直接管理，刷新机制更关注 I/O 性能和数据一致性。</li>
</ul>
</li>
<li><strong>Binlog</strong><ul>
<li>是 <code>MySQL</code> 服务器层的逻辑日志，记录 SQL 级别的操作，主要用于复制和数据恢复。</li>
<li>相比 <code>Redo Log</code>，<code>Binlog</code> 更适合跨服务器的数据同步和审计，但写入和刷新策略则需要权衡性能与数据安全。</li>
</ul>
</li>
</ul>
<h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>日志同步策略</strong>：根据业务对数据一致性与性能的要求，合理设置 <code>sync_binlog</code> 参数。若对数据一致性要求较高，建议设置为 <code>1</code>；若对性能有更高要求，则可以适当调高该值，但需要接受一定的风险。</li>
<li><strong>日志格式选择</strong>：根据实际应用场景选择合适的日志格式。高并发、数据变更频繁的系统可能倾向于 <code>ROW</code> 模式以确保复制精度，但需注意日志量的增加；而对日志量敏感且操作确定性的场景，<code>STATEMENT</code> 模式也可满足需求。</li>
<li><strong>磁盘空间管理</strong>：由于 <code>Binlog</code> 会不断增长，需要配置日志轮转和清理策略，防止日志文件占满磁盘。可以通过 <code>expire_logs_days</code> 等参数自动清理过期日志。</li>
<li><strong>安全与审计</strong>：<code>Binlog</code> 中记录了所有数据变更，若泄露可能导致安全风险。应当合理设置访问权限，并对 <code>Binlog</code> 文件进行加密或保护。</li>
<li><strong>复制一致性</strong>：在主从复制环境下，确保 <code>Binlog</code> 的格式与相关参数在主从服务器间一致，避免因格式不匹配导致复制异常。</li>
</ul>
<h2 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h2><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><h4 id="定义与默认行为"><a href="#定义与默认行为" class="headerlink" title="定义与默认行为"></a>定义与默认行为</h4><ul>
<li><strong>自动提交模式</strong>：MySQL 默认处于自动提交模式，即 <code>autocommit=1</code>。在该模式下，每条单独的 SQL 语句都被视为一个完整的事务，执行后会立即自动提交，无需显式调用 <code>COMMIT</code>。</li>
<li><strong>优点</strong>：适合简单的操作，不需要手动管理事务边界，编程和使用相对简单。</li>
<li><strong>缺点</strong>：在需要将多条语句组合为一个原子操作时，自动提交模式不适用，因为每条语句都是独立提交的，无法保证整体原子性。</li>
</ul>
<h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><ul>
<li><strong>频繁提交</strong>：每条语句执行完毕后都会立即提交，可能导致较高的 I/O 负担，尤其是在大量 <code>DML</code> 操作时。</li>
<li><strong>事务隔离控制</strong>：由于每个语句都是独立事务，可能无法满足某些需要跨语句的逻辑一致性要求。</li>
<li><strong>如何处理</strong>：如果需要组合多条语句为一个事务，可以通过设置 <code>SET autocommit=0</code> 或在事务中使用 <code>BEGIN/START TRANSACTION</code> 来关闭自动提交，然后在所有操作结束后调用 <code>COMMIT</code> 或在出错时调用 <code>ROLLBACK</code>。</li>
</ul>
<h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><h3 id="定义与触发场景"><a href="#定义与触发场景" class="headerlink" title="定义与触发场景"></a>定义与触发场景</h3><p>隐式提交是指某些 SQL 语句在执行时，会自动提交当前正在进行的事务，即使没有显式调用 <code>COMMIT</code>。这种情况主要出现在以下场景：</p>
<ul>
<li><strong>DDL 语句</strong>：例如 <code>CREATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code> 等操作。在执行这些语句前，MySQL 会先隐式提交当前事务，再执行 <code>DDL</code> 操作。</li>
<li><strong>其他特殊语句</strong>：如 <code>TRUNCATE TABLE</code>、<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code> 等也会触发隐式提交。</li>
</ul>
<h4 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h4><ul>
<li><strong>事务边界不清晰</strong>：如果在一个事务中混合使用 <code>DML</code> 操作（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）和 <code>DDL</code> 操作，可能会在不经意间触发隐式提交，从而导致事务提前结束。这会使得之前未提交的修改被自动提交，无法再通过 <code>ROLLBACK</code> 撤销。</li>
<li><strong>不可控的提交</strong>：在一些复杂的业务逻辑中，开发者可能希望将多个操作放在一个事务中统一提交，但一旦执行了触发隐式提交的语句，整个事务会被强制提交，可能破坏原本预期的原子性和一致性。</li>
</ul>
<h2 id="调优策略"><a href="#调优策略" class="headerlink" title="调优策略"></a>调优策略</h2><h3 id="减少事务持有时间"><a href="#减少事务持有时间" class="headerlink" title="减少事务持有时间"></a>减少事务持有时间</h3><ul>
<li><p><strong>精简事务内的操作</strong></p>
<ul>
<li><p>将事务中必须的操作限定在一个较小的范围内，只包含那些在逻辑上必须原子提交的语句。</p>
</li>
<li><p>避免在事务内执行不必要的复杂计算或等待用户输入，使事务尽快完成。</p>
</li>
</ul>
</li>
<li><p><strong>尽早提交事务</strong></p>
<ul>
<li><p>尽快执行 <code>COMMIT</code>，防止事务长时间持有锁，降低因长事务带来的锁竞争。</p>
</li>
<li><p>对于批量处理或长时间任务，可考虑将大事务拆分为多个短事务，按业务逻辑分阶段提交。</p>
</li>
</ul>
</li>
<li><p><strong>合理设计事务边界</strong></p>
<ul>
<li><p>将只读操作与写操作分离。对于只读查询尽量利用 <code>MVCC</code> 快照机制，而不必在事务内加锁。</p>
</li>
<li><p>对于涉及多步操作的业务逻辑，确保事务范围仅限于必要操作，其他辅助操作在事务外执行。</p>
</li>
</ul>
</li>
<li><p><strong>使用异步处理</strong></p>
<ul>
<li>对于不要求实时一致性但数据量较大的操作，可以考虑使用消息队列、异步任务等方式将大事务拆分成小的、可独立处理的任务。</li>
</ul>
</li>
<li><p><strong>避免外部依赖阻塞</strong></p>
<ul>
<li>避免在事务中调用外部服务或执行耗时操作，防止因外部响应延迟而拖长事务时间。</li>
</ul>
</li>
<li><p><strong>关注事务间依赖</strong></p>
</li>
</ul>
<ul>
<li>在拆分事务时要注意数据之间的依赖关系，确保拆分后的事务不会破坏整体业务逻辑的数据一致性，必要时通过补偿机制或额外的校验保证正确性。</li>
</ul>
<h3 id="降低死锁概率"><a href="#降低死锁概率" class="headerlink" title="降低死锁概率"></a>降低死锁概率</h3><ul>
<li><strong>统一访问顺序</strong><ul>
<li>确保所有事务按照相同的顺序访问同一组资源（例如按主键或索引顺序更新记录），避免因资源竞争顺序不一致而产生死锁。</li>
</ul>
</li>
<li><strong>减少锁粒度和锁持有范围</strong><ul>
<li>尽可能缩小 SQL 的影响范围，利用精准的 <code>WHERE</code> 条件，减少锁定的记录数量。</li>
<li>合理使用索引，使得查询和更新操作能够定位到少量记录，从而降低锁定范围。</li>
</ul>
</li>
<li><strong>合理选择隔离级别</strong><ul>
<li>根据业务需求，选择合适的事务隔离级别。例如在允许一定程度脏读或不可重复读的场景下，可以选择 <code>READ COMMITTED</code> 而非 <code>REPEATABLE READ</code>，从而减少 <code>Next-Key Lock</code> 的范围。</li>
</ul>
</li>
<li><strong>短事务优先策略</strong><ul>
<li>如前所述，缩短事务的持有时间可以减少死锁发生的概率，因为长时间锁定数据的事务容易与其他并发事务产生冲突。</li>
</ul>
</li>
<li><strong>错误重试机制</strong><ul>
<li>在应用层面设计合理的错误处理和重试机制，一旦检测到死锁错误（错误代码 <code>1213</code>），可以捕获异常并重新执行事务逻辑，降低死锁对业务的影响。</li>
</ul>
</li>
</ul>
<h3 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h3><ul>
<li><p><strong>提高查询效率</strong></p>
<ul>
<li><p>索引可以大幅减少扫描的行数，使查询更快，同时也降低了需要加锁的记录数量，从而减少锁竞争和死锁发生。</p>
</li>
<li><p>设计合理的复合索引，覆盖查询条件和排序字段，避免全表扫描。</p>
</li>
</ul>
</li>
<li><p><strong>避免不必要的锁定</strong></p>
<ul>
<li><p>通过索引能精确定位目标记录，避免对大量不相关记录加锁。</p>
</li>
<li><p>在更新操作时，确保更新条件能充分利用索引，使得锁定范围只集中在目标记录，而非整个数据页或更大范围。</p>
</li>
</ul>
</li>
<li><p><strong>索引维护与优化</strong></p>
<ul>
<li><p>定期对索引使用情况进行监控，移除不必要的或冗余的索引，避免因为过多索引导致写操作变慢以及锁竞争加剧。</p>
</li>
<li><p>考虑在高并发环境下使用覆盖索引，减少回表查询，从而进一步降低锁竞争。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Binlog-配置优化"><a href="#Binlog-配置优化" class="headerlink" title="Binlog 配置优化"></a>Binlog 配置优化</h3><ul>
<li><p><strong>sync_binlog 参数</strong>：</p>
<ul>
<li><p>设置 <code>sync_binlog=1</code> 可确保每次事务提交时 <code>Binlog</code> 都会同步写入磁盘，最大限度保证数据一致性，但会对性能产生一定影响。</p>
</li>
<li><p>如果业务对数据一致性的要求稍低，而追求更高的写入性能，可适当调高 <code>sync_binlog</code> 值，但需要接受在故障时可能丢失最近一部分事务的风险。</p>
</li>
</ul>
</li>
<li><p><strong>日志格式选择</strong>：</p>
<ul>
<li>根据应用场景选择合适的日志格式。<code>ROW</code> 模式记录详细变更信息，复制更精确；<code>STATEMENT</code> 模式日志体积小，性能更好，但可能存在某些场景下的复制问题。</li>
</ul>
</li>
<li><p><strong>日志轮转与保留策略</strong>：</p>
<ul>
<li>配置 <code>expire_logs_days</code> 或者手动清理过期 <code>Binlog</code> 文件，避免日志文件无限增长，影响磁盘空间和 I/O 性能。</li>
</ul>
</li>
</ul>
<h3 id="Redo-Log-配置优化"><a href="#Redo-Log-配置优化" class="headerlink" title="Redo Log 配置优化"></a>Redo Log 配置优化</h3><ul>
<li><p><strong>日志缓冲区大小</strong>：</p>
<ul>
<li>调整 <code>innodb_log_buffer_size</code> 参数，保证在高并发写入场景下能够容纳足够的日志数据，减少因日志缓冲不足而频繁刷盘的情况。</li>
</ul>
</li>
<li><p><strong>刷盘策略</strong>：</p>
<ul>
<li>参数 <code>innodb_flush_log_at_trx_commit</code> 控制事务提交时日志的刷盘行为。<ul>
<li>设置为 <code>1</code>：每次提交时都刷盘，数据安全性最高，但性能较低。</li>
<li>设置为 <code>2</code> 或 <code>0</code>：可以提高性能，但在系统崩溃时可能丢失部分最近提交的事务数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redo Log 文件大小和数量</strong>：</p>
<ul>
<li>调整 <code>redo log</code> 文件的大小（<code>innodb_log_file_size</code>）和数量，既要确保在高峰时日志能够充分缓冲，也要避免过大的日志文件导致恢复时间延长。</li>
</ul>
</li>
</ul>
<h2 id="运行事务查询"><a href="#运行事务查询" class="headerlink" title="运行事务查询"></a>运行事务查询</h2><h3 id="查看正在运行的事务"><a href="#查看正在运行的事务" class="headerlink" title="查看正在运行的事务"></a>查看正在运行的事务</h3><h4 id="Performance-Schema-和-Information-Schema"><a href="#Performance-Schema-和-Information-Schema" class="headerlink" title="Performance Schema 和 Information Schema"></a>Performance Schema 和 Information Schema</h4><ul>
<li><p><strong>information_schema.innodb_trx</strong></p>
<p>MySQL 从 5.7 版本开始提供了 <code>information_schema.innodb_trx</code> 表，它列出了当前所有活动的 <code>InnoDB</code> 事务。可以通过如下 SQL 语句查看详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM information_schema.innodb_trx\G<br></code></pre></div></td></tr></table></figure>

<p>其中包含事务的开始时间、状态、等待锁信息以及相关的事务 ID，这有助于判断哪些事务运行时间过长或可能导致锁竞争。</p>
</li>
<li><p><strong>相关表</strong>：还可以结合 <code>information_schema.innodb_locks</code> 和 <code>information_schema.innodb_lock_waits</code> 表，了解锁持有情况及等待关系，从而定位是否存在阻塞或死锁。</p>
</li>
</ul>
<h4 id="SHOW-ENGINE-INNODB-STATUS"><a href="#SHOW-ENGINE-INNODB-STATUS" class="headerlink" title="SHOW ENGINE INNODB STATUS"></a>SHOW ENGINE INNODB STATUS</h4><ul>
<li><p>执行以下命令可以获得当前 <code>InnoDB</code> 引擎的状态信息，其中包括当前正在运行的事务、锁情况、最近的死锁信息等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW ENGINE INNODB STATUS\G<br></code></pre></div></td></tr></table></figure>

<p>输出中会显示 <code>TRANSACTIONS</code> 部分，列出当前活跃的事务、它们持有的锁以及等待的锁信息，对排查问题非常有帮助。</p>
</li>
</ul>
<h4 id="SHOW-FULL-PROCESSLIST"><a href="#SHOW-FULL-PROCESSLIST" class="headerlink" title="SHOW FULL PROCESSLIST"></a>SHOW FULL PROCESSLIST</h4><ul>
<li><p>通过命令可以查看当前所有连接和其执行的 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW FULL PROCESSLIST;<br></code></pre></div></td></tr></table></figure>

<p>这不仅能发现哪些连接正执行长时间事务，还可以看出是否有连接处于 <code>Sleep</code> 状态但长时间未释放事务（例如因未提交的事务）。</p>
</li>
</ul>
<h3 id="异常事务的处理方案"><a href="#异常事务的处理方案" class="headerlink" title="异常事务的处理方案"></a>异常事务的处理方案</h3><p>异常事务一般指运行时间过长、持有锁导致阻塞或已进入死锁状态的事务。处理方案包括以下几个方面：</p>
<h4 id="杀死异常事务"><a href="#杀死异常事务" class="headerlink" title="杀死异常事务"></a>杀死异常事务</h4><p><strong>手动终止</strong>：一旦确定某个事务因为长时间运行或死锁而影响系统，可以通过 <code>KILL</code> 命令终止相应连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">KILL &lt;connection_id&gt;;<br></code></pre></div></td></tr></table></figure>

<p>使用前可以先通过 <code>SHOW FULL PROCESSLIST</code> 或查询 <code>information_schema.innodb_trx</code> 得到对应的线程 ID。</p>
<p><strong>注意</strong>：杀掉事务会导致事务回滚，可能需要评估数据一致性影响。</p>
<h4 id="调整锁等待超时时间"><a href="#调整锁等待超时时间" class="headerlink" title="调整锁等待超时时间"></a>调整锁等待超时时间</h4><p>如果事务等待锁的时间过长，可以适当调整参数 <code>innodb_lock_wait_timeout</code>（单位为秒），以便在达到设定时间后自动回滚等待锁的事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET GLOBAL innodb_lock_wait_timeout = 50;<br></code></pre></div></td></tr></table></figure>

<p>这样可以防止长时间等待造成资源占用，但需要根据具体业务场景权衡超时设置，防止因短暂阻塞误杀正常事务。</p>
<h4 id="分析和解决死锁"><a href="#分析和解决死锁" class="headerlink" title="分析和解决死锁"></a>分析和解决死锁</h4><ul>
<li><strong>查看死锁日志</strong>：使用 <code>SHOW ENGINE INNODB STATUS\G</code> 可以查看最近的死锁信息。根据死锁日志可以分析哪些 SQL 语句、索引或事务访问顺序导致冲突。</li>
<li><strong>优化 SQL 和事务设计</strong>：<ul>
<li><strong>统一访问顺序</strong>：确保多个事务以相同的顺序访问资源，降低死锁发生的概率。</li>
<li><strong>缩短事务持有时间</strong>：尽量将事务范围控制在最小范围内，快速提交事务。</li>
<li><strong>合理使用索引</strong>：通过优化查询条件和索引设计，使得更新或删除操作能精确定位目标记录，减少锁定范围。</li>
</ul>
</li>
</ul>
<h4 id="自动化监控与报警"><a href="#自动化监控与报警" class="headerlink" title="自动化监控与报警"></a>自动化监控与报警</h4><p>部署监控工具（如 <code>Performance Schema</code> 监控、第三方监控系统或 MySQL 自带的日志分析工具）来实时监控事务状态和锁竞争情况。一旦发现异常事务或长事务自动报警，并根据预先设定的规则触发自动处理或通知管理员进行干预。</p>
<h4 id="应用层面优化"><a href="#应用层面优化" class="headerlink" title="应用层面优化"></a>应用层面优化</h4><ul>
<li>在应用逻辑中，对事务执行时间进行监控和记录，及时捕获异常情况。</li>
<li>对可能引起长事务的业务逻辑进行拆分或优化，确保事务不长时间持有锁，从而降低整体系统压力。</li>
</ul>
<h2 id="常见参数总结"><a href="#常见参数总结" class="headerlink" title="常见参数总结"></a>常见参数总结</h2><h3 id="自动提交与事务隔离相关参数"><a href="#自动提交与事务隔离相关参数" class="headerlink" title="自动提交与事务隔离相关参数"></a>自动提交与事务隔离相关参数</h3><h4 id="autocommit"><a href="#autocommit" class="headerlink" title="autocommit"></a>autocommit</h4><ul>
<li><strong>说明</strong>：控制 MySQL 是否在每条独立 SQL 语句后自动提交事务。</li>
<li><strong>配置值</strong>：<ul>
<li><code>autocommit=1</code>（默认）：每条语句自动提交。</li>
<li><code>autocommit=0</code>：关闭自动提交，需要显式使用 <code>BEGIN/COMMIT/ROLLBACK</code> 来管理事务。</li>
</ul>
</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>在自动提交模式下，每条语句都是独立事务，适合简单操作，但无法保证多语句操作的原子性。</li>
<li>若需要将多个操作整合在一个事务中，须关闭自动提交（或使用显式事务），避免意外提交或隐式提交导致数据不一致。</li>
</ul>
</li>
</ul>
<h4 id="transaction-isolation（或-transaction-read-only）"><a href="#transaction-isolation（或-transaction-read-only）" class="headerlink" title="transaction_isolation（或 transaction_read_only）"></a>transaction_isolation（或 transaction_read_only）</h4><ul>
<li><p><strong>说明</strong>：指定事务的隔离级别，决定了并发事务之间数据读取的一致性。</p>
</li>
<li><p><strong>常见配置值</strong>：</p>
<ul>
<li><code>READ-UNCOMMITTED</code></li>
<li><code>READ-COMMITTED</code></li>
<li><code>REPEATABLE-READ</code>（默认 <code>InnoDB</code> 隔离级别）</li>
<li><code>SERIALIZABLE</code></li>
</ul>
</li>
<li><p><strong>影响及注意事项</strong>：</p>
<ul>
<li><p>隔离级别越高，数据一致性越好，但并发性能可能下降。</p>
</li>
<li><p>在高并发系统中，经常采用 <code>READ-COMMITTED</code> 或 <code>REPEATABLE-READ</code> 来平衡一致性与性能。</p>
</li>
<li><p>可在全局或会话级设置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="日志同步与持久性相关参数"><a href="#日志同步与持久性相关参数" class="headerlink" title="日志同步与持久性相关参数"></a>日志同步与持久性相关参数</h3><h4 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h4><ul>
<li><strong>说明</strong>：控制 <code>InnoDB</code> 提交事务时 <code>Redo Log</code> 的写入和刷盘行为。</li>
<li><strong>配置值</strong>：<ul>
<li><code>1</code>（默认）：每次事务提交时将 <code>Redo Log</code> 写入日志文件并刷盘，确保数据持久性。</li>
<li><code>2</code>：事务提交时写入日志文件但不立即刷盘，由操作系统定时刷盘，性能较好但在崩溃时可能丢失最近事务。</li>
<li><code>0</code>：每秒钟刷一次日志，风险与 <code>2</code> 类似，适用于对性能要求较高且数据丢失风险可控的场景。</li>
</ul>
</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>设置为 <code>1</code> 可以获得最高的数据安全性，但会增加 I/O 开销。</li>
<li>根据业务对数据一致性和性能的要求选择合适的值，需权衡数据丢失风险与性能。</li>
</ul>
</li>
</ul>
<h4 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h4><ul>
<li><strong>说明</strong>：控制二进制日志（<code>Binlog</code>）的同步刷新策略。</li>
<li><strong>配置值</strong>：<ul>
<li><code>sync_binlog=1</code>：每次事务提交后同步刷新 <code>Binlog</code> 到磁盘，保证数据复制和恢复的一致性。</li>
<li>大于 <code>1</code> 的值或 <code>0</code>：会降低同步频率，提高写入性能，但在系统崩溃时可能丢失部分 <code>Binlog</code> 数据。</li>
</ul>
</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>对复制环境和点时间恢复要求严格时，建议设置为 <code>1</code>；</li>
<li>如果追求更高的写入性能，可以适当调高，但需要接受在故障时丢失部分最近提交数据的风险。</li>
</ul>
</li>
</ul>
<h4 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h4><ul>
<li><strong>说明</strong>：定义 <code>InnoDB</code> 日志缓冲区的大小，用于暂存事务产生的 <code>Redo Log</code> 数据。</li>
<li><strong>默认值</strong>：通常为 <code>16MB</code>（不同版本可能有所不同）</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>较大的日志缓冲区能减少频繁刷盘的次数，适用于大事务或高并发写入。</li>
<li>若设置过大，会占用较多内存。</li>
<li>根据系统写入负载调整合适的大小。</li>
</ul>
</li>
</ul>
<h4 id="innodb-log-file-size"><a href="#innodb-log-file-size" class="headerlink" title="innodb_log_file_size"></a>innodb_log_file_size</h4><ul>
<li><strong>说明</strong>：控制单个 <code>InnoDB Redo Log</code> 文件的大小。</li>
<li><strong>默认值</strong>：版本不同可能在 <code>48MB ~ 256MB</code> 不等。</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>较大的 <code>Redo Log</code> 文件可以降低日志切换频率，提升写入性能。</li>
<li>但同时在系统崩溃后恢复时间会变长。</li>
<li>调整时需综合考虑写入负载和恢复窗口的需求。</li>
</ul>
</li>
</ul>
<h3 id="锁等待与自增相关参数"><a href="#锁等待与自增相关参数" class="headerlink" title="锁等待与自增相关参数"></a>锁等待与自增相关参数</h3><h4 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h4><ul>
<li><strong>说明</strong>：设置 <code>InnoDB</code> 等待行锁（或其他锁）释放的超时时间（单位：秒）。</li>
<li><strong>默认值</strong>：一般为 <code>50</code> 秒</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>过短的等待时间可能导致事务因暂时的锁竞争频繁回滚。</li>
<li>过长则可能使得事务等待时间过长，影响系统响应。</li>
<li>根据应用特点进行适当调整，防止长时间等待占用资源。</li>
</ul>
</li>
</ul>
<h4 id="innodb-autoinc-lock-mode"><a href="#innodb-autoinc-lock-mode" class="headerlink" title="innodb_autoinc_lock_mode"></a>innodb_autoinc_lock_mode</h4><ul>
<li><strong>说明</strong>：控制自增（<code>AUTO_INCREMENT</code>）字段在多线程并发插入时的锁策略。</li>
<li><strong>配置值</strong>：<ul>
<li><code>0</code>（传统模式）：对每个插入请求都加锁，保证严格连续，但并发性能较低。</li>
<li><code>1</code>（默认，连续模式）：在语句级别加锁，允许批量插入，性能和连续性之间平衡。</li>
<li><code>2</code>（交错模式）：允许多个并发插入无锁竞争，适用于高并发，但可能导致自增值不连续。</li>
</ul>
</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>应根据实际业务对自增值连续性和并发性能的要求选择合适的模式。</li>
</ul>
</li>
</ul>
<h4 id="innodb-print-all-deadlocks"><a href="#innodb-print-all-deadlocks" class="headerlink" title="innodb_print_all_deadlocks"></a>innodb_print_all_deadlocks</h4><ul>
<li><strong>说明</strong>：控制是否将检测到的死锁信息输出到错误日志中。</li>
<li><strong>配置值</strong>：<code>ON</code> 或 <code>OFF</code>，默认通常为 <code>OFF</code>。</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>开启后有助于开发和运维人员分析死锁原因，但可能会在高并发环境下产生较多日志输出。</li>
<li>可在调试阶段开启，生产环境根据需要选择是否保留。</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="binlog-format"><a href="#binlog-format" class="headerlink" title="binlog_format"></a>binlog_format</h4><ul>
<li><strong>说明</strong>：设置 <code>Binlog</code> 的记录格式，对复制和数据恢复影响较大。</li>
<li><strong>配置值</strong>：<ul>
<li><code>STATEMENT</code>：记录 SQL 语句；</li>
<li><code>ROW</code>：记录数据行的变化；</li>
<li><code>MIXED</code>：自动在 <code>STATEMENT</code> 和 <code>ROW</code> 间切换。</li>
</ul>
</li>
<li><strong>影响及注意事项</strong>：<ul>
<li><code>ROW</code> 模式数据一致性更高，但日志量大；<code>STATEMENT</code> 模式性能更好但在某些复杂操作时可能出现不一致；</li>
<li>复制环境下建议保持主从一致的配置。</li>
</ul>
</li>
</ul>
<h4 id="transaction-write-set-extraction"><a href="#transaction-write-set-extraction" class="headerlink" title="transaction_write_set_extraction"></a>transaction_write_set_extraction</h4><ul>
<li><strong>说明</strong>：用于并行复制场景中，提取写集（即事务修改的数据集合），以提高复制效率。</li>
<li><strong>配置值</strong>：例如 <code>XXHASH64</code>、<code>MURMUR32</code> 等。</li>
<li><strong>影响及注意事项</strong>：<ul>
<li>主要用于 <code>GTID</code> 和多线程复制的优化；</li>
<li>配置需与复制方案相适应，调整时注意与其他复制参数的匹配。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务是数据库保证数据一致性和完整性的重要手段，从 <code>ACID</code> 四大特性到 <code>InnoDB</code> 的多版本并发控制（<code>MVCC</code>），无一不体现了 MySQL 对高并发与安全的平衡追求。通过合适的隔离级别选择、精心的日志写入策略（<code>Redo/Undo/Binlog</code>）、间隙锁等锁机制的灵活运用，开发者既能避免常见的脏读、不可重复读、幻读等问题，又能在大多数场景下兼顾性能。在实际应用中，则需要持续关注控制事务范围、隔离级别、维护良好的索引与日志策略，再加上不断地监控、跟踪、诊断、处理异常。只有在理解事务原理与运行细节的基础上，才能在设计与运维中做出恰当决策，让数据库在严苛环境下依然保持高性能与高可靠。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/MySQL/">MySQL</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL%E4%BA%8B%E5%8A%A1/">MySQL事务</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/24/mysql-lock/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL锁机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/11/mysql-sql-optimize/">
                        <span class="hidden-mobile">MySQL优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'iyangtao/iyangtao.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>power by: </span> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span><u>Hexo</u></span></a> <span> - </span> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span><u>Fluid</u></span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize(null);
    }
  </script>




  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
