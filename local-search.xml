<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WebSocket实战</title>
    <link href="/2025/05/11/websocket/"/>
    <url>/2025/05/11/websocket/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动互联网与 IoT 场景下，“毫秒级、双向实时通信” 已成为业务标配：在线聊天、实时协作、行情推送、游戏对战……传统 HTTP 轮询或长轮询不仅延迟高，而且资源浪费严重。</p><p>WebSocket 自 2011 年纳入 RFC 6455，提供了浏览器原生支持的 <strong>全双工、持久化</strong> 通道，是解决上述痛点的行业通用方案。本文先从协议原理出发，梳理握手、帧格式、心跳机制等基础知识；随后给出 <strong>Java 8 原生实现</strong>，帮助读者快速上手；最后落地到 <strong>Spring Boot 2.7.18 + JWT + Redis</strong> 的生产级示例，展示如何在分布式环境下实现鉴权、点对点私聊与全局广播。读完本文，你将具备从 0 到 1 搭建企业级 WebSocket 服务的完整思路与代码骨架。</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="缘起与定位"><a href="#缘起与定位" class="headerlink" title="缘起与定位"></a>缘起与定位</h3><ul><li><strong>痛点</strong>：HTTP 天生是请求–响应模式，服务端无法主动推送，实时性差。</li><li><strong>方案</strong>：WebSocket（RFC 6455，2011 发布）在浏览器与服务器之间建立一条<strong>全双工</strong>、<strong>持久化</strong>的 TCP 连接，允许双方随时发送数据。</li></ul><h3 id="握手流程（HTTP-Upgrade）"><a href="#握手流程（HTTP-Upgrade）" class="headerlink" title="握手流程（HTTP Upgrade）"></a>握手流程（HTTP Upgrade）</h3><ol><li><p><strong>客户端发起 HTTP/1.1 请求</strong></p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<br><span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://example.com          # 可选，防跨站<br><span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>json, chat   # 可选，子协议<br></code></pre></div></td></tr></table></figure></li><li><p><strong>服务器返回 101 Switching Protocols</strong></p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br><span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat        # 若协商成功<br></code></pre></div></td></tr></table></figure><ul><li><code>Sec-WebSocket-Accept = BASE64(SHA-1(Sec-WebSocket-Key + GUID))</code></li><li>握手成功后，连接切换到 WebSocket 帧语义，结束所有 HTTP 语义。</li></ul></li></ol><h3 id="数据帧结构"><a href="#数据帧结构" class="headerlink" title="数据帧结构"></a>数据帧结构</h3><table><thead><tr><th>字段</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td>FIN</td><td>1 bit</td><td>是否为消息最后一帧</td></tr><tr><td>RSV1-3</td><td>1 bit×3</td><td>扩展使用，正常为 0</td></tr><tr><td>Opcode</td><td>4 bit</td><td>0x1 文本，0x2 二进制，0x8 关闭，0x9 Ping，0xA Pong…</td></tr><tr><td>MASK</td><td>1 bit</td><td><strong>客户端→服务器必须为 1</strong>；服务器→客户端通常为 0</td></tr><tr><td>Payload Len</td><td>7/7+16/7+64 bit</td><td>0–125，126，127 长度指示</td></tr><tr><td>Masking-Key</td><td>0/32 bit</td><td>仅当 MASK=1 时存在</td></tr><tr><td>Payload Data</td><td>可变</td><td>真正的数据内容</td></tr></tbody></table><ul><li><strong>掩码（Masking）</strong>：浏览器必须对出站数据用随机 32 bit Key 异或；防止代理缓存与协议混淆攻击。</li><li><strong>分片</strong>：大消息可拆成多帧（FIN=0）。</li><li><strong>控制帧</strong>最大 125 bytes，必须独立（Ping/Pong/Close）。</li></ul><h3 id="连接保活与关闭"><a href="#连接保活与关闭" class="headerlink" title="连接保活与关闭"></a>连接保活与关闭</h3><table><thead><tr><th>场景</th><th>机制</th></tr></thead><tbody><tr><td>保活</td><td>任一端可 <strong>Ping→Pong</strong> 确认活跃；无强制间隔，常配合业务心跳定制</td></tr><tr><td>关闭</td><td>发送 Close 帧（Code+Reason），收到方应回复 Close 并断 TCP（半握手式关闭）</td></tr></tbody></table><p>常见关闭码：1000 正常；1001 终端离开；1006 保留给异常断线（仅本地可见）。</p><h3 id="子协议与扩展"><a href="#子协议与扩展" class="headerlink" title="子协议与扩展"></a>子协议与扩展</h3><ul><li><strong>子协议</strong> (<code>Sec-WebSocket-Protocol</code>)：同一连接内约定更高层语义，如 <code>graphql-ws</code>、<code>mqtt</code>、<code>jsonrpc</code>。</li><li><strong>扩展</strong> (<code>Sec-WebSocket-Extensions</code>)：帧级能力，如 <code>permessage-deflate</code> 压缩、分片重排扩展。需双方协商一致。</li></ul><h3 id="安全考量"><a href="#安全考量" class="headerlink" title="安全考量"></a>安全考量</h3><table><thead><tr><th>风险</th><th>对策</th></tr></thead><tbody><tr><td>明文窃听/篡改</td><td>使用 **wss://**（TLS）</td></tr><tr><td>跨站 WebSocket 劫持 (CSWSH)</td><td>校验 Origin / token / Cookie SameSite</td></tr><tr><td>反射型 DOS</td><td>服务器应限制 Ping / Payload 大小</td></tr><tr><td>代理缓存混淆</td><td>客户端强制 Mask，服务端验证 Upgrade 头完整性</td></tr></tbody></table><h3 id="与-HTTP-HTTP-2-Server-Sent-Events-对比"><a href="#与-HTTP-HTTP-2-Server-Sent-Events-对比" class="headerlink" title="与 HTTP/HTTP-2/Server-Sent Events 对比"></a>与 HTTP/HTTP-2/Server-Sent Events 对比</h3><table><thead><tr><th>特性</th><th>WebSocket</th><th>SSE</th><th>HTTP/2+push</th></tr></thead><tbody><tr><td>双向通信</td><td>√</td><td>×（服务端单向）</td><td>理论可推送，但浏览器已弃用</td></tr><tr><td>传输层</td><td>TCP（或 TLS）</td><td>同</td><td>同</td></tr><tr><td>报文开销</td><td>极低（帧头 2–14 字节）</td><td>较低</td><td>需 HTTP 头</td></tr><tr><td>代理兼容</td><td>需显式支持 Upgrade</td><td>高</td><td>高</td></tr><tr><td>典型场景</td><td>IM、实时协作、游戏</td><td>股票行情、日志流</td><td>资源预加载</td></tr></tbody></table><h3 id="优缺点与适用场景"><a href="#优缺点与适用场景" class="headerlink" title="优缺点与适用场景"></a>优缺点与适用场景</h3><p><strong>优点</strong></p><ul><li>真·全双工&amp;低延迟</li><li>单一持久连接降低握手开销</li><li>广泛浏览器支持（IE 10+）</li></ul><p><strong>局限</strong></p><ul><li>需专门服务器或网关（Nginx、Spring WebFlux、Socket.IO、Vert.x…）</li><li>中间件（反向代理、负载均衡、防火墙）须显式开启 Upgrade 支持</li><li>无自带断线重连与心跳，需要应用层实现</li></ul><p><strong>典型应用</strong>：在线聊天、实时协同编辑、行情推送、多人游戏、IoT 即时控制、直播弹幕、客服系统等。</p><h3 id="实现要点（后端）"><a href="#实现要点（后端）" class="headerlink" title="实现要点（后端）"></a>实现要点（后端）</h3><ol><li><strong>握手与协议栈</strong><ul><li>Java：<code>javax.websocket</code>、Spring Boot <code>WebSocketHandler</code></li><li>Node.js：<code>ws</code>、Socket.IO</li><li>Go：<code>gorilla/websocket</code></li></ul></li><li><strong>会话管理</strong>：连接分组、广播、点对点、身份校验。</li><li><strong>心跳&amp;重连策略</strong>：Ping/Pong + 客户端指数退避重连。</li><li><strong>流量治理</strong>：限连接数、限消息频率、防止大包。</li><li><strong>压缩</strong>：开启 <code>permessage-deflate</code> 时评估 CPU 开销。</li><li><strong>负载均衡</strong>：粘性会话或共享状态（如 Redis 发布订阅、消息队列）。</li></ol><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><ul><li><strong>WebTransport / WebRTC DataChannel</strong>：更现代的多路复用、UDP 支持，可能在部分场景替代 WebSocket。</li><li>**HTTP/3 (QUIC)**：在 TLS + UDP 上的多路复用，将与 WebSocket (over HTTP/3) 协同进化。</li></ul><h2 id="Java-原生实现"><a href="#Java-原生实现" class="headerlink" title="Java 原生实现"></a>Java 原生实现</h2><p>在追求极简的场景（学习、PoC、微服务里自带 WebSocket 服务）下，我们可以抛开 Spring、Netty 等重量级框架，直接使用 Java EE 7 引入的 <code>javax.websocket</code> API。Java 8 自带该包（从 JDK 1.8u20 开始），配合轻量容器或 Tyrus Standalone，即可快速起 WebSocket 服务。</p><ol><li><p>环境准备</p><table><thead><tr><th>工具</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>JDK</td><td>1.8 (UTF-8 编码)</td><td>原生 API</td></tr><tr><td>Maven</td><td>3.6+</td><td>打包 demo</td></tr><tr><td>运行方式 A</td><td><strong>Tomcat 8+ / Jetty 9+</strong></td><td>已内置 WebSocket 容器</td></tr><tr><td>运行方式 B</td><td><strong>Tyrus Standalone</strong></td><td>纯 Java SE 启动，最轻量</td></tr></tbody></table><p>下文同时给出容器部署与嵌入式启动两种方式。</p></li><li><p>Maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>space.yangtao<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-ws<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 仅在“嵌入式 Tyrus”时需要 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.glassfish.tyrus/tyrus-server --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.tyrus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tyrus-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 打可执行 JAR（嵌入式模式） --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span></span><br><span class="hljs-tag">                                        <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>space.yangtao.Bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>若选择 Tomcat 部署，可省略依赖，直接打 WAR。</p></li><li><p>服务端实现</p><p>EchoEndpoint（UTF-8）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint(&quot;/echo&quot;)</span>   <span class="hljs-comment">// ws://host:port/echo</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoEndpoint</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger ONLINE = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = ONLINE.incrementAndGet();<br>        System.out.println(<span class="hljs-string">&quot;WebSocket opened, sid=&quot;</span> + session.getId() + <span class="hljs-string">&quot;, online=&quot;</span> + cnt);<br>    &#125;<br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">onMessage</span><span class="hljs-params">(String msg, Session session)</span> </span>&#123;<br>        String reply = <span class="hljs-string">&quot;【&quot;</span> + LocalDateTime.now() + <span class="hljs-string">&quot;】echo: &quot;</span> + msg;<br>        System.out.println(<span class="hljs-string">&quot;sid=&quot;</span> + session.getId() + <span class="hljs-string">&quot; -&gt; &quot;</span> + msg);<br>        <span class="hljs-keyword">return</span> reply;        <span class="hljs-comment">// 直接返回 =&gt; 自动包装文本帧</span><br>    &#125;<br><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(Session session, CloseReason reason)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = ONLINE.decrementAndGet();<br>        System.out.println(<span class="hljs-string">&quot;WebSocket closed, sid=&quot;</span> + session.getId() +<br>                           <span class="hljs-string">&quot;, reason=&quot;</span> + reason.getReasonPhrase() + <span class="hljs-string">&quot;, online=&quot;</span> + cnt);<br>    &#125;<br><br>    <span class="hljs-meta">@OnError</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Session session, Throwable thr)</span> </span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;sid=&quot;</span> + session.getId() + <span class="hljs-string">&quot; error: &quot;</span> + thr.getMessage());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Bootstrap（嵌入式 Tyrus 可选）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrap</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Server server = <span class="hljs-keyword">new</span> Server(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">null</span>, EchoEndpoint.class);<br>        <span class="hljs-keyword">try</span> &#123;<br>            server.start();<br>            System.out.println(<span class="hljs-string">&quot;WebSocket server started at ws://localhost:8080/echo&quot;</span>);<br>            <span class="hljs-comment">// 阻塞主线程</span><br>            Thread.currentThread().join();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            server.stop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>若用 Tomcat/Jetty，只需把 EchoEndpoint 打包成 WAR 部署，容器会自动扫描 <code>@ServerEndpoint</code>。</p></li><li><p>运行与测试</p><table><thead><tr><th>模式</th><th>步骤</th></tr></thead><tbody><tr><td><strong>容器</strong></td><td><code>mvn clean package -DskipTests</code> → 将 WAR 部署到 Tomcat <code>webapps/</code> → 浏览器连接 <code>ws://localhost:8080/&lt;context&gt;/echo</code></td></tr><tr><td><strong>嵌入式</strong></td><td><code>mvn clean package</code> → <code>java -jar target/websocket-echo-1.0-SNAPSHOT.jar</code> → 终端或浏览器连接 <code>ws://localhost:8080/echo</code></td></tr></tbody></table></li><li><p>常见问题 &amp; 小结</p><table><thead><tr><th>症状</th><th>排查要点</th></tr></thead><tbody><tr><td>404 / 500</td><td>容器未识别 <code>@ServerEndpoint</code>：确认 <code>javax.websocket-api</code> 冲突、<code>WEB-INF/web.xml</code> 无手动配置冲突</td></tr><tr><td>客户端握手失败</td><td>浏览器控制台看 <code>Request/Response</code>，是否返回 101；若是 WSS 需证书</td></tr><tr><td>多节点广播</td><td>WebSocket 连接有粘性，需借助 MQ / Redis 发布订阅做分发</td></tr><tr><td>心跳</td><td>建议业务层定时 <code>ping</code>/自定义消息，客户端断线重连</td></tr></tbody></table><p>至此，已经完成了一个纯原生 Java 8 WebSocket 的完整闭环：服务端、客户端、部署与测试。后续可基于此扩展身份校验、群聊、压缩、限流等生产级特性。</p></li></ol><h2 id="Spring-WebSocket"><a href="#Spring-WebSocket" class="headerlink" title="Spring WebSocket"></a>Spring WebSocket</h2><h3 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h3><p>使用 <strong>Spring-WebSocket</strong> 处理浏览器连接，同步集成 <strong>JWT 鉴权</strong> 与 <strong>Redis Pub/Sub</strong> 实现分布式广播。完整链路分三段：</p><table><thead><tr><th>阶段</th><th>关键动作</th></tr></thead><tbody><tr><td><strong>握手</strong></td><td>浏览器 <code>ws://…/ws?token=xxx</code> → <code>JwtHandshakeInterceptor</code> 校验 → 建立会话</td></tr><tr><td><strong>本机路由</strong></td><td><code>WsHandler</code> 收发消息；<code>WsSessionManager</code> 维护 <em>uid ↔ Session</em> 映射</td></tr><tr><td><strong>跨实例广播</strong></td><td><code>RedisPublisher</code> 将 <code>WsMessage</code> 发布到 <strong>Redis Channel</strong>；<code>RedisSubscriber</code> 订阅并分派给本机在线用户</td></tr></tbody></table><h3 id="核心类及职责"><a href="#核心类及职责" class="headerlink" title="核心类及职责"></a>核心类及职责</h3><table><thead><tr><th>类</th><th>作用</th><th>关键点</th></tr></thead><tbody><tr><td><code>JwtUtil</code></td><td>解析 / 校验 JWT</td><td><code>parseToken()</code> → 返回 userId</td></tr><tr><td><code>JwtHandshakeInterceptor</code></td><td>握手前拦截</td><td>从 URL 查询参数提取 <code>token</code> → 鉴权成功把 <code>uid</code> 放入 <code>attributes</code></td></tr><tr><td><code>WebSocketConfig</code></td><td>注册端点</td><td><code>registry.addHandler(wsHandler, &quot;/ws&quot;)</code> 并挂上拦截器</td></tr><tr><td><code>WsHandler</code></td><td>核心业务 Handler</td><td><code>afterConnectionEstablished()</code> 注册会话；<code>handleTextMessage()</code> 反序列化 <code>WsMessage</code> 并调用 <code>RedisPublisher</code></td></tr><tr><td><code>WsMessage</code></td><td>统一消息模型</td><td><code>uid</code>、<code>content</code>、<code>broadcast</code> 三字段</td></tr><tr><td><code>WsSessionManager</code></td><td>本机 Session 池</td><td><code>register / unregister / sendTo / broadcast</code></td></tr><tr><td><code>RedisPublisher</code></td><td>发布消息到 Redis</td><td><code>convertAndSend(&quot;ws-msg&quot;, json)</code></td></tr><tr><td><code>RedisSubscriber</code></td><td>订阅 <code>ws-msg</code> Channel</td><td>解析 <code>WsMessage</code> → 定向 / 广播 给本机 Session</td></tr><tr><td><code>RedisListenerConfig</code></td><td>官方写法订阅</td><td>用 <code>RedisMessageListenerContainer</code> 注册 <code>RedisSubscriber</code> (可选)</td></tr></tbody></table><p>生产环境还需 TLS、限流、心跳等配套，但与上表类职责正交。</p><h3 id="时序说明"><a href="#时序说明" class="headerlink" title="时序说明"></a>时序说明</h3><pre><code class=" mermaid">sequenceDiagram    participant B as Browser    participant G as Nginx / LB    participant A as Pod-A    participant R as Redis    participant B2 as Pod-B%% 握手阶段    B-&gt;&gt;G: ws://example.com/ws?token=JWT    G-&gt;&gt;A: ws (粘性连接)    A-&gt;&gt;A: JwtHandshakeInterceptor\n解析 token → uid    A--&gt;&gt;B: 101 Switching Protocols%% 私聊消息    B-&gt;&gt;A: &#123;&quot;uid&quot;:&quot;u2&quot;,&quot;content&quot;:&quot;hi&quot;,&quot;broadcast&quot;:false&#125;    A-&gt;&gt;A: WsHandler 生成 WsMessage    A-&gt;&gt;R: Redis PUBLISH ws-msg    R--&gt;&gt;A: SUBSCRIBE\n(本机收到)    R--&gt;&gt;B2: SUBSCRIBE\n(其他实例收到)    A-&gt;&gt;A: WsSessionManager.sendTo(u2)    B2-&gt;&gt;B2: WsSessionManager.sendTo(u2)%% 广播消息    Note over B: 若 broadcast=true\nRedisSubscriber 调用\nsessionManager.broadcast()</code></pre><ol><li><strong>握手阶段</strong><ul><li>请求透过负载均衡到某节点；<code>JwtHandshakeInterceptor</code> 校验成功 → <code>uid</code> 存进 <code>WebSocketSession.attributes</code>。</li></ul></li><li><strong>会话注册</strong><ul><li><code>WsHandler.afterConnectionEstablished</code> 把 <code>(uid, session)</code> 注册到 **<code>WsSessionManager</code>**（可一人多端登录）。</li></ul></li><li><strong>消息入站</strong><ul><li>浏览器发送任意符合 <code>WsMessage</code> 结构的 JSON。</li><li><code>WsHandler.handleTextMessage</code> 反序列化后统一调用 <code>RedisPublisher.publish(msg)</code> ——<strong>所有消息先入 Redis</strong>，保证分布式一致。</li></ul></li><li><strong>跨实例分发</strong><ul><li>每个实例的 <code>RedisSubscriber</code> 订阅 <code>ws-msg</code>：<ul><li><code>broadcast=true</code> ⇒ <code>sessionManager.broadcast(json)</code>。</li><li>否则 <code>sessionManager.sendTo(msg.getUser(), json)</code>。</li></ul></li></ul></li><li><strong>本机推送</strong><ul><li><code>WsSessionManager</code> 遍历目标 Session；<code>sendMessage()</code> 仅在 <code>isOpen()</code> 时发送，避免脏连接。</li></ul></li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><ol><li><p>新建 Spring Boot 项目，引入Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Web &amp; WebSocket --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JWT --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Redis (Lettuce 默认) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>添加 JWT 工具类（简化版）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String secret;<br><br>    <span class="hljs-comment">// 解析并校验，成功返回 userId，失败抛异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">parseToken</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Jwts.parser()<br>                   .setSigningKey(secret.getBytes(StandardCharsets.UTF_8))<br>                   .parseClaimsJws(token.replace(<span class="hljs-string">&quot;Bearer &quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>                   .getBody()<br>                   .getSubject();   <span class="hljs-comment">// userId</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>定义握手拦截器，用于处理鉴权以及绑定会话</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtHandshakeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandshakeInterceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtUtil jwtUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtHandshakeInterceptor</span><span class="hljs-params">(JwtUtil jwtUtil)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jwtUtil = jwtUtil;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">beforeHandshake</span><span class="hljs-params">(ServerHttpRequest req,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ServerHttpResponse resp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   WebSocketHandler handler,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   Map&lt;String, Object&gt; attrs)</span> </span>&#123;<br>        URI uri = req.getURI();<br>        String query = uri.getQuery(); <span class="hljs-comment">// e.g. token=xxx.yyy.zzz</span><br>        <span class="hljs-keyword">if</span> (query != <span class="hljs-keyword">null</span> &amp;&amp; query.contains(<span class="hljs-string">&quot;token=&quot;</span>)) &#123;<br>            String token = Arrays.stream(query.split(<span class="hljs-string">&quot;&amp;&quot;</span>))<br>                    .filter(p -&gt; p.startsWith(<span class="hljs-string">&quot;token=&quot;</span>))<br>                    .map(p -&gt; p.substring(<span class="hljs-string">&quot;token=&quot;</span>.length()))<br>                    .findFirst().orElse(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 解析并校验，成功返回 userId，失败抛异常</span><br>                String userId = jwtUtil.parseToken(token);<br>                attrs.put(<span class="hljs-string">&quot;uid&quot;</span>, userId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;<br>                resp.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHandshake</span><span class="hljs-params">(ServerHttpRequest r, ServerHttpResponse s,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         WebSocketHandler h, Exception e)</span> </span>&#123; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>定义 WebSocket消息体</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WsMessage</span> </span>&#123;<br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 目标用户 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String uid;<br>    <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 文本内容 </span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">private</span> String content;<br>    <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 是否广播标记；true 时忽略 user </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> broadcast;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>WebSocket 会话管理器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WsSessionManager</span> </span>&#123;<br><br>    <span class="hljs-comment">// uid → 会话集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;WebSocketSession&gt;&gt; pool = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String uid, WebSocketSession s)</span> </span>&#123;<br>        pool.computeIfAbsent(uid, k -&gt; ConcurrentHashMap.newKeySet()).add(s);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span><span class="hljs-params">(WebSocketSession s)</span> </span>&#123;<br>        pool.entrySet().removeIf(entry -&gt; entry.getValue().remove(s));<br>    &#125;<br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 精准投递 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendTo</span><span class="hljs-params">(String uid, String json)</span> </span>&#123;<br>        pool.getOrDefault(uid, <span class="hljs-keyword">new</span> HashSet&lt;&gt;()).forEach(s -&gt; safeSend(s, json));<br>    &#125;<br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 全局广播 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(String json)</span> </span>&#123;<br>        pool.values().stream().flatMap(Set::stream).forEach(s -&gt; safeSend(s, json));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">safeSend</span><span class="hljs-params">(WebSocketSession s, String text)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (s.isOpen()) <span class="hljs-keyword">try</span> &#123; s.sendMessage(<span class="hljs-keyword">new</span> TextMessage(text)); &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Redis发布/订阅组件</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisPublisher</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate template;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper mapper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(WsMessage msg)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            template.convertAndSend(<span class="hljs-string">&quot;ws-msg&quot;</span>, mapper.writeValueAsString(msg));<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException ignored) &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WsSessionManager sessionManager;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        Objects.requireNonNull(stringRedisTemplate.getConnectionFactory()).getConnection()<br>                .subscribe(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;ws-msg&quot;</span>.getBytes());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message raw, <span class="hljs-keyword">byte</span>[] pattern)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            WsMessage msg = mapper.readValue(raw.getBody(), WsMessage.class);<br>            <span class="hljs-keyword">if</span> (msg.isBroadcast()) &#123;<br>                sessionManager.broadcast(msg.getContent());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sessionManager.sendTo(msg.getUid(), msg.getContent());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>WebSocket处理器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WsHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextWebSocketHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WsSessionManager sessionManager;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisPublisher publisher;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession s)</span> </span>&#123;<br>        String uid = (String) s.getAttributes().get(<span class="hljs-string">&quot;uid&quot;</span>);<br>        sessionManager.register(uid, s);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTextMessage</span><span class="hljs-params">(WebSocketSession s, TextMessage tm)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (tm.getPayload().equalsIgnoreCase(<span class="hljs-string">&quot;PING&quot;</span>)) &#123;<br>                s.sendMessage(<span class="hljs-keyword">new</span> TextMessage(<span class="hljs-string">&quot;PONG&quot;</span>));<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 客户端直接发送符合 WsMessage 结构的 JSON</span><br>            WsMessage msg = mapper.readValue(tm.getPayload(), WsMessage.class);<br><br>            <span class="hljs-comment">// 服务端可补充 from/时间戳等信息</span><br>            <span class="hljs-comment">// msg.setFrom(uid)...</span><br><br>            publisher.publish(msg);   <span class="hljs-comment">// 一律走 Redis，实现跨实例广播 / 定向</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterConnectionClosed</span><span class="hljs-params">(WebSocketSession s, CloseStatus cs)</span> </span>&#123;<br>        sessionManager.unregister(s);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">spring-ws</span><br><br><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br><br><span class="hljs-meta">jwt.secret</span>=<span class="hljs-string">abc123</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>协议层</strong>：一次 HTTP Upgrade 握手即可切换到轻量帧语义，帧头最小仅 2 Bytes，依靠 Ping/Pong 保活。</li><li><strong>开发层</strong>：Java 提供 <code>javax.websocket</code>（Tyrus）满足纯 JDK 场景；Spring-WebSocket 则无缝融入 MVC 生态，可配合拦截器完成 JWT 鉴权。</li><li><strong>分布式</strong>：使用 Redis Pub/Sub 解耦实例，实现 <strong>“写入一次，集群即达”</strong>；统一的 <code>WsMessage</code> 数据结构简化了本机与跨节点路由。</li><li><strong>生产层</strong>：心跳、限流、TLS、Origin 校验、日志监控缺一不可；推荐用 <code>RedisMessageListenerContainer</code>、Prometheus 指标与灰度发布完善运维链路。</li><li><strong>演进方向</strong>：随着 HTTP/3 与 WebTransport 普及，未来可在 QUIC/UDP 上获得更低延迟与多路复用能力，但短期内 WebSocket 仍是浏览器实时通信的主力军。</li></ol>]]></content>
    
    
    <categories>
      
      <category>WebSocket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebSocket</tag>
      
      <tag>计算机网络</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO——网络IO</title>
    <link href="/2025/02/17/javase-io-socket/"/>
    <url>/2025/02/17/javase-io-socket/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络 IO (Network IO) 是分布式系统和互联网应用的基础。在 Java 生态中，从最初的 <code>Socket</code> / <code>ServerSocket</code>（阻塞式 BIO）到基于 <code>Selector</code> 的 NIO、再到 AIO（异步 IO）和高性能框架 Netty，都为不同规模的网络应用提供了丰富的选择。本文将介绍 Java 网络编程中常见的 TCP/UDP 套接字用法，并进一步探讨在高并发场景下广泛应用的Netty框架和零拷贝技术。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络IO（Network IO）指的是计算机通过网络进行数据传输的输入与输出操作，通常基于 Socket（套接字）进行通信。Socket是操作系统提供的编程接口（API），用于在不同设备或进程间建立网络连接，并进行数据收发。</p><h2 id="网络-IO-模式"><a href="#网络-IO-模式" class="headerlink" title="网络 IO 模式"></a>网络 IO 模式</h2><p>网络IO可以分为不同的模式：</p><ul><li><strong>阻塞 IO（BIO, Blocking IO）</strong><ul><li>服务器为每个客户端维护一个线程，适用于连接数较少的场景。</li><li>典型实现：<code>ServerSocket</code> 和 <code>Socket</code>。</li></ul></li><li><strong>非阻塞 IO（NIO, Non-blocking IO）</strong><ul><li>采用多路复用（Selector），可以管理多个Socket连接，提高性能。</li><li>适用于高并发场景，如 Netty 框架。</li></ul></li><li><strong>异步 IO（AIO, Asynchronous IO）</strong><ul><li>使用回调机制，完全异步非阻塞，适用于高吞吐需求的应用。</li></ul></li></ul><h2 id="Socket-与-ServerSocket"><a href="#Socket-与-ServerSocket" class="headerlink" title="Socket 与 ServerSocket"></a>Socket 与 ServerSocket</h2><h3 id="Socket-通信模型"><a href="#Socket-通信模型" class="headerlink" title="Socket 通信模型"></a>Socket 通信模型</h3><p>基于Socket的网络IO通信模型一般包含以下几个关键步骤：</p><ul><li><strong>服务器端</strong><ol><li>创建Socket（<code>ServerSocket</code>）。</li><li>绑定端口，监听客户端连接。</li><li>等待客户端连接（<code>accept()</code>）。</li><li>读取/发送数据（<code>InputStream</code> / <code>OutputStream</code>）。</li><li>关闭连接。</li></ol></li><li><strong>客户端</strong><ol><li>创建Socket并连接服务器（<code>Socket</code>）。</li><li>发送/接收数据。</li><li>关闭连接。</li></ol></li></ul><p>在 Java 中，<code>Socket</code> 和 <code>ServerSocket</code> 主要用于基于 TCP 协议的网络通信。<code>ServerSocket</code> 用于服务器端监听连接，<code>Socket</code> 用于客户端与服务器端通信。</p><h3 id="ServerSocket（服务器端）"><a href="#ServerSocket（服务器端）" class="headerlink" title="ServerSocket（服务器端）"></a>ServerSocket（服务器端）</h3><p><code>ServerSocket</code> 主要用于监听客户端的连接请求，一旦接受连接，它会返回一个新的 <code>Socket</code> 实例与客户端进行通信。</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>ServerSocket(int port)</code></td><td>创建绑定到指定端口的服务器套接字</td></tr><tr><td><code>accept()</code></td><td>监听并接受客户端连接（阻塞式）</td></tr><tr><td><code>close()</code></td><td>关闭服务器套接字</td></tr><tr><td><code>setSoTimeout(int timeout)</code></td><td>设置 <code>accept()</code> 方法的超时时间</td></tr><tr><td><code>getInetAddress()</code></td><td>获取服务器的 IP 地址</td></tr><tr><td><code>getLocalPort()</code></td><td>获取服务器监听的端口号</td></tr></tbody></table><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>; <span class="hljs-comment">// 监听端口</span><br>        <span class="hljs-keyword">try</span> (ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器启动，监听端口：&quot;</span> + port);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept(); <span class="hljs-comment">// 阻塞等待客户端连接</span><br>                System.out.println(<span class="hljs-string">&quot;客户端连接：&quot;</span> + socket.getInetAddress());<br><br>                <span class="hljs-keyword">new</span> Thread(() -&gt; handleClient(socket)).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleClient</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>             BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream()))) &#123;<br><br>            String message;<br>            <span class="hljs-keyword">while</span> ((message = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;收到客户端消息: &quot;</span> + message);<br>                writer.write(<span class="hljs-string">&quot;服务端回复: &quot;</span> + message + <span class="hljs-string">&quot;\n&quot;</span>);<br>                writer.flush();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><code>ServerSocket</code> 监听端口 <code>8080</code>，等待客户端连接。</li><li>每个连接由一个独立的线程处理，读取数据并回传给客户端。</li></ul><h3 id="Socket（客户端）"><a href="#Socket（客户端）" class="headerlink" title="Socket（客户端）"></a>Socket（客户端）</h3><p><code>Socket</code> 负责建立连接并进行数据收发。</p><h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Socket(String host, int port)</code></td><td>连接到指定主机和端口</td></tr><tr><td><code>getInputStream()</code></td><td>获取输入流（接收数据）</td></tr><tr><td><code>getOutputStream()</code></td><td>获取输出流（发送数据）</td></tr><tr><td><code>close()</code></td><td>关闭套接字</td></tr><tr><td><code>getInetAddress()</code></td><td>获取远程服务器的 IP 地址</td></tr><tr><td><code>setSoTimeout(int timeout)</code></td><td>设置读取数据的超时时间</td></tr></tbody></table><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String serverAddress = <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <span class="hljs-comment">// 本机服务器</span><br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>; <span class="hljs-comment">// 服务器端口</span><br><br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(serverAddress, port);<br>             BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>             BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream()));<br>             BufferedReader console = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in))) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;已连接到服务器 &quot;</span> + serverAddress + <span class="hljs-string">&quot;:&quot;</span> + port);<br><br>            String userInput;<br>            <span class="hljs-keyword">while</span> ((userInput = console.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                writer.write(userInput + <span class="hljs-string">&quot;\n&quot;</span>);<br>                writer.flush();<br><br>                String response = reader.readLine();<br>                System.out.println(<span class="hljs-string">&quot;服务器回复: &quot;</span> + response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>连接服务器 <code>127.0.0.1:8080</code>。</li><li>通过 <code>BufferedWriter</code> 发送消息，读取服务器的响应。</li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li><p><strong>运行服务器</strong>：先启动 <code>SimpleServer</code>，服务器会监听 <code>8080</code> 端口，等待客户端连接。</p></li><li><p><strong>运行客户端</strong>：启动 <code>SimpleClient</code>，成功连接服务器后，可以在终端输入消息。服务器收到消息后，会原样返回。</p></li><li><p><strong>示例交互</strong>：</p><ol><li><p>服务器启动：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">服务器启动，监听端口：8080<br></code></pre></div></td></tr></table></figure></li><li><p>客户端启动：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">已连接到服务器 <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">8080</span><br></code></pre></div></td></tr></table></figure></li><li><p>服务器连接成功：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">客户端连接：/<span class="hljs-number">127.0.0.1</span><br></code></pre></div></td></tr></table></figure></li><li><p>客户端发送消息：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">已连接到服务器 <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">8080</span><br>hello<br></code></pre></div></td></tr></table></figure></li><li><p>服务器收到消息并自动响应：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">服务器启动，监听端口：<span class="hljs-number">8080</span><br>客户端连接：/<span class="hljs-number">127.0.0.1</span><br>收到客户端消息: hello<br></code></pre></div></td></tr></table></figure></li><li><p>客户端接收到服务器的响应：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">已连接到服务器 <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">8080</span><br>hello<br>服务器回复: 服务端回复: hello<br></code></pre></div></td></tr></table></figure></li></ol></li></ol><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="TCP-通信特性"><a href="#TCP-通信特性" class="headerlink" title="TCP 通信特性"></a>TCP 通信特性</h4><ul><li><strong>面向连接</strong>：必须先建立连接（三次握手）。</li><li><strong>可靠传输</strong>：数据按序到达，无丢失（超时重传、流量控制、拥塞控制）。</li><li><strong>流式传输</strong>：数据以字节流方式传输，接收端需要解析数据边界。</li></ul><h4 id="TCP-底层实现"><a href="#TCP-底层实现" class="headerlink" title="TCP 底层实现"></a>TCP 底层实现</h4><p>TCP 的底层基于操作系统内核协议栈完成数据传输，主要包括：</p><ol><li><p>三次握手建立连接，当 <code>Socket</code> 进行 <code>connect()</code> 时，操作系统会执行 TCP 三次握手，过程如下：</p><ol><li>客户端发送 <code>SYN</code> 包给服务器，请求建立连接。</li><li>服务器返回 <code>SYN + ACK</code>，表示接受连接请求。</li><li>客户端回复 <code>ACK</code>，完成握手，连接建立。</li></ol><p>三次握手后，<code>Socket</code> 连接才真正建立，之后可以进行数据传输。</p></li><li><p>数据传输：</p><ul><li><p>TCP 使用滑动窗口和 ACK 确认机制保证数据可靠性。</p></li><li><p>TCP 会对数据进行分片和重组（MSS），并处理乱序、丢失的数据包（重传机制）。</p></li></ul></li><li><p>关闭连接（四次挥手），当 <code>Socket</code> 关闭时，会执行 TCP 四次挥手：</p><ol><li>客户端发送 <code>FIN</code>，请求断开连接。</li><li>服务器返回 <code>ACK</code>，表示收到请求。</li><li>服务器发送 <code>FIN</code>，请求关闭连接。</li><li>客户端发送 <code>ACK</code>，确认关闭。</li></ol><p>四次挥手完成后，操作系统释放 <code>Socket</code> 相关资源。</p></li></ol><h2 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h2><h3 id="DatagramSocket（UDP-套接字）"><a href="#DatagramSocket（UDP-套接字）" class="headerlink" title="DatagramSocket（UDP 套接字）"></a>DatagramSocket（UDP 套接字）</h3><p><code>DatagramSocket</code> 用于在发送端和接收端创建 UDP 连接。</p><ul><li>发送方用于发送 <code>DatagramPacket</code>。</li><li>接收方用于接收 <code>DatagramPacket</code>。</li></ul><h3 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a><strong>主要方法</strong></h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>DatagramSocket()</code></td><td>创建默认端口的 UDP 套接字</td></tr><tr><td><code>DatagramSocket(int port)</code></td><td>绑定指定端口的 UDP 套接字</td></tr><tr><td><code>send(DatagramPacket p)</code></td><td>发送数据包</td></tr><tr><td><code>receive(DatagramPacket p)</code></td><td>接收数据包（阻塞等待）</td></tr><tr><td><code>setSoTimeout(int timeout)</code></td><td>设置接收超时时间</td></tr><tr><td><code>close()</code></td><td>关闭套接字</td></tr></tbody></table><h3 id="DatagramPacket（UDP-数据包）"><a href="#DatagramPacket（UDP-数据包）" class="headerlink" title="DatagramPacket（UDP 数据包）"></a>DatagramPacket（UDP 数据包）</h3><p><code>DatagramPacket</code> 用于封装要发送和接收的数据。</p><ul><li><strong>发送方</strong>：指定目标地址、端口、数据内容。</li><li><strong>接收方</strong>：用于存储接收到的数据。</li></ul><p><strong>构造方法</strong>：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code></td><td>创建用于发送的 UDP 数据包</td></tr><tr><td><code>DatagramPacket(byte[] buf, int length)</code></td><td>创建用于接收的 UDP 数据包</td></tr></tbody></table><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>UDP 是无连接的，因此不需要像 TCP 那样建立 <code>Socket</code> 连接。下面是一个 UDP 通信的完整示例，包括服务器端（接收）和客户端（发送）。</p><h4 id="UDP-服务器端"><a href="#UDP-服务器端" class="headerlink" title="UDP 服务器端"></a>UDP 服务器端</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>; <span class="hljs-comment">// 监听端口</span><br>        <span class="hljs-keyword">try</span> (DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket(port)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;UDP 服务器已启动，监听端口：&quot;</span> + port);<br><br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 数据接收缓冲区</span><br>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(buffer, buffer.length);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                socket.receive(packet); <span class="hljs-comment">// 阻塞等待接收数据</span><br>                String receivedData = <span class="hljs-keyword">new</span> String(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>                System.out.println(<span class="hljs-string">&quot;收到消息: &quot;</span> + receivedData + <span class="hljs-string">&quot; 来自 &quot;</span> + packet.getAddress() + <span class="hljs-string">&quot;:&quot;</span> + packet.getPort());<br><br>                <span class="hljs-comment">// 服务器回复消息</span><br>                String response = <span class="hljs-string">&quot;服务器已收到：&quot;</span> + receivedData;<br>                <span class="hljs-keyword">byte</span>[] responseData = response.getBytes();<br>                DatagramPacket responsePacket = <span class="hljs-keyword">new</span> DatagramPacket(<br>                        responseData, responseData.length, packet.getAddress(), packet.getPort());<br>                socket.send(responsePacket);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;服务器异常&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>服务器创建 <code>DatagramSocket</code> 监听 <code>8080</code> 端口。</li><li>通过 <code>socket.receive(packet)</code> 接收 UDP 数据包（阻塞等待）。</li><li>解析 <code>packet.getData()</code> 获取消息内容。</li><li>服务器收到消息后，使用 <code>socket.send(responsePacket)</code> 发送回复消息。</li></ul><h4 id="UDP-客户端"><a href="#UDP-客户端" class="headerlink" title="UDP 客户端"></a>UDP 客户端</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String serverAddress = <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <span class="hljs-comment">// 服务器地址</span><br>        <span class="hljs-keyword">int</span> serverPort = <span class="hljs-number">8080</span>; <span class="hljs-comment">// 服务器端口</span><br><br>        <span class="hljs-keyword">try</span> (DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket();<br>             Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)) &#123;<br>            InetAddress serverInetAddress = InetAddress.getByName(serverAddress);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.print(<span class="hljs-string">&quot;请输入消息: &quot;</span>);<br>                String message = scanner.nextLine();<br>                <span class="hljs-keyword">byte</span>[] sendData = message.getBytes();<br><br>                <span class="hljs-comment">// 发送数据包</span><br>                DatagramPacket sendPacket = <span class="hljs-keyword">new</span> DatagramPacket(sendData, sendData.length, serverInetAddress, serverPort);<br>                socket.send(sendPacket);<br><br>                <span class="hljs-comment">// 接收服务器的回复</span><br>                <span class="hljs-keyword">byte</span>[] receiveBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                DatagramPacket receivePacket = <span class="hljs-keyword">new</span> DatagramPacket(receiveBuffer, receiveBuffer.length);<br>                socket.receive(receivePacket);<br><br>                String response = <span class="hljs-keyword">new</span> String(receivePacket.getData(), <span class="hljs-number">0</span>, receivePacket.getLength());<br>                System.out.println(<span class="hljs-string">&quot;服务器回复: &quot;</span> + response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;客户端异常&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>客户端创建 <code>DatagramSocket</code> 用于发送数据包。</li><li>通过 <code>DatagramPacket</code> 发送数据到 <strong><code>127.0.0.1:8080</code></strong> 服务器端。</li><li>发送后，阻塞等待服务器的响应并打印出来。</li></ul><h3 id="运行流程-1"><a href="#运行流程-1" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li><p><strong>运行服务器</strong>：先启动 <code>UDPServer</code>，服务器会在 <code>8080</code> 端口监听 UDP 数据包，等待客户端连接。</p></li><li><p><strong>运行客户端</strong>：启动 <code>UDPClient</code>，成功连接服务器后，可以在终端输入消息。服务器收到消息后，会原样返回。</p></li><li><p><strong>示例交互</strong>：</p><ol><li><p>服务器启动：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">UDP</span> 服务器已启动，监听端口：<span class="hljs-number">8080</span><br></code></pre></div></td></tr></table></figure></li><li><p>客户端启动连接。</p></li><li><p>服务器连接成功。</p></li><li><p>客户端发送消息：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">请输入消息: hello</span><br></code></pre></div></td></tr></table></figure></li><li><p>服务器收到消息并自动响应：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">UDP</span> 服务器已启动，监听端口：<span class="hljs-number">8080</span><br>收到消息: hello 来自 /<span class="hljs-number">127.0.0.1:56379</span><br></code></pre></div></td></tr></table></figure></li><li><p>客户端接收到服务器的响应：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">请输入消息: hello</span><br><span class="hljs-section">服务器回复: 服务器已收到：hello</span><br><span class="hljs-section">请输入消息: </span><br></code></pre></div></td></tr></table></figure></li></ol></li></ol><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="UDP-通信特性"><a href="#UDP-通信特性" class="headerlink" title="UDP 通信特性"></a>UDP 通信特性</h4><ul><li><strong>无连接</strong>：数据直接发送，无需建立连接。</li><li><strong>不可靠</strong>：不保证数据到达、顺序，也不处理丢包。</li><li><strong>面向数据报</strong>：UDP 以数据报（<code>DatagramPacket</code>）的方式发送和接收。</li></ul><h4 id="UDP-底层实现"><a href="#UDP-底层实现" class="headerlink" title="UDP 底层实现"></a>UDP 底层实现</h4><p>UDP 依赖 IP 层+UDP 协议进行数据传输，主要流程如下：</p><ol><li><p>发送数据</p><ul><li><p>用户数据封装成 <code>DatagramPacket</code>（包括数据、目标 IP/端口）。</p></li><li><p><code>UDP</code> 协议在数据前面添加 UDP 头部（源端口、目标端口、长度、校验和）。</p></li><li><p><code>IP</code> 层负责查找路由，将数据发送到目标主机。</p></li></ul><p>UDP 头部只有 8 字节，比 TCP 小很多，传输效率更高。</p></li><li><p>接收数据：</p><ul><li><p>操作系统监听 UDP 端口，接收符合条件的数据报文。</p></li><li><p>UDP 解析数据报头，去掉 UDP 头部后，将数据传递给应用层。</p></li></ul><p>UDP 不会自动重传丢失数据，应用层需要自己实现超时重传机制。</p></li></ol><h2 id="Socket-模型对比"><a href="#Socket-模型对比" class="headerlink" title="Socket 模型对比"></a>Socket 模型对比</h2><table><thead><tr><th>对比项</th><th>TCP（<code>Socket</code>）</th><th>UDP（<code>DatagramSocket</code>）</th></tr></thead><tbody><tr><td><strong>是否连接</strong></td><td>需要建立连接（三次握手）</td><td>无连接，直接发送</td></tr><tr><td><strong>可靠性</strong></td><td>可靠，保证数据到达、顺序、完整性</td><td>不可靠，可能丢包、乱序</td></tr><tr><td><strong>传输方式</strong></td><td>面向流，按字节流传输</td><td>面向数据报，每个 <code>DatagramPacket</code> 是独立数据</td></tr><tr><td><strong>头部大小</strong></td><td>20-60 字节（TCP 头部）</td><td>8 字节（UDP 头部）</td></tr><tr><td><strong>速度</strong></td><td>较慢（有流控和拥塞控制）</td><td>快（无流控、无握手）</td></tr><tr><td><strong>适用场景</strong></td><td>文件传输、Web 服务、数据库连接</td><td>直播、语音通话、游戏</td></tr></tbody></table><ul><li><code>DatagramSocket</code> 用于 UDP 通信，无需建立连接，适用于高速数据传输。</li><li><code>DatagramPacket</code> 封装 UDP 数据，可用于发送或接收数据包。</li><li>UDP 适用于实时性高、对数据完整性要求不高的场景，如：<ul><li>视频直播</li><li>语音通话</li><li>在线游戏</li><li>IoT 设备通信</li></ul></li></ul><h2 id="高性能网络框架-Netty"><a href="#高性能网络框架-Netty" class="headerlink" title="高性能网络框架 Netty"></a><strong>高性能网络框架 Netty</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Netty 是基于 Java NIO（非阻塞 IO） 开发的异步、高性能、事件驱动的网络通信框架，广泛用于高并发的网络应用，如 IM、RPC、网关、游戏服务器等。具有如下特性：</p><ul><li>原生 NIO 复杂（如 <code>Selector</code>、<code>ByteBuffer</code>、多线程管理）</li><li>Netty 封装了 NIO，提供高效、简洁的 API</li><li>适用于 TCP、UDP、WebSocket 等多种协议</li></ul><h3 id="底层架构"><a href="#底层架构" class="headerlink" title="底层架构"></a>底层架构</h3><p>Netty 的核心架构包括：</p><ul><li>Bootstrap &amp; ServerBootstrap（启动器）</li><li>EventLoopGroup（事件循环线程组）</li><li>Channel &amp; ChannelPipeline（通道 &amp; 处理管道）</li><li>ChannelHandler（事件处理器）</li><li>ByteBuf（高效数据缓冲区）</li></ul><h3 id="核心组件解析"><a href="#核心组件解析" class="headerlink" title="核心组件解析"></a>核心组件解析</h3><h4 id="Bootstrap-ServerBootstrap"><a href="#Bootstrap-ServerBootstrap" class="headerlink" title="Bootstrap / ServerBootstrap"></a>Bootstrap / ServerBootstrap</h4><ul><li><code>Bootstrap</code>：用于客户端启动 Netty。</li><li><code>ServerBootstrap</code>：用于服务器端启动 Netty。</li></ul><h4 id="EventLoopGroup（事件循环组）"><a href="#EventLoopGroup（事件循环组）" class="headerlink" title="EventLoopGroup（事件循环组）"></a>EventLoopGroup（事件循环组）</h4><ul><li><code>BossGroup</code>：处理客户端连接。</li><li><code>WorkerGroup</code>：处理具体数据读写。</li><li>每个 EventLoop 绑定一个 <code>Selector</code>，监听 Channel 事件（如 read、write）。</li></ul><h4 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h4><ul><li>封装底层 <code>SocketChannel</code>，用于数据读写。</li></ul><h4 id="ChannelPipeline（处理管道）"><a href="#ChannelPipeline（处理管道）" class="headerlink" title="ChannelPipeline（处理管道）"></a>ChannelPipeline（处理管道）</h4><ul><li>多个 <code>ChannelHandler</code> 组成的责任链，依次处理数据。</li><li>事件流转：<code>Inbound（入站）</code> → <code>Outbound（出站）</code>。</li></ul><h4 id="ChannelHandler（事件处理器）"><a href="#ChannelHandler（事件处理器）" class="headerlink" title="ChannelHandler（事件处理器）"></a>ChannelHandler（事件处理器）</h4><ul><li>入站处理器（处理读事件）</li><li>出站处理器（处理写事件）</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到消息: &quot;</span> + msg);<br>        ctx.writeAndFlush(<span class="hljs-string">&quot;Server Ack\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Netty-服务器端代码"><a href="#Netty-服务器端代码" class="headerlink" title="Netty 服务器端代码"></a>Netty 服务器端代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyServerHandler());<br>                    &#125;<br>                &#125;);<br><br>            ChannelFuture future = bootstrap.bind(<span class="hljs-number">8080</span>).sync();<br>            System.out.println(<span class="hljs-string">&quot;Netty 服务器启动！&quot;</span>);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到客户端消息: &quot;</span> + msg);<br>        ctx.writeAndFlush(<span class="hljs-string">&quot;Server Ack\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Netty-客户端代码"><a href="#Netty-客户端代码" class="headerlink" title="Netty 客户端代码"></a>Netty 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyClientHandler());<br>                    &#125;<br>                &#125;);<br><br>            ChannelFuture future = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            System.out.println(<span class="hljs-string">&quot;客户端连接成功！&quot;</span>);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        ctx.writeAndFlush(<span class="hljs-string">&quot;Hello Netty Server!\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到服务器回复: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Netty-VS-原生-NIO"><a href="#Netty-VS-原生-NIO" class="headerlink" title="Netty VS 原生 NIO"></a>Netty VS 原生 NIO</h3><table><thead><tr><th>对比项</th><th><strong>Netty</strong></th><th><strong>Java NIO</strong></th></tr></thead><tbody><tr><td><strong>API 简洁性</strong></td><td>封装好，使用简单</td><td>复杂，需要手动管理</td></tr><tr><td><strong>线程管理</strong></td><td>自动优化 <code>EventLoopGroup</code></td><td>需手动创建 <code>Selector</code>、<code>ThreadPool</code></td></tr><tr><td><strong>数据处理</strong></td><td><code>ByteBuf</code> 更高效</td><td><code>ByteBuffer</code> 操作繁琐</td></tr><tr><td><strong>支持协议</strong></td><td>TCP、UDP、WebSocket、HTTP</td><td>仅支持 TCP/UDP</td></tr><tr><td><strong>扩展性</strong></td><td>支持插件、拦截器、编解码器</td><td>需手写业务逻辑</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>IM 即时通讯（如微信、QQ、聊天室）</li><li>RPC 远程调用（Dubbo、gRPC）</li><li>网关、代理服务器（如 Nginx、Kong）</li><li>游戏服务器（高并发，低延迟）</li><li>高性能 WebSocket 应用</li></ul><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在传统的 IO 模型中，数据通常需要在用户空间和内核空间之间多次拷贝。例如，从磁盘读取数据到内核空间，然后再将其拷贝到用户空间，接着再从用户空间拷贝回内核空间，最后才发送到网络或写入到另一个文件。这种反复拷贝过程会带来额外的 CPU 开销和内存带宽消耗。</p><p>零拷贝（Zero Copy）技术通过利用操作系统（OS）的底层支持，将数据在文件（或其他数据源）与网络或另一数据目标之间直接在内核空间完成传输，从而省去或减少不必要的用户态-内核态数据拷贝。零拷贝并不是绝对 “零”，而是指对用户态来说不再进行额外拷贝，极大地减少了数据在用户空间与内核空间之间的来回移动。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><h4 id="FileChannel-的-transferTo-transferFrom"><a href="#FileChannel-的-transferTo-transferFrom" class="headerlink" title="FileChannel 的 transferTo / transferFrom"></a>FileChannel 的 transferTo / transferFrom</h4><p>在 Java 的 NIO 中，<code>FileChannel</code> 提供了两个方法来支持零拷贝式的数据传输：</p><ol><li><code>transferTo(long position, long count, WritableByteChannel target)</code><ul><li>可以将当前文件通道的数据直接传输到目标通道（比如网络通道或另一个文件通道）。</li><li>底层可能调用操作系统的 <code>sendfile</code> 等本地方法，避免了用户空间的拷贝。</li></ul></li><li><code>transferFrom(ReadableByteChannel src, long position, long count)</code><ul><li>与 <code>transferTo</code> 相反，将数据从可读通道直接传输到当前文件通道。</li></ul></li></ol><p><strong>工作原理</strong>：</p><ul><li>如果操作系统及其底层驱动支持 “零拷贝” 功能（如 Linux 的 <code>sendfile()</code> 系统调用），Java NIO 就能利用这些系统调用将数据直接从文件通道拷贝到网络或另一个文件通道的内核缓冲区。</li><li>这样做的好处是：数据并不会再返回到 Java 用户态中，从而显著降低了 CPU 消耗和内存带宽的占用。</li></ul><h4 id="MappedByteBuffer-与内存映射文件"><a href="#MappedByteBuffer-与内存映射文件" class="headerlink" title="MappedByteBuffer 与内存映射文件"></a>MappedByteBuffer 与内存映射文件</h4><p>在 Java NIO 中，还可以使用 <code>MappedByteBuffer</code>（通过 <code>FileChannel.map</code> 方法）将文件直接映射到内存中，这也是一种 “零拷贝” 的思想体现。</p><ul><li>当文件被映射到内存之后，就可以像操作内存数组一样对文件进行读写，而实际上读写的过程由操作系统负责将磁盘数据加载到内存（往往使用分页和缓存）。</li><li>对于大文件，操作系统会根据需要分段将数据加载到内存，且会使用缺页中断技术实现部分加载；对文件的写操作也可以 “懒加载” 或 “延时写回”。</li><li>这样也避免了传统 IO 对文件内容进行多次复制，有助于提升 IO 性能。</li></ul><p>需要注意的是，<code>MappedByteBuffer</code> 常用于大文件或随机读写场景，且要留意可能出现的 “直接内存” 占用过大或文件锁问题。</p><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><p>以 Linux 平台为例，在使用零拷贝进行文件到网络的传输时，一般会调用操作系统的 <code>sendfile()</code> 或者更先进的 <code>splice()</code>、<code>sendfile64()</code> 之类的系统调用，整体流程可以概括如下：</p><ol><li><p><strong>内核读取文件页缓存</strong>：</p><p>当需要将文件数据发送到网络时，操作系统首先会将文件对应的磁盘数据读入到内核空间的页缓存（page cache）中（如果先前还没在缓存里）。</p></li><li><p><strong>直接将内核缓存数据传送到 Socket 缓冲区</strong>：</p><p>通过零拷贝方法（如 <code>sendfile()</code>），文件数据不需要再拷贝到用户空间，而是直接在内核态将数据从页缓存复制（或映射）到 Socket 缓冲区。</p></li><li><p><strong>DMA（Direct Memory Access）驱动的数据发送</strong>：</p><p>网络接口卡（NIC）在发送数据时，会由 DMA 控制器直接从 Socket 缓冲区中读取数据并发送到网络上，这一步也不需要 CPU 参与数据拷贝。</p></li></ol><p>整个过程中，CPU 不再需要进行数据的用户态/内核态切换拷贝，大幅减少了复制开销。</p><h3 id="对比传统网络-IO"><a href="#对比传统网络-IO" class="headerlink" title="对比传统网络 IO"></a>对比传统网络 IO</h3><h4 id="传统-Socket-发送文件流程"><a href="#传统-Socket-发送文件流程" class="headerlink" title="传统 Socket 发送文件流程"></a>传统 Socket 发送文件流程</h4><p>当应用使用 <code>read()</code> 读取磁盘文件并通过 <code>Socket</code> 发送时，数据会经历多个拷贝：</p><pre><code class=" mermaid">sequenceDiagram    autonumber    participant 应用层    participant 用户态缓冲区    participant 内核态缓冲区    participant 磁盘    participant 网卡    rect rgb(255, 204, 204)    应用层-&gt;&gt;磁盘: read()    磁盘--&gt;&gt;内核态缓冲区: DMA拷贝（磁盘-&gt;内核）    内核态缓冲区--&gt;&gt;用户态缓冲区: CPU拷贝（内核-&gt;用户）    用户态缓冲区--&gt;&gt;内核态缓冲区: CPU拷贝（用户-&gt;内核）    内核态缓冲区--&gt;&gt;网卡: DMA拷贝（内核-&gt;网卡）    end</code></pre><ol><li><code>read()</code>：数据从磁盘拷贝到内核缓冲区（Page Cache）（DMA 拷贝）。</li><li>拷贝到用户态：数据从内核缓冲区拷贝到用户缓冲区（CPU 拷贝）。</li><li><code>write()</code>：用户缓冲区数据拷贝回内核 Socket 缓冲区（CPU 拷贝）。</li><li>数据发送：数据从 Socket 缓冲区拷贝到网卡缓冲区（DMA 拷贝）。</li></ol><p><strong>问题</strong>：有 4 次数据拷贝，其中 2 次 CPU 拷贝（用户态 ⇄ 内核态）会造成 CPU 额外开销。</p><h4 id="零拷贝-sendfile-方式"><a href="#零拷贝-sendfile-方式" class="headerlink" title="零拷贝 sendfile() 方式"></a>零拷贝 sendfile() 方式</h4><p><code>sendfile()</code> 是 Linux 提供的零拷贝系统调用，用于高效传输文件：</p><pre><code class=" mermaid">sequenceDiagram    autonumber    participant 应用层    participant 用户态缓冲区    participant 内核态缓冲区    participant 磁盘    participant 网卡    rect rgb(204, 255, 204)    磁盘--&gt;&gt;内核态缓冲区: DMA拷贝（磁盘-&gt;内核）    内核态缓冲区--&gt;&gt;网卡: DMA拷贝（内核-&gt;网卡）    end</code></pre><ol><li><code>sendfile(fd, socket, offset, length)</code> 直接让内核缓冲区数据通过 DMA 传输送到 Socket 缓冲区。</li><li>数据直接传输到网卡，不进入用户态，减少 CPU 参与。</li></ol><p><strong>优势</strong>：</p><ul><li>少了 CPU 拷贝（不进入用户态），极大地减少了 CPU 消耗。</li><li>适用于大文件传输，如文件服务器、Web 服务器。</li></ul><h4 id="更高级的-mmap-sendfile（splice-技术）"><a href="#更高级的-mmap-sendfile（splice-技术）" class="headerlink" title="更高级的 mmap + sendfile（splice 技术）"></a>更高级的 mmap + sendfile（splice 技术）</h4><p>Linux 2.6 之后，提供了 <code>mmap + sendfile()</code> 或 <code>splice()</code>：</p><ul><li><code>mmap()</code>：将文件映射到用户态虚拟地址空间，避免 <code>read()</code> 时拷贝到用户态。</li><li><code>sendfile()</code> 或 <code>splice()</code>：直接从 Page Cache 传输到 Socket 缓冲区。</li></ul><p>这样，数据只在内核中流转，不需要进入用户态，大大提高高吞吐场景 的性能。</p><h3 id="Java-Netty-零拷贝"><a href="#Java-Netty-零拷贝" class="headerlink" title="Java Netty 零拷贝"></a>Java Netty 零拷贝</h3><p>Netty 广泛使用零拷贝技术，以下是 Netty 相关的零拷贝机制：</p><h4 id="Netty-FileRegion-实现零拷贝"><a href="#Netty-FileRegion-实现零拷贝" class="headerlink" title="Netty FileRegion 实现零拷贝"></a>Netty FileRegion 实现零拷贝</h4><p>在 Netty 服务器中，可以使用 <code>DefaultFileRegion</code> 直接将文件数据传输到 <code>SocketChannel</code>，避免数据进入用户态：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;largeFile.txt&quot;</span>);<br>RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;r&quot;</span>);<br>FileRegion region = <span class="hljs-keyword">new</span> DefaultFileRegion(raf.getChannel(), <span class="hljs-number">0</span>, file.length());<br>ctx.writeAndFlush(region);<br></code></pre></div></td></tr></table></figure><p><strong>原理</strong>：直接调用 <code>sendfile()</code> 发送数据，不经过 <code>ByteBuf</code>，避免数据拷贝，提高效率。</p><h4 id="Netty-ByteBuf-的零拷贝"><a href="#Netty-ByteBuf-的零拷贝" class="headerlink" title="Netty ByteBuf 的零拷贝"></a>Netty ByteBuf 的零拷贝</h4><p>Netty 通过 <code>ByteBuf</code> 优化数据存储，减少拷贝：</p><ul><li><code>CompositeByteBuf</code>（组合缓冲区）：多个 <code>ByteBuf</code> 共享数据，避免 <code>byte[]</code> 拷贝。</li><li><code>slice()</code>（数据切片）：共享数据，而不是复制数据。</li><li><code>DirectByteBuf</code>（直接缓冲区）：绕过 JVM 堆，直接使用 <code>ByteBuffer.allocateDirect()</code> 进行零拷贝。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ByteBuf buf = Unpooled.directBuffer(<span class="hljs-number">1024</span>);<br>buf.writeBytes(<span class="hljs-string">&quot;Zero Copy Test&quot;</span>.getBytes());<br></code></pre></div></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li>减少 <code>byte[]</code> 数组拷贝</li><li>直接使用 NIO <code>ByteBuffer</code>，减少 Java 堆 GC 开销</li><li>高效的网络数据处理</li></ul><h3 id="优势与适用场景"><a href="#优势与适用场景" class="headerlink" title="优势与适用场景"></a>优势与适用场景</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p><strong>减少数据拷贝次数</strong>：</p><p>传统 IO 模型需要多次在用户态和内核态之间进行数据拷贝，而零拷贝大幅减少了这些拷贝次数。</p></li><li><p><strong>降低 CPU 占用</strong>：</p><p>由于减少了内核态-用户态的拷贝操作，CPU 不再需要消耗额外的计算资源来进行大规模的数据搬运。</p></li><li><p><strong>提高数据吞吐量</strong>：</p><p>减少拷贝与减少 CPU 开销相结合，可以提升整体吞吐量。对于大文件传输或高并发场景，性能改进尤其明显。</p></li></ol><h4 id="典型适用场景"><a href="#典型适用场景" class="headerlink" title="典型适用场景"></a>典型适用场景</h4><ol><li><p><strong>文件服务器或大文件传输</strong>：</p><p>比如实现一个高效的文件下载服务器，把本地磁盘文件通过网络 Socket 发给客户端，这时可以使用 <code>FileChannel.transferTo()</code> 实现高效的零拷贝传输。</p></li><li><p><strong>Log 传输 / 实时流媒体</strong>：</p><p>对于需要快速推送大批量数据的日志系统或流媒体服务器，也可以利用零拷贝来减少负载。</p></li><li><p><strong>高并发、高吞吐网络应用</strong>：</p><p>在 Netty 等高性能网络框架中，也常常依赖操作系统底层的零拷贝机制来提升 IO 性能。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><strong>操作系统及硬件支持</strong>：</p><p>零拷贝通常依赖底层操作系统（如 Linux）的特定系统调用，以及硬件（如 NIC）对 DMA 的支持，不同操作系统上的实现和限制可能有所不同。</p></li><li><p><strong>在某些情况下仍有拷贝</strong>：</p><ul><li>如果要对数据进行修改或处理（比如加密、压缩、数据格式转换等），那必须由用户态程序拿到数据再进行操作，这时就无法完全规避拷贝。</li><li>如果数据目标通道不支持零拷贝特性，也可能会退回到传统方式传输。</li></ul></li><li><p><strong>transferTo 和 transferFrom 可能会有大小限制</strong>：</p><p>在一些操作系统版本或某些 JDK 实现中，对可传输的字节数有一定限制，需要分段传输大文件。</p></li><li><p><strong>MappedByteBuffer 占用直接内存</strong>：</p><p>映射文件时操作系统会分配 “直接内存”，如果映射文件非常大或未及时释放，可能造成内存紧张甚至 <code>OutOfMemoryError</code>。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 网络编程既可以使用阻塞 IO（BIO）搭配 <code>Socket</code> / <code>ServerSocket</code> 来编写简单直接的服务端与客户端，也能借助 NIO（非阻塞 IO）和 <code>Selector</code> 实现单线程管理多连接的高并发模型。对于需要更强性能、可扩展性的场景，如即时通讯、大规模并发连接或实时数据传输，Netty 框架提供了事件驱动、线程池分工以及强大的编解码处理能力，让网络开发更高效。</p><p>此外，零拷贝技术与 Netty 的 <code>FileRegion</code>、<code>ByteBuf</code> 等特性更是通过操作系统底层优化极大降低了复制开销，进一步提高了吞吐量。在选择合适的网络 IO 模型时，应结合应用需求（延迟、吞吐、并发数、数据可靠性等）进行权衡，从而在正确的场景下用合适的技术发挥最大的效能。</p>]]></content>
    
    
    <categories>
      
      <category>Java IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java IO</tag>
      
      <tag>网络IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO——NIO</title>
    <link href="/2025/02/14/javase-io-nio/"/>
    <url>/2025/02/14/javase-io-nio/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java NIO（New I/O）是从 Java 1.4 开始引入，并在后续版本不断完善的一套高性能 I/O 编程模型。它在保留传统流式 I/O 的基础上，提供了更灵活的缓冲区（Buffer） 与通道（Channel）机制，并加入了非阻塞 I/O和多路复用（Selector）等概念，极大地提升了高并发环境下的吞吐量。本篇文章将从缓冲区与通道的基本用法讲起，逐步剖析异步文件读写、网络编程，以及基于 Selector 的非阻塞服务器模型，帮助读者深入掌握 Java NIO。</p><h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 NIO 中，所有数据都是通过缓冲区（Buffer）来处理的。Buffer 本质上是一个容器，用于存储不同数据类型的数据（如 <code>ByteBuffer</code>、<code>CharBuffer</code>、<code>IntBuffer</code> 等）。数据的读写都必须经过 Buffer，Channel 与 Buffer 搭配使用，完成数据在程序与底层设备间的传输。</p><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><h4 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h4><ul><li><strong>作用：</strong> 用于记录一个特定的位置。调用 <code>mark()</code> 方法后，Buffer 会保存当前位置，后续可以通过 <code>reset()</code> 方法将 <code>position</code> 重置到该位置。</li><li><strong>注意：</strong> 一旦调用 <code>reset()</code>，如果 <code>mark</code> 不存在则会抛出异常。</li></ul><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><ul><li><strong>作用：</strong> 表示当前读写操作的位置。每次读或写操作后，<code>position</code> 会自动前移。</li><li><strong>特点：</strong> 在切换模式时（如调用 <code>flip()</code> 或 <code>rewind()</code>），<code>position</code> 会被相应调整。</li></ul><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><ul><li><strong>作用：</strong> 表示当前缓冲区中可以操作的最大范围。对于写操作来说，<code>limit</code> 通常等于 <code>capacity</code>；而对于读操作来说，<code>limit</code> 指定了数据的末尾位置。</li><li><strong>注意：</strong> 超过 <code>limit</code> 的位置是不可访问的。</li></ul><h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><ul><li><strong>作用：</strong> 表示缓冲区的固定大小，即能容纳的最大元素数。一经分配便不能改变。</li><li><strong>特点：</strong> <code>capacity</code> 决定了缓冲区分配时的总内存大小。</li></ul><h4 id="address"><a href="#address" class="headerlink" title="address"></a>address</h4><ul><li><strong>作用：</strong> 对于直接缓冲区（Direct Buffer）来说，该属性表示分配的内存地址。</li><li><strong>注意：</strong> 这是底层实现细节，一般仅用于性能优化或与本地代码交互的场景。</li></ul><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>Buffer(int mark, int pos, int lim, int cap)</code>：构造方法（受保护）用来初始化 Buffer 的 <code>mark</code>、<code>position</code>、<code>limit</code> 与 <code>capacity</code>。通常在子类（如 <code>ByteBuffer</code>）中调用，不直接在应用中使用。</li></ul><h4 id="设置和获取属性"><a href="#设置和获取属性" class="headerlink" title="设置和获取属性"></a>设置和获取属性</h4><ul><li><code>int capacity()</code>：返回缓冲区的容量。</li><li><code>int position()</code>：返回当前的 <code>position</code>。</li><li><code>Buffer position(int newPosition)</code>：设置新的 <code>position</code>，并返回当前 Buffer 实例，便于链式调用。调用时会检查 <code>newPosition</code> 是否在合法范围内。</li><li><code>int limit()</code>：返回当前的 <code>limit</code>。</li><li><code>Buffer limit(int newLimit)</code>：设置新的 <code>limit</code>，返回当前 Buffer 实例，同样会进行范围检查。</li><li><code>Buffer mark()</code>：在当前 <code>position</code> 处设置 <code>mark</code>，便于后续的 <code>reset</code> 操作。</li><li><code>Buffer reset()</code>：将 <code>position</code> 重置为之前保存的 <code>mark</code>。若 <code>mark</code> 不存在，将抛出异常。</li></ul><h4 id="模式转换操作"><a href="#模式转换操作" class="headerlink" title="模式转换操作"></a>模式转换操作</h4><ul><li><code>Buffer clear()</code>：重置缓冲区，设置 <code>position</code> 为 0，<code>limit</code> 为 <code>capacity</code>，同时丢弃 <code>mark</code>。通常用于写操作前的准备。</li><li><code>Buffer flip()</code>：将缓冲区从写模式切换到读模式。<code>flip()</code> 方法会将 <code>limit</code> 设置为当前 <code>position</code> 的值，然后将 <code>position</code> 重置为 0，同时丢弃 <code>mark</code>。用于写入完毕后准备读取数据。</li><li><code>Buffer rewind()</code>：将 <code>position</code> 重置为 0（保留 <code>limit</code> 不变），常用于重新读取缓冲区中的数据，而不需要重新写入数据。</li></ul><h4 id="数据剩余和状态检查"><a href="#数据剩余和状态检查" class="headerlink" title="数据剩余和状态检查"></a>数据剩余和状态检查</h4><ul><li><code>int remaining()</code>：返回缓冲区中剩余可读或可写的元素数量（<code>limit - position</code>）。</li><li><code>boolean hasRemaining()</code>：判断缓冲区中是否还有未处理的数据（<code>remaining() &gt; 0</code>）。</li><li><code>boolean isReadOnly()</code>：检查当前缓冲区是否为只读模式。</li><li><code>boolean hasArray()</code>：判断缓冲区是否有一个可公开访问的底层数组（例如堆缓冲区通常支持）。</li><li><code>Object array()</code>：返回底层数组（如果存在），用于直接操作缓冲区数据。</li><li><code>int arrayOffset()</code>：返回底层数组中与缓冲区起始位置相关的偏移量。</li><li><code>boolean isDirect()</code>：判断缓冲区是否为直接缓冲区。直接缓冲区在操作系统内核层面分配内存，通常具有更高的 I/O 性能。</li></ul><h4 id="内部索引和边界检查方法"><a href="#内部索引和边界检查方法" class="headerlink" title="内部索引和边界检查方法"></a>内部索引和边界检查方法</h4><p>以下方法大多为包内或内部使用，用于确保索引操作的安全性。</p><ul><li><code>int nextGetIndex()</code> / <code>int nextGetIndex(int nb)</code>：用于在读取数据时获取下一个索引位置，后者支持一次性读取多个数据。内部会检查是否越界。</li><li><code>int nextPutIndex()</code> / <code>int nextPutIndex(int nb)</code>：用于写入数据时获取下一个写入索引，同样支持批量操作，并进行越界检查。</li><li><code>int checkIndex(int i)</code> / <code>int checkIndex(int i, int nb)</code>：用于检查单个索引或一段连续区域是否在合法范围内，防止数组越界异常。</li><li><code>int markValue()</code>：返回当前保存的 <code>mark</code> 值。</li><li><code>void truncate()</code>：内部方法，可能用于截断缓冲区数据（具体实现依赖于子类）。</li><li><code>void discardMark()</code>：丢弃已设置的 <code>mark</code>，通常在调用 <code>clear()</code> 或 <code>flip()</code> 时自动执行。</li><li><code>void checkBounds(int off, int len, int size)</code>：用于检查操作的起始偏移和长度是否在规定范围内。确保 <code>off</code> 和 <code>len</code> 的组合不超过指定 <code>size</code>。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使用缓冲区通常会涉及以下几个步骤：</p><ol><li><strong>写入数据</strong>：将数据放入 Buffer 中，此时 <code>position</code> 会递增。</li><li><strong>切换读模式</strong>：调用 <code>flip()</code> 方法，将 <code>position</code> 置为 0，同时将 <code>limit</code> 设置为之前写入的数据量。</li><li><strong>读取数据</strong>：从 Buffer 中取出数据。</li><li><strong>清理或压缩</strong>：调用 <code>clear()</code> 方法重置缓冲区或调用 <code>compact()</code> 方法保留未读数据以继续写入。</li></ol><h3 id="字节数据缓冲区"><a href="#字节数据缓冲区" class="headerlink" title="字节数据缓冲区"></a>字节数据缓冲区</h3><p>字节数据缓冲区 <code>ByteBuffer</code> 是最常用的缓冲区类型，用于存储和操作字节数据。在文件 I/O、网络通信等场景中，我们经常需要通过 <code>ByteBuffer</code> 来处理原始数据流。ByteBuffer 支持多种操作，如读写、切换模式、标记和复位等。</p><p><strong>示例</strong>：使用 <code>ByteBuffer</code> 进行基本的读写操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 分配一个 32 字节大小的 ByteBuffer</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">32</span>);<br><br>        <span class="hljs-comment">// 写入数据到缓冲区</span><br>        String input = <span class="hljs-string">&quot;Hello, NIO ByteBuffer!&quot;</span>;<br>        buffer.put(input.getBytes(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 切换到读模式</span><br>        buffer.flip();<br><br>        <span class="hljs-comment">// 从缓冲区中读取数据</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>        buffer.get(bytes);<br>        String output = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br><br>        System.out.println(<span class="hljs-string">&quot;读取数据：&quot;</span> + output);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="字符数据缓冲区"><a href="#字符数据缓冲区" class="headerlink" title="字符数据缓冲区"></a>字符数据缓冲区</h3><p>字符数据缓冲区 <code>CharBuffer</code> 专用于存储字符数据，在处理文本时十分常用。与 <code>ByteBuffer</code> 类似，<code>CharBuffer</code> 也具有 <code>position</code>、<code>limit</code> 和 <code>capacity</code> 属性，并提供相应的读写操作。它特别适合需要对字符或字符串进行操作的场景，如文件字符编码转换、字符数据处理等。</p><p><strong>示例</strong>：使用 <code>ByteBuffer</code> 进行基本的读写操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharBufferDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 分配一个容量为 20 的 CharBuffer</span><br>        CharBuffer charBuffer = CharBuffer.allocate(<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 写入字符数据</span><br>        String message = <span class="hljs-string">&quot;Hello, CharBuffer!&quot;</span>;<br>        charBuffer.put(message);<br><br>        <span class="hljs-comment">// 切换到读模式</span><br>        charBuffer.flip();<br><br>        <span class="hljs-comment">// 读取字符数据</span><br>        StringBuilder output = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (charBuffer.hasRemaining()) &#123;<br>            output.append(charBuffer.get());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;读取字符数据：&quot;</span> + output.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="其他类型缓冲区"><a href="#其他类型缓冲区" class="headerlink" title="其他类型缓冲区"></a>其他类型缓冲区</h3><p>除了 <code>ByteBuffer</code> 和 <code>CharBuffer</code>，<code>NIO</code> 还提供了其他多种缓冲区类型，分别对应不同的数据类型，如：</p><ul><li><code>IntBuffer</code>：用于存储整数。</li><li><code>LongBuffer</code>：用于存储长整型数据。</li><li><code>FloatBuffer</code>：用于存储单精度浮点数。</li><li><code>DoubleBuffer</code>：用于存储双精度浮点数。</li></ul><p>这些缓冲区的使用方式与 <code>ByteBuffer</code> 和 <code>CharBuffer</code> 类似，都支持基本的写入、读取、重置等操作。在需要处理非字节数据时，选择合适的缓冲区类型能够大幅提高程序的可读性和性能。</p><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>通道 Channel 是 Java NIO 中用于进行数据传输的组件。与传统 I/O 中的流不同，Channel 是双向的，即它既能进行读操作，也能进行写操作。常见的 Channel 包括：</p><ul><li><code>FileChannel</code>：用于文件的读写操作。</li><li><code>SocketChannel</code>：用于网络通信的读写操作。</li><li><code>ServerSocketChannel</code>：用于监听客户端连接请求。</li><li><code>DatagramChannel</code>：用于 UDP 网络通信。</li></ul><h3 id="与-Buffer-的配合"><a href="#与-Buffer-的配合" class="headerlink" title="与 Buffer 的配合"></a>与 Buffer 的配合</h3><p>Channel 不能直接操作数据，而是需要借助 Buffer。通过 Channel 将数据读入 Buffer，再由 Buffer 将数据写出到 Channel。这样的设计使得数据操作更加灵活，同时也便于实现非阻塞 I/O。</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p><code>FileChannel</code> 用于文件的读写操作。它不直接存储数据，而是依靠 Buffer 作为数据的容器。<code>FileChannel</code> 支持随机访问，因此可以在文件的任意位置进行读取或写入操作。注意：<code>FileChannel</code> 无法设置为非阻塞模式，但它提供了高效的文件 I/O 操作，例如文件拷贝和内存映射文件等。</p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li><strong>打开文件</strong>：通过 <code>open(Path path, OpenOption... options)</code> 方法打开一个文件。</li><li><strong>读取数据</strong>：通过 <code>read(ByteBuffer)</code> 方法将数据从文件读取到缓冲区。</li><li><strong>写入数据</strong>：通过 <code>write(ByteBuffer)</code> 方法将数据从缓冲区写入文件。</li><li><strong>文件定位</strong>：可以通过 <code>position()</code> 方法获取或设置文件中的当前位置，实现随机读取/写入。</li></ul><h3 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h3><p>通过 <code>open</code> 方法打开文件时，支持以下打开模式：</p><table><thead><tr><th><strong>模式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>READ</code></td><td>只读模式</td></tr><tr><td><code>WRITE</code></td><td>只写模式</td></tr><tr><td><code>APPEND</code></td><td>拼接的方式进行写操作</td></tr><tr><td><code>TRUNCATE_EXISTING</code></td><td>先将长度截断为 0（清空文件），再进行写操作</td></tr><tr><td><code>CREATE</code></td><td>文件不存在时创建</td></tr><tr><td><code>CREATE_NEW</code></td><td>只在文件不存在时创建（否则抛异常）</td></tr><tr><td><code>DELETE_ON_CLOSE</code></td><td>关闭时删除文件</td></tr><tr><td><code>SPARSE</code></td><td>允许创建稀疏文件</td></tr><tr><td><code>SYNC</code></td><td>文件内容或元数据的每次更新都立即同步文写入底层存储设备</td></tr><tr><td><code>DSYNC</code></td><td>文件内容的每次更新都立即同步文写入底层存储设备</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了如何使用 <code>FileChannel</code> 读取一个文本文件，并将读取到的数据输出到控制台。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileChannelDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String filePath = <span class="hljs-string">&quot;test.txt&quot;</span>;<br>        Charset charset = StandardCharsets.UTF_8; <span class="hljs-comment">// 确保读写使用相同的字符集</span><br><br>        <span class="hljs-comment">// 写入文件</span><br>        <span class="hljs-keyword">try</span> (RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(filePath, <span class="hljs-string">&quot;rw&quot;</span>);<br>             FileChannel fileChannel = file.getChannel()) &#123;<br><br>            String content = <span class="hljs-string">&quot;你好，FileChannel！&quot;</span>;<br>            ByteBuffer buffer = charset.encode(content); <span class="hljs-comment">// 将字符串编码为 ByteBuffer</span><br>            fileChannel.write(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 读取文件</span><br>        <span class="hljs-keyword">try</span> (RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(filePath, <span class="hljs-string">&quot;r&quot;</span>);<br>             FileChannel fileChannel = file.getChannel()) &#123;<br><br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            fileChannel.read(buffer);<br><br>            buffer.flip(); <span class="hljs-comment">// 切换到读模式</span><br>            String result = charset.decode(buffer).toString(); <span class="hljs-comment">// 解码为字符串</span><br>            System.out.println(<span class="hljs-string">&quot;读取内容: &quot;</span> + result);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在该示例中，我们首先打开一个文件并获取其 <code>FileChannel</code>，然后利用 <code>ByteBuffer</code> 将文件数据分段读取到内存中，并输出到控制台。</p><p><strong>关键点</strong>：</p><ul><li><strong>写入时</strong>： <code>Charset.encode(content)</code> 将字符串转换为 <code>ByteBuffer</code>。</li><li><strong>读取时</strong>： <code>Charset.decode(buffer)</code> 进行解码。</li></ul><h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p><code>AsynchronousFileChannel</code> 是 Java 7 引入的异步文件 I/O 通道，位于 <code>java.nio.channels</code> 包中。它支持非阻塞文件读写，使文件操作可以异步执行，特别适用于高并发文件访问、日志系统、文件服务器等场景。</p><p>相比于 <code>FileChannel</code>（同步 I/O），<code>AsynchronousFileChannel</code> 允许：</p><ul><li>读写操作异步执行，不阻塞主线程</li><li>支持 <code>CompletionHandler</code> 回调</li><li>支持 <code>Future</code> 机制</li><li>适用于高性能 I/O（如日志、数据存储）</li></ul><h4 id="对比-FileChannel"><a href="#对比-FileChannel" class="headerlink" title="对比 FileChannel"></a>对比 FileChannel</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>FileChannel</strong></th><th><strong>AsynchronousFileChannel</strong></th></tr></thead><tbody><tr><td><strong>I/O 模型</strong></td><td>同步</td><td>异步</td></tr><tr><td><strong>线程阻塞</strong></td><td>可能阻塞</td><td>不阻塞</td></tr><tr><td><strong>适用场景</strong></td><td>小型文件读写、普通 I/O</td><td>高并发文件访问、大型文件</td></tr><tr><td><strong>调用方式</strong></td><td><code>read()</code> / <code>write()</code></td><td><code>read()</code> / <code>write()</code>（带 <code>Future</code> 或 <code>CompletionHandler</code>）</td></tr><tr><td><strong>并发支持</strong></td><td>需要手动同步</td><td>线程安全，支持多个并发操作</td></tr></tbody></table><p><strong>适用场景</strong>：</p><ul><li><code>FileChannel</code> 适用于单线程文件操作。</li><li><code>AsynchronousFileChannel</code> 适用于多线程并发访问。</li></ul><h4 id="打开模式-1"><a href="#打开模式-1" class="headerlink" title="打开模式"></a>打开模式</h4><p>见 <code>FileChannel</code>。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul><li><p>使用 <code>Future</code> 进行异步读取。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncReadDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Path path = Paths.get(<span class="hljs-string">&quot;example_utf8.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 确保文件存在，并使用 UTF-8 编码写入测试内容</span><br>        <span class="hljs-keyword">if</span> (!Files.exists(path)) &#123;<br>            Files.write(path, <span class="hljs-string">&quot;你好，AsynchronousFileChannel！&quot;</span>.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE);<br>        &#125;<br><br>        AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);<br><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">long</span> position = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 异步读取</span><br>        Future&lt;Integer&gt; future = channel.read(buffer, position);<br><br>        <span class="hljs-comment">// 这里可以执行其他任务...</span><br><br>        <span class="hljs-comment">// 获取读取结果</span><br>        <span class="hljs-keyword">int</span> bytesRead = future.get();<br>        buffer.flip();<br>        String content = StandardCharsets.UTF_8.decode(buffer).toString();<br>        System.out.println(<span class="hljs-string">&quot;读取内容: &quot;</span> + content);<br><br>        channel.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>使用 <code>CompletionHandler</code> 进行异步读取。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncReadWithHandlerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        Path path = Paths.get(<span class="hljs-string">&quot;example_utf8.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 确保文件存在，并使用 UTF-8 编码写入测试内容</span><br>        <span class="hljs-keyword">if</span> (!Files.exists(path)) &#123;<br>            Files.write(path, <span class="hljs-string">&quot;你好，AsynchronousFileChannel！&quot;</span>.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE);<br>        &#125;<br><br>        AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);<br><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">long</span> position = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 使用 CompletionHandler 进行非阻塞读取</span><br>        channel.read(buffer, position, buffer, <span class="hljs-keyword">new</span> java.nio.channels.CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer bytesRead, ByteBuffer attachment)</span> </span>&#123;<br>                attachment.flip();<br>                String content = StandardCharsets.UTF_8.decode(attachment).toString();<br>                System.out.println(<span class="hljs-string">&quot;读取内容: &quot;</span> + content);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取失败: &quot;</span> + exc.getMessage());<br>            &#125;<br>        &#125;);<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 让主线程等待异步任务完成</span><br>        channel.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p><code>SocketChannel</code> 是用于网络通信的通道，主要用来实现基于 TCP 的客户端操作。它既支持阻塞模式，也支持非阻塞模式，特别适合需要进行异步网络 I/O 的场景。通过 <code>SocketChannel</code>，客户端可以连接到远程服务器，并发送/接收数据。</p><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li><strong>建立连接</strong>：使用 <code>connect(SocketAddress)</code> 方法连接到服务器。</li><li><strong>读取数据</strong>：使用 <code>read(ByteBuffer)</code> 从通道中读取数据。</li><li><strong>写入数据</strong>：使用 <code>write(ByteBuffer)</code> 向通道中写入数据。</li><li><strong>非阻塞模式</strong>：通过 <code>configureBlocking(false)</code> 将 <code>SocketChannel</code> 设置为非阻塞模式，以便在进行网络 I/O 时不被阻塞。</li></ul><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p><code>ServerSocketChannel</code> 是用于监听客户端连接请求的通道。它与传统的 <code>ServerSocket</code> 类似，但同样支持非阻塞模式，并且可与 <code>Selector</code> 配合使用，实现高效的多路复用。使用 <code>ServerSocketChannel</code> 可以在单线程中处理大量并发连接。</p><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li><strong>绑定端口</strong>：通过 <code>bind(SocketAddress)</code> 方法绑定服务器监听的地址和端口。</li><li><strong>接收连接</strong>：通过 <code>accept()</code> 方法接收客户端连接请求，该方法在非阻塞模式下返回 null 表示当前没有连接。</li><li><strong>设置非阻塞</strong>：通过 <code>configureBlocking(false)</code> 将通道设置为非阻塞模式。</li></ul><h2 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器 Selector"></a>选择器 Selector</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p><code>Selector</code> 是 Java NIO 提供的多路复用（Multiplexing） 机制，可以通过单个线程监听多个 <code>Channel</code>（通道）的事件（如可读、可写、连接等）。这样可以减少线程数量，提高系统的吞吐量，适用于高并发的网络服务器，如 HTTP 服务器、聊天服务器等。</p><p>传统的阻塞 I/O 需要为每个连接创建一个独立的线程，而 <code>Selector</code> 允许一个线程管理多个连接，实现非阻塞 I/O，大大减少了线程切换的开销。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h4><ul><li>例如 <code>SocketChannel</code>（TCP 客户端）、<code>ServerSocketChannel</code>（TCP 服务器）、<code>DatagramChannel</code>（UDP）。</li><li><code>Channel</code> 必须设置为非阻塞模式，才能配合 <code>Selector</code> 工作。</li></ul><h4 id="SelectionKey（选择键）"><a href="#SelectionKey（选择键）" class="headerlink" title="SelectionKey（选择键）"></a>SelectionKey（选择键）</h4><ul><li><p>代表 <code>Selector</code> 监听的事件，如：</p><ul><li><code>OP_ACCEPT</code>：连接就绪。</li><li><code>OP_READ</code>：可读。</li><li><code>OP_WRITE</code>：可写。</li><li><code>OP_CONNECT</code>：连接完成。</li></ul></li><li><p><code>SelectionKey</code> 绑定了 <code>Channel</code> 和 <code>Selector</code>，用于标识哪个通道准备好了特定的操作。</p></li></ul><h4 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h4><ul><li>负责监视多个 <code>Channel</code> 的事件变化，避免传统 <code>while(true)</code> 的轮询方式。</li></ul><h3 id="关键方法-1"><a href="#关键方法-1" class="headerlink" title="关键方法"></a>关键方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Selector.open()</code></td><td>创建 Selector</td></tr><tr><td><code>select()</code></td><td>阻塞等待至少一个通道就绪</td></tr><tr><td><code>select(long timeout)</code></td><td>超时等待指定时间（毫秒）</td></tr><tr><td><code>selectNow()</code></td><td>非阻塞检查就绪通道</td></tr><tr><td><code>selectedKeys()</code></td><td>获取已选择的 SelectionKey 集合</td></tr><tr><td><code>keys()</code></td><td>获取所有注册的 SelectionKey</td></tr><tr><td><code>wakeup()</code></td><td>让一个阻塞的 <code>select()</code> 方法立即返回</td></tr><tr><td><code>close()</code></td><td>关闭 Selector</td></tr></tbody></table><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><p>创建 <code>Selector</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Selector selector = Selector.open();<br></code></pre></div></td></tr></table></figure></li><li><p>将 <code>Channel</code> 注册到 <code>Selector</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">// 设置非阻塞</span><br>serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></div></td></tr></table></figure></li><li><p>轮询就绪事件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    selector.select();  <span class="hljs-comment">// 阻塞，直到至少有一个事件发生</span><br>    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        SelectionKey key = iterator.next();<br>        <span class="hljs-comment">// 处理 key</span><br>        iterator.remove();  <span class="hljs-comment">// 处理后删除，防止重复处理</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="SelectionKey-的操作类型"><a href="#SelectionKey-的操作类型" class="headerlink" title="SelectionKey 的操作类型"></a>SelectionKey 的操作类型</h3><p><code>Selector</code> 监听的事件包括：</p><table><thead><tr><th>操作类型</th><th>常量</th><th>适用于</th><th>说明</th></tr></thead><tbody><tr><td>接收连接</td><td><code>SelectionKey.OP_ACCEPT</code></td><td><code>ServerSocketChannel</code></td><td>监听新的客户端连接</td></tr><tr><td>连接完成</td><td><code>SelectionKey.OP_CONNECT</code></td><td><code>SocketChannel</code></td><td>检查客户端连接是否完成</td></tr><tr><td>读取数据</td><td><code>SelectionKey.OP_READ</code></td><td><code>SocketChannel</code></td><td>监听通道是否有数据可读</td></tr><tr><td>写入数据</td><td><code>SelectionKey.OP_WRITE</code></td><td><code>SocketChannel</code></td><td>监听通道是否可写</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>以下是一个基于 Java NIO（非阻塞 I/O）实现的多人聊天室，包括服务器和客户端。该代码实现了一个基于 <code>Selector</code> 的非阻塞 TCP 服务器，能够同时支持多个客户端进行聊天。</p><h4 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h4><ul><li>支持多客户端连接。</li><li>客户端可以发送消息到服务器。</li><li>服务器收到消息后会响应客户端发送的消息。</li><li>使用 <code>Selector</code> 管理多个 <code>SocketChannel</code>，提高性能。</li><li>非阻塞 I/O，适用于高并发聊天应用。</li></ul><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioChatServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1. 创建 Selector</span><br>        Selector selector = Selector.open();<br><br>        <span class="hljs-comment">// 2. 创建 ServerSocketChannel 并绑定端口</span><br>        ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));<br>        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// 设置非阻塞</span><br>        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        System.out.println(<span class="hljs-string">&quot;NIO 聊天服务器已启动，监听端口：&quot;</span> + PORT);<br><br>        <span class="hljs-comment">// 3. 轮询 Selector 监听事件</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            selector.select(); <span class="hljs-comment">// 阻塞直到有事件发生</span><br>            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();<br><br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                SelectionKey key = iterator.next();<br>                iterator.remove(); <span class="hljs-comment">// 处理完后删除，防止重复处理</span><br><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-comment">// 处理新的客户端连接</span><br>                    ServerSocketChannel server = (ServerSocketChannel) key.channel();<br>                    SocketChannel clientChannel = server.accept();<br>                    clientChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                    clientChannel.register(selector, SelectionKey.OP_READ);<br>                    System.out.println(<span class="hljs-string">&quot;新客户端连接：&quot;</span> + clientChannel.getRemoteAddress());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">// 处理客户端发送的消息</span><br>                    SocketChannel clientChannel = (SocketChannel) key.channel();<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">int</span> bytesRead = clientChannel.read(buffer);<br><br>                    <span class="hljs-keyword">if</span> (bytesRead == -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 客户端断开连接</span><br>                        System.out.println(<span class="hljs-string">&quot;客户端断开：&quot;</span> + clientChannel.getRemoteAddress());<br>                        clientChannel.close();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        buffer.flip();<br>                        String message = <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.limit());<br>                        System.out.println(<span class="hljs-string">&quot;收到消息：&quot;</span> + message);<br>                        <span class="hljs-comment">// 为了方便测试，这里只回复消息给发送者</span><br>                        clientChannel.write(ByteBuffer.wrap((<span class="hljs-string">&quot;你发送的消息是：&quot;</span> + message).getBytes()));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioChatClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVER_ADDRESS = <span class="hljs-string">&quot;localhost&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1. 创建 SocketChannel 并连接服务器</span><br>        SocketChannel clientChannel = SocketChannel.open();<br>        clientChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        clientChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(SERVER_ADDRESS, PORT));<br><br>        <span class="hljs-keyword">while</span> (!clientChannel.finishConnect()) &#123;<br>            <span class="hljs-comment">// 等待连接完成</span><br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;已连接到聊天服务器，输入消息发送：&quot;</span>);<br><br>        <span class="hljs-comment">// 启动新线程监听服务器消息</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    buffer.clear();<br>                    <span class="hljs-keyword">int</span> bytesRead = clientChannel.read(buffer);<br>                    <span class="hljs-keyword">if</span> (bytesRead &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.flip();<br>                        System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, buffer.limit()));<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;服务器已断开！&quot;</span>);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 主线程负责发送消息</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            String message = scanner.nextLine();<br>            clientChannel.write(ByteBuffer.wrap(message.getBytes()));<br>        &#125;<br><br>        clientChannel.close();<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol><li><p>启动服务器，服务器控制台打印如下：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">NIO</span> 聊天服务器已启动，监听端口：<span class="hljs-number">5000</span><br></code></pre></div></td></tr></table></figure></li><li><p>启动客户端，客户端控制台打印如下：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">已连接到聊天服务器，输入消息发送：<br></code></pre></div></td></tr></table></figure></li><li><p>服务器收到客户端的连接信息：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">NIO</span> 聊天服务器已启动，监听端口：<span class="hljs-number">5000</span><br>新客户端连接：/<span class="hljs-number">127.0.0.1:49791</span><br></code></pre></div></td></tr></table></figure></li><li><p>使用客户端发送消息：</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">已连接到聊天服务器，输入消息发送：</span><br><span class="hljs-comment">你好，这里是客户端a。</span><br></code></pre></div></td></tr></table></figure></li><li><p>服务器收到客户端发送的消息：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">NIO</span> 聊天服务器已启动，监听端口：<span class="hljs-number">5000</span><br>新客户端连接：/<span class="hljs-number">127.0.0.1:49791</span><br>收到消息：你好，这里是客户端a。<br></code></pre></div></td></tr></table></figure></li><li><p>客户端收到服务器响应的消息：</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">已连接到聊天服务器，输入消息发送：</span><br><span class="hljs-comment">你好，这里是客户端a。</span><br><span class="hljs-comment">你发送的消息是：你好，这里是客户端a。</span><br></code></pre></div></td></tr></table></figure></li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>单线程管理多个连接</strong>：相比于传统阻塞 I/O（每个连接需要一个线程），<code>Selector</code> 允许单个线程高效管理多个连接。</li><li><strong>减少上下文切换</strong>：使用非阻塞 I/O 可以避免线程切换的开销，提高性能。</li><li><strong>使用 ByteBuffer 进行数据传输</strong>：确保数据的高效读取和写入。</li><li><strong>适用于高并发场景</strong>：如聊天室、HTTP 服务器、WebSockets、游戏服务器等。</li></ul><h2 id="非阻塞模型总结"><a href="#非阻塞模型总结" class="headerlink" title="非阻塞模型总结"></a>非阻塞模型总结</h2><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><p><strong>打开通道（Channel）</strong></p><ul><li>服务器端：调用 <code>ServerSocketChannel.open()</code> 创建服务器通道，用于监听客户端连接请求。</li><li>客户端：调用 <code>SocketChannel.open()</code> 创建客户端通道，用于发起连接。</li></ul></li><li><p><strong>配置通道为非阻塞模式</strong></p><ul><li>对于 <code>ServerSocketChannel</code> 或 <code>SocketChannel</code> 执行 <code>configureBlocking(false)</code>，表示使用非阻塞模式。</li></ul></li><li><p><strong>创建选择器（Selector）</strong></p><ul><li>调用 <code>Selector.open()</code> 获得一个选择器实例。</li></ul></li><li><p><strong>通道注册到选择器（register）</strong></p><ul><li><p>服务器端示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(port));<br>serverChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></div></td></tr></table></figure></li><li><p>表示该服务器通道对 “接受连接（OP_ACCEPT）” 事件感兴趣。</p></li></ul></li><li><p><strong>事件循环（轮询就绪通道）</strong></p><ul><li>在主循环中调用 <code>selector.select()</code>，阻塞等待就绪事件，或调用 <code>selector.selectNow()</code> 做非阻塞检测。</li><li>当有就绪事件时，<code>selector.selectedKeys()</code> 中包含了所有就绪的 <code>SelectionKey</code>。然后对这些 key 逐一处理：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    SelectionKey key = iter.next();<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// 处理接受连接</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// 处理读事件</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>        <span class="hljs-comment">// 处理写事件</span><br>    &#125;<br>    iter.remove(); <span class="hljs-comment">// 移除已处理的key</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>处理具体读/写操作</strong></p><ul><li>如果事件是 <code>isReadable()</code>，就拿到对应的通道（如 <code>SocketChannel</code>）进行 <code>read()</code> 操作。读操作会将数据读入到 <code>ByteBuffer</code>。在非阻塞模式下，如果此时对方并没有发送数据可读，<code>read()</code> 调用会返回 0 或 -1（连接关闭），而不会阻塞线程。</li><li>如果事件是 <code>isWritable()</code>，就可以将数据从 <code>ByteBuffer</code> 写到通道中。如果通道暂时无法写满数据，也不会阻塞，可以下次继续写。</li><li>在需要的情况下，还可以根据当前处理流程动态修改对通道感兴趣的事件，比如读完后需要写，就把通道在选择器上注册为对写事件感兴趣。</li></ul></li></ol><p>通过上述流程，便可以在单线程或少量线程下管理成百上千的连接。只有当某个通道真正就绪时，才会触发相应的处理逻辑，大大提高了并发效率。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>选择器实现依赖于操作系统</strong><ul><li>在不同平台上，<code>Selector</code> 可能基于 <code>select</code>、<code>poll</code> 或 <code>epoll</code>。在高并发场景下，需要注意操作系统对文件描述符数量或内核参数的限制。</li></ul></li><li><strong>Selector 的空轮询（空转）问题</strong><ul><li>某些版本的 JDK（尤其在 Linux epoll 上）可能会出现空轮询 bug，导致 CPU 飙升。可以通过升级 JDK 或更改配置来解决。</li></ul></li><li><strong>读写时的缓冲区管理</strong><ul><li>建议重复使用 <code>ByteBuffer</code>，以减少对象创建的开销。或者使用内存池做统一管理。</li></ul></li><li><strong>与传统阻塞 IO 的配合</strong><ul><li>同一个通道要么是阻塞模式，要么是非阻塞模式。若业务中有阻塞操作，需确保不会影响非阻塞通道的高并发特性。</li></ul></li><li><strong>适用场景</strong><ul><li>非阻塞 IO 在大量短连接（如聊天服务器、游戏服务器、消息推送）或需要同时处理成百上千连接的场景特别有效。</li><li>如果连接数较少，但数据吞吐量大且需要稳定的流式处理，传统阻塞式 BIO 或者基于多线程的 I/O 也可能是可行的选择。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java NIO 的核心在于使用 Channel + Buffer 的数据传输模型，以及通过 Selector 实现单线程管理多连接的高并发特性。缓冲区让数据的读写更灵活可控，通道抽象出多种 I/O 形态（文件、网络、异步），Selector 解决了大量并发连接的线程切换难题。在实际项目中，NIO 非阻塞模式尤其适合网络服务器、代理、聊天系统等需要同时处理大量连接的场景。当然，对于小规模文件处理或简单网络通信，传统的阻塞 I/O 依然易于理解和维护。根据应用场景选择合适的 I/O 模型，才能更好地发挥 Java I/O 的威力。</p>]]></content>
    
    
    <categories>
      
      <category>Java IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java IO</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO——IO工具</title>
    <link href="/2025/02/08/javase-io-utils/"/>
    <url>/2025/02/08/javase-io-utils/</url>
    
    <content type="html"><![CDATA[<h2 id="Path-类"><a href="#Path-类" class="headerlink" title="Path 类"></a>Path 类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 Java NIO（<code>java.nio.file</code>）中，<code>Path</code> 类是 Java 7 引入的新文件路径处理 API，属于 <code>java.nio.file</code> 包的一部分。相比于旧的 <code>java.io.File</code>，<code>Path</code> 具有更强大的功能，包括：</p><ul><li>支持跨平台路径处理（自动适配 Windows 和 Unix/Linux）</li><li>支持相对路径与绝对路径</li><li>提供丰富的路径操作方法</li><li>支持符号链接（Symbolic Links）</li><li>与 <code>Files</code> 类搭配使用，实现强大的文件操作</li></ul><p><code>Path</code> 不是文件或目录本身，而是文件路径的抽象表示，它可以表示一个文件或目录的路径，既可以是相对路径，也可以是绝对路径。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Path 对象通过 java.nio.file.Paths 类的静态方法构造。</p><ul><li><code>Path get(String first, String... more)</code>：通过字符串创建 Path 对象。</li><li><code>Path get(URI uri)</code>：通过 URI 对象创建 Path 对象。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>FileSystem getFileSystem()</code>：返回创建此对象的文件系统。</li><li><code>boolean isAbsolute()</code>：判断是否为绝对路径。</li><li><code>Path getRoot()</code>：获取根路径。</li><li><code>Path getFileName()</code>：获取文件名。</li><li><code>Path getParent()</code>：获取父路径。</li><li><code>int getNameCount()</code>：获取路径层级数量。</li><li><code>Path getName(int index)</code>：获取层级（目录或文件）的名称。</li><li><code>Path subpath(int beginIndex, int endIndex)</code>：返回一个相对路径，该路径是此路径的名称元素的子序列。</li><li><code>Path toAbsolutePath()</code>：将路径转换为绝对路径。</li><li><code>boolean startsWith(Path other)</code>：判断此路径是否从给定路径开始。</li><li><code>boolean startsWith(String other)</code>：判断此路径是否从给定路径开始。</li><li><code>boolean endsWith(Path other)</code>：判断此路径是否从给定路径结束。</li><li><code>boolean endsWith(String other)</code>：判断此路径是否从给定路径结束。</li><li><code>Path resolve(Path other)</code>：拼接两个 Path。</li><li><code>Path relativize(Path other)</code>：构造此路径和给定路径之间的相对路径。</li><li><code>URI toUri()</code>：返回此路径的 URI。</li><li><code>File toFile()</code>：返回此路径标识的 File 对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException </span>&#123;<br>        <span class="hljs-comment">// 创建 Path 对象1</span><br>        Path path1 = Paths.get(<span class="hljs-string">&quot;nio-demo.txt&quot;</span>);<br>        <span class="hljs-comment">// 创建 Path 对象2</span><br>        Path path2 = Paths.get(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;file:///nio-demo.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 返回创建此对象的文件系统</span><br>        System.out.println(<span class="hljs-string">&quot;文件系统：&quot;</span> + path1.getFileSystem());<br><br>        <span class="hljs-comment">// 转换为绝对路径</span><br>        path1 = path1.toAbsolutePath();<br>        System.out.println(<span class="hljs-string">&quot;转换为绝对路径：&quot;</span> + path1);<br><br>        <span class="hljs-comment">// 是否为绝对路径</span><br>        System.out.println(<span class="hljs-string">&quot;是否为绝对路径：&quot;</span> + path1.isAbsolute());<br><br>        <span class="hljs-comment">// 获取根路径</span><br>        System.out.println(<span class="hljs-string">&quot;根路径：&quot;</span> + path1.getRoot());<br><br>        <span class="hljs-comment">// 获取文件路径层级信息</span><br>        System.out.println(<span class="hljs-string">&quot;文件路径层级数量：&quot;</span> + path1.getNameCount());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; path1.getNameCount(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;层级 &quot;</span> + i + <span class="hljs-string">&quot;：&quot;</span> + path1.getName(i));<br>        &#125;<br><br>        <span class="hljs-comment">// 返回 1-2 之间的子路径</span><br>        System.out.println(<span class="hljs-string">&quot;子路径：&quot;</span> + path1.subpath(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 是否以指定路径开始或结束</span><br>        System.out.println(<span class="hljs-string">&quot;是否以指定路径开始：&quot;</span> + path1.startsWith(Paths.get(<span class="hljs-string">&quot;C:/&quot;</span>)));<br>        System.out.println(<span class="hljs-string">&quot;是否以指定路径结束：&quot;</span> + path1.endsWith(<span class="hljs-string">&quot;nio-demo.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 拼接路径</span><br>        System.out.println(<span class="hljs-string">&quot;拼接路径：&quot;</span> + path1.resolve(<span class="hljs-string">&quot;nio-demo2.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 与 C:/ 的相对路径</span><br>        System.out.println(<span class="hljs-string">&quot;与 C:/ 的相对路径：&quot;</span> + path1.relativize(Paths.get(<span class="hljs-string">&quot;C:/&quot;</span>)));<br><br>        <span class="hljs-comment">// 返回路径 URI</span><br>        System.out.println(<span class="hljs-string">&quot;路径 URI：&quot;</span> + path1.toUri());<br><br>        <span class="hljs-comment">// 返回 File 对象</span><br>        System.out.println(<span class="hljs-string">&quot;File 对象：&quot;</span> + path1.toFile());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Files-类"><a href="#Files-类" class="headerlink" title="Files 类"></a>Files 类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>java.nio.file.Files</code> 是 Java 7 引入的文件和目录操作工具类，提供了大量静态方法来简化文件创建、删除、复制、移动、读取、写入、属性管理等 操作。相比 <code>java.io.File</code>，<code>Files</code> 类功能更丰富，并且可以与 <code>Path</code> 类无缝结合，适用于现代 Java 项目。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code>：创建文件。</li><li><code>Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code>：创建单层目录。</li><li><code>Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</code>：创建多层目录。</li><li><code>Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</code>：创建临时文件。</li><li><code>Path createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs)</code>：创建临时目录。</li><li><code>void delete(Path path)</code>：删除文件。</li><li><code>boolean deleteIfExists(Path path)</code>：安全地删除。</li><li><code>Path copy(Path source, Path target, CopyOption... options)</code>：将文件复制到目标文件。</li><li><code>Path move(Path source, Path target, CopyOption... options)</code>：将文件移动或重命名为目标文件。</li><li><code>Path write(Path path, byte[] bytes, OpenOption... options)</code>：将字节写入文件（通过参数控制追加、新建等）。</li><li><code>BufferedWriter newBufferedWriter(Path path, OpenOption... options)</code>：打开或创建用于写入的文件，返回BufferedWriter以高效的方式将文本写入文件。</li><li><code>List&lt;String&gt; readAllLines(Path path)</code>：读取文件中的所有行（UTF-8 字符集）。</li><li><code>BufferedReader newBufferedReader(Path path)</code>：打开文件进行读取，返回BufferedReader以高效的方式从文件中读取文本。</li><li><code>boolean exists(Path path, LinkOption... options)</code>：判断文件是否存在。</li><li><code>boolean notExists(Path path, LinkOption... options)</code>：判断文件是否不存在。</li><li><code>boolean isRegularFile(Path path, LinkOption... options)</code>：判断是否为文件。</li><li><code>boolean isDirectory(Path path, LinkOption... options)</code>：判断是否为目录。</li><li><code>boolean isHidden(Path path)</code>：判断文件是否被隐藏。</li><li><code>boolean isReadable(Path path)</code>：判断文件是否可读。</li><li><code>Stream&lt;Path&gt; list(Path dir)</code>：遍历目录下的文件。</li><li><code>Stream&lt;Path&gt; walk(Path start, FileVisitOption... options)</code>：递归遍历目录下的文件。</li><li><code>InputStream newInputStream(Path path, OpenOption... options)</code>：创建文件的输入流。</li><li><code>OutputStream newOutputStream(Path path, OpenOption... options)</code>：文件文件的输出流。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilesDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path path = Paths.get(<span class="hljs-string">&quot;files-nio-demo.txt&quot;</span>);<br>        <span class="hljs-comment">// 创建文件</span><br>        Files.createFile(path);<br><br>        <span class="hljs-comment">// 创建单层目录</span><br>        Files.createDirectory(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir&quot;</span>));<br><br>        <span class="hljs-comment">// 创建多层目录</span><br>        Files.createDirectories(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir1/dir2/dir3&quot;</span>));<br><br>        <span class="hljs-comment">// 创建临时文件</span><br>        Path tempFile = Files.createTempFile(<span class="hljs-string">&quot;temp-files&quot;</span>, <span class="hljs-string">&quot;.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 创建临时目录</span><br>        Path tempDir = Files.createTempDirectory(<span class="hljs-string">&quot;temp-dir&quot;</span>);<br><br>        <span class="hljs-comment">// 删除文件</span><br>        Files.delete(path);<br><br>        <span class="hljs-comment">// 删除目录（安全模式，不抛出异常）</span><br>        Files.deleteIfExists(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir&quot;</span>));<br><br>        <span class="hljs-comment">// 复制文件（覆盖已存在的文件）</span><br>        Files.copy(Paths.get(<span class="hljs-string">&quot;source.txt&quot;</span>), Paths.get(<span class="hljs-string">&quot;files-copy.txt&quot;</span>), StandardCopyOption.REPLACE_EXISTING);<br><br>        <span class="hljs-comment">// 移动文件（覆盖已存在的文件）</span><br>        Files.move(Paths.get(<span class="hljs-string">&quot;source.txt&quot;</span>), Paths.get(<span class="hljs-string">&quot;files-move.txt&quot;</span>), StandardCopyOption.REPLACE_EXISTING);<br><br>        <span class="hljs-comment">// 写入文本</span><br>        Files.write(path, <span class="hljs-string">&quot;Hello, Files!&quot;</span>.getBytes());<br><br>        <span class="hljs-comment">// 追加文本</span><br>        Files.write(path, <span class="hljs-string">&quot;Hello, Files!&quot;</span>.getBytes(), StandardOpenOption.APPEND);<br><br>        <span class="hljs-comment">// 使用 BufferedWriter 写入文本</span><br>        <span class="hljs-keyword">try</span> (BufferedWriter writer = Files.newBufferedWriter(path)) &#123;<br>            writer.write(<span class="hljs-string">&quot;Hello, Files!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 读取所有行</span><br>        List&lt;String&gt; strings = Files.readAllLines(Paths.get(<span class="hljs-string">&quot;files-nio-demo.txt&quot;</span>));<br><br>        <span class="hljs-comment">// 使用 BufferedReader 读取文件</span><br>        List&lt;String&gt; lines = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">try</span> (BufferedReader reader = Files.newBufferedReader(Paths.get(<span class="hljs-string">&quot;files-nio-demo.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                lines.add(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 判断文件是否存在</span><br>        System.out.println(Files.exists(path));<br><br>        <span class="hljs-comment">// 判断文件是否不存在</span><br>        System.out.println(Files.notExists(path));<br><br>        <span class="hljs-comment">// 判断是否为文件</span><br>        System.out.println(Files.isRegularFile(path));<br><br>        <span class="hljs-comment">// 判断是否为目录</span><br>        System.out.println(Files.isDirectory(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir1&quot;</span>)));<br><br>        <span class="hljs-comment">// 判断是否为隐藏文件</span><br>        System.out.println(Files.isHidden(path));<br><br>        <span class="hljs-comment">// 判断是否可读</span><br>        System.out.println(Files.isReadable(path));<br><br>        <span class="hljs-comment">// 遍历目录下的文件</span><br>        Files.list(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir1&quot;</span>)).forEach(System.out::println);<br><br>        <span class="hljs-comment">// 递归遍历目录下的文件</span><br>        Files.walk(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir1&quot;</span>)).forEach(System.out::println);<br><br>        <span class="hljs-comment">// 递归遍历目录下的文件（不包含目录）</span><br>        Files.walk(Paths.get(<span class="hljs-string">&quot;files-nio-demo-dir1&quot;</span>), FileVisitOption.FOLLOW_LINKS).forEach(System.out::println);<br><br>        <span class="hljs-comment">// 创建 InputStream</span><br>        <span class="hljs-keyword">try</span> (InputStream inputStream = Files.newInputStream(path)) &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputStream.available()];<br>            inputStream.read(bytes);<br>            System.out.println(<span class="hljs-keyword">new</span> String(bytes));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 创建 OutputStream</span><br>        <span class="hljs-keyword">try</span> (OutputStream outputStream = Files.newOutputStream(path)) &#123;<br>            outputStream.write(<span class="hljs-string">&quot;Hello, Files!&quot;</span>.getBytes());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>java.nio.file.FileVisitor&lt;T&gt;</code> 是 Java NIO 提供的文件遍历接口，用于递归遍历目录及其子目录，适用于文件搜索、批量删除、复制、统计等操作。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><p>支持递归遍历，可以深入子目录，无需手动管理递归调用。</p></li><li><p>提供四种回调方法，对每个文件和目录执行特定操作。</p></li><li><p>相比 <code>Files.list()</code> 和 <code>Files.walk()</code>，<code>FileVisitor</code> 可自定义行为，如：</p><ul><li><p>统计文件大小</p></li><li><p>删除非空目录</p></li><li><p>过滤特定类型文件</p></li><li><p>处理符号链接</p></li></ul></li></ul><h4 id="对比-Files-walk"><a href="#对比-Files-walk" class="headerlink" title="对比 Files.walk()"></a>对比 Files.walk()</h4><table><thead><tr><th><strong>方式</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><code>Files.walk()</code></td><td>代码简洁，适用于简单遍历</td><td>控制力较弱，无法细粒度定制操作</td></tr><tr><td><code>FileVisitor</code></td><td>可精准控制遍历过程，如提前终止</td><td>代码较 <code>walk()</code> 复杂</td></tr></tbody></table><h3 id="四个回调方法"><a href="#四个回调方法" class="headerlink" title="四个回调方法"></a>四个回调方法</h3><p><code>FileVisitor&lt;T&gt;</code> 通过回调机制处理文件遍历，每当访问一个文件或目录时，会触发以下方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>触发时机</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code>preVisitDirectory(T dir, BasicFileAttributes attrs)</code></td><td>进入目录前</td><td>可用于记录访问路径、统计目录数量等</td></tr><tr><td><code>visitFile(T file, BasicFileAttributes attrs)</code></td><td>访问文件时</td><td>适用于文件分析、统计大小、复制等</td></tr><tr><td><code>visitFileFailed(T file, IOException exc)</code></td><td>访问文件失败</td><td>处理无权限、文件损坏等异常</td></tr><tr><td><code>postVisitDirectory(T dir, IOException exc)</code></td><td>退出目录后</td><td>可用于删除空目录等</td></tr></tbody></table><p><strong>方法返回值</strong>：</p><ul><li><code>FileVisitResult.CONTINUE</code> ：继续遍历</li><li><code>FileVisitResult.SKIP_SUBTREE</code> ：跳过当前目录的所有子文件</li><li><code>FileVisitResult.SKIP_SIBLINGS</code> ：跳过当前目录下的其他文件和子目录</li><li><code>FileVisitResult.TERMINATE</code> ：立即终止遍历</li></ul><h3 id="SimpleFileVisitor"><a href="#SimpleFileVisitor" class="headerlink" title="SimpleFileVisitor"></a>SimpleFileVisitor</h3><p><code>SimpleFileVisitor&lt;T&gt;</code> 简化了 <code>FileVisitor</code>，是 <code>FileVisitor&lt;T&gt;</code> 的 默认实现，已提供基本方法，只需重写需要的方法即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFileVisitorDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleFileVisitor</span>&lt;<span class="hljs-title">Path</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问文件: &quot;</span> + file);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;进入目录: &quot;</span> + dir);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFileFailed</span><span class="hljs-params">(Path file, IOException exc)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无法访问文件: &quot;</span> + file);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;退出目录: &quot;</span> + dir);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path startPath = Paths.get(<span class="hljs-string">&quot;testDir&quot;</span>);<br>        Files.walkFileTree(startPath, <span class="hljs-keyword">new</span> SimpleFileVisitorDemo());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">makefile复制编辑进入目录: testDir</span><br><span class="hljs-section">访问文件: testDir/file1.txt</span><br><span class="hljs-section">访问文件: testDir/file2.txt</span><br><span class="hljs-section">进入目录: testDir/subDir</span><br><span class="hljs-section">访问文件: testDir/subDir/file3.txt</span><br><span class="hljs-section">退出目录: testDir/subDir</span><br><span class="hljs-section">退出目录: testDir</span><br></code></pre></div></td></tr></table></figure><h3 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h3><h4 id="递归删除目录（支持非空目录）"><a href="#递归删除目录（支持非空目录）" class="headerlink" title="递归删除目录（支持非空目录）"></a>递归删除目录（支持非空目录）</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeleteDirectoryVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleFileVisitor</span>&lt;<span class="hljs-title">Path</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Files.delete(file); <span class="hljs-comment">// 删除文件</span><br>        System.out.println(<span class="hljs-string">&quot;删除文件: &quot;</span> + file);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Files.delete(dir); <span class="hljs-comment">// 删除目录</span><br>        System.out.println(<span class="hljs-string">&quot;删除目录: &quot;</span> + dir);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path dirToDelete = Paths.get(<span class="hljs-string">&quot;testDir&quot;</span>);<br>        Files.walkFileTree(dirToDelete, <span class="hljs-keyword">new</span> DeleteDirectoryVisitor());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>作用</strong>：删除非空目录，<code>Files.delete()</code> 直接删除空目录，但 <code>FileVisitor</code> 可递归删除所有文件和子目录。</p><h4 id="统计目录中的文件大小"><a href="#统计目录中的文件大小" class="headerlink" title="统计目录中的文件大小"></a>统计目录中的文件大小</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSizeCalculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleFileVisitor</span>&lt;<span class="hljs-title">Path</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> totalSize = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> </span>&#123;<br>        totalSize += attrs.size(); <span class="hljs-comment">// 累加文件大小</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalSize;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path path = Paths.get(<span class="hljs-string">&quot;testDir&quot;</span>);<br>        FileSizeCalculator calculator = <span class="hljs-keyword">new</span> FileSizeCalculator();<br>        Files.walkFileTree(path, calculator);<br>        System.out.println(<span class="hljs-string">&quot;目录总大小: &quot;</span> + calculator.getTotalSize() + <span class="hljs-string">&quot; 字节&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>作用</strong>：递归计算目录的总大小，包括所有子目录的文件大小。</p><h4 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyDirectoryVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleFileVisitor</span>&lt;<span class="hljs-title">Path</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Path sourceDir;<br>    <span class="hljs-keyword">private</span> Path targetDir;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyDirectoryVisitor</span><span class="hljs-params">(Path sourceDir, Path targetDir)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sourceDir = sourceDir;<br>        <span class="hljs-keyword">this</span>.targetDir = targetDir;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path newDir = targetDir.resolve(sourceDir.relativize(dir));<br>        Files.createDirectories(newDir); <span class="hljs-comment">// 复制目录</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path newFile = targetDir.resolve(sourceDir.relativize(file));<br>        Files.copy(file, newFile, StandardCopyOption.REPLACE_EXISTING);<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path source = Paths.get(<span class="hljs-string">&quot;sourceDir&quot;</span>);<br>        Path target = Paths.get(<span class="hljs-string">&quot;backupDir&quot;</span>);<br>        Files.walkFileTree(source, <span class="hljs-keyword">new</span> CopyDirectoryVisitor(source, target));<br>        System.out.println(<span class="hljs-string">&quot;目录复制完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>作用</strong>：递归复制目录，<code>Files.copy()</code> 只能复制单个文件，而 <code>FileVisitor</code> 可遍历所有子目录进行复制。</p><h2 id="WatchService"><a href="#WatchService" class="headerlink" title="WatchService"></a>WatchService</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>文件监听服务 <code>WatchService</code> 是 Java NIO 提供的文件监听服务，用于监视目录中的文件变化，如：</p><ul><li>文件创建（<code>ENTRY_CREATE</code>）</li><li>文件修改（<code>ENTRY_MODIFY</code>）</li><li>文件删除（<code>ENTRY_DELETE</code>）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>实时文件监控</li><li>日志文件自动更新</li><li>自动重载配置</li><li>检测文件上传（FTP/云存储）</li><li>开发工具（如 IDE）监听文件变更</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>创建 <code>WatchService</code></li><li>注册目录到 <code>WatchService</code></li><li>监听事件</li><li>处理触发的文件事件</li></ol><h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>FileSystem.newWatchService()</code></td><td>创建 <code>WatchService</code></td></tr><tr><td><code>Path.register(WatchService, WatchEvent.Kind&lt;?&gt;...)</code></td><td>将目录注册到 <code>WatchService</code></td></tr><tr><td><code>watchService.poll()</code></td><td>非阻塞地获取事件</td></tr><tr><td><code>watchService.take()</code></td><td>阻塞等待事件</td></tr><tr><td><code>watchKey.pollEvents()</code></td><td>获取事件列表</td></tr><tr><td><code>watchKey.reset()</code></td><td>重新注册监听事件</td></tr></tbody></table><h3 id="监听目录变化示例"><a href="#监听目录变化示例" class="headerlink" title="监听目录变化示例"></a>监听目录变化示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WatchServiceExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 获取文件系统的 WatchService</span><br>        WatchService watchService = FileSystems.getDefault().newWatchService();<br><br>        <span class="hljs-comment">// 2. 监听的目录（确保该目录存在）</span><br>        Path dir = Paths.get(<span class="hljs-string">&quot;watchedDir&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!Files.exists(dir)) &#123;<br>            Files.createDirectory(dir);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 注册监听事件</span><br>        dir.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,<br>                     StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);<br><br>        System.out.println(<span class="hljs-string">&quot;正在监听目录: &quot;</span> + dir);<br><br>        <span class="hljs-comment">// 4. 监听事件（无限循环）</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            WatchKey key = watchService.take(); <span class="hljs-comment">// 阻塞等待事件</span><br><br>            <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br>                WatchEvent.Kind&lt;?&gt; kind = event.kind();<br>                Path filePath = dir.resolve((Path) event.context());<br><br>                System.out.println(<span class="hljs-string">&quot;事件类型: &quot;</span> + kind + <span class="hljs-string">&quot;，文件: &quot;</span> + filePath);<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> valid = key.reset();<br>            <span class="hljs-keyword">if</span> (!valid) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        watchService.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，当 <code>watchedDir</code> 目录下有文件变化时，会输出：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">正在监听目录: <span class="hljs-type">watchedDir</span><br>事件类型: <span class="hljs-type">ENTRY_CREATE</span>，文件: <span class="hljs-type">watchedDir</span>/<span class="hljs-keyword">new</span><span class="hljs-type">File</span>.txt<br>事件类型: <span class="hljs-type">ENTRY_MODIFY</span>，文件: <span class="hljs-type">watchedDir</span>/<span class="hljs-keyword">new</span><span class="hljs-type">File</span>.txt<br>事件类型: <span class="hljs-type">ENTRY_DELETE</span>，文件: <span class="hljs-type">watchedDir</span>/<span class="hljs-keyword">new</span><span class="hljs-type">File</span>.txt<br></code></pre></div></td></tr></table></figure><p><strong>拓展</strong>：</p><ul><li><p>可以注册多个目录进行监听：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Path dir1 = Paths.get(<span class="hljs-string">&quot;dir1&quot;</span>);<br>Path dir2 = Paths.get(<span class="hljs-string">&quot;dir2&quot;</span>);<br><br>dir1.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);<br>dir2.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);<br></code></pre></div></td></tr></table></figure></li><li><p>如果有必要，还可以搭配线程池进行异步监听：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService executor = Executors.newSingleThreadExecutor();<br>executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            WatchKey key = watchService.take();<br>            <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;事件类型: &quot;</span> + event.kind() + <span class="hljs-string">&quot;，文件: &quot;</span> + dir.resolve((Path) event.context()));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!key.reset()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>异步监听不会阻塞主线程，适用于后台运行的文件监听程序。</p></li></ul><h3 id="监听事件类型"><a href="#监听事件类型" class="headerlink" title="监听事件类型"></a>监听事件类型</h3><p><code>WatchService</code> 可监听三种文件事件：</p><table><thead><tr><th><strong>事件类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ENTRY_CREATE</code></td><td>文件或目录被创建</td></tr><tr><td><code>ENTRY_MODIFY</code></td><td>文件被修改（写入、更新）</td></tr><tr><td><code>ENTRY_DELETE</code></td><td>文件或目录被删除</td></tr></tbody></table><h3 id="监听子目录"><a href="#监听子目录" class="headerlink" title="监听子目录"></a>监听子目录</h3><p><code>WatchService</code> 默认不会监听子目录，如果需要递归监听子目录，可以使用 <code>FileVisitor</code> 注册所有子目录：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursiveWatchService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        WatchService watchService = FileSystems.getDefault().newWatchService();<br>        Path rootDir = Paths.get(<span class="hljs-string">&quot;watchedDir&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!Files.exists(rootDir)) &#123;<br>            Files.createDirectories(rootDir);<br>        &#125;<br><br>        <span class="hljs-comment">// 递归注册所有子目录</span><br>        Files.walkFileTree(rootDir, <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                dir.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,<br>                             StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);<br>                <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;监听目录及子目录: &quot;</span> + rootDir);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            WatchKey key = watchService.take();<br>            <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;事件类型: &quot;</span> + event.kind() + <span class="hljs-string">&quot;，文件: &quot;</span> + key.watchable());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!key.reset()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java IO</tag>
      
      <tag>IO工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitFlow工作流</title>
    <link href="/2025/02/06/git-gitflow/"/>
    <url>/2025/02/06/git-gitflow/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在团队协作开发中，分支管理始终是一个需要精细设计的环节。如何在并行开发与稳定交付之间取得平衡，是每个团队都要面对的挑战。<code>GitFlow</code> 作为一种经典的 Git 分支管理模型，以 “双主分支” 和辅助分支模式为核心，为中大型项目或发行版式开发提供了清晰的开发流程和版本管理方案。本文将详细介绍 <code>GitFlow</code> 的基本概念、分支模型以及在实际项目中的应用与局限，为读者在团队协作时提供一个可行的参考。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>核心理念：</strong> <code>GitFlow</code> 是一种基于 <code>Git</code> 的分支管理模型，其目标是为团队开发提供一个清晰、可控的分支结构。</li><li><strong>双主分支</strong>：该工作流主要依赖两个长期存在的分支。<ul><li><strong>主分支（master）：</strong> 始终保存着经过验证、可用于生产环境的代码。</li><li><strong>开发分支（develop）：</strong> 用于集成所有正在进行中的开发工作，是新功能和改动的汇总地。</li></ul></li><li><strong>辅助分支：</strong> 为了支持不同阶段的开发和发布，还引入了功能、发布、热修复等分支，以便在不影响主分支和开发分支的前提下进行平行开发和版本管理。</li></ul><h3 id="适用项目"><a href="#适用项目" class="headerlink" title="适用项目"></a>适用项目</h3><ul><li><strong>版本迭代复杂：</strong> 对于版本发布、补丁管理要求明确的大型项目或者中长期开发周期项目，<code>GitFlow</code> 能够帮助明确各阶段代码的状态。</li><li><strong>团队协作：</strong> 当团队规模较大，各成员需要并行开发不同功能模块时，<code>GitFlow</code> 的分支结构可以有效隔离不同开发任务，减少冲突。</li><li><strong>发布管理严格：</strong> 对于需要频繁发布或支持多个版本共存的项目（例如企业级软件、桌面应用等），<code>GitFlow</code> 通过专门的发布与热修复分支，确保生产环境的代码稳定。</li></ul><h3 id="与微服务架构的适配性"><a href="#与微服务架构的适配性" class="headerlink" title="与微服务架构的适配性"></a>与微服务架构的适配性</h3><ul><li><strong>微服务独立性：</strong> 微服务架构中，各个服务可以独立开发和部署，<code>GitFlow</code> 的分支模型能够为每个微服务提供独立的开发与发布流程。</li><li><strong>整体一致性：</strong> 尽管各微服务可能独立，但整个系统通常需要协调一致的版本管理。<code>GitFlow</code> 可以帮助团队在各个微服务之间保持一致的版本控制策略。</li><li><strong>灵活性与扩展性：</strong> 针对微服务架构中的服务拆分和独立演进需求，可以根据实际情况调整 <code>GitFlow</code> 的细节（如是否每个服务都使用完全相同的分支策略），以便更好地支持多服务协同开发和持续集成。</li></ul><h3 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow.png" alt="Git Flow总体流程"></p><h2 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h2><h3 id="主分支（master）"><a href="#主分支（master）" class="headerlink" title="主分支（master）"></a>主分支（master）</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow-master.png" alt="gitflow-master"></p><ul><li><strong>代码环境</strong>：生产环境（<code>PROD</code>）</li><li><strong>增量代码来源</strong>：<ul><li>仓库初始化后：默认分支</li><li>新版本发布前：来自发布分支（<code>release</code>）合并</li><li>线上热修复时：来自热修复分支（<code>hotfix</code>）合并</li></ul></li><li><strong>权限控制</strong>：版本发布人员</li><li><strong>注意事项</strong>：<ul><li>绝不能直接在此分支上进行开发或提交。</li><li>保持主分支的代码随时可部署，确保其稳定性和安全性。</li><li>通常在合并到主分支后，要打上版本标签（<code>Tag</code>），便于版本追踪和回溯。</li></ul></li></ul><h3 id="开发分支（develop）"><a href="#开发分支（develop）" class="headerlink" title="开发分支（develop）"></a>开发分支（develop）</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow-develop.png" alt="gitflow-develop"></p><ul><li><strong>代码环境</strong>：集成测试环境（<code>SIT</code>）</li><li><strong>增量代码来源</strong>：<ul><li>仓库初始化后：从主分支拉取而来</li><li>新版本发布前：来自功能分支（<code>feature</code>）的合并</li><li>线上热修复时：来自热修复分支（<code>hotfix</code>）的合并</li><li>测试完成后：来自发布分支（<code>release</code>）的合并（主要内容为 <code>bug</code> 修复）</li></ul></li><li><strong>权限控制</strong>：各个开发者</li><li><strong>注意事项</strong>：<ul><li>作为所有新功能合并前的集成分支，需要保持代码质量和可部署性。</li><li>定期进行代码审查和集成测试，确保开发分支的健康状态。</li></ul></li></ul><h3 id="功能分支（feature）"><a href="#功能分支（feature）" class="headerlink" title="功能分支（feature）"></a>功能分支（feature）</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow-feature.png" alt="gitflow-feature"></p><ul><li><strong>代码环境</strong>：开发人员的本地环境或者开发者独立的测试环境（<code>DEV</code>）</li><li><strong>增量代码来源</strong>：<ul><li>新功能开发前：从开发分支（<code>develop</code>）拉取而来</li></ul></li><li><strong>权限控制</strong>：具体负责该功能的开发者</li><li><strong>注意事项</strong>：<ul><li>每个功能分支应保持单一功能开发，避免跨分支的功能混合。</li><li>功能开发完成后，应进行自测试或小范围的团队内部测试，确认功能正常后再合并到开发分支。</li><li>合并回开发分支前，应从开发分支拉取最新代码，解决可能的冲突。</li></ul></li></ul><h3 id="发布分支（release）"><a href="#发布分支（release）" class="headerlink" title="发布分支（release）"></a>发布分支（release）</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow-release.png" alt="gitflow-release"></p><ul><li><strong>代码环境</strong>：用户测试环境（<code>UAT</code>）</li><li><strong>增量代码来源</strong>：<ul><li>新版本发布前：从开发分支（<code>develop</code>）拉取而来</li></ul></li><li><strong>权限控制</strong>：版本管理人员</li><li><strong>注意事项</strong>：<ul><li>在此分支上进行的修改应限于 <code>bug</code> 修复、文档编写和其他为发布准备的必要任务，也可以理解为 “待发布” 分支。</li><li>完成所有必要的准备后，该分支被合并到开发分支和主分支。发布分支用于测试和确保在新的开发周期中包含这些更改，主分支用于生产部署。</li></ul></li></ul><h3 id="热修复分支（hotfix）"><a href="#热修复分支（hotfix）" class="headerlink" title="热修复分支（hotfix）"></a>热修复分支（hotfix）</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/gitflow-hotfix.png" alt="gitflow-hotfix"></p><ul><li><strong>代码环境</strong>：生产环境（<code>PROD</code>）</li><li><strong>增量代码来源</strong>：<ul><li>线上出问题后：从主分支（<code>master</code>）拉取而来</li></ul></li><li><strong>权限控制</strong>：线上问题修复人员</li><li><strong>注意事项</strong>：<ul><li>必须确保修复迅速且不引入新的错误。</li><li>修复完成后合并到开发分支，并进行必要的测试，同时防止该问题在未来版本中重复出现。</li><li>热修复问题测试通过后，应将修复合并回主分支并立即部署。</li></ul></li></ul><h2 id="命令行实践"><a href="#命令行实践" class="headerlink" title="命令行实践"></a>命令行实践</h2><h3 id="1-初始化仓库及主分支"><a href="#1-初始化仓库及主分支" class="headerlink" title="1. 初始化仓库及主分支"></a>1. 初始化仓库及主分支</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 初始化远程仓库信息</span><br>git init<br>git remote add origin https://github.com/iyangtao/gitflow.git<br><br><span class="hljs-comment"># 初始化提交</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# gitflow main&quot;</span> &gt;&gt; README.md<br>git add README.md<br>git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;init&quot;</span><br><br><span class="hljs-comment"># 创建主分支并推送到远程仓库</span><br>git branch <span class="hljs-literal">-M</span> master<br>git push <span class="hljs-literal">-u</span> origin master<br><br><span class="hljs-comment"># 从主分支拉取出开发分支并推送到远程仓库</span><br>git checkout <span class="hljs-literal">-b</span> develop master<br>git push origin develop<br></code></pre></div></td></tr></table></figure><h3 id="2-新功能开发"><a href="#2-新功能开发" class="headerlink" title="2. 新功能开发"></a>2. 新功能开发</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 从开发分支拉取出功能分支</span><br>git pull origin develop<br>git checkout <span class="hljs-literal">-b</span> feature/f1 develop<br><br><span class="hljs-comment"># 推送功能分支至远程仓库</span><br>git push origin feature/f1<br><br><span class="hljs-comment"># 功能开发</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;f1&quot;</span> &gt;&gt; BUSINESS.md<br><br><span class="hljs-comment"># 完成开发、添加、提交并推送</span><br>git add BUSINESS.md<br>git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;f1 finish&quot;</span><br>git pull origin feature/f1<br>git push origin feature/f1<br></code></pre></div></td></tr></table></figure><h3 id="3-合并开发分支"><a href="#3-合并开发分支" class="headerlink" title="3. 合并开发分支"></a>3. 合并开发分支</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 更新本地开发分支</span><br>git pull origin develop<br><br><span class="hljs-comment"># 更新本地功能分支</span><br>git pull origin feature/f1<br><br><span class="hljs-comment"># 将功能分支合并到开发分支并推送远程仓库</span><br>git checkout develop<br>git merge -<span class="hljs-literal">-no</span><span class="hljs-literal">-ff</span> feature/f1<br>git push origin develop<br></code></pre></div></td></tr></table></figure><h3 id="4-预发布"><a href="#4-预发布" class="headerlink" title="4. 预发布"></a>4. 预发布</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 从开发分支拉取出发布分支并推送</span><br>git checkout <span class="hljs-literal">-b</span> release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span> develop<br><br><span class="hljs-comment"># 有bug进行修复</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;f1 fix&quot;</span> &gt;&gt; BUSINESS.md<br>git add BUSINESS.md<br>git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;f1 fix&quot;</span><br>git pull origin release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>git push origin release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="5-发布"><a href="#5-发布" class="headerlink" title="5. 发布"></a>5. 发布</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 将发布分支合并到主分支、打上标签后推送远程仓库</span><br>git pull origin release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>git checkout master<br>git pull origin master<br>git merge -<span class="hljs-literal">-no</span><span class="hljs-literal">-ff</span> release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>git push origin master<br>git tag <span class="hljs-literal">-a</span> v0.<span class="hljs-number">1.0</span> <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;release v0.1.0 with feature f1&quot;</span><br>git push origin v0.<span class="hljs-number">1.0</span><br><br><span class="hljs-comment"># 将发布合并回开发分支</span><br>git checkout develop<br>git pull origin develop<br>git merge -<span class="hljs-literal">-no</span><span class="hljs-literal">-ff</span> release/<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>git push origin develop<br></code></pre></div></td></tr></table></figure><h3 id="6-线上热修复"><a href="#6-线上热修复" class="headerlink" title="6. 线上热修复"></a>6. 线上热修复</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 从主分支拉取出热修复分支并进行修复</span><br>git checkout <span class="hljs-literal">-b</span> hotfix/<span class="hljs-number">0.1</span>.<span class="hljs-number">1</span> master<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;f1 fix hot fix&quot;</span> &gt;&gt; BUSINESS.md<br>git add BUSINESS.md<br>git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;f1 hot fix&quot;</span><br>git push origin hotfix/<span class="hljs-number">0.1</span>.<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 将热修复合并到主分支进行发布</span><br>git checkout master<br>git pull origin master<br>git merge -<span class="hljs-literal">-no</span><span class="hljs-literal">-ff</span> hotfix/<span class="hljs-number">0.1</span>.<span class="hljs-number">1</span><br>git push origin master<br>git tag <span class="hljs-literal">-a</span> v0.<span class="hljs-number">1.1</span> <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;release v0.1.1 with hotfix/0.1.1&quot;</span><br>git push origin v0.<span class="hljs-number">1.1</span><br><br><span class="hljs-comment"># 将热修复合并到开发分支</span><br>git checkout develop<br>git pull origin develop<br>git merge -<span class="hljs-literal">-no</span><span class="hljs-literal">-ff</span> hotfix/<span class="hljs-number">0.1</span>.<span class="hljs-number">1</span><br>git push origin develop<br></code></pre></div></td></tr></table></figure><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><ul><li><p><strong>辅助分支删除</strong>：发布分支（<code>release/0.1.0</code>）、功能分支（<code>feature/f1</code>）、热修复分支（<code>hotfix/0.1.1</code>）在合并回 <code>develop</code> 和/或 <code>master</code> 之后，其使命已完成，在确保所有人都知晓分支已完成且不可用后，将这些辅助分支进行删除。</p></li><li><p><strong>PR/MR 工作流</strong>：在多人协作的团队中，通常会在远程平台（<code>GitHub</code>、<code>GitLab</code> 等）创建 <code>Pull Request/Merge Request</code>，让其他成员进行代码评审（<code>Code Review</code>）。这样能保证合并到主干分支（<code>develop</code>、<code>master</code>）的代码质量，并让团队成员清楚功能开发的上下文。</p></li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><h3 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><code>A</code> 团队成员开发完一个 <code>feature</code> 分支，然后合并到 <code>develop</code>；此时 <code>B</code> 团队成员再从 <code>develop</code> 切出 <code>feature</code> 分支，天然就会带上 <code>A</code> 的代码。如果 <code>B</code> 的功能需要先上线，那么它就会把 <code>A</code> 的功能一起带到生产环境中，但 <code>A</code> 的功能可能尚未准备好上线。</p><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><ul><li>在 <code>GitFlow</code> 中，<code>develop</code> 分支是公共集成分支，只要某个功能合并进去，其他新功能分支也会继承这些改动。</li><li>如果某些功能要晚于其他功能上线，或者甚至被搁置，就会在 <code>develop</code> 中 “共享” 给后续分支，从而产生冲突。</li></ul><h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li><p><strong>Feature Toggle（特性开关）</strong></p><ul><li><p><code>A</code> 的功能虽然合并到 <code>develop</code>，但通过配置开关让代码在运行时处于关闭状态，即使 <code>B</code> 的功能先上线，也不会真正启用 <code>A</code> 的功能。</p></li><li><p><strong>优点</strong>：减少分支管理的复杂度，<code>A</code> 的代码不会干扰 <code>B</code> 的上线；上线次序只需要切换配置，无需大规模合并或回退。</p></li><li><p><strong>缺点</strong>：需要在代码中预先设计特性开关，运维环境也要能根据需要动态控制开关。</p></li></ul></li><li><p><strong>Release 分支筛选</strong></p><ul><li><p>并不是把所有的功能都一次性从 <code>develop</code> 合并到 <code>release</code>，而是在拉取 <code>release</code> 分支时，有选择地 <code>cherry-pick</code> 或者只合并特定功能分支的提交。</p></li><li><p><strong>优点</strong>：能避免不想要的功能被带到发布分支。</p></li><li><p><strong>缺点</strong>：操作复杂，容易出错，特别在回合并到 <code>develop</code> 时还会面临冲突；对团队协作要求更高。</p></li></ul></li><li><p><strong>Trunk-Based Development</strong></p><ul><li><p>减少长生命周期分支，只在一个 “主干” 中快速合并并通过 <code>Feature Toggle</code> 控制功能上线。</p></li><li><p><strong>优点</strong>：大幅简化分支管理。</p></li><li><p><strong>缺点</strong>：对团队的测试、<code>CI/CD</code>、代码质量和自动化要求更高；一般需要成熟的持续交付流程做支撑。</p></li></ul></li></ul><h3 id="多版本并行发布"><a href="#多版本并行发布" class="headerlink" title="多版本并行发布"></a>多版本并行发布</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>可能出现 <code>SIT</code>、<code>UAT</code> 并行测试多个版本，或者同时存在多个待上线版本，<code>GitFlow</code> 标准模式中的一个 <code>develop</code> + 一个 <code>release</code> 难以满足频繁或并行发布的需求。</p><h4 id="应对方法-1"><a href="#应对方法-1" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li><p><strong>多 Release 分支并行</strong>：为每个即将进入 <code>UAT</code> 的版本都单独开一个 <code>release/x.y.z</code> 分支进行测试与修复。在 <code>GitFlow</code> 标准流程上更 “宽松”，允许多个 <code>Release</code> 分支并存。</p></li><li><p><strong>额外维护 Support 分支</strong>：对某些长期维护版本，使用 <code>support/x.y.z</code> 分支，和新版本并行维护。</p></li></ul><h3 id="提交历史复杂"><a href="#提交历史复杂" class="headerlink" title="提交历史复杂"></a>提交历史复杂</h3><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><p>开发中可能发现某功能需要彻底废弃，或者某次合并引入大量冲突需要回退时，<code>GitFlow</code> 的多分支合并会导致提交历史非常分散。</p><h4 id="应对方法-2"><a href="#应对方法-2" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li><strong>Rebase + Merge Request</strong>：在合并前，对功能分支进行 <code>Rebase</code>，让提交历史保持线性，减少 “Merge branch …” 的嵌套。</li><li><strong>合并策略约定</strong>：一些团队偏好 “快速向前合并（<code>fast-forward</code>）”，另一些团队偏好 “保持合并记录（<code>no-ff</code>）”，需要团队内部统一标准，才能减少历史混乱。</li></ul><h3 id="频繁上线"><a href="#频繁上线" class="headerlink" title="频繁上线"></a>频繁上线</h3><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><p><code>GitFlow</code> 设计之初更偏向于 “发行版模式”，即一次性合并多个特性一起发布，如果团队要每天/每周频繁上线，则 <code>release</code> 分支的意义可能被削弱，合并分支操作相对繁重。</p><h4 id="应对方法-3"><a href="#应对方法-3" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li>考虑 <code>Trunk-Based Development</code> 或 <code>GitLab Flow/GitHub Flow</code>，通过 “短分支 + 代码审查 + 持续集成 + 持续部署” 取代笨重的发布分支。</li></ul><h3 id="开发周期长"><a href="#开发周期长" class="headerlink" title="开发周期长"></a>开发周期长</h3><h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><p>某个功能开发周期长，<code>feature</code> 分支存在很久，频繁与 <code>develop</code> 甚至其他功能分支冲突。</p><h4 id="应对方法-4"><a href="#应对方法-4" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li>更小粒度的功能拆分，缩短 <code>feature</code> 分支存活时间。</li><li>在分支开发期间定期 <code>Rebase</code> 或 <code>Merge</code> 来跟进主线，以免开发结束时合并冲突堆积。</li><li><code>Feature Toggle</code> 对迭代式开发非常有帮助，可将大功能分多次合并。</li></ul><h3 id="多条发布线并存"><a href="#多条发布线并存" class="headerlink" title="多条发布线并存"></a>多条发布线并存</h3><h4 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h4><p>项目需要同时维护多个已上线版本（例：<code>v1.x</code>、<code>v2.x</code> 同时存在）时，<code>GitFlow</code> 出现多分支并行维护的复杂性。</p><h4 id="应对方法-5"><a href="#应对方法-5" class="headerlink" title="应对方法"></a>应对方法</h4><ul><li><code>Support</code> 分支 为特定版本提供长期支持。</li><li>使用 <code>CI/CD</code> 脚本自动管理不同版本分支合并和发布。</li></ul><h2 id="综合结论与建议"><a href="#综合结论与建议" class="headerlink" title="综合结论与建议"></a>综合结论与建议</h2><h3 id="GitFlow-并非万能"><a href="#GitFlow-并非万能" class="headerlink" title="GitFlow 并非万能"></a>GitFlow 并非万能</h3><p><code>GitFlow</code> 在 “中长周期”、“较为明确的发行版式” 项目中表现优秀，但在 “需求变动频繁、要快节奏连续上线” 的互联网或微服务环境里，有时会显得过重。</p><p>归根结底，没有绝对完美的工作流，最优的方案永远是结合团队规模、交付频率、项目复杂度以及测试/运维流程制定出的“定制化”流程。</p><h3 id="常见问题的应对"><a href="#常见问题的应对" class="headerlink" title="常见问题的应对"></a>常见问题的应对</h3><ul><li><strong>特性开关</strong>：不想要的功能不一定非得在分支层面隔离，可以在代码层面隔离。</li><li><strong>短分支 + 快速合并</strong>：减少长时间积累冲突的风险。</li><li><strong>多 Release 分支并行 / 选择性合并</strong>：适合多版本并行测试和发布，但操作复杂度会上升。</li><li><strong>Trunk-Based Development / GitHub Flow / GitLab Flow</strong>：如果团队更追求 “小步快跑”，可以试试这些更简化的模型。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>GitFlow</code> 工作流在 “中长周期、明确发行版” 的项目场景中有其独到的优势，通过主分支与开发分支的长期维护、功能/发布/热修复分支的灵活切换，可以让团队更好地管控版本迭代节奏。但也要注意，项目需求频繁变动、快速迭代或多版本并行发布时，<code>GitFlow</code> 可能变得复杂甚至笨重。实践中，我们可以结合特性开关、短分支快速合并，以及其他简化模型（如 <code>Trunk-Based</code>、<code>GitHub Flow</code> 等）灵活应对。没有任何一种工作流是放之四海而皆准的，最优方案往往需要团队在实际落地时做适度裁剪与定制化。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本管理</tag>
      
      <tag>GitFlow工作流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO——BIO</title>
    <link href="/2025/02/05/javase-io-bio/"/>
    <url>/2025/02/05/javase-io-bio/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java 的 IO（输入/输出）系统在软件开发中扮演着关键角色，几乎所有与数据交互的场景都离不开 IO 操作。无论是读取本地文件、写入网络流、处理大文件还是进行多线程间通信，Java 都提供了功能丰富且易于扩展的 IO 类库。本篇文章将从最基础的 <code>File</code> 类开始，逐步介绍 Java IO 中常见的流类别、用法以及 Java IO 的设计模式，帮助读者在学习与实践中更好地理解和掌握 Java 的输入输出机制。</p><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p><strong>抽象路径名表示</strong>：</p><p><code>File</code> 类封装了文件或目录的路径，可以使用相对路径或绝对路径来创建对象。它既可以代表一个具体的文件，也可以代表一个目录。</p></li><li><p><strong>与文件系统交互</strong>：</p><p><code>File</code> 类提供的方法允许程序查询文件是否存在、判断文件类型、创建或删除文件和目录等操作，但并不直接读写文件内容。</p></li><li><p><strong>跨平台性</strong>：</p><p><code>File</code> 类封装了不同操作系统的文件系统差异，例如路径分隔符问题，通过 API 屏蔽了平台细节。</p></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>File(String pathname)</code>：根据路径名字符串创建 File 对象。</li><li><code>File(String parent, String child)</code>：根据父目录和子路径创建 File 对象。</li><li><code>File(File parent, String child)</code>：根据父 File 对象和子路径创建 File 对象。</li></ul><h4 id="属性查询方法"><a href="#属性查询方法" class="headerlink" title="属性查询方法"></a>属性查询方法</h4><ul><li><code>boolean exists()</code>：判断文件或目录是否存在。</li><li><code>boolean isFile()</code>：判断是否为文件。</li><li><code>boolean isDirectory()</code>：判断是否为目录。</li><li><code>String getName()</code>：返回文件或目录的名称（不包含路径）。</li><li><code>String getPath()</code>：返回创建 File 对象时使用的路径字符串。</li><li><code>String getAbsolutePath()</code>：返回文件或目录的绝对路径。</li><li><code>long length()</code>：返回文件的大小（以字节为单位）；对于目录，该方法可能不返回有意义的结* 果。</li><li><code>long lastModified()</code>：返回文件或目录最后修改的时间（以毫秒计）。</li></ul><h4 id="文件和目录操作方法"><a href="#文件和目录操作方法" class="headerlink" title="文件和目录操作方法"></a>文件和目录操作方法</h4><ul><li><code>boolean createNewFile()</code>：在指定路径创建一个新的空文件，如果文件已经存在则返回 false。</li><li><code>boolean delete()</code>：删除文件或目录（目录需为空）。</li><li><code>boolean renameTo(File dest)</code>：将文件或目录重命名为目标路径。</li><li><code>boolean mkdir()</code>：创建单级目录；如果父目录不存在则创建失败。</li><li><code>boolean mkdirs()</code>：创建多级目录，即使父目录不存在也会一并创建。</li></ul><h4 id="列出目录内容的方法"><a href="#列出目录内容的方法" class="headerlink" title="列出目录内容的方法"></a>列出目录内容的方法</h4><ul><li><code>String[] list()</code>：返回目录中所有文件和目录的名称数组。</li><li><code>File[] listFiles()</code>：返回目录中所有文件和目录的 File 对象数组，便于进一步操作。</li></ul><h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ul><li><strong>文件和目录的存在性检查</strong>：使用 <code>exists()</code> 判断一个文件是否存在，避免在读写操作时出现异常。</li><li><strong>创建新文件/目录</strong>：使用 <code>createNewFile()</code>、<code>mkdir()</code> 或 <code>mkdirs()</code> 创建所需文件或目录。</li><li><strong>文件重命名和删除</strong>：使用 <code>renameTo()</code> 实现文件重命名，<code>delete()</code> 实现文件或空目录删除。</li><li><strong>遍历目录内容</strong>：通过 <code>list()</code> 或 <code>listFiles()</code> 方法遍历目录中的所有文件，常用于文件管理器或批处理程序。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用绝对路径或相对路径创建 File 对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Demo.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 判断文件是否存在</span><br>        <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 创建新文件</span><br>                <span class="hljs-keyword">boolean</span> created = file.createNewFile();<br>                System.out.println(<span class="hljs-string">&quot;文件创建：&quot;</span> + created);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;创建文件失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 输出文件的名称和绝对路径</span><br>        System.out.println(<span class="hljs-string">&quot;文件名称：&quot;</span> + file.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径：&quot;</span> + file.getAbsolutePath());<br><br>        <span class="hljs-comment">// 检查是否为文件或目录</span><br>        System.out.println(<span class="hljs-string">&quot;是否为文件：&quot;</span> + file.isFile());<br>        System.out.println(<span class="hljs-string">&quot;是否为目录：&quot;</span> + file.isDirectory());<br><br>        <span class="hljs-comment">// 获取文件大小和最后修改时间</span><br>        System.out.println(<span class="hljs-string">&quot;文件大小：&quot;</span> + file.length() + <span class="hljs-string">&quot; 字节&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最后修改时间：&quot;</span> + file.lastModified());<br><br>        <span class="hljs-comment">// 重命名文件</span><br>        File newFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Demo-renamed.txt&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> renamed = file.renameTo(newFile);<br>        System.out.println(<span class="hljs-string">&quot;重命名成功：&quot;</span> + renamed);<br><br>        <span class="hljs-comment">// 删除文件</span><br>        <span class="hljs-keyword">boolean</span> deleted = newFile.delete();<br>        System.out.println(<span class="hljs-string">&quot;删除文件：&quot;</span> + deleted);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>不直接操作文件内容</strong>：<code>File</code> 类主要用于表示路径和管理文件属性，读写文件内容需要结合字节流或字符流（如 <code>FileInputStream</code>、<code>FileReader</code> 等）。</li><li><strong>平台差异</strong>：尽量使用 API 提供的分隔符，如 <code>File.separator</code>，以保证跨平台兼容性。</li><li><strong>安全性问题</strong>：在操作文件时应注意权限问题，确保程序有足够的权限读写或删除文件，避免出现 <code>SecurityException</code>。</li></ul><h2 id="IO-流概述及分类"><a href="#IO-流概述及分类" class="headerlink" title="IO 流概述及分类"></a>IO 流概述及分类</h2><p>Java IO（Input/Output）是 Java 提供的一套处理输入和输出操作的 API，广泛用于文件操作、网络通信、数据流处理等场景。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p><strong>基本思想</strong>：</p><p>Java IO 将数据的读写抽象为 “流” 的概念。一个流代表一个数据通道，数据可以顺序地从流中读取或写入。</p><p><strong>链式操作与装饰器模式</strong>：</p><p>很多 IO 类设计遵循装饰器模式。例如，<code>FileInputStream</code> 可以被包装在 <code>BufferedInputStream</code> 中，后者通过内部缓冲区来提高读取性能。这种设计允许开发者通过 “链式” 组合来增强流的功能，而不改变底层流的接口或实现。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><ul><li><strong>同步 IO（Synchronous IO）</strong>：调用者在发起 IO 操作后，必须等待操作完成才能继续执行。例如，Java 传统的 <code>java.io</code> 包中的 IO 操作大多数是同步的，线程在读写数据时会阻塞。</li><li><strong>异步 IO（Asynchronous IO）</strong>：调用者发起 IO 操作后，不需要等待操作完成，而是由系统通知（如回调、事件驱动）操作完成的结果。Java <code>NIO</code>（New IO）引入了异步 IO 机制，例如 <code>AsynchronousFileChannel</code>。</li></ul><h4 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h4><ul><li><strong>阻塞 IO（Blocking IO）</strong>：调用者在 IO 操作完成之前会一直被阻塞，无法执行其他任务。例如，<code>InputStream.read()</code> 需要等待数据到达，线程无法继续执行。</li><li><strong>非阻塞 IO（Non-Blocking IO）</strong>：调用者可以在数据未准备好时立即返回，而不是一直等待。例如，Java <code>NIO</code> 提供的 <code>SelectableChannel</code> 允许非阻塞模式，线程可以在多个 IO 操作之间切换。</li></ul><h4 id="按数据类型（字节流-字符流）"><a href="#按数据类型（字节流-字符流）" class="headerlink" title="按数据类型（字节流/字符流）"></a><strong>按数据类型（字节流/字符流）</strong></h4><p>Java IO 主要分为 字节流（<code>Byte Streams</code>） 和字符流（<code>Character Streams</code>）：</p><ul><li><strong>字节流（Byte Streams）</strong>：用于处理二进制数据，例如图片、音频、视频、文件流等。字节流的基类是：<ul><li><strong>输入流</strong>：<code>InputStream</code></li><li><strong>输出流</strong>：<code>OutputStream</code></li></ul></li><li><strong>字符流（Character Streams）</strong>：用于处理文本数据，支持字符编码转换，适用于读取和写入文本文件。字符流的基类是：<ul><li><strong>输入流</strong>：<code>Reader</code></li><li><strong>输出流</strong>：<code>Writer</code></li></ul></li></ul><p><strong>对比</strong></p><table><thead><tr><th>类型</th><th>基类</th><th>处理单位</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>字节流</strong></td><td><code>InputStream</code> / <code>OutputStream</code></td><td>8-bit 字节</td><td>处理二进制数据（如图片、音视频）</td></tr><tr><td><strong>字符流</strong></td><td><code>Reader</code> / <code>Writer</code></td><td>16-bit 字符</td><td>处理文本数据（如 <code>.txt</code> 文件）</td></tr></tbody></table><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>IO 操作通常涉及系统调用，每次调用都会带来一定的开销。通过使用缓冲流（如 <code>BufferedInputStream</code>、<code>BufferedReader</code> 等），可以将多次小规模的读写合并成一次大规模的操作，从而显著提升性能。</p><p>默认缓冲区一般为 8KB，但在特定场景下（如大文件的顺序读取），适当调整缓冲区大小可能会带来更好的性能表现。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h3><p>Java IO 提供了两个字节流的基础类：</p><ul><li><code>InputStream</code>（输入流）：用于从数据源读取字节数据。</li><li><code>OutputStream</code>（输出流）：用于向数据目标写入字节数据。</li></ul><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><code>InputStream</code> 是所有字节输入流的父类，提供了一系列从数据源（如文件、字节数组、网络）读取字节数据的方法。</p><p><strong>核心方法</strong>：</p><ul><li><code>int read()</code>：读取单个字节。</li><li><code>int read(byte[] b)</code>：读取多个字节到数组中。</li><li><code>int read(byte[] b, int off, int len)</code>：从 off 开始读取 len 个字节。</li><li><code>long skip(long n)</code>：跳过 n 个字节。</li><li><code>int available()</code>：返回可读取的字节数。</li><li><code>void close()</code>：关闭流，释放资源。</li><li><code>void mark(int readlimit)</code>：标记此输入流中的当前位置。</li><li><code>void reset()</code>：将此流重新定位到上次在此输入流上调用标记方法时的位置。</li></ul><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p><code>OutputStream</code> 是所有字节输出流的父类，提供了一系列向目标（如文件、字节数组、网络）写入字节数据的方法。</p><p><strong>核心方法</strong>：</p><ul><li><code>void write(int b)</code>：写入单个字节。</li><li><code>void write(byte[] b)</code>：写入字节数组。</li><li><code>void write(byte[] b, int off, int len)</code>：从数组的 off 位置开始写入 len 个字节。</li><li><code>void flush()</code>：刷新输出流，确保数据写入。</li><li><code>void close()</code>：关闭流，释放资源。</li></ul><h3 id="字节文件流"><a href="#字节文件流" class="headerlink" title="字节文件流"></a>字节文件流</h3><p>用于从文件读取/写入字节数据。</p><h4 id="字节文件输入流"><a href="#字节文件输入流" class="headerlink" title="字节文件输入流"></a>字节文件输入流</h4><p>字节文件输入流 <code>FileInputStream</code>，用于从文件中读取数据。</p><p><strong>构造方法</strong>：</p><ul><li><code>FileInputStream(File file)</code>：通过 File 对象创建输入流。</li><li><code>FileInputStream(String name)</code>：通过文件路径创建输入流。</li></ul><p><strong>示例</strong>：使用 <code>FileInputStream</code> 读取文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileInputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) data); <span class="hljs-comment">// 逐字节读取并输出</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br>                    fis.close(); <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭文件失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于读取二进制文件（如 <code>.jpg</code>、<code>.mp3</code>）或文本文件（但不推荐，可能会出现乱码问题，用 <code>Reader</code> 处理文本更合适）。</li><li>逐字节读取，效率较低，通常与缓冲流（<code>BufferedInputStream</code>）一起使用提升性能。</li></ul><h4 id="字节文件输出流"><a href="#字节文件输出流" class="headerlink" title="字节文件输出流"></a>字节文件输出流</h4><p>字节文件输出流 <code>FileOutputStream</code>，用于向文件中写入数据。</p><p><strong>构造方法</strong>：</p><ul><li><p><code>FileOutputStream(File file)</code>：通过 File 对象创建输出流。</p></li><li><p><code>FileOutputStream(String name)</code>：通过文件路径创建输出流。</p></li><li><p><code>FileOutputStream(File file, boolean append)</code>：是否以追加模式写入。</p></li><li><p><code>FileOutputStream(String name, boolean append)</code>：通过路径创建并控制是否追加。</p></li></ul><p><strong>示例</strong>：使用 <code>FileOutputStream</code> 写入文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileOutputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String data = <span class="hljs-string">&quot;Hello, Java IO!&quot;</span>;<br>        FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>            fos.write(data.getBytes()); <span class="hljs-comment">// 写入字节数据</span><br>            fos.flush(); <span class="hljs-comment">// 确保数据立即写入</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;<br>                    fos.close(); <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭文件失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于写入二进制文件，如图片、音频等。</li><li><code>flush()</code> 方法可以确保数据立即写入，而不是缓存到缓冲区。</li></ul><h3 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h3><p>字节数组流无需涉及磁盘文件，适合小数据量的读取操作。</p><h4 id="字节数组输入流"><a href="#字节数组输入流" class="headerlink" title="字节数组输入流"></a>字节数组输入流</h4><p>字节数组输入流 <code>ByteArrayInputStream</code> 允许将字节数组作为输入源，提供类似 <code>InputStream</code> 的读取方法。</p><p><strong>构造方法</strong>：</p><ul><li><code>ByteArrayInputStream(byte[] buf)</code>：使用字节数组创建输入流。</li><li><code>ByteArrayInputStream(byte[] buf, int off, int len)</code>：指定偏移量和长度创建输入流。</li></ul><p><strong>示例</strong>：使用 <code>ByteArrayInputStream</code> 读取内存中的数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteArrayInputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-string">&quot;Hello, ByteArrayInputStream!&quot;</span>.getBytes();<br>        ByteArrayInputStream bais = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(data);<br>            <span class="hljs-keyword">int</span> byteData;<br>            <span class="hljs-keyword">while</span> ((byteData = bais.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) byteData);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (bais != <span class="hljs-keyword">null</span>) &#123;<br>                    bais.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭流失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于处理小数据量的内存操作，避免磁盘 IO。</li><li>可用于数据缓存、流转换等场景。</li></ul><h4 id="字节数组输出流"><a href="#字节数组输出流" class="headerlink" title="字节数组输出流"></a>字节数组输出流</h4><p>字节数组输出流 <code>ByteArrayOutputStream</code> 允许将字节数据写入到内存中的字节数组，而不是直接写入文件。</p><p><strong>构造方法</strong>：</p><ul><li><code>ByteArrayOutputStream()</code>：默认初始缓冲区大小 32。</li><li><code>ByteArrayOutputStream(int size)</code>：指定初始缓冲区大小。</li></ul><p><strong>示例</strong>：使用 <code>ByteArrayOutputStream</code> 生成字节数组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteArrayOutputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteArrayOutputStream baos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            baos.write(<span class="hljs-string">&quot;Hello, ByteArrayOutputStream!&quot;</span>.getBytes());<br>            System.out.println(baos); <span class="hljs-comment">// 转换成字符串输出</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入数据失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (baos != <span class="hljs-keyword">null</span>) &#123;<br>                    baos.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭流失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于动态构造字节数组，避免频繁创建 <code>byte[]</code> 数组。</li><li>适合数据缓冲、数据拼接的场景。</li></ul><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节缓冲流用于提升 IO 读写效率，通过内部缓存方式减少底层 IO 访问次数。</p><h4 id="字节缓冲输入流"><a href="#字节缓冲输入流" class="headerlink" title="字节缓冲输入流"></a>字节缓冲输入流</h4><p>字节缓冲输入流 <code>BufferedInputStream</code> 为输入流提供缓冲，减少 <code>read()</code> 调用次数，提高读取性能。</p><p><strong>构造方法</strong>：</p><ul><li><code>BufferedInputStream(InputStream in)</code>：创建默认缓冲输入流（8KB）。</li><li><code>BufferedInputStream(InputStream in, int size)</code>：指定缓冲区大小创建缓冲输入流。</li></ul><p><strong>示例</strong>：使用 <code>BufferedInputStream</code> 读取文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedInputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BufferedInputStream bis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>));<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) data);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (bis != <span class="hljs-keyword">null</span>) &#123;<br>                    bis.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭流失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>默认缓冲区大小为 8KB（可自定义）。</li><li>适用于大文件读取，避免频繁调用底层 IO 操作。</li></ul><h4 id="字节缓冲输出流"><a href="#字节缓冲输出流" class="headerlink" title="字节缓冲输出流"></a>字节缓冲输出流</h4><p>字节缓冲输出流 <code>BufferedOutputStream</code> 为输出流提供缓冲，减少 <code>write()</code> 的磁盘 IO 频率，提高写入性能。</p><p><strong>构造方法</strong>：</p><ul><li><code>BufferedOutputStream(OutputStream out)</code>：创建默认缓冲输出流（8KB）。</li><li><code>BufferedOutputStream(OutputStream out, int size)</code>：指定缓冲区大小创建缓冲输出流。</li></ul><p><strong>示例</strong>：使用 <code>BufferedOutputStream</code> 写入文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedOutputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String data = <span class="hljs-string">&quot;BufferedOutputStream Demo!&quot;</span>;<br>        BufferedOutputStream bos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>            bos.write(data.getBytes());<br>            bos.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (bos != <span class="hljs-keyword">null</span>) &#123;<br>                    bos.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;关闭流失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于频繁写入的场景，例如日志系统、流式写入文件等。</li></ul><h2 id="Closeable-接口与-try-with-resources-语法"><a href="#Closeable-接口与-try-with-resources-语法" class="headerlink" title="Closeable 接口与 try-with-resources 语法"></a>Closeable 接口与 try-with-resources 语法</h2><p>在 Java IO 操作中，打开的资源（如文件流、数据库连接、网络流等）需要在使用完后正确关闭，以释放系统资源，防止资源泄露。</p><p>Java 7 之前，我们通常在 <code>finally</code> 代码块中调用 <code>close()</code> 方法来关闭流。但 Java 7 引入了 <code>try-with-resources</code> 语法（基于 <code>AutoCloseable</code> 接口），让资源管理更简单、代码更简洁。</p><h3 id="Closeable-接口"><a href="#Closeable-接口" class="headerlink" title="Closeable 接口"></a>Closeable 接口</h3><p><code>Closeable</code> 是 Java IO 包 (<code>java.io</code>) 提供的资源管理接口，它只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></div></td></tr></table></figure><p><strong>作用</strong>：</p><ul><li>使得实现此接口的类可以被安全地关闭，例如 <code>FileInputStream</code>、<code>BufferedReader</code> 等。</li><li><code>close()</code> 方法释放资源，防止资源泄露。</li></ul><p><strong>继承关系</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Closeable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AutoCloseable</span></span><br></code></pre></div></td></tr></table></figure><p>它继承了 <code>AutoCloseable</code>（Java 7 引入），这使得 <code>Closeable</code> 也可以在 <code>try-with-resources</code> 中使用。</p><h3 id="try-with-resources-语法"><a href="#try-with-resources-语法" class="headerlink" title="try-with-resources 语法"></a>try-with-resources 语法</h3><h4 id="传统方式关闭资源"><a href="#传统方式关闭资源" class="headerlink" title="传统方式关闭资源"></a>传统方式关闭资源</h4><p>在 Java 7 之前，我们需要手动在 <code>finally</code> 代码块中调用 <code>close()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldStyleFileRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;Demo.txt&quot;</span>);<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) data);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fis.close(); <span class="hljs-comment">// 关闭流</span><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    log.error(<span class="hljs-string">&quot;关闭流失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>问题</strong>：</p><ul><li>代码冗长，需要手动检查 <code>null</code>，防止 <code>NullPointerException</code>。</li><li>容易出错，如果 <code>try</code> 代码块抛出异常，<code>finally</code> 仍需执行关闭逻辑。</li></ul><h4 id="自动关闭资源"><a href="#自动关闭资源" class="headerlink" title="自动关闭资源"></a>自动关闭资源</h4><p>Java 7 引入了 <code>try-with-resources</code>，资源在 <code>try()</code> 里声明，只需要捕获异常，而不需要在 <code>finally</code> 块中手动调用 <code>close()</code> 方法，即可自动关闭资源：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryWithResourcesDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;Demo.txt&quot;</span>)) &#123; <span class="hljs-comment">// 资源在 try() 里声明</span><br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) data);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125; <span class="hljs-comment">// 这里不需要 finally，资源会被自动关闭</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li>代码简洁，无需手动 <code>close()</code>。</li><li>异常安全，即使 <code>try</code> 代码块抛出异常，资源仍会自动关闭。</li><li>多个资源管理，<code>try</code> 语法可以管理多个 <code>Closeable</code> 资源。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>Java 7 引入 <code>AutoCloseable</code>，它是 <code>Closeable</code> 的超接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><table><thead><tr><th><strong>接口</strong></th><th><strong>主要方法</strong></th><th><strong>抛出的异常</strong></th><th><strong>适用范围</strong></th></tr></thead><tbody><tr><td><code>Closeable</code></td><td><code>void close() throws IOException</code></td><td><code>IOException</code></td><td>主要用于 IO 资源，如 <code>InputStream</code></td></tr><tr><td><code>AutoCloseable</code></td><td><code>void close() throws Exception</code></td><td><code>Exception</code>（更广泛）</td><td>适用于所有需要关闭的资源（数据库连接、线程池等）</td></tr></tbody></table><ul><li><code>Closeable</code> 主要用于 IO 相关的资源（<code>InputStream</code>、<code>OutputStream</code> 等）。</li><li><code>AutoCloseable</code> 适用于更广泛的需要关闭资源连接的场景（<code>Connection</code>、<code>ExecutorService</code> 等）。</li></ul><h3 id="多资源同时关闭"><a href="#多资源同时关闭" class="headerlink" title="多资源同时关闭"></a>多资源同时关闭</h3><p>如果有多个资源，可以在 <code>try</code> 语句中同时声明，在方法结束后这些资源的 <code>close()</code> 方法都会被调用，如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiResourceDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (<br>                FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>                FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)<br>        ) &#123;<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(data); <span class="hljs-comment">// 读取一个字节，写入目标文件</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>工作原理：</strong></p><ul><li><code>try</code> 语句块执行完毕后，<code>fis</code> 和 <code>fos</code> 按声明顺序关闭。</li><li>即使发生异常，资源仍然会被关闭。</li></ul><h3 id="自定义-Closeable-资源"><a href="#自定义-Closeable-资源" class="headerlink" title="自定义 Closeable 资源"></a>自定义 Closeable 资源</h3><p><code>try-with-resources</code> 适用于所有实现 <code>Closeable</code> 或 <code>AutoCloseable</code> 的类。</p><p>我们可以自定义一个可自动关闭的资源：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Using resource...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Resource closed.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCloseableDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123;<br>            resource.use();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">Using resource...<br>Resource closed.<br></code></pre></div></td></tr></table></figure><p>即使 <code>use()</code> 方法抛出异常，<code>close()</code> 也会被自动调用。</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Java 字符流（Character Streams）用于处理文本数据，以 16-bit（char）为单位进行数据读写，适用于文本文件（如 <code>.txt</code>、<code>.xml</code>、<code>.csv</code>）的操作。字符流支持字符编码转换，相比字节流（Byte Streams）更适合处理 Unicode 及多语言文本。</p><h3 id="输入流与输出流-1"><a href="#输入流与输出流-1" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h3><p>Java 字符流的两个基类：</p><ul><li><code>Reader</code>（字符输入流）：用于从数据目标读取字符数据。</li><li><code>Writer</code>（字符输出流）：用于向数据目标写入字符数据。</li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code> 是所有字符输入流的父类，提供了读取字符的基础方法：</p><ul><li><code>int read()</code>：读取单个字符，返回字符的 Unicode 值（int），如果到达流末尾返回 -1。</li><li><code>int read(char[] cbuf)</code>：读取多个字符到字符数组 cbuf 中。</li><li><code>int read(char[] cbuf, int off, int len)</code>：从 off 位置开始读取 len 个字符。</li><li><code>long skip(long n)</code>：跳过 n 个字节。</li><li><code>boolean ready()</code>：判断流是否可读取。</li><li><code>boolean markSupported()</code>：判断是否支持 mark 操作。</li><li><code>void mark(int readAheadLimit)</code>：标记流中的当前位置。</li><li><code>void reset()</code>：将此流重新定位到上次在此输入流上调用标记方法时的位置。</li><li><code>void close()</code>：关闭流，释放资源。</li></ul><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Writer</code> 是所有字符输出流的父类，提供了写入字符的基础方法：</p><ul><li><code>void write(int c)</code>：写入单个字符。</li><li><code>void write(char[] cbuf)</code>：写入字符数组。</li><li><code>void write(char[] cbuf, int off, int len)</code>：从字符数组的 off 位置开始写入 len 个字符。</li><li><code>void write(String str)</code>：写入字符串。</li><li><code>void write(String str, int off, int len)</code>：从字符数组的 off 位置开始写入 len 个字符。</li><li><code>Writer append(CharSequence csq)</code>：将指定的字符序列附加到此写入程序。</li><li><code>Writer append(CharSequence csq, int start, int end)</code>：将指定字符序列的子序列[start, end)附加到此写入程序 。</li><li><code>Writer append(char c)</code>//将指定字符附加到此写入程序。</li><li><code>void flush()</code>：刷新流，将缓冲区内容写入目标。</li><li><code>void close()</code>：关闭流，释放资源。</li></ul><h3 id="字符文件流"><a href="#字符文件流" class="headerlink" title="字符文件流"></a>字符文件流</h3><p>用于从文件读取/写入字符数据。</p><h4 id="字符文件输入流"><a href="#字符文件输入流" class="headerlink" title="字符文件输入流"></a>字符文件输入流</h4><p>字符文件输入流 <code>FileReader</code>，用于从文件中读取数据。</p><p><strong>构造方法</strong>：</p><ul><li><code>FileReader(File file)</code>：通过 File 对象创建输入流。</li><li><code>FileReader(String name)</code>：通过文件路径创建输入流。</li></ul><p><strong>示例</strong>：使用 <code>FileReader</code> 读取文本文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;source.txt&quot;</span>)) &#123;<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) data); <span class="hljs-comment">// 逐字符读取并输出</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于文本文件读取（不适合二进制文件）。</li><li>默认使用平台默认编码（如 UTF-8、GBK），可使用 <code>InputStreamReader</code> 指定编码。</li></ul><h4 id="字符文件输出流"><a href="#字符文件输出流" class="headerlink" title="字符文件输出流"></a>字符文件输出流</h4><p>字符文件输出流 <code>FileWriter</code>，用于向文件中写入数据。</p><p><strong>构造方法</strong>：</p><ul><li><p><code>FileWriter(File file)</code>：通过 File 对象创建输出流。</p></li><li><p><code>FileWriter(String name)</code>：通过文件路径创建输出流。</p></li><li><p><code>FileWriter(File file, boolean append)</code>：是否以追加模式写入。</p></li><li><p><code>FileWriter(String name, boolean append)</code>：通过路径创建并控制是否追加。</p></li></ul><p><strong>示例</strong>：使用 <code>FileWriter</code> 写入文本文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileWriterDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String data = <span class="hljs-string">&quot;Hello, FileWriter!&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> (FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>            fw.write(data); <span class="hljs-comment">// 写入字符串</span><br>            fw.flush();     <span class="hljs-comment">// 确保数据写入</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于文本数据写入。</li><li><code>flush()</code> 确保数据立即写入，而不是缓存在内存。</li></ul><h3 id="字符数组流"><a href="#字符数组流" class="headerlink" title="字符数组流"></a>字符数组流</h3><p>适用于内存中的字符数组读写，避免磁盘 IO，适合临时数据存储。</p><h4 id="字符数组输入流"><a href="#字符数组输入流" class="headerlink" title="字符数组输入流"></a>字符数组输入流</h4><p>字符数组输入流 <code>CharArrayReader</code>，允许将字符数组作为输入源。</p><p><strong>构造方法</strong>：</p><ul><li><code>CharArrayReader(char[] buf)</code>：使用字符数组创建输入流。</li><li><code>CharArrayReader(char[] buf, int off, int len)</code>：指定偏移量和长度创建输入流。</li></ul><p><strong>示例</strong>：使用 <code>CharArrayReader</code> 读取字符数组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharArrayReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] data = <span class="hljs-string">&quot;Hello, CharArrayReader!&quot;</span>.toCharArray();<br><br>        <span class="hljs-keyword">try</span> (CharArrayReader car = <span class="hljs-keyword">new</span> CharArrayReader(data)) &#123;<br>            <span class="hljs-keyword">int</span> charData;<br>            <span class="hljs-keyword">while</span> ((charData = car.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-keyword">char</span>) charData);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取字符数组失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于内存中的字符数据，无需文件 IO。</li></ul><h4 id="字符数组输出流"><a href="#字符数组输出流" class="headerlink" title="字符数组输出流"></a>字符数组输出流</h4><p>字符数组输出流 <code>CharArrayWriter</code> 允许写入字符数据到内存中的字符数组，类似 <code>ByteArrayOutputStream</code>。</p><p><strong>构造方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CharArrayWriter()                          <span class="hljs-comment">// 默认初始缓冲区大小 32</span><br>CharArrayWriter(<span class="hljs-keyword">int</span> size)                  <span class="hljs-comment">// 指定初始缓冲区大小</span><br></code></pre></div></td></tr></table></figure><p><strong>示例</strong>：使用 <code>CharArrayWriter</code> 生成字符数组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharArrayWriterDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (CharArrayWriter caw = <span class="hljs-keyword">new</span> CharArrayWriter()) &#123;<br>            caw.write(<span class="hljs-string">&quot;Hello, CharArrayWriter!&quot;</span>);<br>            <span class="hljs-keyword">char</span>[] charArray = caw.toCharArray();<br>            System.out.println(<span class="hljs-keyword">new</span> String(charArray)); <span class="hljs-comment">// 转换成字符串输出</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入字符数组失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>动态存储字符数据，适用于字符串拼接、缓存。</li></ul><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符缓冲流用于提升 IO 读写效率，通过内部缓存方式减少底层 IO 访问次数。</p><h4 id="字符缓冲输入流"><a href="#字符缓冲输入流" class="headerlink" title="字符缓冲输入流"></a>字符缓冲输入流</h4><p>字符缓冲输入流 <code>BufferedReader</code>，为输入流提供缓冲，提高文本读取性能，并支持按行读取。</p><p><strong>构造方法</strong>：</p><ul><li><code>BufferedReader(Reader in)</code>：创建默认缓冲输入流（8KB）。</li><li><code>BufferedReader(Reader in, int size)</code>：指定缓冲区大小创建缓冲输入流。</li></ul><p><strong>示例</strong>：使用 <code>BufferedReader</code> 读取文本文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;Demo.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 按行读取</span><br>                System.out.println(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>默认缓冲区大小为 8KB（可自定义）。</li><li><code>readLine()</code> 逐行读取，适用于读取大文件。</li></ul><h4 id="字符缓冲输出流"><a href="#字符缓冲输出流" class="headerlink" title="字符缓冲输出流"></a>字符缓冲输出流</h4><p><code>BufferedWriter</code> 为输出流提供缓冲，减少 <code>write()</code> 的 IO 频率，提高写入性能。</p><p><strong>构造方法</strong>：</p><ul><li><code>BufferedWriter(Writer out)</code>：创建默认缓冲输出流（8KB）。</li><li><code>BufferedWriter(Writer out, int size)</code>：指定缓冲区大小创建缓冲输出流。</li></ul><p><strong>示例</strong>：使用 <code>BufferedWriter</code> 写入文本文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedWriterDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;buffered_output.txt&quot;</span>))) &#123;<br>            bw.write(<span class="hljs-string">&quot;BufferedWriter Demo!&quot;</span>);<br>            bw.newLine(); <span class="hljs-comment">// 写入换行符</span><br>            bw.write(<span class="hljs-string">&quot;Hello, Java IO!&quot;</span>);<br>            bw.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>newLine()</code> 方法可写入系统换行符（适用于跨平台换行）。</li><li>适用于频繁写入的场景（如日志系统、流式写入文件）。</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><code>DataInputStream</code> 和 <code>DataOutputStream</code> 允许以二进制格式读写 Java 的基本数据类型（如 <code>int</code>、<code>double</code>、<code>boolean</code>）和字符串（<code>UTF-8</code> 编码），保证跨平台兼容性。</p><h3 id="数据输出流"><a href="#数据输出流" class="headerlink" title="数据输出流"></a>数据输出流</h3><p>数据输出流 <code>DataOutputStream</code> 以二进制格式写入基本数据类型，避免因字符编码或换行符差异造成的数据不兼容问题。常用于文件存储、网络传输，适合序列化数据写入。</p><p><strong>常用方法</strong>：</p><ul><li><p><code>DataOutputStream(OutputStream out)</code>：传入一个基础的字节输出流构造。</p></li><li><p><code>void writeInt(int v)</code>：写入 int 类型数据。</p></li><li><p><code>void writeDouble(double v)</code>：写入 double 类型数据。</p></li><li><p><code>void writeBoolean(boolean v)</code>：写入 boolean 类型数据。</p></li><li><p><code>void writeUTF(String str)</code>：以 UTF-8 格式写入字符串。</p></li><li><p><code>void flush()</code>：刷新流。</p></li><li><p><code>void close()</code>：关闭流。</p></li></ul><p><strong>示例</strong>：写入二进制数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataOutputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (DataOutputStream dos = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;data.bin&quot;</span>))) &#123;<br>            dos.writeInt(<span class="hljs-number">100</span>);<br>            dos.writeDouble(<span class="hljs-number">99.99</span>);<br>            dos.writeBoolean(<span class="hljs-keyword">true</span>);<br>            dos.writeUTF(<span class="hljs-string">&quot;Hello, DataOutputStream!&quot;</span>);<br>            dos.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入数据流失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>writeInt()</code>、<code>writeDouble()</code> 直接存储二进制数据，而不是字符串表示的数字，节省存储空间。</li><li><code>writeUTF()</code> 以 UTF-8 编码存储字符串，保证跨平台兼容性。</li></ul><h3 id="数据输入流"><a href="#数据输入流" class="headerlink" title="数据输入流"></a>数据输入流</h3><p>数据输入流 <code>DataInputStream</code>  以二进制格式读取数据，确保数据类型一致性。必须与 <code>DataOutputStream</code> 配合使用，否则读取时会发生错误。</p><p><strong>常用方法</strong>：</p><ul><li><p><code>DataInputStream(InputStream in)</code>：传入一个基础的字节输入流构造。</p></li><li><p><code>int readInt()</code>：读取 int 类型数据。</p></li><li><p><code>double readDouble()</code>：读取 double 类型数据。</p></li><li><p><code>boolean readBoolean()</code>：读取 boolean 类型数据。</p></li><li><p><code>String readUTF()</code>：读取 UTF-8 编码的字符串。</p></li><li><p><code>void close()</code>：关闭流。</p></li></ul><p><strong>示例</strong>：读取二进制数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataInputStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;data.bin&quot;</span>))) &#123;<br>            <span class="hljs-keyword">int</span> intValue = dis.readInt();<br>            <span class="hljs-keyword">double</span> doubleValue = dis.readDouble();<br>            <span class="hljs-keyword">boolean</span> boolValue = dis.readBoolean();<br>            String strValue = dis.readUTF();<br><br>            System.out.println(<span class="hljs-string">&quot;Int: &quot;</span> + intValue);<br>            System.out.println(<span class="hljs-string">&quot;Double: &quot;</span> + doubleValue);<br>            System.out.println(<span class="hljs-string">&quot;Boolean: &quot;</span> + boolValue);<br>            System.out.println(<span class="hljs-string">&quot;String: &quot;</span> + strValue);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取数据流失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">Int</span>: <span class="hljs-number">100</span><br><span class="hljs-keyword">Double</span>: <span class="hljs-number">99.99</span><br><span class="hljs-keyword">Boolean</span>: <span class="hljs-literal">true</span><br><span class="hljs-keyword">String</span>: Hello, DataOutputStream!<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>读取数据的顺序必须与写入顺序一致，否则可能发生数据格式错误。</li></ul><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p><code>PrintStream</code> 和 <code>PrintWriter</code> 主要用于格式化输出，支持自动 <code>flush()</code>，可输出到控制台、文件、字节流。</p><h3 id="打印字节流"><a href="#打印字节流" class="headerlink" title="打印字节流"></a>打印字节流</h3><p>打印字节流 <code>PrintStream</code> 继承自 <code>OutputStream</code>，属于字节流，主要用于打印格式化数据到控制台或文件，该流打印时不会抛出 IOException，错误时只会设置内部错误标志，适合日志系统。</p><p><strong>常用方法</strong>：</p><ul><li><p><code>PrintStream(OutputStream out)</code>：包装字节输出流。</p></li><li><p><code>PrintStream(String fileName)</code>：直接写入文件。</p></li><li><p><code>PrintStream(OutputStream out, boolean autoFlush)</code>：是否自动刷新。</p></li><li><p><code>void print(String s)</code>：输出字符串（不换行）。</p></li><li><p><code>void println(String s)</code>：输出字符串（换行）。</p></li><li><p><code>void printf(String format, Object... args)</code>：格式化输出。</p></li><li><p><code>boolean checkError()</code>：检查流是否有错误。</p></li><li><p><code>void close()</code>：关闭流。</p></li></ul><p><strong>示例</strong>：写入文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;print.txt&quot;</span>))) &#123;<br>            ps.println(<span class="hljs-string">&quot;Hello, PrintStream!&quot;</span>);<br>            ps.printf(<span class="hljs-string">&quot;Number: %d, Price: %.2f%n&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-number">19.99</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>println()</code> 自动换行，适合写日志。</li><li><code>printf()</code> 格式化输出，类似 C 语言的 <code>printf()</code>。</li></ul><h3 id="打印字符流"><a href="#打印字符流" class="headerlink" title="打印字符流"></a>打印字符流</h3><p>打印字符流 <code>PrintWriter</code> 继承自 <code>Writer</code>，属于字符流，适用于文本文件或网络输出。该流提供 <code>print()</code>、<code>println()</code> 方法，打印不会抛出 <code>IOException</code>，错误时需用 <code>checkError()</code> 检查。</p><p><strong>常用方法</strong>：</p><ul><li><p><code>PrintWriter(Writer out)</code>：包装字符输出流。</p></li><li><p><code>PrintWriter(String fileName)</code>：直接写入文件。</p></li><li><p><code>PrintWriter(OutputStream out)</code>：包装字节流（适用于控制台输出）。</p></li><li><p><code>PrintWriter(Writer out, boolean autoFlush)</code>：是否自动刷新。</p></li><li><p><code>void print(String s)</code>：输出字符串（不换行）。</p></li><li><p><code>void println(String s)</code>：输出字符串（换行）。</p></li><li><p><code>void printf(String format, Object... args)</code>：格式化输出。</p></li><li><p><code>boolean checkError()</code>：检查流是否有错误。</p></li><li><p><code>void close()</code>：关闭流。</p></li></ul><p><strong>示例</strong>：写入文本文件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintWriterDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;print_writer.txt&quot;</span>)) &#123;<br>            pw.println(<span class="hljs-string">&quot;Hello, PrintWriter!&quot;</span>);<br>            pw.printf(<span class="hljs-string">&quot;Score: %d, Accuracy: %.2f%% %n&quot;</span>, <span class="hljs-number">95</span>, <span class="hljs-number">97.5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>适用于文本数据，不会自动转换为二进制。</li><li>支持格式化，比 <code>BufferedWriter</code> 更灵活。</li></ul><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>Java 对象流（Object Streams）用于序列化（Serialization） 和反序列化（Deserialization），使 Java 对象能够以二进制格式进行存储或传输，例如写入文件、通过网络传输等。对象流基于 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 实现。</p><h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p>对象输出流 <code>ObjectOutputStreams</code> 将对象转换为二进制数据 并写入文件或网络流，适用于持久化 Java 对象或远程通信（如 RMI）。</p><p><strong>常用方法</strong>：</p><ul><li><p><code>ObjectOutputStream(OutputStream out)</code>：需要包装字节流，如 FileOutputStream。</p></li><li><p><code>void writeObject(Object obj)</code>：将对象写入流。</p></li><li><p><code>void flush()</code>：刷新流，确保数据写入。</p></li><li><p><code>void close()</code>：关闭流。</p></li></ul><h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p>对象输入流 <code>ObjectInputStream</code> 从二进制流中读取对象 并还原为 Java 实例，需要和 <code>ObjectOutputStream</code> 配合使用，保证数据格式一致。</p><p><strong>常用方法</strong>：</p><ul><li><code>ObjectInputStream(InputStream in)</code>：需要包装字节流，如 FileInputStream。</li><li><code>Object readObject()</code>：读取对象（需要强制转换）。</li><li><code>void close()</code>：关闭流。</li></ul><p><strong>示例</strong>：使用对象流进行序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 需要实现 Serializable 接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>; <span class="hljs-comment">// 推荐定义 serialVersionUID</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br><br>        <span class="hljs-comment">// 序列化（写入对象到文件）</span><br>        <span class="hljs-keyword">try</span> (ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            oos.writeObject(person);<br>            System.out.println(<span class="hljs-string">&quot;对象已序列化&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;写入文件失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 反序列化（从文件读取对象）</span><br>        <span class="hljs-keyword">try</span> (ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            Person restoredPerson = (Person) ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;反序列化对象：&quot;</span> + restoredPerson);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            log.error(<span class="hljs-string">&quot;读取文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">对象已序列化<br>反序列化对象：Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attribute">age</span>=25&#125;<br></code></pre></div></td></tr></table></figure><h3 id="序列化机制"><a href="#序列化机制" class="headerlink" title="序列化机制"></a>序列化机制</h3><h4 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h4><p><strong>作用</strong>：</p><ul><li>允许对象序列化，使其能够写入 <code>ObjectOutputStream</code> 并恢复到 <code>ObjectInputStream</code>。</li><li>这是一个标记接口（Marker Interface），没有任何方法，Java 通过反射检查类是否实现了 <code>Serializable</code>。</li></ul><p><strong>定义方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>serialVersionUID</code> 的作用：</p><ul><li>用于唯一标识类的版本，确保反序列化时版本兼容。</li><li>如果类发生改变（如添加字段），但 <code>serialVersionUID</code> 不变，仍然可以反序列化。</li><li>如果 <code>serialVersionUID</code> 变更或未定义，默认会基于类结构计算，类修改后可能导致 <code>InvalidClassException</code>。</li></ul><h4 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h4><p><strong>作用</strong>：</p><ul><li>被此关键字标识的变量不参与序列化，防止敏感数据（如密码）或非必要数据（如缓存）被写入文件或网络。</li><li><code>transient</code> 修饰的字段不会被 <code>writeObject()</code> 保存，在 <code>readObject()</code> 时该字段会使用默认值（如 <code>null</code> 或 <code>0</code>）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> String password; <span class="hljs-comment">// 不序列化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>        <span class="hljs-keyword">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;username=&#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27;, password=&#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransientDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-keyword">try</span> (ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;user.dat&quot;</span>))) &#123;<br>            oos.writeObject(user);<br>            System.out.println(<span class="hljs-string">&quot;用户对象已序列化&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;序列化用户失败&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-keyword">try</span> (ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;user.dat&quot;</span>))) &#123;<br>            User restoredUser = (User) ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;反序列化用户：&quot;</span> + restoredUser);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            log.error(<span class="hljs-string">&quot;反序列化用户失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">用户对象已序列化<br>反序列化用户：User&#123;<span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br></code></pre></div></td></tr></table></figure><p><code>password</code> 字段在反序列化后为 <code>null</code>，因为 <code>transient</code> 使其未被存储。</p><h3 id="Java-序列化过程"><a href="#Java-序列化过程" class="headerlink" title="Java 序列化过程"></a>Java 序列化过程</h3><ul><li><strong>序列化（Serialization）</strong>：<code>ObjectOutputStream.writeObject(obj)</code> 将对象转换为二进制格式，并存储到文件或发送到网络。</li><li><strong>反序列化（Deserialization）</strong>：<code>ObjectInputStream.readObject()</code> 从文件或网络中读取二进制数据，并恢复为原始对象。</li></ul><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>必须实现 <code>Serializable</code>，否则 <code>writeObject()</code> 会抛 <code>NotSerializableException</code>。</li><li><code>static</code> 变量属于类而非实例，因此不会序列化，不会被存储。</li><li><code>transient</code> 修饰的变量不会序列化，需手动初始化，或在 <code>readObject()</code> 方法中恢复值。</li></ul><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>如果类需要特殊的序列化逻辑，可以自定义 <code>writeObject()</code> 和 <code>readObject()</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(ObjectOutputStream oos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    oos.defaultWriteObject(); <span class="hljs-comment">// 让默认字段序列化</span><br>    oos.writeUTF(encrypt(password)); <span class="hljs-comment">// 手动加密存储</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>    ois.defaultReadObject(); <span class="hljs-comment">// 读取默认字段</span><br>    <span class="hljs-keyword">this</span>.password = decrypt(ois.readUTF()); <span class="hljs-comment">// 读取并解密</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>defaultWriteObject()</code> 正常处理需要序列化的字段。</li><li><code>writeUTF()</code> 手动处理 <code>transient</code> 字段 <code>password</code>。</li></ul><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>Java 管道流（Piped Streams） 主要用于线程间通信，它们允许一个线程写入数据，另一个线程从管道中读取数据，从而实现数据的传递。Java 提供了两种管道流：</p><ul><li><strong>字节流管道</strong>：<code>PipedInputStream</code> / <code>PipedOutputStream</code></li><li><strong>字符流管道</strong>：<code>PipedReader</code> / <code>PipedWriter</code></li></ul><p>这些流通常用于生产者-消费者模式，一个线程写入数据，另一个线程读取数据。它们不适用于同一线程中，必须在不同的线程间进行通信。</p><h3 id="字节管道流"><a href="#字节管道流" class="headerlink" title="字节管道流"></a>字节管道流</h3><h4 id="字节输出管道"><a href="#字节输出管道" class="headerlink" title="字节输出管道"></a>字节输出管道</h4><p>字节输出管道 <code>PipedOutputStream</code> 允许将数据写入管道，数据可以被 <code>PipedInputStream</code> 读取。适用于字节数据传输，例如文件数据、二进制流等。</p><p><strong>常用方法</strong>：</p><ul><li><code>PipedOutputStream()</code>：默认构造方法。</li><li><code>PipedOutputStream(PipedInputStream snk)</code>：连接到指定的管道输入流。</li><li><code>void connect(PipedInputStream snk)</code>：连接到指定的管道输入流。</li><li><code>void write(int b)</code>：写入单个字节。</li><li><code>void write(byte[] b)</code>：写入字节数组。</li><li><code>void write(byte[] b, int off, int len)</code>：从偏移量 off 开始写入 len 个字节。</li><li><code>void flush()</code>：刷新流。</li><li><code>void close()</code>：关闭流。</li></ul><h4 id="字节输入管道"><a href="#字节输入管道" class="headerlink" title="字节输入管道"></a>字节输入管道</h4><p>字节输入管道 <code>PipedInputStream</code> 允许从管道读取数据，数据必须由 <code>PipedOutputStream</code> 写入，适用于字节数据的读取，不能直接使用在主线程，而需要和 <code>PipedOutputStream</code> 连接。</p><p><strong>常用方法</strong>：</p><ul><li><code>PipedInputStream()</code>：默认构造方法。</li><li><code>PipedInputStream(PipedOutputStream src)</code>：连接到指定的管道输出流。</li><li><code>void connect(PipedOutputStream src)</code>：连接到指定的管道输出流。</li><li><code>int read()</code>：读取单个字节。</li><li><code>int read(byte[] b)</code>：读取多个字节到数组。</li><li><code>int read(byte[] b, int off, int len)</code>：从偏移量 off 开始读取 len 个字节。</li><li><code>void close()</code>：关闭流。</li></ul><h4 id="线程通信示例"><a href="#线程通信示例" class="headerlink" title="线程通信示例"></a>线程通信示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipedStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        PipedInputStream pis = <span class="hljs-keyword">new</span> PipedInputStream();<br>        PipedOutputStream pos = <span class="hljs-keyword">new</span> PipedOutputStream(pis); <span class="hljs-comment">// 连接两个管道流</span><br><br>        <span class="hljs-comment">// 生产者线程（写入数据）</span><br>        Thread producer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String message = <span class="hljs-string">&quot;Hello from producer!&quot;</span>;<br>                pos.write(message.getBytes());<br>                pos.close(); <span class="hljs-comment">// 关闭输出流</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;写入数据失败&quot;</span>, e);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程（读取数据）</span><br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> data;<br>                <span class="hljs-keyword">while</span> ((data = pis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.print((<span class="hljs-keyword">char</span>) data);<br>                &#125;<br>                pis.close(); <span class="hljs-comment">// 关闭输入流</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;读取数据失败&quot;</span>, e);<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Hello <span class="hljs-keyword">from</span> producer!<br></code></pre></div></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>用于线程间通信，生产者写入数据，消费者读取数据。</li><li>必须在不同线程间使用，否则会导致死锁。</li><li>默认缓冲区大小为 1024 字节，数据超过后写入线程会阻塞，直到有数据被读取。</li></ul><h3 id="字符管道流"><a href="#字符管道流" class="headerlink" title="字符管道流"></a>字符管道流</h3><h4 id="字符输出管道"><a href="#字符输出管道" class="headerlink" title="字符输出管道"></a>字符输出管道</h4><p>字符输出管道 <code>PipedWriter</code> 允许写入字符数据 到 <code>PipedReader</code> 进行读取，适用于文本数据传输。</p><p><strong>常用方法</strong>：</p><ul><li><code>PipedWriter()</code>：默认构造方法。</li><li><code>PipedWriter(PipedReader snk)</code>：连接到指定的管道输入流。</li><li><code>void connect(PipedReader snk)</code>：连接到指定的管道输入流。</li><li><code>void write(int c)</code>：写入单个字符。</li><li><code>void write(char[] cbuf)</code>：写入字符数组。</li><li><code>void write(char[] cbuf, int off, int len)</code>：从偏移量 off 开始写入 len 个字符。</li><li><code>void write(String str)</code>：写入字符串。</li><li><code>void flush()</code>：刷新流。</li><li><code>void close()</code>：关闭流。</li></ul><h4 id="字符输入管道"><a href="#字符输入管道" class="headerlink" title="字符输入管道"></a>字符输入管道</h4><p>字符输入管道 <code>PipedReader</code> 从管道读取字符数据，数据必须由 <code>PipedWriter</code> 发送，适用于文本数据的读取。</p><p><strong>常用方法</strong>：</p><ul><li><code>PipedReader()</code>：默认构造方法。</li><li><code>PipedReader(PipedWriter src)</code>：连接到指定的管道输出流。</li><li><code>void connect(PipedWriter src)</code>：连接到指定的管道输出流。</li><li><code>int read()</code>：读取单个字符。</li><li><code>int read(char[] cbuf)</code>：读取多个字符到数组。</li><li><code>int read(char[] cbuf, int off, int len)</code>：从偏移量 off 开始读取 len 个字符。</li><li><code>void close()</code>：关闭流。</li></ul><h4 id="线程通信示例-1"><a href="#线程通信示例-1" class="headerlink" title="线程通信示例"></a>线程通信示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipedCharStreamDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        PipedReader pr = <span class="hljs-keyword">new</span> PipedReader();<br>        PipedWriter pw = <span class="hljs-keyword">new</span> PipedWriter(pr); <span class="hljs-comment">// 连接两个管道流</span><br><br>        <span class="hljs-comment">// 生产者线程（写入数据）</span><br>        Thread producer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String message = <span class="hljs-string">&quot;Hello from PipedWriter!&quot;</span>;<br>                pw.write(message);<br>                pw.close(); <span class="hljs-comment">// 关闭输出流</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;写入数据失败&quot;</span>, e);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程（读取数据）</span><br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> data;<br>                <span class="hljs-keyword">while</span> ((data = pr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.print((<span class="hljs-keyword">char</span>) data);<br>                &#125;<br>                pr.close(); <span class="hljs-comment">// 关闭输入流</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(<span class="hljs-string">&quot;读取数据失败&quot;</span>, e);<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Hello <span class="hljs-keyword">from</span> PipedWriter!<br></code></pre></div></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>用于线程间通信，生产者写入数据，消费者读取数据。</li><li>必须在不同线程间使用，否则会导致死锁。</li><li>默认缓冲区大小为 1024 字节，数据超过后写入线程会阻塞，直到有数据被读取。</li><li>适用于文本数据传输，避免手动转换 <code>byte[]</code> 和 <code>String</code>。</li></ul><h2 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在 Java 中，<code>RandomAccessFile</code> 是 <code>java.io</code> 包中的一个特殊文件操作类，它既可以像 <code>FileInputStream</code> 那样读取文件，也可以像 <code>FileOutputStream</code> 那样写入文件，同时它支持文件随机访问，允许在文件的任意位置进行读写操作，而不像普通的流操作那样只能顺序处理文件数据。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>支持文件的随机访问（可在文件的任意位置进行读写）。</li><li>同时具备输入流和输出流的功能。</li><li>支持指针（file pointer）定位，可跳转到指定位置进行读写。</li><li>适用于数据库索引、日志管理、大型文件处理（如 MP4、ISO 文件）。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>日志系统</strong>：在日志文件的某个特定位置插入或修改数据。</li><li><strong>索引文件</strong>：如数据库索引，支持快速查找和更新。</li><li><strong>大文件处理</strong>：如视频、音频文件的随机访问。</li><li><strong>配置文件</strong>：修改特定字段，不必重写整个文件。</li></ul><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>RandomAccessFile</code> 需要指定文件路径和访问模式：</p><ul><li><code>RandomAccessFile(String name, String mode)</code>：通过文件路径创建。</li><li><code>RandomAccessFile(File file, String mode)</code>：通过 File 对象创建。</li></ul><p>其中，mode（访问模式）常见值：</p><table><thead><tr><th><strong>模式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>&quot;r&quot;</code></td><td>只读模式（read-only），不允许写入</td></tr><tr><td><code>&quot;rw&quot;</code></td><td>读写模式（read-write），文件可读可写</td></tr><tr><td><code>&quot;rws&quot;</code></td><td>读写模式，数据和元数据（如文件大小、修改时间）同步写入</td></tr><tr><td><code>&quot;rwd&quot;</code></td><td>读写模式，仅数据同步写入，不同步元数据</td></tr></tbody></table><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><ul><li><code>int read()</code>：读取单个字节（返回 0-255，或 -1 表示 EOF）。</li><li><code>int read(byte[] b)</code>：读取多个字节到数组 b。</li><li><code>int read(byte[] b, int off, int len)</code>：读取 len 个字节到数组 b，从 off 位置开始。</li><li><code>boolean readBoolean()</code>：读取 boolean。</li><li><code>byte readByte()</code>：读取 byte。</li><li><code>char readChar()</code>：读取 char。</li><li><code>double readDouble()</code>：读取 double。</li><li><code>float readFloat()</code>：读取 float。</li><li><code>int readInt()</code>：读取 int。</li><li><code>long readLong()</code>：读取 long。</li><li><code>short readShort()</code>：读取 short。</li><li><code>String readUTF()</code>：读取 UTF-8 编码的字符串。</li><li><code>void write(int b)</code>：写入单个字节。</li><li><code>void write(byte[] b)</code>：写入字节数组。</li><li><code>void write(byte[] b, int off, int len)</code>：从数组的 off 位置开始写入 len 个字节。</li><li><code>void writeBoolean(boolean v)</code>：写入 boolean。</li><li><code>void writeByte(int v)</code>：写入 byte。</li><li><code>void writeChar(int v)</code>：写入 char。</li><li><code>void writeDouble(double v)</code>：写入 double。</li><li><code>void writeFloat(float v)</code>：写入 float。</li><li><code>void writeInt(int v)</code>：写入 int。</li><li><code>void writeLong(long v)</code>：写入 long。</li><li><code>void writeShort(int v)</code>：写入 short。</li><li><code>void writeUTF(String str)</code>：写入 UTF-8 编码的字符串。</li></ul><h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><ul><li><code>long getFilePointer()</code>：获取当前文件指针的位置。</li><li><code>void seek(long pos)</code>：移动文件指针到指定位置。</li><li><code>long length()</code>：获取文件长度（字节数）。</li><li><code>void setLength(long newLength)</code>：设置文件长度（可用于截断或扩展文件）。</li></ul><h4 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a>关闭流</h4><ul><li><code>void close()</code>：关闭文件。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="基本的文件读写"><a href="#基本的文件读写" class="headerlink" title="基本的文件读写"></a>基本的文件读写</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessFileDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;Demo.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            raf.writeUTF(<span class="hljs-string">&quot;Hello, RandomAccessFile!&quot;</span>);<br>            raf.writeInt(<span class="hljs-number">100</span>);<br>            raf.writeDouble(<span class="hljs-number">99.99</span>);<br>            raf.seek(<span class="hljs-number">0</span>); <span class="hljs-comment">// 指针回到开头</span><br><br>            <span class="hljs-comment">// 读取数据</span><br>            String text = raf.readUTF();<br>            <span class="hljs-keyword">int</span> number = raf.readInt();<br>            <span class="hljs-keyword">double</span> value = raf.readDouble();<br><br>            System.out.println(<span class="hljs-string">&quot;读取到的内容：&quot;</span> + text);<br>            System.out.println(<span class="hljs-string">&quot;读取到的整数：&quot;</span> + number);<br>            System.out.println(<span class="hljs-string">&quot;读取到的浮点数：&quot;</span> + value);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;操作文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">读取到的内容：Hello, RandomAccessFile!<br>读取到的整数：<span class="hljs-number">100</span><br>读取到的浮点数：<span class="hljs-number">99.99</span><br></code></pre></div></td></tr></table></figure><h4 id="指针跳转"><a href="#指针跳转" class="headerlink" title="指针跳转"></a>指针跳转</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessFilePointerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;pointer.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 写入数据</span><br>            raf.writeUTF(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            raf.writeInt(<span class="hljs-number">100</span>);<br>            raf.writeDouble(<span class="hljs-number">99.99</span>);<br><br>            <span class="hljs-comment">// 获取当前指针位置</span><br>            <span class="hljs-keyword">long</span> pos = raf.getFilePointer();<br>            System.out.println(<span class="hljs-string">&quot;当前指针位置：&quot;</span> + pos);<br><br>            <span class="hljs-comment">// 回到文件开头并读取内容</span><br>            raf.seek(<span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;读取字符串：&quot;</span> + raf.readUTF());<br><br>            <span class="hljs-comment">// 跳转到整数的位置</span><br>            raf.seek(<span class="hljs-number">7</span>);  <span class="hljs-comment">// UTF-8 编码的 &quot;Hello&quot; 占 7 字节（额外2字节长度信息）</span><br>            System.out.println(<span class="hljs-string">&quot;读取整数：&quot;</span> + raf.readInt());<br><br>            <span class="hljs-comment">// 跳转到浮点数的位置</span><br>            raf.seek(<span class="hljs-number">11</span>);<br>            System.out.println(<span class="hljs-string">&quot;读取浮点数：&quot;</span> + raf.readDouble());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;操作文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">当前指针位置：19<br>读取字符串：Hello<br>读取整数：100<br>读取浮点数：99.99<br></code></pre></div></td></tr></table></figure><h4 id="覆盖写入"><a href="#覆盖写入" class="headerlink" title="覆盖写入"></a>覆盖写入</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessFileOverwriteDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;overwrite.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 写入初始数据</span><br>            raf.writeUTF(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><br>            <span class="hljs-comment">// 跳到第 7 个字节（&quot;World!&quot; 位置）</span><br>            raf.seek(<span class="hljs-number">7</span>);<br>            raf.writeUTF(<span class="hljs-string">&quot;Java&quot;</span>);<br><br>            <span class="hljs-comment">// 读取数据</span><br>            raf.seek(<span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;修改后的内容：&quot;</span> + raf.readUTF());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;操作文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">修改后的内容：Hello Java!<br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>RandomAccessFile</code> 可以修改文件的任意部分，不会影响其他部分数据。</li></ul><h4 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessFileTruncateDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;truncate.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            raf.writeUTF(<span class="hljs-string">&quot;Hello, Java!&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;文件长度：&quot;</span> + raf.length());<br><br>            <span class="hljs-comment">// 截断文件到 7 字节</span><br>            raf.setLength(<span class="hljs-number">7</span>);<br>            System.out.println(<span class="hljs-string">&quot;截断后文件长度：&quot;</span> + raf.length());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;操作文件失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台打印如下：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">文件长度：14<br>截断后文件长度：7<br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>如果想缩短或扩展文件大小，可以使用 <code>setLength()</code>。</li></ul><ul><li><code>setLength(7)</code> 截断文件，只保留前 7 字节，参数为 0 则可以清空整个文件。</li><li>可用于清理部分数据或预分配文件大小。</li></ul><h2 id="IO-设计模式"><a href="#IO-设计模式" class="headerlink" title="IO 设计模式"></a>IO 设计模式</h2><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式（Decorator Pattern）的核心思想是：在不改变原有类结构的前提下，通过 “包装” 的方式为对象添加新的职责或行为，从而使得功能可以灵活地组合或扩展。</p><p><strong>角色划分</strong>：</p><ol><li><strong>Component（抽象组件）</strong>：定义对象的基本接口或抽象类。</li><li><strong>ConcreteComponent（具体组件）</strong>：实现或继承上述抽象组件。它是最基础的功能提供者。</li><li><strong>Decorator（抽象装饰器）</strong>：同样实现或继承抽象组件，同时持有一个组件类型的引用，用于对组件进行 “包装” 或 “增强”。</li><li><strong>ConcreteDecorator（具体装饰器）</strong>：继承装饰器，真正对组件功能进行扩展或增强。</li></ol><p>在 Java IO 中，对应的角色可以映射到各种 <code>InputStream</code>、<code>OutputStream</code> 以及它们的子类。例如 <code>InputStream</code> 就是抽象组件，<code>FileInputStream</code>、<code>ByteArrayInputStream</code> 等是具体组件，而 <code>FilterInputStream</code> 及其子类则扮演装饰器角色。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>在 Java IO 中最典型的装饰器结构可以归纳为以下几层：</p><ol><li><p><strong>抽象组件（Component）</strong>：</p><ul><li><code>InputStream</code>：定义输入流的抽象方法，比如 <code>read()</code>、<code>close()</code> 等。</li><li><code>OutputStream</code>：定义输出流的抽象方法，比如 <code>write()</code>、<code>close()</code> 等。</li></ul></li><li><p><strong>具体组件（ConcreteComponent）</strong>：</p><ul><li><code>FileInputStream</code>：从文件中读取数据。</li><li><code>ByteArrayInputStream</code>：从内存中的字节数组读取数据。</li><li><code>PipedInputStream</code>：从管道读取数据。</li><li>……</li></ul><p>这些类是实际与数据源或数据目的地交互的基础流，是最原始、最简单的功能实现。</p></li><li><p><strong>抽象装饰器（Decorator）</strong>：</p><ul><li><code>FilterInputStream</code>：它是对 <code>InputStream</code> 的包装，内部持有一个 <code>InputStream</code> 类型的引用，并通过委托的方式将方法调用转发给被装饰的对象，同时提供自身的额外或改良实现。</li><li><code>FilterOutputStream</code>：对应输出流的装饰器。</li></ul></li><li><p><strong>具体装饰器（ConcreteDecorator）</strong>：</p><ul><li><code>BufferedInputStream</code>：在原有流之上添加缓冲功能，提高读操作的效率。</li><li><code>DataInputStream</code>：提供对基本数据类型如 <code>int</code>、<code>long</code>、<code>float</code>、<code>double</code> 等的读取方法。</li><li><code>PushbackInputStream</code>：允许将读取的数据推回到缓冲区，以便再次读取。</li><li><code>BufferedOutputStream</code>、<code>DataOutputStream</code>、<code>PrintStream</code> 等对于输出流类似。</li></ul></li></ol><p>通过这种层层包装，不同装饰器就可以像搭积木一样组合。例如在读取文件时，我们可以将一个 <code>FileInputStream</code> 装饰（包装）到 <code>BufferedInputStream</code> 中，以获得缓冲功能，再进一步包装到 <code>DataInputStream</code> 中，以获得对各种原始数据类型的读取。</p><h3 id="典型使用示例"><a href="#典型使用示例" class="headerlink" title="典型使用示例"></a>典型使用示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<br>    <span class="hljs-comment">// 最基础的功能：从文件中读取字节</span><br>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;example.txt&quot;</span>);<br><br>    <span class="hljs-comment">// 装饰器一：在读取功能之上增加缓冲，提高读取效率</span><br>    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br><br>    <span class="hljs-comment">// 装饰器二：在上面再增加读取各种基础数据类型的能力</span><br>    DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(bis)<br>) &#123;<br>    <span class="hljs-comment">// 使用 dis 来读取各种数据类型，如 readInt()、readUTF() 等</span><br>    <span class="hljs-keyword">int</span> number = dis.readInt();<br>    String text = dis.readUTF();<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这里，<code>fis</code> 是最基础的文件输入流，而 <code>bis</code> 为其添加了缓冲功能，<code>dis</code> 在 <code>bis</code> 的功能上又添加了读取各种数据类型的能力。通过这种层层包装，运行时就能组合出一个满足当前需求的 “增强版” 流对象。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li><p><strong>单一职责和高内聚</strong>：</p><p>每个具体组件（例如 <code>FileInputStream</code>）只负责跟文件的底层读写打交道，而各个具体装饰器（例如 <code>BufferedInputStream</code>、<code>DataInputStream</code>）则负责特定的功能增强。这样有利于保持类的单一职责，也让功能划分更清晰。</p></li><li><p><strong>灵活可扩展</strong>：</p><p>用户可以根据需求选择合适的装饰器来组合功能，而不必为了支持新的功能就修改已有的类（符合开闭原则）。</p></li><li><p><strong>运行时动态组合</strong>：</p><p>装饰器模式支持运行时组合，调用者可以灵活地决定如何组织流，比如想要缓存，可以加 <code>BufferedInputStream</code>，想要数据解析可以再加 <code>DataInputStream</code>，二者可以相互独立却又可以无缝配合。</p></li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li><p><strong>过度嵌套导致调试困难</strong>：</p><p>如果装饰器过多，流的包装层次变得复杂，可能会给调试和理解带来难度。</p></li><li><p><strong>对象数量增多</strong>：</p><p>每增加一个装饰器就多出一个包装层，Java IO 中常常要写多层构造器，比如 <code>new DataInputStream(new BufferedInputStream(new FileInputStream(...)))</code>，对于初学者来说，这种深度嵌套比较费解。</p></li><li><p><strong>接口层缺乏统一的高级抽象</strong>：</p><p>尽管装饰器给了我们组合的灵活性，但有时也让选择过于分散，需要开发者自己决定到底要使用哪些组合方式。对于某些场景，或许提供更高级别统一封装的类会更直观（比如在 NIO 和一些更高级别的库里提供了更丰富的抽象）。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 <code>File</code> 类及其常用方法的学习，我们能够更灵活地对文件和目录进行管理；借助字节流和字符流两大分支，再配合缓冲流、数据流、打印流等多种装饰/扩展用法，Java IO 为处理文件、网络数据、线程间通信等提供了一套优雅而强大的解决方案；文章还对 Java IO 的设计模式进行了简单介绍。</p><p>下一篇我们将进一步探索 Java NIO（New IO）、Channel 与 Buffer、Selector 等高阶特性；。希望本篇文章能够帮助你快速建立对 Java IO 体系的认知，为后续深入学习打下坚实的基础。</p>]]></content>
    
    
    <categories>
      
      <category>Java IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java IO</tag>
      
      <tag>BIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战——消息队列</title>
    <link href="/2024/12/29/redis-async-queue/"/>
    <url>/2024/12/29/redis-async-queue/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代分布式系统中，消息队列起着至关重要的作用。它通过异步通信的方式，实现系统各服务间的解耦和流量削峰。对于初级场景，我们可能在单个 Java 应用中借助阻塞队列来简化异步处理，但随着业务需求的增长和系统架构的演进，跨进程通信、数据持久化、高并发以及分布式部署成为关键要素。此时，Redis 作为一款高性能的内存数据库，提供了多种消息队列实现方式——包括 <code>List</code>、<code>Pub/Sub</code> 和 <code>Streams</code>，从而在不同层次的需求下灵活应对。本篇文章将从一个简单的“订单保存”案例入手，循序渐进地介绍如何使用 Redis 取代单机内存队列，实现跨进程、多节点的异步处理，并探讨不同模式的优缺点、适用场景以及注意事项。</p><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>订单保存订单操作</p><h3 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveIt</span><span class="hljs-params">(SalesOrder salesOrder)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验</span><br>    check(salesOrder);<br>    <span class="hljs-comment">// 生成销售订单号</span><br>    String soNo = generateSoNo();<br>    <span class="hljs-comment">// 保存</span><br>    doSave(soNo);<br>    <span class="hljs-keyword">return</span> soNo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    SalesOrder salesOrder = <span class="hljs-keyword">new</span> SalesOrder();<br>    salesOrder.setId(IdWorker.getId());<br>    salesOrder.setSoNo(soNo);<br>    save(salesOrder);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Java-内存异步"><a href="#Java-内存异步" class="headerlink" title="Java 内存异步"></a>Java 内存异步</h3><p>对于保存这个比较耗费时间的动作，可使用阻塞队列异步进行处理（基于内存）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;String&gt; QUEUE = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">100000</span>);<br><br><span class="hljs-comment">// 异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveIt</span><span class="hljs-params">(SalesOrder salesOrder)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验</span><br>    check(salesOrder);<br>    <span class="hljs-comment">// 生成销售订单号</span><br>    String soNo = generateSoNo();<br>    <span class="hljs-comment">// 保存</span><br>    <span class="hljs-comment">// doSave(soNo);</span><br>    asyncSave(soNo);<br>    <span class="hljs-keyword">return</span> soNo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    <span class="hljs-comment">// 模拟延迟</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    SalesOrder salesOrder = <span class="hljs-keyword">new</span> SalesOrder();<br>    salesOrder.setId(IdWorker.getId());<br>    salesOrder.setSoNo(soNo);<br>    save(salesOrder);<br>&#125;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.submit(<span class="hljs-keyword">new</span> SaveTask());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaveTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                doSave(QUEUE.take());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;保存销售订单异常&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    QUEUE.add(soNo);<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.shutdown();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li><strong>不支持跨进程</strong>：异步数据不支持跨进程，仅限于同一个 JVM 进程内部。</li><li><strong>无持久化实现</strong>：一旦应用退出或 JVM 崩溃，队列中的数据会丢失。</li><li><strong>无分布式支持</strong>：Java 阻塞队列仅限于单个进程或节点使用，不适合分布式场景。</li><li><strong>数据监控困难</strong>：Java 阻塞队列无法直接提供可观测性，需额外编写代码实现状态监控。</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>消息队列是一种用于在不同系统组件之间传递数据的通信机制。它通过将消息存储在队列中，使得生产者和消费者可以异步地进行数据交换。Redis 作为一个内存数据库，凭借其高速读写能力和丰富的数据结构，常被用来实现高效的消息队列系统。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>高性能</strong>：Redis 基于内存，读写速度极快，能够处理大量的消息。</li><li><strong>简单易用</strong>：通过简单的命令和数据结构即可实现基本的消息队列功能。</li><li><strong>丰富的数据结构</strong>：支持多种数据结构（如 <code>List</code>、<code>Pub/Sub</code>、<code>Streams</code>），满足不同的应用场景。</li><li><strong>持久化支持</strong>：通过 <code>RDB</code> 和 <code>AOF</code> 机制，Redis 能够持久化存储消息，防止数据丢失。</li><li><strong>可扩展性</strong>：支持主从复制和分片，能够扩展到大型分布式系统。</li><li><strong>跨进程</strong>：Redis 是基于网络的内存存储，支持多个进程或多种语言的客户端通过网络共享队列。</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li><strong>内存消耗</strong>：Redis 基于内存存储，消息量大时会消耗大量内存，成本较高。</li><li><strong>缺乏高级特性</strong>：相比于专门的消息队列系统（如 <code>RabbitMQ</code>、<code>Kafka</code>），Redis 在消息路由、事务支持等方面功能有限。</li><li><strong>消息持久化性能</strong>：虽然 Redis 支持持久化，但在高并发下，持久化性能可能成为瓶颈。</li><li><strong>可靠性</strong>：在某些实现方式中（如 <code>List</code> 和 <code>Pub/Sub</code>），缺乏完善的消息确认和重试机制，可能导致消息丢失或重复消费。</li></ul><h2 id="List消息队列"><a href="#List消息队列" class="headerlink" title="List消息队列"></a>List消息队列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Redis List</code> 是一个列表数据结构，支持从队列的头部或尾部插入和移除元素，非常适合用来实现队列。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-queue-list.png"></p><p>在使用 Redis 实现消息队列时，通常将一个 <code>Redis List</code> 作为队列：</p><ul><li><strong>生产者（Producer）</strong>：将消息插入队列的一个端（通常是左端）。</li><li><strong>消费者（Consumer）</strong>：从队列的另一个端弹出消息（通常是右端），以实现先进先出（<code>FIFO</code>）的队列行为。</li></ul><p>这种模式利用了 <code>Redis List</code> 的高效插入和弹出操作，适用于简单的消息传递需求。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li><p><strong>简单易用</strong>：只需使用 <code>LPUSH</code> 和 <code>BRPOP</code> 等简单命令即可实现消息队列。。</p></li><li><p><strong>高性能</strong>：Redis 基于内存，读写速度极快，适合高吞吐量的消息传递。</p><p><strong>阻塞操作</strong>：<code>BRPOP</code> 命令支持阻塞弹出，消费者可以高效地等待新消息，减少轮询开销。</p><p><strong>持久化支持</strong>：通过 Redis 的持久化机制，可以在一定程度上保证消息的持久性。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><strong>缺乏消息确认机制</strong>：使用 <code>Redis List</code> 实现的队列没有内置的消息确认机制，可能导致消息丢失或重复消费。</li><li><strong>无法实现消费者组</strong>：无法像 <code>Redis Streams</code> 那样支持多个消费者组，难以实现消息的负载均衡和广播。</li><li><strong>有限的功能</strong>：相较于 <code>Redis Streams</code> 或专门的消息队列系统，List实现的消息队列功能较为基础，缺乏高级特性如消息重试、消息优先级等。</li><li><strong>内存消耗</strong>：所有消息存储在内存中，消息量大时会占用大量内存资源。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>简单的任务队列</strong>：适用于异步处理任务，如发送邮件、图片处理等。</li><li><strong>轻量级消息传递</strong>：适用于不需要复杂消息确认和消费者管理的场景。</li><li><strong>实时通知</strong>：适用于低延迟的通知系统，虽然不如 <code>Pub/Sub</code> 实时，但在队列模式下具备一定的灵活性。</li><li><strong>短期存储和处理</strong>：适用于消息量较小且不需要长期存储的场景。</li></ul><h3 id="Redis命令示例"><a href="#Redis命令示例" class="headerlink" title="Redis命令示例"></a>Redis命令示例</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 生产者推送消息</span><br>127.0.0.1:6379&gt; LPUSH myqueue <span class="hljs-string">&quot;message1&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; LPUSH myqueue <span class="hljs-string">&quot;message2&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br><br><span class="hljs-comment"># 消费者弹出消息</span><br>127.0.0.1:6379&gt; BRPOP myqueue 0<br>1) <span class="hljs-string">&quot;myqueue&quot;</span><br>2) <span class="hljs-string">&quot;message1&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>myqueue</strong>：队列名称</li><li><strong>0</strong>：阻塞时间，单位为秒，0表示无限等待。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>使用 <code>RedisTemplate</code> 操作 <code>Redis List</code>，往保存订单的队列中添加消息，同时启用消费者线程将队列中的消息取出进行消费（创建订单）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br><span class="hljs-comment">// 异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 启动异步保存线程</span><br>    EXECUTOR.submit(<span class="hljs-keyword">new</span> OrderSaveListConsumer(redisTemplate));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveIt</span><span class="hljs-params">(SalesOrder salesOrder)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验</span><br>    check(salesOrder);<br>    <span class="hljs-comment">// 生成销售订单号</span><br>    String soNo = generateSoNo();<br>    <span class="hljs-comment">// 异步保存</span><br>    asyncSave(soNo);<br>    <span class="hljs-keyword">return</span> soNo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    redisTemplate.opsForList().leftPush(OrderSaveListConsumer.ASYNC_SAVE_QUEUE, soNo);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单保存列表消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderSaveListConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ASYNC_SAVE_QUEUE = <span class="hljs-string">&quot;order.save.queue&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String message = redisTemplate.opsForList().rightPop(ASYNC_SAVE_QUEUE);<br>                <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(message)) &#123;<br>                    SpringUtil.getBean(SalesOrderServiceImpl.class).doSave(message);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理销售订单异常&quot;</span>, e);<br>                <span class="hljs-comment">// 根据需要，可以实现重试机制或将失败的消息重新放回队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    SalesOrder salesOrder = <span class="hljs-keyword">new</span> SalesOrder();<br>    salesOrder.setId(IdWorker.getId());<br>    salesOrder.setSoNo(soNo);<br>    save(salesOrder);<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.shutdown();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 <code>Redisson</code> 也可以完成相同的操作，只需对上面生产和消费的方法进行简单的改造。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br><span class="hljs-comment">// 异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 启动异步保存线程</span><br>    EXECUTOR.submit(<span class="hljs-keyword">new</span> OrderSaveListConsumer(redissonClient));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveIt</span><span class="hljs-params">(SalesOrder salesOrder)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验</span><br>    check(salesOrder);<br>    <span class="hljs-comment">// 生成销售订单号</span><br>    String soNo = generateSoNo();<br>    <span class="hljs-comment">// 异步保存</span><br>    asyncSave(soNo);<br>    <span class="hljs-keyword">return</span> soNo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    redissonClient.getQueue(OrderSaveListConsumer.ASYNC_SAVE_QUEUE).add(soNo);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单保存列表消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderSaveListConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ASYNC_SAVE_QUEUE = <span class="hljs-string">&quot;order.save.queue&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;Object&gt; poll = redissonClient.getQueue(ASYNC_SAVE_QUEUE).poll(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (CollUtil.isEmpty(poll)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                Object o = poll.get(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || StrUtil.isBlank(o.toString())) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                SpringUtil.getBean(SalesOrderServiceImpl.class).doSave(o.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理销售订单异常&quot;</span>, e);<br>                <span class="hljs-comment">// 根据需要，可以实现重试机制或将失败的消息重新放回队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    SalesOrder salesOrder = <span class="hljs-keyword">new</span> SalesOrder();<br>    salesOrder.setId(IdWorker.getId());<br>    salesOrder.setSoNo(soNo);<br>    save(salesOrder);<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.shutdown();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 <code>Redis List</code> 实现消息队列适用于简单、低复杂度的场景，如基本的任务异步处理和轻量级消息传递。然而，由于其缺乏高级特性和在可靠性、扩展性方面的局限，当业务需求变得复杂或对消息队列的可靠性要求更高时，可能需要考虑其他解决方案。</p><h2 id="Pub-Sub消息队列"><a href="#Pub-Sub消息队列" class="headerlink" title="Pub/Sub消息队列"></a>Pub/Sub消息队列</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Redis 的 <code>Pub/Sub</code>（发布/订阅）是一种消息传递模式，允许消息生产者（发布者）向一个或多个频道发布消息，而消息消费者（订阅者）订阅这些频道以接收相关消息。<code>Pub/Sub</code> 模式适用于实时消息传递和广播场景。</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-pub-sub.png"></p><p>Redis 通过维护频道与订阅者的映射关系，实现消息的即时推送。发布者和订阅者之间无需直接通信，Redis 负责将消息分发给所有订阅者。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>实时性强</strong>：消息一旦发布，所有订阅者立即接收到，无需轮询或等待。</li><li><strong>简单易用</strong>：通过简单的 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 命令即可实现消息传递。</li><li><strong>广播机制</strong>：支持将消息广播给所有订阅者，适合实时通知和广播场景。</li><li><strong>低延迟</strong>：基于内存操作，消息传递延迟极低。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>无持久化</strong>：消息不会被持久化，订阅者必须在线才能接收消息，离线订阅者将错过消息且后续也无法获取。</li><li><strong>无消息确认机制</strong>：发布的消息无法确认是否被订阅者成功接收，存在消息丢失的风险。</li><li><strong>不支持消费者组</strong>：无法像 <code>Streams</code> 那样实现负载均衡和消息分发给多个消费者组。</li><li><strong>只有广播模式</strong>：<code>Pub/Sub</code> 本质上是广播机制，每个订阅者都会收到发布频道的消息，因此如果一个服务有多个实例的话会被多次消费，应该注意业务逻辑的正确性。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>实时通知系统</strong>：如在线聊天、即时消息推送、实时监控报警等，需要实时将消息推送给多个用户。</li><li><strong>事件驱动架构</strong>：微服务之间的事件通知和实时通信，确保各服务能够即时响应事件。</li><li><strong>直播和广播</strong>：适用于需要将数据实时广播给多个订阅者的场景，如直播平台的数据分发。</li><li><strong>即时数据更新</strong>：如实时股票行情、体育比赛得分更新等，确保客户端能够即时接收最新数据。</li></ul><h3 id="Redis命令示例-1"><a href="#Redis命令示例-1" class="headerlink" title="Redis命令示例"></a>Redis命令示例</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 订阅者订阅频道</span><br>127.0.0.1:6379&gt; SUBSCRIBE mychannel<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;mychannel&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br><br><span class="hljs-comment"># 发布者发布消息</span><br>127.0.0.1:6379&gt; PUBLISH mychannel <span class="hljs-string">&quot;Hello, Subscribers!&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br><br><span class="hljs-comment"># 订阅者接收消息</span><br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;mychannel&quot;</span><br>3) <span class="hljs-string">&quot;Hello, Subscribers!&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    redisTemplate.convertAndSend(OrderSaveSubscriber.ASYNC_SAVE_CHANNEL, soNo);<br>    <span class="hljs-comment">// 或使用Redisson发布订阅</span><br> redissonClient.getTopic(OrderSaveSubscriber.ASYNC_SAVE_CHANNEL).publish(soNo);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单保存订阅者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderSaveSubscriber</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ASYNC_SAVE_CHANNEL = <span class="hljs-string">&quot;order.save.channel&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisMessageListenerContainer <span class="hljs-title">container</span><span class="hljs-params">(RedisConnectionFactory connectionFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                   MessageListener listener)</span> </span>&#123;<br>        RedisMessageListenerContainer container = <span class="hljs-keyword">new</span> RedisMessageListenerContainer();<br>        container.setConnectionFactory(connectionFactory);<br>        container.addMessageListener(listener, <span class="hljs-keyword">new</span> ChannelTopic(ASYNC_SAVE_CHANNEL));<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息监听器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageListener <span class="hljs-title">listener</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (message, pattern) -&gt; &#123;<br>            String soNo = <span class="hljs-keyword">new</span> String(message.getBody());<br>            log.info(<span class="hljs-string">&quot;接收到销售订单号：&#123;&#125;&quot;</span>, soNo);<br>            SpringUtil.getBean(SalesOrderServiceImpl.class).doSave(soNo);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：<code>Pub/Sub</code> 为广播模式，请特别注意多个实例导致的重复消费问题。</p><p>虽然 <code>Pub/Sub</code> 模式在即时消息传递和广播通知方面表现出色，但它缺乏消息持久化和确认机制，导致在某些情况下可能会出现消息丢失或重复消费的问题，为此 <code>Redis 5.0</code> 中引入了 <code>Streams</code> 数据结构，提供了更加丰富和可靠的消息队列功能。</p><h2 id="Stream消息队列"><a href="#Stream消息队列" class="headerlink" title="Stream消息队列"></a>Stream消息队列</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><code>Redis Streams</code> 是 <code>Redis 5.0</code> 引入的一种新的数据结构，旨在提供更强大和灵活的消息队列功能。与 <code>Redis List</code> 和 <code>Pub/Sub</code> 不同，<code>Redis Streams</code> 支持消息的持久化、消费者组、消息确认和重试机制，使其适用于需要高可靠性和复杂消息处理逻辑的场景。</p><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>在 <code>Redis Streams</code> 中，消息以条目的形式存储在一个有序的日志中。每个条目都有一个唯一的 <code>ID</code>（通常是时间戳加序列号），并包含一个或多个字段-值对。生产者将消息添加到流中，而消费者则通过消费者组读取和处理这些消息。</p><p><strong>核心概念：</strong></p><ul><li><strong>Stream（流）</strong>：消息的集合，类似于一个日志。</li><li><strong>Entry（条目）</strong>：流中的单条消息，包含唯一 <code>ID</code> 和字段-值对。</li><li><strong>Consumer Group（消费者组）</strong>：一组消费者共同消费流中的消息，每条消息只被组内一个消费者处理。</li><li><strong>Pending Entries（待处理条目）</strong>：消费者组中尚未被确认的消息。</li><li><strong>Acknowledge（确认）</strong>：消费者确认已成功处理某条消息。</li></ul><p>通过这些机制，<code>Redis Streams</code> 实现了高可靠性、负载均衡和消息持久化。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>持久化</strong>：消息被持久化存储，确保在 Redis 重启后消息不会丢失。</li><li><strong>消费者组</strong>：支持多个消费者组，每个组独立消费消息，实现负载均衡。</li><li><strong>消息确认</strong>：消费者可以确认已处理的消息，支持消息的重试机制，确保消息不丢失。</li><li><strong>消息ID</strong>：每条消息有唯一的 <code>ID</code>，支持按时间范围或特定 <code>ID</code> 查询消息。</li><li><strong>回溯和历史查询</strong>：支持消费组可以从任意位置开始消费，甚至回溯历史消息。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>使用复杂度较高</strong>：相比 <code>Redis List</code> 和 <code>Pub/Sub</code>，<code>Redis Streams</code> 的概念和使用方式更为复杂，学习曲线较陡。</li><li><strong>资源消耗</strong>：虽然 Redis 本身高效，但 <code>Redis Streams</code> 的持久化和消费者组机制可能会增加一定的资源消耗。</li><li><strong>不适合实时广播</strong>：<code>Redis Streams</code> 更适用于工作队列模式，而非实时广播场景。</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>复杂的任务队列</strong>：需要消息确认和重试机制，确保任务不丢失。需要负载均衡，多个消费者组共同处理任务。</li><li><strong>事件驱动架构</strong>：微服务之间的事件传递，确保每个事件被至少一个服务处理。</li><li><strong>日志收集和处理</strong>：实时收集和处理大量日志数据，确保数据不丢失。</li><li><strong>实时数据处理</strong>：需要处理实时数据流，如实时分析、监控等。</li><li><strong>金融交易系统</strong>：需要高可靠性和顺序保证的交易消息处理。</li></ul><h3 id="单消费者"><a href="#单消费者" class="headerlink" title="单消费者"></a>单消费者</h3><p>生产者往指定的流中推送消息，消费者则可以从流中读取消息。</p><h4 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 向指定的 Stream 中添加消息</span><br>XADD key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|id field value [field value ...]<br><br><span class="hljs-comment"># 示例</span><br>XADD mystream * field1 value1 field2 value2<br>XADD mystream MAXLEN ~ 1000 * field1 value1<br>XADD mystream MINID ~ 1680000000000-0 * field1 value1<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>NOMKSTREAM</strong>：如果流不存在，不自动创建；默认是自动创建流。</li><li><strong>MAXLEN|MINID</strong>：控制流的长度。<ul><li><strong>MAXLEN</strong>：通过指定消息数量限制流的长度。</li><li><strong>MINID</strong>：按消息 <code>ID</code> 删除早于指定 <code>ID</code> 的消息。</li><li>**=**：严格删除，确保不超过指定限制。</li><li>**~**：近似删除（默认），性能更高但结果不精确。</li></ul></li><li><strong>threshold</strong>：长度或 <code>ID</code> 的限制值。</li><li><strong>LIMIT count</strong>：限制每次删除的消息数量（与 <code>MAXLEN|MINID</code> 配合使用）。</li><li>*****：由 Redis 自动生成消息 <code>ID</code>（时间戳 + 序列号）。</li><li><strong>id</strong>：用户自定义的消息 <code>ID</code>。</li><li><strong>field value</strong>：消息内容，由键值对组成。</li></ul><h4 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 从一个或多个 Stream 中读取消息</span><br>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]<br><br><span class="hljs-comment"># 示例</span><br>XREAD COUNT 10 STREAMS mystream 0<br>XREAD BLOCK 5000 STREAMS mystream $<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>COUNT count</strong>：一次读取的最大消息数量。</p></li><li><p><strong>BLOCK milliseconds</strong>：阻塞等待的时间（毫秒），如果没有新消息立即返回，<code>0</code> 表示无限等待。</p></li><li><p>**STREAMS key [key …]**：指定要读取的 <code>Redis Streams</code>。</p></li><li><p>**id [id …]**：指定起始读取的消息 <code>ID</code>。</p></li></ul><ul><li><strong>0</strong>：从第一个消息开始。</li><li>**$**：从最新的消息开始。</li></ul><p>Java 程序伪代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 循环处理</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">// 读取最新的一条消息，阻塞两秒</span><br>Object msg = redis.execute(<span class="hljs-string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS mystream $&quot;</span>)<br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>    <span class="hljs-comment">// 处理消息</span><br>    handleMessage(msg);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>问题</strong>：如果在处理消息的过程中，生产者连发消息，那单消费者只处理最新的一条会导致漏处理消息。</p><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组可以将多个消费者划分到同一个组中，监听同一个队列，可以实现：</p><ol><li><strong>消息分流</strong>：队列中的消息会被分流到组内不同消费者，而不重复消费，加快消息处理的速度。</li><li><strong>消费标示</strong>：消费者组会维护一个标识，记录最后一个被处理的消息，每次消费都从未被处理的消息开始。</li><li><strong>消费确认</strong>：消费者获取消息后，消息处于 <code>Pending</code> 状态，并存入一个 <code>Pending Entries List</code>。当处理完成后需要通过 <code>XACK</code> 确认消息，标记为已处理，从 <code>Pending Entries List</code> 中移除。</li></ol><h4 id="XGROUP"><a href="#XGROUP" class="headerlink" title="XGROUP"></a>XGROUP</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 为 Stream 创建消费者组。</span><br>XGROUP CREATE key group id|$ [MKSTREAM] [ENTRIESREAD entries-read]<br><br><span class="hljs-comment"># 示例</span><br>XGROUP CREATE mystream mygroup 0 MKSTREAM<br>XGROUP CREATE mystream mygroup $ MKSTREAM<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>key</strong>：流的名称。</p></li><li><p><strong>group</strong>：消费者组名称。</p></li><li><p>**id|$**：消费者组从该 <code>ID</code> 开始消费。</p><ul><li><p><strong>id</strong>：指定消息 <code>ID</code>。</p></li><li><p>**$**：从最新的消息开始消费。</p></li></ul></li><li><p><strong>MKSTREAM</strong>：如果流不存在，自动创建流。</p></li><li><p><strong>ENTRIESREAD entries-read</strong>：指定已读取条目数，用于恢复某些消费状态。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 为现有的消费者组创建一个消费者</span><br>XGROUP CREATECONSUMER key group consumer<br><br><span class="hljs-comment"># 示例</span><br>XGROUP CREATECONSUMER mystream mygroup consumer1<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>group</strong>：消费者组名称。</li><li><strong>consumer</strong>：消费者名称。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 从消费者组中删除一个消费者</span><br>XGROUP DELCONSUMER key group consumer<br><br><span class="hljs-comment"># 示例</span><br>XGROUP DELCONSUMER mystream mygroup consumer1<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>group</strong>：消费者组名称。</li><li><strong>consumer</strong>：消费者名称。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 删除一个消费者组</span><br>XGROUP DESTROY key group<br><br><span class="hljs-comment"># 示例</span><br>XGROUP DESTROY mystream mygroup<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>group</strong>：消费者组名称。</li></ul><h4 id="XREADGROUP"><a href="#XREADGROUP" class="headerlink" title="XREADGROUP"></a>XREADGROUP</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 从消费者组中读取消息</span><br>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]<br><br><span class="hljs-comment"># 示例</span><br>XREADGROUP GROUP mygroup consumer1 COUNT 10 BLOCK 5000 STREAMS mystream &gt;<br>XREADGROUP GROUP mygroup consumer1 STREAMS mystream 0<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>GROUP group consumer</strong>：指定消费者组和消费者名称。</p></li><li><p><strong>COUNT count</strong>：一次读取的最大消息数量。</p></li><li><p><strong>BLOCK milliseconds</strong>：阻塞等待时间（毫秒）。</p></li><li><p><strong>NOACK</strong>：不等待确认，消息不会进入 <code>Pending Entries List（PEL）</code>。</p></li><li><p>**STREAMS key [key …]**：指定要读取的 <code>Redis Streams</code>。</p></li><li><p>**id [id …]**：</p></li></ul><ul><li>**&gt;**：从未被消费的消息开始读取。</li><li><strong>其他 ID</strong>：从指定 <code>ID</code> 开始读取。</li></ul><h4 id="XACK"><a href="#XACK" class="headerlink" title="XACK"></a>XACK</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 确认消息已被成功处理（从消费者组的 Pending Entries List 中移除消息）</span><br>XACK key group id [id ...]<br><br><span class="hljs-comment"># 示例</span><br>XACK mystream mygroup 1640345568000-0<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>group</strong>：消费者组的名称。</li><li><strong>id</strong>：要确认的消息 <code>ID</code>，可以同时指定多个。</li></ul><h4 id="XPENDING"><a href="#XPENDING" class="headerlink" title="XPENDING"></a>XPENDING</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 Redis Stream 中指定消费者组的待确认消息（Pending Entries List，PEL）</span><br>XPENDING key group [[IDLE min-idle-time] start end count [consumer]]<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong>：流的名称。</li><li><strong>group</strong>：消费者组的名称。</li><li><strong>IDLE min-idle-time</strong>：仅返回在 PEL 中等待超过指定时间（毫秒）的消息。</li><li><strong>start</strong>：查询起始的消息 <code>ID</code>，<code>-</code> 表示最早的消息。</li><li><strong>end</strong>：查询结束的消息 <code>ID</code>，<code>+</code> 表示最新的消息。</li><li><strong>count</strong>：限制返回的消息数量。</li><li><strong>consumer</strong>：指定消费者，查询该消费者的待确认消息。</li></ul><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>使用 <code>RedisTemplate</code> 操作 <code>Redis Streams</code>，向指定流中添加消息，同时启用消费者线程将流中的消息取出进行消费（创建订单）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br><span class="hljs-comment">// 异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 启动异步保存线程</span><br>    EXECUTOR.submit(<span class="hljs-keyword">new</span> OrderSaveStreamConsumer(redisTemplate));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    redisTemplate.opsForStream().add(<span class="hljs-string">&quot;stream.orders&quot;</span>, <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(<span class="hljs-number">1</span>) &#123;&#123;<br>            put(<span class="hljs-string">&quot;soNo&quot;</span>, soNo);<br>        &#125;&#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单保存流消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderSaveStreamConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STREAM_KEY = <span class="hljs-string">&quot;stream.orders&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GROUP_NAME = <span class="hljs-string">&quot;order.group&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建消费组</span><br>        <span class="hljs-keyword">if</span> (!redisTemplate.hasKey(STREAM_KEY)) &#123;<br>            redisTemplate.opsForStream().createGroup(STREAM_KEY, GROUP_NAME);<br>        &#125;<br>        <span class="hljs-comment">// 消费</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取 Streams 中的订单号（XREADGROUP GROUP order.group consumer-1 STREAMS stream.orders &gt;）</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = redisTemplate.opsForStream().read(<br>                        Consumer.from(GROUP_NAME, <span class="hljs-string">&quot;consumer-1&quot;</span>),<br>                        StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())<br>                );<br>                <span class="hljs-keyword">if</span> (CollUtil.isEmpty(list)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 处理订单</span><br>                <span class="hljs-keyword">for</span> (MapRecord&lt;String, Object, Object&gt; entries : list) &#123;<br>                    String messageId = entries.getId().getValue();<br>                    entries.getValue().forEach((k, v) -&gt; &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;soNo&quot;</span>.equals(k.toString())) &#123;<br>                            SpringUtil.getBean(SalesOrderServiceImpl.class).doSave(v.toString());<br>                        &#125;<br>                    &#125;);<br>                    <span class="hljs-comment">// 消息确认</span><br>                    redisTemplate.opsForStream().acknowledge(STREAM_KEY, GROUP_NAME, messageId);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理销售订单异常&quot;</span>, e);<br>                <span class="hljs-comment">// 根据需要，可以实现重试机制或将失败的消息重新放回队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.shutdown();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可使用 <code>Redisson</code> 替代 <code>RedisTemplate</code> 操作 <code>Redis Stream</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-comment">// 异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 启动异步保存线程</span><br>    EXECUTOR.submit(<span class="hljs-keyword">new</span> OrderSaveStreamConsumer(redissonClient));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncSave</span><span class="hljs-params">(String soNo)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 Redisson 发送订单号至 Streams 队列</span><br>    redissonClient.getStream(<span class="hljs-string">&quot;stream.orders&quot;</span>).add(<span class="hljs-string">&quot;soNo&quot;</span>, soNo);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单保存流消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderSaveStreamConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STREAM_KEY = <span class="hljs-string">&quot;stream.orders&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GROUP_NAME = <span class="hljs-string">&quot;order.group&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建消费组</span><br>        RStream&lt;Object, Object&gt; initialStream = redissonClient.getStream(STREAM_KEY);<br>        <span class="hljs-keyword">if</span> (initialStream.size() == <span class="hljs-number">0</span>) &#123;<br>            initialStream.createGroup(GROUP_NAME);<br>        &#125;<br>        <span class="hljs-comment">// 消费</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取 Streams 中的订单号（XREADGROUP GROUP order.group consumer-1 STREAMS stream.orders &gt;）</span><br>                Map&lt;StreamMessageId, Map&lt;Object, Object&gt;&gt; streamMessageIdMapMap = initialStream.readGroup(GROUP_NAME, <span class="hljs-string">&quot;consumer-1&quot;</span>);<br>                streamMessageIdMapMap.forEach((streamMessageId, map) -&gt; &#123;<br>                    map.forEach((k, v) -&gt; &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;soNo&quot;</span>.equals(k.toString())) &#123;<br>                            SpringUtil.getBean(SalesOrderServiceImpl.class).doSave(v.toString());<br>                        &#125;<br>                    &#125;);<br>                    initialStream.ack(GROUP_NAME, streamMessageId);<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理销售订单异常&quot;</span>, e);<br>                <span class="hljs-comment">// 根据需要，可以实现重试机制或将失败的消息重新放回队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    EXECUTOR.shutdown();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="对比其他MQ"><a href="#对比其他MQ" class="headerlink" title="对比其他MQ"></a>对比其他MQ</h2><table><thead><tr><th>特性</th><th><strong>Redis (List/PubSub/Streams)</strong></th><th><strong>RabbitMQ</strong></th><th><strong>Kafka</strong></th><th><strong>RocketMQ</strong></th></tr></thead><tbody><tr><td><strong>消息模型</strong></td><td>List：工作队列；Pub/Sub：广播；Streams：可靠消息 &amp; 消费者组</td><td>AMQP 协议，队列交换机模式，丰富路由规则</td><td>发布/订阅模型，分区+副本，多用于日志流处理</td><td>与 Kafka 类似，支持主题+分区 &amp; 多种协议</td></tr><tr><td><strong>消息持久化</strong></td><td>Pub/Sub 无持久化；List/Streams 支持持久化</td><td>高度可配置，默认持久化</td><td>按日志存储，天然持久化且不可修改</td><td>同样按日志存储，支持多级存储</td></tr><tr><td><strong>消息确认与重试</strong></td><td>List 无确认；Pub/Sub 无确认；Streams 有确认 &amp; 重试</td><td>拥有完备的 ACK &amp; 重发机制</td><td>有 Consumer Group，手动提交偏移量</td><td>有 ACK，支持消息重试，支持死信队列</td></tr><tr><td><strong>消费者组 &amp; 负载均衡</strong></td><td>Streams 支持消费者组；List、Pub/Sub 不支持</td><td>有队列绑定，多消费者可负载均衡</td><td>有 Consumer Group，自动负载均衡</td><td>Topic + Consumer Group, 负载均衡</td></tr><tr><td><strong>消息路由功能</strong></td><td>较简单（Streams 没有高级路由），List &amp; Pub/Sub 几乎无路由功能</td><td>复杂路由规则（topic、direct、fanout 等）</td><td>简单（按 topic + partition）</td><td>相对灵活（Topic、Tag、Key 等），略低于 RabbitMQ</td></tr><tr><td><strong>吞吐量 &amp; 性能</strong></td><td>基于内存，单机性能较高，分布式扩展需要 Redis Cluster；</td><td>轻量但单机吞吐量中等，集群方式提升吞吐量</td><td>高吞吐量，专为海量日志和流处理设计</td><td>与 Kafka 类似，吞吐量较高</td></tr><tr><td><strong>应用场景</strong></td><td>中小型异步处理、高速缓存消息、简易通知；Streams 可做可靠队列</td><td>需要灵活路由、强大队列功能和扩展性</td><td>大规模日志分析、流数据处理、事件驱动体系</td><td>与 Kafka 类似，国内金融、电商常用</td></tr><tr><td><strong>学习成本</strong></td><td>List/PubSub 简单；Streams 较复杂</td><td>较高（AMQP 概念相对丰富）</td><td>较高（分区、副本、偏移量等概念）</td><td>较高（类似 Kafka 但细节有所差异）</td></tr></tbody></table><p><strong>选择建议</strong>：</p><ul><li>如果仅需要简单异步和高性能，对消息的可靠性和复杂路由要求不高，可首选 <code>Redis List</code> 或 <code>Pub/Sub</code>。</li><li>如果需要消息持久化、确认、重试等较高可靠性保障，又希望借助 Redis 的高性能和易部署，可用 <code>Redis Streams</code>。</li><li>如果对消息路由、高可用集群、巨量日志处理等要求高，或需要复杂的消息模式（<code>RPC</code>、事务消息、定时消息等），则可考虑 <code>RabbitMQ / Kafka / RocketMQ</code> 等专业消息队列系统。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 Java 内存队列和 Redis 不同消息队列实现（<code>List</code>、<code>Pub/Sub</code>、<code>Redis Streams</code>）的对比，可以发现 Redis 天然支持跨进程、可持久化且能在分布式环境下灵活扩展，适合在生产级别的高并发场景中使用。<code>Redis List</code> 适用于轻量、简单的异步处理；<code>Pub/Sub</code> 强调实时广播；而 <code>Redis Streams</code> 则在消息确认、消费者组和重试机制方面更进一步，适合对可靠性要求更高的复杂场景。</p><p>在实际项目中，如何选择合适的 Redis 消息队列方案，取决于对消息可靠性、吞吐量、延迟以及系统复杂度的综合考量。如果你需要更丰富的消息路由与高可靠性保证，也可以考虑专业的消息队列系统（<code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等）。但对于中小型或对延迟要求较高的项目而言，Redis 依然是一个高效而简洁的解决方案。</p><p>由于篇幅原因，以下几个方向的内容今后再重新整理：</p><ol><li><strong>幂等性和重试</strong>：探索如何结合 Redis 的 <code>XPENDING</code>、<code>XCLAIM</code> 等命令实现安全可靠的消息重试。</li><li><strong>高可用与可观测性</strong>：借助 Redis 集群、哨兵模式，以及监控工具（<code>Grafana</code> + <code>Prometheus</code>）构建全面的可视化监控体系。</li><li><strong>与其他消息队列对比</strong>：根据业务需求，从事务支持、消息路由、消费模式等角度对比 <code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等系统的优劣点。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>Redis实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战——分布式业务ID生成器</title>
    <link href="/2024/12/25/redis-practice-id/"/>
    <url>/2024/12/25/redis-practice-id/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在分布式系统中，为了保证订单、流水等业务单号的唯一性、高可用、高性能和有序递增，我们通常会选择分布式ID生成方案。本文将结合一个“业务单号”案例，演示如何使用<code>RedisAtomicLong</code>来生成符合业务需求的可读单号，并与常见的<code>Snowflake</code>算法做简单对比。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>在实际业务场景中，单号除了需要具备唯一性，还希望包含一些能够体现业务维度的信息，方便快速识别或手动对账。例如，一个典型的销售订单号可能会包含：</p><ul><li><strong>前缀</strong>：业务类型，如销售订单（Sales Order）可简写为<code>SO</code></li><li><strong>业务参数</strong>：如店代码<code>DGDA010</code></li><li><strong>日期</strong>：单号生成日期，常用<code>yyyyMMdd</code>格式，如<code>20240101</code></li><li><strong>序列号</strong>：一天内自增，如<code>00001</code>，长度可配</li></ul><p>因此，一个完整的销售订单号示例会是<code>SODGDA0102024010100001</code></p><ul><li><code>SO</code> —— 销售订单前缀</li><li><code>DGDA010</code> —— 店铺代码</li><li><code>20240101</code> —— 订单日期</li><li><code>00001</code> —— 序列号（当天从 1 开始累加，左补零）</li></ul><p>相比纯数字的全局 ID，这类“业务单号”更方便人工查询和业务审计。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>一个完善的分布式全局业务ID生成器，应当满足：</p><ol><li><strong>唯一性</strong>：不能产生重复的ID。</li><li><strong>高可用</strong>：在分布式和高并发环境中保持稳定运行。</li><li><strong>高性能</strong>：ID的生成过程不能成为性能瓶颈。</li><li><strong>递增性</strong>：ID有序（如按时间或数值递增），方便做数据分区、排序或日志查询。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在分布式环境中，保证序列号自增的常见做法有：</p><ol><li><strong>数据库自增主键</strong>：容易成为性能瓶颈和单点故障。</li><li><strong>Snowflake算法</strong>：能够快速生成高并发下的全局唯一 ID，但生成的结果通常是无业务含义的 64 位长整型。</li><li><strong>Redis自增</strong>：基于Redis的<code>INCR</code>命令或<code>RedisAtomicLong</code>，既可以实现分布式场景下的原子性自增，又能灵活拼接业务前缀、参数与日期，生成“可读”的业务单号。</li></ol><h3 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h3><ul><li><strong>高性能</strong>：在内存中本地生成，不依赖外部服务；</li><li><strong>分布式</strong>：可以将机器ID、时间戳等信息组合在一个64位长整型中，轻松实现跨节点唯一；</li><li><strong>不含业务信息</strong>：生成的长整型ID难以让人直接看出其含义，通常需要额外查询或计算才能做分类、分表等。</li></ul><h3 id="RedisAtomicLong"><a href="#RedisAtomicLong" class="headerlink" title="RedisAtomicLong"></a>RedisAtomicLong</h3><p><code>Spring Data Redis</code>提供的一个便捷类，内置了以下优势：</p><ul><li><strong>原子性</strong>：底层基于Redis的<code>INCR</code>命令，多线程同时操作也能保持正确的计数。</li><li><strong>易用性</strong>：提供了<code>incrementAndGet</code>、<code>addAndGet</code>等简洁方法，且支持设置过期时间（<code>expire</code>）。</li><li><strong>可维护性</strong>：把计数器作为Key存在Redis，易于在运维层面做监控或清理。</li><li><strong>可包含业务信息</strong>：能够在“纯数字”之外附带前缀、日期、参数等更多逻辑；</li></ul><p>如果你仅仅需要一个纯数字型ID（如数据库表主键），不关心其“含义”或“格式”，Snowflake算法更轻便，且不需要额外的外部存储；如果你更关注让ID本身表达业务信息（业务单号），则基于<code>RedisAtomicLong</code>的方式通常更简单直观。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下方是一段使用<code>Spring Boot + Spring Data Redis</code>示例代码，用于在分布式场景下生成业务单号。代码具备以下特征：</p><ul><li><strong>灵活可定制</strong>：可配置前缀、业务参数、日期、序列号长度、重试机制等。</li><li><strong>自动过期</strong>：每天自动过期，确保不会冗余太多无用数据。</li><li><strong>批量生成</strong>：可一次性生成多个ID，减少对Redis的交互次数。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BizIdUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Redis Key 的前缀，避免与其他业务冲突</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_BIZ_ID_LOCK = <span class="hljs-string">&quot;redis_biz_id_lock:&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BizIdBuilder <span class="hljs-title">builder</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BizIdBuilder(stringRedisTemplate);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取 BizIdBuilder 实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BizIdBuilder</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BizIdBuilder</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        &#125;<br><br>        <span class="hljs-comment">// 用于缓存 RedisAtomicLong 实例，减少重复创建的开销</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, RedisAtomicLong&gt; counterMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 前缀</span><br>        <span class="hljs-keyword">private</span> String prefix;<br><br>        <span class="hljs-comment">// 业务参数</span><br>        <span class="hljs-keyword">private</span> List&lt;String&gt; params;<br><br>        <span class="hljs-comment">// 业务参数拼接字符串</span><br>        <span class="hljs-keyword">private</span> String paramsStr;<br><br>        <span class="hljs-comment">// 日期标识（可选，默认为当前日期）</span><br>        <span class="hljs-keyword">private</span> String dateStr = DATE_FORMATTER.format(LocalDate.now());<br><br>        <span class="hljs-comment">// 序列号长度</span><br>        <span class="hljs-keyword">private</span> Integer length = <span class="hljs-number">5</span>;<br><br>        <span class="hljs-comment">// 重试次数</span><br>        <span class="hljs-keyword">private</span> Integer retryTimes = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 重试间隔</span><br>        <span class="hljs-keyword">private</span> Integer retryInterval = <span class="hljs-number">100</span>;<br><br>        <span class="hljs-comment">// 重试间隔单位</span><br>        <span class="hljs-keyword">private</span> TimeUnit retryUnit = TimeUnit.MILLISECONDS;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">prefix</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.prefix = prefix;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">params</span><span class="hljs-params">(List&lt;String&gt; params)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (CollUtil.isNotEmpty(params)) &#123;<br>                <span class="hljs-keyword">this</span>.paramsStr = String.join(<span class="hljs-string">&quot;&quot;</span>, params);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">dateStr</span><span class="hljs-params">(String dateStr)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.dateStr = dateStr;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">length</span><span class="hljs-params">(Integer length)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.length = length;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">retryTimes</span><span class="hljs-params">(Integer retryTimes)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.retryTimes = retryTimes;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">retryInterval</span><span class="hljs-params">(Integer retryInterval)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.retryInterval = retryInterval;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BizIdBuilder <span class="hljs-title">unit</span><span class="hljs-params">(TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.retryUnit = unit;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成单个 ID</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> buildBatch(<span class="hljs-number">1</span>).get(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 批量生成 ID</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">buildBatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>            String counter = REDIS_BIZ_ID_LOCK + prefix + paramsStr + dateStr;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 从缓存中获取或创建 RedisAtomicLong</span><br>                    RedisAtomicLong entityIdCounter = counterMap.computeIfAbsent(counter, k -&gt; &#123;<br>                        <span class="hljs-comment">// 注意，这里必须确保 stringRedisTemplate 的连接工厂不为 null</span><br>                        RedisAtomicLong ra = <span class="hljs-keyword">new</span> RedisAtomicLong(counter, Objects.requireNonNull(stringRedisTemplate.getConnectionFactory()));<br>                        <span class="hljs-comment">// 设置过期时间为 1 天，防止冗余过多无用数据</span><br>                        ra.expire(<span class="hljs-number">1</span>, java.util.concurrent.TimeUnit.DAYS);<br>                        <span class="hljs-keyword">return</span> ra;<br>                    &#125;);<br>                    <br>                    <span class="hljs-comment">// 批量递增</span><br>                    <span class="hljs-keyword">long</span> serialNum = entityIdCounter.addAndGet(count);<br>                    <br>                    <span class="hljs-comment">// 检查溢出</span><br>                    StringBuilder maxSerialNum = <span class="hljs-keyword">new</span> StringBuilder();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                        maxSerialNum.append(<span class="hljs-string">&quot;9&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (serialNum &gt; Long.parseLong(maxSerialNum.toString())) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;序列号已达最大值&quot;</span>);<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 最终业务ID</span><br>                    List&lt;String&gt; result = CollUtil.newArrayList();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                        result.add(prefix + paramsStr + dateStr + String.format(<span class="hljs-string">&quot;%0&quot;</span> + length + <span class="hljs-string">&quot;d&quot;</span>, serialNum - count + i + <span class="hljs-number">1</span>));<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;&#123;&#125;生成业务ID失败&quot;</span>, counter, e);<br>                &#125;<br>                <br>                <span class="hljs-comment">// 重试间隔</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(retryUnit.toMillis(retryInterval));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                    log.error(<span class="hljs-string">&quot;&#123;&#125;线程休眠失败&quot;</span>, counter, ex);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(counter + <span class="hljs-string">&quot;生成业务ID失败&quot;</span>);<br>                &#125;<br>                <br>            <span class="hljs-comment">// 异常重试</span><br>            &#125; <span class="hljs-keyword">while</span> (retryTimes-- &gt; <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(counter + <span class="hljs-string">&quot;生成业务ID失败，重试次数已用完&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用示例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderBizId</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BizIdUtil.builder(stringRedisTemplate)<br>            .prefix(<span class="hljs-string">&quot;SO&quot;</span>)<span class="hljs-comment">// 业务单号前缀</span><br>            .params(Arrays.asList(<span class="hljs-string">&quot;DGDA010&quot;</span>))  <span class="hljs-comment">// 参数</span><br>            .length(<span class="hljs-number">5</span>)<span class="hljs-comment">// 序列号长度</span><br>            .retryTimes(<span class="hljs-number">3</span>)<span class="hljs-comment">// 失败重试次数</span><br>            .retryInterval(<span class="hljs-number">100</span>) <span class="hljs-comment">// 失败重试间隔</span><br>            .unit(TimeUnit.MILLISECONDS)  <span class="hljs-comment">// 重试间隔等待时间单位</span><br>            .build();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每次运行都能得到唯一的自增单号，如</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">SODGDA010<span class="hljs-number">2024010100001</span><br>SODGDA010<span class="hljs-number">2024010100002</span><br>SODGDA010<span class="hljs-number">2024010100003</span><br></code></pre></div></td></tr></table></figure><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>如果<code>prefix + paramsStr + dateStr</code>可能组合非常多，则会导致Redis中保存大量Key和 <code>RedisAtomicLong</code> 实例。可以考虑：</p><ul><li>设置合理的过期策略（每天自动过期）</li><li>评估业务实际组合量，或者使用更灵活的生成策略</li></ul><h3 id="序列号溢出"><a href="#序列号溢出" class="headerlink" title="序列号溢出"></a>序列号溢出</h3><p>如果序列号长度是5位，意味着同一天最多只能生成99999个订单。如果实际业务量更大，需要适当增加序列号长度或在序列号快到上限时发出告警，并做相应扩容策略。</p><h3 id="高并发下的原子性"><a href="#高并发下的原子性" class="headerlink" title="高并发下的原子性"></a>高并发下的原子性</h3><p><code>RedisAtomicLong</code>的内部操作本质是Redis的<code>INCR</code>命令，保证了计数的原子性。如果需要更复杂的操作（比如提前判断是否溢出、再进行<code>INCR</code>），可以考虑<code>Lua</code>脚本进行一次性判断与递增操作，以避免两次Redis调用中间产生竞态条件。</p><h3 id="重试次数与间隔"><a href="#重试次数与间隔" class="headerlink" title="重试次数与间隔"></a>重试次数与间隔</h3><p>在网络抖动或Redis短暂不可用时，此处的重试逻辑可以提供一定的容错能力。也可以结合更专业的断路器（<code>Circuit Breaker</code>）与熔断策略来提高系统稳定性。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>如果业务需要在生成 ID 时确保其他关键操作的互斥，可以考虑配合分布式锁（如 Redisson）使用。但本示例只关注生成ID，不涉及到额外的锁。</p><h3 id="批量生成的效率"><a href="#批量生成的效率" class="headerlink" title="批量生成的效率"></a>批量生成的效率</h3><p>对于需要一次性生成大批量ID（如1万条）的场景，可考虑基于 “段式分配” 的思路，即从Redis一次获取一段计数区间（如1～10000），再在应用内自行分配，以减少与Redis的交互次数。此思路实现较为复杂，此处只作思路提示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上思路和示例，就能在分布式场景下生成带业务信息的订单号或流水号，既满足了业务侧对“可读性”的需求，也保证了分布式全局唯一与高并发下的有序性。在实际项目中，可按需进一步扩展，如添加分库分表策略、结合监控报警、或引入更多重试和降级机制，打造更完善的分布式业务ID生成方案。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>Redis实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战——缓存</title>
    <link href="/2024/12/25/redis-practice-cache/"/>
    <url>/2024/12/25/redis-practice-cache/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代软件系统中，缓存已成为提升性能、减少数据库压力和提高响应速度的重要手段。尤其是在高并发、分布式环境中，缓存往往是架构中的“加速器”。Redis由于其高性能、丰富的数据结构以及良好的生态支持，被广泛用作缓存层。本篇文章将围绕“Redis作为缓存”这一主题，详细探讨缓存的概念、适用场景、更新策略、常见问题以及与流行框架的结合。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>缓存是一个存储层，旨在存储部分数据的副本，以减少从数据库、文件系统或远程服务中获取数据的延迟。缓存一般存储的是常用且查询频繁的数据，数据过期或不常用时会被清除或更新。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>提高性能</strong>：通过减少对数据库或远程服务的访问，缓存可以显著降低响应时间，提高系统吞吐量。</li><li><strong>减轻压力</strong>：通过缓存热点数据，减轻数据库和其他后端服务的压力，尤其在高并发访问时。</li><li><strong>节省资源</strong>：在某些情况下，缓存可以减少计算开销，避免重复计算和冗余处理。</li></ul><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><ul><li><strong>内存占用</strong>：缓存数据需要占用内存，可能导致内存资源的浪费，尤其是缓存过多不常用或冗余的数据时。</li><li><strong>一致性问题</strong>：缓存中的数据和数据库中的数据可能不一致，需要有缓存更新机制。</li><li><strong>复杂性</strong>：缓存的管理、失效策略和同步机制增加了系统的复杂度。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>热点数据</strong>：例如用户信息、商品列表、常用配置等，这类数据访问频繁，使用缓存可以大大提升性能。</li><li><strong>频繁查询、少更新的数据</strong>：如广告投放数据、天气信息等，这些数据变化频繁但查询量大，缓存可以减少重复查询的成本。</li><li><strong>计算密集型操作的结果</strong>：如复杂的查询结果或统计数据，缓存这些结果可以避免重复计算。</li><li><strong>分布式系统中</strong>：缓存可以减少跨服务调用的频率，降低系统的耦合度，提高性能。</li></ul><h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul><li><strong>数据变动频繁的数据</strong>：如实时交易数据、用户操作日志等频繁变动的场景，缓存中的数据需要频繁更新，会增加复杂性和一致性问题。</li><li><strong>极小的数据集</strong>：如果数据集很小，使用缓存可能会浪费内存，反而不如直接访问原数据。</li><li><strong>高一致性要求的业务</strong>：例如金融交易、支付系统等，需要严格保证数据一致性，使用缓存可能会带来脏数据问题。</li><li><strong>不适用时延要求严格的操作</strong>：如果某些操作需要实时数据（例如实时监控系统），缓存可能引入不必要的延迟。</li></ul><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><h3 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h3><p>利用Redis的内存淘汰机制。设置Redis服务的使用内存，当内存不足时依据淘汰策略（<code>LRU</code>、<code>LFU</code>、随机淘汰）自动淘汰部分数据，下次查询时更新缓存。</p><ul><li>一致性较差</li><li>基本无维护成本</li></ul><h3 id="超时剔除"><a href="#超时剔除" class="headerlink" title="超时剔除"></a>超时剔除</h3><p>利用Redis的<code>TTL</code>机制，给缓存添加存活时间，到期后自动删除，或启用定时任务，定期扫描Redis中的数据进行删除，下次查询时更新缓存。</p><ul><li>一致性一般</li><li>维护成本较低</li></ul><h3 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h3><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p><strong>更新</strong>：</p><ol><li>服务端更新数据库数据</li><li>删除Redis缓存</li></ol><p><strong>读取</strong>：</p><ol><li>服务端根据客户端的查询条件从Redis中读取数据，如果读取到则返回数据至客户端，如果未读取到则继续。</li><li>根据查询条件从数据库中读取数据。</li><li>将读取到的数据缓存至Redis中，并设置合理的过期时间。</li><li>返回数据至客户端。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>一致性好</li><li>维护成本较高</li></ul><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    participant 数据库    %% 更新流程    服务端-&gt;&gt;数据库: 更新数据库数据    服务端-&gt;&gt;Redis: 删除缓存    %% 读取流程    客户端-&gt;&gt;服务端: 发送查询请求    服务端-&gt;&gt;Redis: 根据查询条件读取数据    alt 数据存在于Redis        Redis-&gt;&gt;服务端: 返回数据        服务端-&gt;&gt;客户端: 返回数据    else 数据未找到        服务端-&gt;&gt;数据库: 根据查询条件从数据库读取数据        数据库-&gt;&gt;服务端: 返回数据        服务端-&gt;&gt;Redis: 将数据缓存至Redis并设置过期时间        服务端-&gt;&gt;客户端: 返回数据    end</code></pre><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这里选择更常用的主动更新策略作为代码示例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Shop&gt; <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    String cacheKey = CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 查询redis</span><br>    String json = stringRedisTemplate.opsForValue().get(cacheKey);<br>    <span class="hljs-comment">// 存在，直接返回</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(JSONUtil.toBean(json, Shop.class));<br>    &#125;<br>    <span class="hljs-comment">// 不存在则查询数据库</span><br>    Shop shop = getById(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 数据库为空</span><br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 返回</span><br>    <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Void&gt; <span class="hljs-title">update</span><span class="hljs-params">(Shop shop)</span> </span>&#123;<br>    Long id = shop.getId();<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺id不能为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 更新数据库</span><br>    updateById(shop);<br>    <span class="hljs-comment">// 删除缓存</span><br>    stringRedisTemplate.delete(cacheKey);<br>    <span class="hljs-keyword">return</span> RestResult.success();<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>相较于每次更新数据库都更新缓存，会导致无效写比较多，因此直接删除缓存、等待读取时再更新缓存会更合适。</li><li>读取完操作后更新缓存可用异步的方式，但需保证异步更新成功且需要有更新失败时的兜底机制，只适用于一致性要求不高的场景。</li><li>应先更新数据库，后删除缓存。在高并发场景下，对于先删除缓存、后更新数据库，可能会造成删除缓存后、更新数据库前这个期间，其他线程查询出旧数据并写入缓存；而对于先操作数据库、后更新缓存，则可能会有查询数据库后、写入缓存前，其他线程先更新了数据库并删除了缓存，本线程后将旧数据写入了缓存。但综合了两种问题的发生情况，第二种问题发生的概率应该是明显小于第一种问题发生的概率，因为写入缓存这个动作是非常快的，所以选择了先更新数据库、后删除缓存。</li></ol><h2 id="常见问题及优化"><a href="#常见问题及优化" class="headerlink" title="常见问题及优化"></a>常见问题及优化</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指请求的数据在缓存和数据库中都不存在，每次请求都绕过了缓存直接访问数据库，导致缓存失效、数据库压力增大，甚至可能对数据库造成攻击性压力。</p><p>主要有以下解决方案：</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>服务端在第一次查询到数据为空以后，在Redis中存入一份空对象并设置存活时间TTL，下次再有相同的查询就从Redis中取出空对象返回。</p><p><strong>优点</strong>：实现简单，维护方便。</p><p><strong>缺点</strong>：额外的内存消耗。</p><p><strong>时序图</strong></p><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    participant 数据库    客户端-&gt;&gt;服务端: 发送请求    服务端-&gt;&gt;Redis: 缓存未命中    服务端-&gt;&gt;数据库: 查询数据为空    服务端-&gt;&gt;Redis: 缓存空数据并设置过期时间    服务端-&gt;&gt;客户端: 返回异常信息        客户端-&gt;&gt;服务端: 发送请求    服务端-&gt;&gt;Redis: 命中空数据    服务端-&gt;&gt;客户端: 返回异常信息</code></pre><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Shop&gt; <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    String cacheKey = CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 查询redis</span><br>    String json = stringRedisTemplate.opsForValue().get(cacheKey);<br>    <span class="hljs-comment">// 数据库查询不存在的数据写入的空值</span><br>    <span class="hljs-keyword">if</span> (json != <span class="hljs-keyword">null</span> &amp;&amp; StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;经销商不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 不为空值则返回</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(JSONUtil.toBean(json, Shop.class));<br>    &#125;<br>    <span class="hljs-comment">// 不存在则查询数据库</span><br>    Shop shop = getById(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 数据库为空则存入空值</span><br>        stringRedisTemplate.opsForValue().set(cacheKey, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 写入redis</span><br>    stringRedisTemplate.opsForValue().set(cacheKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 返回</span><br>    <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一个空间效率非常高的数据结构，可以用来快速判断一个元素是否存在。使用布隆过滤器可以在访问数据库前进行过滤，判断该数据是否存在于数据库中，如果不存在，则不进行数据库查询，直接返回空或错误信息，避免无效请求击穿缓存。</p><p><strong>原理</strong>：</p><ul><li><strong>位数组（bit array）</strong>：布隆过滤器内部包含一个大小为<code>m</code>的位数组，每个元素对应一个位置。</li><li><strong>哈希函数</strong>：使用多个哈希函数<code>k</code>，每个哈希函数将元素映射到位数组的某些位置（哈希值）。</li><li> <strong>添加元素</strong>：每次添加元素时，通过<code>k</code>个哈希函数计算出<code>k</code>个位置，将这些位置的位设为<code>1</code>。</li><li><strong>查询元素</strong>：查询元素时，通过<code>k</code>个哈希函数计算出<code>k</code>个位置，如果所有这些位置的值都为<code>1</code>，则返回 “存在”；如果有任意一个位置为<code>0</code>，则返回 “不存在”。</li></ul><p><strong>优点</strong>：内存占用少，没有多余的Key。</p><p><strong>缺点</strong>：实现复杂且存在误判可能。如果某个元素存在，布隆过滤器可能返回 “存在”，但有一定的误判概率（即假阳性）。如果布隆过滤器返回 “不存在”，则元素一定不在集合中。</p><p><strong>时序图</strong></p><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    participant 数据库    客户端-&gt;&gt;服务端: 发送请求    服务端-&gt;&gt;服务端: 布隆过滤器判断结果    alt 布隆过滤器中不存在此值    服务端-&gt;&gt;客户端: 返回错误信息    else 布隆过滤器中存在此值    服务端-&gt;&gt;Redis: 查询缓存    服务端-&gt;&gt;数据库: 查询数据    服务端-&gt;&gt;Redis: 缓存空数据并设置过期时间    服务端-&gt;&gt;客户端: 返回数据    end</code></pre><p><strong>代码示例</strong></p><ol><li><p>确保<code>RedisBloom</code>模块已安装，可以使用<code>Redis Stack</code>镜像，它已经集成了<code>RedisBloom</code>模块。</p><p>使用<code>Docker</code>启动带有<code>RedisBloom</code>的Redis实例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker run -d --name redis-bloom -p 6379:6379 redis/redis-stack-server:latest<br></code></pre></div></td></tr></table></figure></li><li><p>Redis依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>工具类封装</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedissonBloomUtil</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redisson;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BLOOM_FILTER_KEY = <span class="hljs-string">&quot;myBloomFilter&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建布隆过滤器并设置误差率和容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBloomFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        redisson.getBloomFilter(BLOOM_FILTER_KEY).tryInit(<span class="hljs-number">100000000</span>, <span class="hljs-number">0.01</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 销毁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        redisson.getBloomFilter(BLOOM_FILTER_KEY).delete();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到布隆过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addToBloomFilter</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisson.getBloomFilter(BLOOM_FILTER_KEY).add(value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断元素是否存在于布隆过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsInBloomFilter</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisson.getBloomFilter(BLOOM_FILTER_KEY).contains(value);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>业务代码修改，不再缓存空对象，而是在对象创建之后将id初始化至布隆过滤器，使用id查询时先判断布隆过滤器中是否含有此id</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Shop&gt; <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    String cacheKey = CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 布隆过滤器判断</span><br>    <span class="hljs-keyword">boolean</span> bloomExists = redissonBloomUtil.containsInBloomFilter(cacheKey);<br>    <span class="hljs-comment">// 数据库查询不存在的数据写入的空值</span><br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(bloomExists)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 查询redis</span><br>    String json = stringRedisTemplate.opsForValue().get(cacheKey);<br>    <span class="hljs-comment">// 不为空值则返回</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(JSONUtil.toBean(json, Shop.class));<br>    &#125;<br>    <span class="hljs-comment">// 不存在则查询数据库</span><br>    Shop shop = getById(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 写入redis</span><br>    stringRedisTemplate.opsForValue().set(cacheKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 返回</span><br>    <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Void&gt; <span class="hljs-title">save</span><span class="hljs-params">(Shop shop)</span> </span>&#123;<br>    <span class="hljs-comment">// 数据校验</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// 保存到数据库</span><br>    save(shop);<br>    <span class="hljs-comment">// 删除缓存</span><br>    stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());<br>    <span class="hljs-comment">// 初始布隆过滤器</span><br>    <span class="hljs-keyword">if</span> (redissonBloomUtil.addToBloomFilter(CACHE_SHOP_KEY + shop.getId())) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.success();<br>    &#125;<br>    <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;保存失败&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="请求校验"><a href="#请求校验" class="headerlink" title="请求校验"></a>请求校验</h4><p>加强对请求的限制和校验，防止恶意请求（如加强请求参数校验、引入验证码、限制请求频率）。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一时刻，大量缓存数据同时过期或失效，导致大量请求直接访问后端数据库或服务，从而引发后端系统过载、性能下降甚至崩溃的现象。这种情况通常发生在高并发的系统中，尤其是在缓存失效时间设置不合理或没有采取有效防护措施时。</p><p>主要有以下解决方案：</p><h4 id="缓存过期时间随机化"><a href="#缓存过期时间随机化" class="headerlink" title="缓存过期时间随机化"></a>缓存过期时间随机化</h4><p>为不同的缓存设置不同的过期时间，避免大量缓存同时过期，同时可针对热点KEY设置更长的过期时间。例如，将TTL设置为基础值加上一个随机值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> finalTtl = CACHE_SHOP_TTL + RandomUtil.randomInt(<span class="hljs-number">10</span>);<br>stringRedisTemplate.opsForValue().set(cacheKey, JSONUtil.toJsonStr(shop), finalTtl, TimeUnit.MINUTES);<br></code></pre></div></td></tr></table></figure><h4 id="限制单线程刷新缓存"><a href="#限制单线程刷新缓存" class="headerlink" title="限制单线程刷新缓存"></a>限制单线程刷新缓存</h4><p>使用互斥锁或信号量限制单个线程刷新缓存。当缓存失效时，只有一个线程去查询数据库并刷新缓存，其他线程等待缓存刷新完成后再从缓存中读取。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Shop&gt; <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    String cacheKey = CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 布隆过滤器判断</span><br>    <span class="hljs-keyword">boolean</span> bloomExists = redissonBloomUtil.containsInBloomFilter(cacheKey);<br>    <span class="hljs-comment">// 数据库查询不存在的数据写入的空值</span><br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(bloomExists)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 查询redis</span><br>    String json = stringRedisTemplate.opsForValue().get(cacheKey);<br>    <span class="hljs-comment">// 不为空值则返回</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(JSONUtil.toBean(json, Shop.class));<br>    &#125;<br>    <span class="hljs-comment">// 互斥锁应对缓存雪崩</span><br>    RLock lock = redissonClient.getLock(CACHE_SHOP_LOCK_KEY + id);<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(<span class="hljs-number">30</span>, <span class="hljs-number">120</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (locked) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不存在则查询数据库</span><br>            Shop shop = getById(id);<br>            <span class="hljs-keyword">if</span> (shop == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 写入redis</span><br>            stringRedisTemplate.opsForValue().set(cacheKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL + RandomUtil.randomInt(<span class="hljs-number">10</span>), TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回</span><br>            <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;查询失败&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>在系统启动时，提前将常用的数据加载到缓存中，避免系统启动后短时间内大量请求访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在系统启动时，提前将常用的数据加载到缓存中</span><br>    List&lt;Shop&gt; hotShops = getHotShopsFromDatabase();<br>    <span class="hljs-keyword">for</span> (Shop shop : hotShops) &#123;<br>        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + shop.getId(), JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从数据库查询热门店铺</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Shop&gt; <span class="hljs-title">getHotShopsFromDatabase</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> list();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用定时任务定期刷新缓存中的热点数据，确保这些数据始终在缓存中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 单体应用简单示例，分布式系统应考虑使用其他定时任务调度工具</span><br><span class="hljs-meta">@Scheduled(cron = &quot;0 0 * * * ?&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preheatCache</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Shop&gt; hotShops = getHotShopsFromDatabase();<br>    <span class="hljs-keyword">for</span> (Shop shop : hotShops) &#123;<br>        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + shop.getId(), JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="使用多级缓存"><a href="#使用多级缓存" class="headerlink" title="使用多级缓存"></a>使用多级缓存</h4><p>在应用层引入本地缓存（如<code>Caffeine</code>、<code>Guava</code>），作为一级缓存，结合Redis作为二级缓存，减少对Redis的依赖和压力。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;Shop&gt; <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 判断本地缓存中是否存在</span><br>    String cacheKey = CACHE_SHOP_KEY + id;<br>    Shop shop = localCache.getIfPresent(cacheKey);<br>    <span class="hljs-keyword">if</span> (shop != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>    &#125;<br>    <span class="hljs-comment">// 布隆过滤器判断</span><br>    <span class="hljs-keyword">boolean</span> bloomExists = redissonBloomUtil.containsInBloomFilter(cacheKey);<br>    <span class="hljs-comment">// 数据库查询不存在的数据写入的空值</span><br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(bloomExists)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 查询redis</span><br>    String json = stringRedisTemplate.opsForValue().get(cacheKey);<br>    <span class="hljs-comment">// 不为空值则返回</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-keyword">return</span> RestResult.successWithData(JSONUtil.toBean(json, Shop.class));<br>    &#125;<br>    <span class="hljs-comment">// 互斥锁应对缓存雪崩</span><br>    RLock lock = redissonClient.getLock(CACHE_SHOP_LOCK_KEY + id);<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(<span class="hljs-number">30</span>, <span class="hljs-number">120</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (locked) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不存在则查询数据库</span><br>            shop = getById(id);<br>            <span class="hljs-keyword">if</span> (shop == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 写入本地缓存</span><br>            localCache.put(cacheKey, shop);<br>            <span class="hljs-comment">// 写入redis</span><br>            stringRedisTemplate.opsForValue().set(cacheKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL + RandomUtil.randomInt(<span class="hljs-number">10</span>), TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回</span><br>            <span class="hljs-keyword">return</span> RestResult.successWithData(shop);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;查询失败&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="熔断、降级、限流"><a href="#熔断、降级、限流" class="headerlink" title="熔断、降级、限流"></a>熔断、降级、限流</h4><ul><li><strong>服务熔断</strong>：当检测到后端数据库压力过大时，暂时拒绝部分请求，保护数据库不被过载。</li><li><strong>服务降级</strong>：返回默认值或友好提示，避免系统崩溃。</li><li><strong>限流策略</strong>：限制单位时间内的请求数量，防止恶意或异常流量导致缓存雪崩。</li></ul><h4 id="使用集群和高可用架构"><a href="#使用集群和高可用架构" class="headerlink" title="使用集群和高可用架构"></a>使用集群和高可用架构</h4><ul><li><p><strong>Redis集群</strong>：部署Redis集群，提高缓存系统的可用性和扩展性，防止单点故障导致的缓存雪崩。</p></li><li><p><strong>主从复制和哨兵</strong>：配置Redis的主从复制和哨兵机制，确保Redis高可用，减少缓存失效的风险。</p></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫热点KEY问题，是指某个热点数据的缓存失效后，多个请求直接访问数据库，导致数据库压力骤增的现象。</p><p>与缓存雪崩不同，缓存击穿通常是由于缓存中的某个热点数据在某一时刻失效或者过期，而这个热点数据的查询频率非常高。</p><p>缓存击穿的应对策略可以复用缓存雪崩中的限制单线程访问数据库及刷新缓存、限流，降低因热点KEY访问数据库骤增而带来的压力。</p><h2 id="结合框架"><a href="#结合框架" class="headerlink" title="结合框架"></a>结合框架</h2><h3 id="MyBatis二级缓存"><a href="#MyBatis二级缓存" class="headerlink" title="MyBatis二级缓存"></a>MyBatis二级缓存</h3><p>MyBatis的二级缓存是指在同一<code>SqlSessionFactory</code>下共享的缓存，可以用于存储查询结果，以减少数据库访问次数。默认情况下，MyBatis支持使用内存作为二级缓存，但也可以配置Redis作为缓存提供者，Redis可以让MyBatis二级缓存成为分布式缓存。</p><p>简单配置步骤如下：</p><ol><li><p>开启二级缓存</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">mybatis.configuration.cache-enabled</span>=<span class="hljs-string">true</span><br></code></pre></div></td></tr></table></figure></li><li><p>实现MyBatis的Cache接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisRedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String COMMON_CACHE_KEY = <span class="hljs-string">&quot;mybatis:cache:&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namespace;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBatisRedisCache</span><span class="hljs-params">(String namespace)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(namespace)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Cache instances require an ID&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.namespace = namespace;<br>        <span class="hljs-keyword">this</span>.redisTemplate = SpringUtil.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 一个mapper对应一个mybatis的缓存操作对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getNamespace();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getKeys</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> COMMON_CACHE_KEY + <span class="hljs-keyword">this</span>.getNamespace() + <span class="hljs-string">&quot;:*&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> COMMON_CACHE_KEY + <span class="hljs-keyword">this</span>.getNamespace() + <span class="hljs-string">&quot;:&quot;</span> + key;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;<br>        <span class="hljs-comment">// 缓存设置为1小时过期</span><br>        redisTemplate.opsForValue().set(getKey(key), value, <span class="hljs-number">3600</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> redisTemplate.opsForValue().get(getKey(key));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;获取缓存失败&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object n = redisTemplate.opsForValue().get(getKey(key));<br>            redisTemplate.delete(getKey(key));<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;删除缓存失败&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        redisTemplate.delete(redisTemplate.keys(getKeys()));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.keys(getKeys()).size();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在Mapper文件中使用</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.config.MyBatisRedisCache&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p><code>Spring Cache</code>是Spring框架的一个抽象缓存层，支持通过不同的缓存实现（如：<code>Redis</code>、<code>Ehcache</code>、<code>Guava</code>等）来管理应用的缓存。</p><p>简单配置步骤如下：</p><ol><li><p>启动类中开启<code>Spring Cache</code>支持</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringcacheApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringcacheApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>使用Redis作为缓存提供者</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()<br>                <span class="hljs-comment">// 设置缓存过期时间为10分钟</span><br>                .entryTtl(Duration.ofMinutes(<span class="hljs-number">10</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> StringRedisSerializer()))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer()))<br>                <span class="hljs-comment">// 不缓存空值</span><br>                .disableCachingNullValues();<br><br>        <span class="hljs-keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)<br>                .cacheDefaults(config)<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>业务代码中使用，在需要缓存的方法上使用<code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>等注解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getProductById</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    <span class="hljs-comment">// 从数据库获取数据</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从缓存的概念入手，介绍了其在系统中的作用以及可能带来的成本，重点阐述了如何使用Redis来实现缓存策略，并且针对 常见的问题（缓存穿透、缓存雪崩、缓存击穿）给出了相应的 解决方案。</p><p>在实际项目中，缓存层的设计需要结合具体的业务场景、数据特点以及一致性要求进行权衡。对于大部分以读多写少、关注高并发的系统，Redis通常是优选的缓存载体。但同时也要注意缓存一致性和内存占用等问题，合理设置过期策略、更新策略，必要时使用分布式锁、布隆过滤器、多级缓存等手段，方能在保证性能的同时，维护系统的稳定性与可扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>Redis实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战——验证码和Token的存储与管理</title>
    <link href="/2024/12/19/redis-practice-codes-tokens/"/>
    <url>/2024/12/19/redis-practice-codes-tokens/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着互联网应用的快速发展，用户认证方式也在不断演进。传统的用户名密码登录方式虽然广泛使用，但存在密码泄露、暴力破解等安全隐患。基于验证码的登录方式，尤其是通过邮箱验证码进行登录，因其操作简便、安全性高而受到越来越多应用的青睐。</p><p>在微服务架构下，多个服务协同工作，用户认证与授权需要具备高可用性和可扩展性。Redis作为高性能的内存数据存储系统，凭借其快速的数据读写能力和丰富的数据结构，成为实现分布式认证系统的理想选择。</p><p>本文将详细介绍如何在微服务架构中使用Redis实现邮箱验证码登录系统，包括各个流程的具体步骤、代码实现以及相关的优化建议。</p><h2 id="发送邮箱验证码流程"><a href="#发送邮箱验证码流程" class="headerlink" title="发送邮箱验证码流程"></a>发送邮箱验证码流程</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>客户端填写邮箱并提交至服务端。</li><li>服务端校验邮箱是否合法，不合法则提示客户端重新输入，合法则继续以下步骤。</li><li>判断邮箱是否有未过期的登录验证码，有则提示客户端勿频繁请求，无则继续以下步骤。</li><li>服务端生成多位数的随机验证码。</li><li>将邮箱与验证码的对应关系存入Redis中，并设置一定的过期时间。</li><li>异步地将验证码发送至对应的邮箱中，并进行日志记录与监控。</li></ol><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    participant 邮件服务    participant 日志系统    客户端-&gt;&gt;服务端: 提交邮箱    服务端-&gt;&gt;服务端: 校验邮箱合法性    alt 邮箱不合法        服务端-&gt;&gt;客户端: 提示重新输入    else 邮箱合法        服务端-&gt;&gt;Redis: 检查是否有未过期的验证码        alt 存在未过期的验证码            服务端-&gt;&gt;客户端: 提示勿频繁请求        else 无未过期验证码            服务端-&gt;&gt;服务端: 生成验证码            服务端-&gt;&gt;Redis: 存储邮箱与验证码关系并设置过期时间            服务端-&gt;&gt;邮件服务: 异步发送验证码            服务端-&gt;&gt;日志系统: 记录日志与监控            服务端-&gt;&gt;客户端: 验证码发送成功提示        end    end</code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult <span class="hljs-title">sendEmailCode</span><span class="hljs-params">(String email)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验邮箱合法性</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isEmailInvalid(email)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;邮箱格式错误！&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 生成验证码</span><br>    String code = RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <br>    <span class="hljs-comment">// 使用Redis的SETNX确保验证码判断存在与存储是原子操作</span><br>    Boolean isSet = stringRedisTemplate.opsForValue().setIfAbsent(LOGIN_CODE_KEY + email, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isSet)) &#123;<br>        <span class="hljs-comment">// 已存在且未过期</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;请求频繁，请稍后再试！&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 发送邮件（异步）</span><br>    springMailUtil.sendSimpleEmail(email, <span class="hljs-string">&quot;验证码&quot;</span>, <span class="hljs-string">&quot;您的验证码是：&quot;</span> + code);<br>    <br>    <span class="hljs-keyword">return</span> RestResult.success();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="邮箱验证码登录流程"><a href="#邮箱验证码登录流程" class="headerlink" title="邮箱验证码登录流程"></a>邮箱验证码登录流程</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>客户端填写邮箱及收到的验证码并提交至服务端。</li><li>服务端校验邮箱是否合法，不合法提示客户端重新输入，合法则继续以下步骤。</li><li>同一邮箱验证多次不通过以后应当限制该邮箱的登录操作。</li><li>校验邮箱与验证码的对应关系是否存在于Redis中，不存在则提示客户端重新输入、增加失败次数，存在则继续以下步骤。</li><li>根据邮箱查找用户是否存在，不存在则先创建用户。</li><li>生成Token并将Token与用户对象的对应关系存入Redis中，注意设置合理的过期时间。</li><li>将校验通过地邮箱验证码对应关系进行删除，防止重复使用。</li><li>返回Token至客户端。</li></ol><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    participant 用户数据库    客户端-&gt;&gt;服务端: 提交邮箱和验证码    服务端-&gt;&gt;服务端: 校验邮箱合法性    alt 邮箱不合法        服务端-&gt;&gt;客户端: 提示重新输入    else 邮箱合法        服务端-&gt;&gt;Redis: 检查该邮箱的登录尝试次数        alt 验证次数过多            服务端-&gt;&gt;客户端: 限制登录操作        else 验证次数正常            服务端-&gt;&gt;Redis: 校验邮箱与验证码的对应关系            alt 校验失败                服务端-&gt;&gt;客户端: 提示重新输入            else 校验成功                服务端-&gt;&gt;用户数据库: 根据邮箱查找用户                alt 用户不存在                    服务端-&gt;&gt;用户数据库: 创建新用户                end                服务端-&gt;&gt;服务端: 生成Token                服务端-&gt;&gt;Redis: 存储Token与用户的对应关系并设置过期时间                服务端-&gt;&gt;Redis: 删除邮箱与验证码的对应关系                服务端-&gt;&gt;客户端: 返回Token                客户端-&gt;&gt;客户端: 本地存储Token值            end        end    end</code></pre><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;String&gt; <span class="hljs-title">emailLogin</span><span class="hljs-params">(String email, String code)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验邮箱合法性</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isEmailInvalid(email)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;邮箱格式错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 校验验证码合法性</span><br>    <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || code.length() != <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 失败次数过多拦截</span><br>    String loginFailValue = stringRedisTemplate.opsForValue().get(LOGIN_FAIL_COUNT + email);<br>    <span class="hljs-keyword">if</span> (loginFailValue != <span class="hljs-keyword">null</span> &amp;&amp; Integer.parseInt(loginFailValue) &gt;= <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;请稍后再试！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 校验验证码是否正确</span><br>    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + email);<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;验证码已过期&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!code.equals(cacheCode)) &#123;<br>        stringRedisTemplate.opsForValue().increment(LOGIN_FAIL_COUNT + email);<br>        stringRedisTemplate.expire(LOGIN_FAIL_COUNT + email, <span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 查找用户，不存在则新建</span><br>    User user = query().eq(<span class="hljs-string">&quot;email&quot;</span>, email).one();<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>        user = <span class="hljs-keyword">new</span> User();<br>        user.setEmail(email);<br>        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>        save(user);<br>    &#125;<br>    <span class="hljs-comment">// 生成Token并将Token与用户对象的对应关系存入Redis中</span><br>    String token = UUID.randomUUID().toString(<span class="hljs-keyword">true</span>);<br>    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);<br>    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, BeanUtil.beanToMap(userDTO));<br>    <span class="hljs-comment">// 删除验证码，防止重复使用</span><br>    stringRedisTemplate.delete(LOGIN_CODE_KEY + email);<br>    <span class="hljs-comment">// 返回Token</span><br>    <span class="hljs-keyword">return</span> RestResult.successWithData(token);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="用户登录后的请求流程"><a href="#用户登录后的请求流程" class="headerlink" title="用户登录后的请求流程"></a>用户登录后的请求流程</h2><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol><li>设置拦截器获取请求头中authorization字段的Token值（注意拦截器应对注册、登录、请求验证码等接口放行）。</li><li>若Token值为空则响应401，否则对请求放行。</li><li>根据Token值从Redis中取出对应的用户对象，若用户对象为空，则响应401，否则继续放行。</li><li>将Token值对应的用户对象存入ThreadLocal中，方便后续流程使用。</li><li>刷新此Redis中此Token值的过期时间。</li><li>放行请求。</li><li>注意请求处理结束以后需及时清理ThreadLocal中的用户数据，避免内存泄漏。</li></ol><h3 id="时序图-2"><a href="#时序图-2" class="headerlink" title="时序图"></a>时序图</h3><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    客户端-&gt;&gt;服务端: 发送请求（带Token）    服务端-&gt;&gt;服务端: 拦截器获取请求头中的Token值    alt Token为空        服务端-&gt;&gt;客户端: 返回401响应    else Token不为空        服务端-&gt;&gt;Redis: 根据Token从Redis获取用户对象        alt 用户对象为空            服务端-&gt;&gt;客户端: 返回401响应        else 用户对象存在            服务端-&gt;&gt;服务端: 往ThreadLocal存入用户对象            服务端-&gt;&gt;Redis: 刷新Token的过期时间            服务端-&gt;&gt;服务端: 放行请求            服务端-&gt;&gt;服务端: 处理请求            服务端-&gt;&gt;服务端: 请求结束，清理ThreadLocal中的用户数据        end    end</code></pre><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>用户信息存取工具类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserHolder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(UserDTO user)</span></span>&#123;<br>        tl.set(user);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeUser</span><span class="hljs-params">()</span></span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>登录拦截器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> HttpServletRequest request,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-meta">@Nullable</span> HttpServletResponse response,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-meta">@Nullable</span> Object handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 拦截</span><br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">assert</span> response != <span class="hljs-keyword">null</span>;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            response.getWriter().write(<span class="hljs-string">&quot;未登录或登录已过期，请重新登录&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Token有效期刷新拦截器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RefreshTokenInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取请求头中的token</span><br>        String token = request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基于TOKEN获取redis中的用户</span><br>        String key  = LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">// 用户存在则将用户信息存入ThreadLocal并刷新token有效期</span><br>        <span class="hljs-keyword">if</span> (CollUtil.isNotEmpty(userMap)) &#123;<br>            UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> UserDTO(), <span class="hljs-keyword">false</span>);<br>            UserHolder.saveUser(userDTO);<br>            stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果Token不存在或已过期，清除Token，并返回错误信息</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            response.getWriter().write(<span class="hljs-string">&quot;登录信息已过期，请重新登录&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> HttpServletRequest request, </span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-meta">@Nullable</span> HttpServletResponse response, </span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-meta">@Nullable</span> Object handler, Exception ex)</span> </span>&#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Spring Boot拦截器配置</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 分别添加登录拦截器和token刷新拦截器，登录拦截器优先级高</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> LoginInterceptor()).excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/user/logout&quot;</span>).order(<span class="hljs-number">1</span>);<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="用户登出流程"><a href="#用户登出流程" class="headerlink" title="用户登出流程"></a>用户登出流程</h2><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol><li>获取请求头Token值，校验Token合法性，若不合法则返回错误信息，合法则继续。</li><li>删除Redis中Token值对应的键值对数据。</li></ol><p>注意：</p><ol><li>Token的多设备支持，应根据业务要求决定是否允许单一Token多设备登录，或者为每个设备生成独立的Token。登出时，可以选择删除单个Token或所有相关Token。</li><li>确保客户端在登出后，清理本地存储的Token，防止意外的会话恢复。</li></ol><h3 id="时序图-3"><a href="#时序图-3" class="headerlink" title="时序图"></a>时序图</h3><pre><code class=" mermaid">sequenceDiagram    participant 客户端    participant 服务端    participant Redis    客户端-&gt;&gt;服务端: 发送登出请求（带Token）    服务端-&gt;&gt;服务端: 获取请求头中的Token值    alt Token不合法        服务端-&gt;&gt;客户端: 返回错误信息    else Token合法        服务端-&gt;&gt;Redis: 删除Token对应的键值对数据        服务端-&gt;&gt;服务端: 删除ThreadLocal中的用户信息        服务端-&gt;&gt;客户端: 返回登出成功消息        客户端-&gt;&gt;客户端: 删除本地存取的Token值    end</code></pre><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RestResult&lt;String&gt; <span class="hljs-title">logout</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取请求头中的Token值</span><br>    String token = request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 删除Redis中Token对应的用户数据</span><br>        stringRedisTemplate.delete(LOGIN_USER_KEY + token);<br>        <span class="hljs-comment">// 清理ThreadLocal中的用户信息</span><br>        UserHolder.removeUser();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果Token为空，返回401 Unauthorized</span><br>        <span class="hljs-keyword">return</span> RestResult.fail(<span class="hljs-string">&quot;Token已过期或无效，请重新登录&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> RestResult.success(<span class="hljs-string">&quot;登出成功&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h2><ol><li><strong>单点故障</strong>：Redis作为核心组件，若出现故障可能影响整个认证系统的可用性。需通过Redis集群、高可用配置等手段提升系统的可靠性。</li><li><strong>内存消耗</strong>：验证码和Token的存储依赖于Redis的内存，若用户量过大，可能导致Redis内存消耗迅速增加。需合理设置数据的过期时间，并进行内存监控和管理。</li><li><strong>复杂的异常处理</strong>：在高并发和分布式环境下，验证码和Token的管理涉及多种异常情况（如Redis连接异常、网络延迟等），需要细致的异常处理和恢复机制。</li><li><strong>Token管理的复杂性</strong>：若采用传统的Opaque Token，需要在每次请求时访问Redis进行Token验证，可能成为性能瓶颈。可考虑使用JWT等无状态Token机制，但需权衡安全性和管理复杂性。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了如何在微服务架构下使用Redis实现基于邮箱验证码的登录系统，包括发送验证码、登录验证、Token管理以及登出流程。通过具体的步骤、时序图和代码示例，展示了系统的实现过程，并提出了多项优化建议，提升系统的性能、安全性和可维护性。</p><p>Redis凭借其高性能和丰富的数据结构，成为分布式认证系统中不可或缺的组件。然而，系统设计需充分考虑Redis的高可用性、内存管理以及异常处理，确保系统在高并发和分布式环境下的稳定性和可靠性。</p><p>在实际应用中，还可结合其他技术和策略，如使用消息队列进行异步处理、引入分布式锁防止并发冲突、采用无状态的JWT Token机制以减少对Redis的依赖等，进一步优化系统性能和用户体验。</p><p>通过合理的设计和优化，基于Redis的邮箱验证码登录系统能够在微服务架构中高效、安全地完成用户认证与授权，满足现代互联网应用的需求。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>Redis实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——Redisson分布式锁</title>
    <link href="/2024/12/15/redis-distributed-lock-usage/"/>
    <url>/2024/12/15/redis-distributed-lock-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们基于Redis实现的分布式锁能处理最基本的互斥，但还有许多的功能没有实现，如可重入、可重试、自旋等，在企业开发环境下，通常会引入<code>Redisson</code>这个成熟的框架来完善这些功能。本文将详细介绍<code>Redisson</code>的分布式锁功能，包括不同类型的锁的特性、应用场景以及如何在Spring Boot项目中实现和配置这些锁。</p><h2 id="Redisson分布式锁支持"><a href="#Redisson分布式锁支持" class="headerlink" title="Redisson分布式锁支持"></a>Redisson分布式锁支持</h2><p><code>Redisson</code>是一个在Java环境下使用Redis实现分布式数据结构和同步机制的库，其中包括多种类型的分布式锁，这些分布式锁支持为企业提供了一种简单、可靠且高效的方式来同步分布式应用中的操作。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a><strong>高性能</strong></h3><p><code>Redisson</code>基于Redis，后者是一个高性能的内存数据存储。通过<code>Redisson</code>实现的分布式锁能够快速响应和处理锁请求，特别适用于高并发的环境。</p><h3 id="高可用性和可靠性"><a href="#高可用性和可靠性" class="headerlink" title="高可用性和可靠性"></a>高可用性和可靠性</h3><p><code>Redisson</code>可通过使用多个Redis节点和复制机制来保证锁服务的高可用性。即使部分Redis节点发生故障，也能保持锁服务的连续性。</p><h3 id="简易性"><a href="#简易性" class="headerlink" title="简易性"></a>简易性</h3><p><code>Redisson</code>提供了与Java标准锁接口相似的API，使得开发者可以很容易地在项目中使用它来实现分布式锁，无需担心底层的复杂实现。</p><h3 id="灵活性和扩展性"><a href="#灵活性和扩展性" class="headerlink" title="灵活性和扩展性"></a>灵活性和扩展性</h3><p><code>Redisson</code>支持多种配置选项，能够满足不同场景下的分布式锁需求，支持从简单的单Redis节点配置到复杂的集群模式。</p><h3 id="成熟的社区和文档"><a href="#成熟的社区和文档" class="headerlink" title="成熟的社区和文档"></a>成熟的社区和文档</h3><p><code>Redisson</code>有一个活跃的开发和支持社区。详尽的文档和社区支持使得企业能够解决在实现和运行分布式锁过程中遇到的问题。</p><h2 id="Spring-Boot集成Redisson锁"><a href="#Spring-Boot集成Redisson锁" class="headerlink" title="Spring Boot集成Redisson锁"></a>Spring Boot集成Redisson锁</h2><h3 id="集成方式选择"><a href="#集成方式选择" class="headerlink" title="集成方式选择"></a>集成方式选择</h3><p><code>Redisson</code>作为Redis的高级客户端，提供了丰富的分布式数据结构和工具，如分布式锁、分布式集合、分布式计数器等。尽管<code>Redisson</code>提供了<code>redisson-spring-boot-starter</code>，许多开发者和文章却更倾向于单独集成<code>Redisson</code>，而对于操作Redis数据库则优先考虑<code>spring-boot-starter-data-redis</code>。主要出于以下方面的考虑：</p><h4 id="职责分离与关注点分离"><a href="#职责分离与关注点分离" class="headerlink" title="职责分离与关注点分离"></a>职责分离与关注点分离</h4><p>通过职责分离，项目可以更清晰地管理不同类型的Redis操作，避免混淆和潜在的配置冲突。</p><ul><li><strong>RedisTemplate</strong>：Spring Boot自带的<code>RedisTemplate</code>专注于标准的Redis操作，如存储、读取、删除数据等。它经过广泛优化，适用于大多数常见的缓存和数据操作场景。</li><li><strong>Redisson</strong>：作为高级Redis客户端，<code>Redisson</code>提供了分布式锁、分布式集合、发布/订阅等高级功能。这些功能通常不在标准的<code>RedisTemplate</code>的使用范畴内。</li></ul><h4 id="避免依赖冲突与配置复杂性"><a href="#避免依赖冲突与配置复杂性" class="headerlink" title="避免依赖冲突与配置复杂性"></a>避免依赖冲突与配置复杂性</h4><p>提高系统的稳定性和可维护性，减少因配置冲突引发的问题。</p><ul><li><strong>多客户端共存</strong>：在同一个项目中同时使用<code>RedisTemplate</code>和<code>Redisson</code>时，自动配置可能会导致bean冲突或配置覆盖问题。单独集成<code>Redisson</code>可以避免这种情况。</li><li><strong>自定义配置</strong>：手动集成<code>Redisson</code>允许开发者对其进行更精细的配置，满足特定的业务需求，而不受Starter预设配置的限制。</li></ul><h4 id="性能与资源优化"><a href="#性能与资源优化" class="headerlink" title="性能与资源优化"></a>性能与资源优化</h4><p>提升整体系统的性能和响应速度，尤其在高并发和复杂业务场景下。</p><ul><li><strong>优化针对性</strong>：<code>RedisTemplate</code>是针对标准Redis操作高度优化的，而<code>Redisson</code>的高级功能可能需要不同的资源和优化策略。分离两者的使用可以更好地优化每个客户端的性能表现。</li></ul><h4 id="灵活性与可扩展性"><a href="#灵活性与可扩展性" class="headerlink" title="灵活性与可扩展性"></a>灵活性与可扩展性</h4><p>提高系统的灵活性，便于根据业务需求进行独立调整和优化。</p><ul><li><strong>独立管理</strong>：单独集成<code>Redisson</code>使其成为独立的组件，便于单独管理、扩展和升级，而不影响<code>RedisTemplate</code>的正常使用。</li></ul><h3 id="集成及配置"><a href="#集成及配置" class="headerlink" title="集成及配置"></a>集成及配置</h3><p>本文使用更常见的单独集成<code>Redisson</code>，而对于Redis存取等基本操作仍然采用<code>RedisTemplate</code>。</p><ol><li><p>添加<code>Redisson</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;redisson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>配置<code>RedissonClient</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedissonConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span>   <span class="hljs-comment">// 应用关闭时关闭 RedissonClient，释放资源</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient</span><span class="hljs-params">()</span> </span>&#123;<br>        Config config = <span class="hljs-keyword">new</span> Config();<br>        config.useSingleServer()<br>              .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>)<br>              .setPassword(<span class="hljs-string">&quot;yourRedisPassword&quot;</span>) <span class="hljs-comment">// 如果没有密码，可以省略</span><br>              .setDatabase(<span class="hljs-number">0</span>)<br>              .setConnectionPoolSize(<span class="hljs-number">64</span>)<br>              .setConnectionMinimumIdleSize(<span class="hljs-number">24</span>)<br>              .setTimeout(<span class="hljs-number">3000</span>)<br>              .setRetryAttempts(<span class="hljs-number">3</span>)<br>              .setRetryInterval(<span class="hljs-number">1500</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>常用配置详解</p><ol><li><p>连接配置</p><ul><li><p><strong>address</strong>：Redis服务器地址，格式为<code>redis://host:port</code>或<code>rediss://host:port</code>（启用SSL）。</p></li><li><p><strong>password</strong>：Redis认证密码。</p></li><li><p><strong>database</strong>：使用的Redis数据库编号（默认为0）。</p></li><li><p><strong>connectionPoolSize</strong>：连接池的最大连接数。</p></li><li><p><strong>connectionMinimumIdleSize</strong>：连接池的最小空闲连接数。</p></li><li><p><strong>idleConnectionTimeout</strong>：空闲连接超时时间（毫秒）。</p></li><li><p><strong>connectTimeout</strong>：连接超时时间（毫秒）。</p></li><li><p><strong>timeout</strong>：命令执行超时时间（毫秒）。</p></li><li><p><strong>retryAttempts</strong>：重试次数。</p></li><li><p><strong>retryInterval</strong>：重试间隔时间（毫秒）。</p></li><li><p><strong>subscriptionsPerConnection</strong>：每个连接的订阅数量。</p></li></ul></li><li><p>锁相关配置</p><ul><li><strong>lockWatchdogTimeout</strong>：锁看门狗超时时间（毫秒），默认30秒。用于自动续期，防止锁被意外释放。</li></ul></li><li><p>集群和哨兵配置</p><ul><li><p><strong>scanInterval</strong>：集群状态扫描间隔时间（毫秒）。</p></li><li><p><strong>masterName</strong>：哨兵模式下的主节点名称。</p></li></ul></li><li><p>高级配置</p><ul><li><p><strong>codec</strong>：自定义序列化编解码器，如 <code>org.redisson.codec.JsonJacksonCodec</code>。</p></li><li><p><strong>threads</strong>：<code>Redisson</code>客户端内部线程池的线程数量。</p></li><li><p><strong>nettyThreads</strong>：<code>Netty</code>客户端内部线程池的线程数量。</p></li></ul></li></ol></li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面将展示最基础的可重入锁的使用：创建订单时以用户id为锁粒度进行加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注入RedissonClient Bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    RLock lock = redissonClient.getLock(<span class="hljs-string">&quot;createOrder&quot;</span> + getUserId());<br>    <span class="hljs-comment">// 尝试获取锁，最多等待10秒，超时时间为20秒</span><br>    <span class="hljs-keyword">long</span> waitTime = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">long</span> leaseTime = <span class="hljs-number">20000</span>;<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，直接返回</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取锁成功，模拟创建订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;创建订单失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 创建订单结束后，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>锁的粒度设计</strong>：合理设计锁的粒度，过大的锁可能导致性能瓶颈，过小的锁可能增加复杂性。例如，针对具体资源加锁，而不是全局加锁。</li><li><strong>锁的持有时间</strong>：设置合适的锁持有时间，避免因业务处理时间过长导致锁被自动释放，从而引发数据不一致问题。可以结合业务逻辑动态调整锁持有时间。</li><li><strong>自动续期机制</strong>：未指定锁的释放时间情况下，<code>Redisson</code>提供了锁的自动续期功能，确保在业务处理时间较长时锁不会被意外释放。但需要注意，当业务逻辑异常终止时，<code>Redisson</code>仍会尝试续期，可能导致锁无法及时释放。可以通过合理的异常处理和锁释放机制来规避。</li><li><strong>异常处理</strong>：在使用<code>Redisson</code>进行加锁和解锁时，需妥善处理异常，确保在任何情况下锁都能被正确释放，防止死锁。例如，在<code>finally</code>块中释放锁。</li><li><strong>网络分区问题</strong>：在分布式环境中，网络分区可能导致锁状态不一致。建议结合Redis的高可用机制（如哨兵、集群）进行部署，确保Redis服务的稳定性和可用性。</li><li><strong>资源释放</strong>：确保在应用关闭时，正确关闭<code>RedissonClient</code>实例，释放资源。可以通过在配置类中指定<code>destroyMethod = &quot;shutdown&quot;</code>来自动关闭。</li><li><strong>性能监控</strong>：监控<code>Redisson</code>和Redis的性能，避免因锁竞争激烈导致系统性能下降。可以通过Redis的监控工具（如<code>Redis Monitor</code>、<code>Redis Sentinel</code>）和<code>Redisson</code>的统计功能进行监控。</li><li><strong>安全性</strong>：在生产环境中，确保Redis服务的安全，设置强密码，限制访问来源，使用<code>SSL/TLS</code>加密等，防止未经授权的访问和恶意操作。</li><li><strong>版本兼容性</strong>：确保<code>Redisson</code>与Spring Boot及Redis服务器版本的兼容性，避免因版本不匹配导致的问题。</li></ol><h2 id="Redisson分布式锁类型"><a href="#Redisson分布式锁类型" class="headerlink" title="Redisson分布式锁类型"></a>Redisson分布式锁类型</h2><h3 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>可重入锁（Reentrant Lock）是一种允许同一个线程多次获得同一把锁的同步机制。在获取可重入锁时，如果当前线程已经持有该锁，则可以再次获取而不会造成死锁。每次获取锁，内部计数器都会增加，释放锁时计数器减少，直到计数器为零，锁才会被真正释放。</p><p>在分布式环境中，可重入锁不仅需要在单个线程内重入，还需要在分布式系统的多个进程或节点之间保持一致性，确保同一时间只有一个客户端能够持有锁。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h4><ul><li><strong>可重入性</strong>：允许同一个客户端多次获取同一把锁，锁计数器会随之增加。</li><li><strong>自动续期</strong>：<code>Redisson</code>自动续期锁的持有时间，避免因业务处理时间过长而锁被释放。</li><li><strong>公平性</strong>：支持公平锁，确保锁的请求按照先后顺序被处理，防止“饥饿”现象。</li><li><strong>挂起锁等待</strong>：当锁被占用时，客户端可以选择等待锁释放或立即返回。</li><li><strong>锁的可见性</strong>：通过Redis的监控和日志功能，可以实时查看锁的状态和持有者。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ol><li><strong>分布式缓存更新</strong>：在分布式环境下，确保只有一个实例负责更新缓存，避免缓存击穿或雪崩。</li><li><strong>订单生成</strong>：确保同一订单号在生成过程中不被重复创建，避免数据不一致。</li><li><strong>资源分配</strong>：在分布式系统中，确保对有限资源的独占访问，如分布式文件系统的文件写操作。</li><li><strong>分布式任务调度</strong>：确保定时任务在分布式环境下只被一个节点执行，避免重复执行。</li><li><strong>分布式事务管理</strong>：在分布式事务中，确保事务的原子性和一致性，防止并发操作导致的数据不一致。</li></ol><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RLock getLock(String name)</td><td>获取指定名称的分布式可重入锁。</td></tr><tr><td>RLock getFairLock(String name)</td><td>获取公平的指定名称的分布式可重入锁。</td></tr></tbody></table><p><strong>RLock</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>加锁，阻塞直到获取到锁。<br />当需要确保某段代码在分布式环境下的互斥执行时使用。</td></tr><tr><td>void lock(long leaseTime, TimeUnit unit)</td><td>加锁，并设置锁的自动释放时间。<br />当需要限制锁的持有时间，防止锁被永久占用。</td></tr><tr><td>boolean tryLock()</td><td>尝试获取锁，立即返回结果（是否成功获取锁）<br />非阻塞地尝试获取锁，适用于快速失败的场景。</td></tr><tr><td>boolean tryLock(long waitTime, long leaseTime, TimeUnit unit)</td><td>在指定的等待时间内尝试获取锁，成功后设置锁的自动释放时间。<br />需要在一定时间内尝试获取锁，避免长时间阻塞。</td></tr><tr><td>void unlock()</td><td>释放锁。<br />在完成锁定的业务逻辑后，必须释放锁以允许其他线程获取。</td></tr><tr><td>boolean isLocked()</td><td>检查锁是否被任何线程持有。<br />监控锁的状态，进行相关逻辑处理。</td></tr><tr><td>boolean isHeldByCurrentThread()</td><td>检查当前线程是否持有锁。<br />确保锁的释放操作由持有锁的线程执行，防止非法释放。</td></tr><tr><td>void lockInterruptibly()</td><td>获取锁，允许线程在等待锁的过程中被中断。<br />需要响应线程中断信号的场景，防止线程长时间阻塞。</td></tr><tr><td>boolean forceUnlock()</td><td>强制释放锁，不管当前线程是否持有锁。<br />在特殊情况下需要强制释放锁，如系统异常恢复。</td></tr><tr><td>RFuture&lt;Boolean&gt; forceUnlockAsync()</td><td>异步方式强制释放锁。<br />需要非阻塞地强制释放锁。</td></tr><tr><td>RFuture&lt;Void&gt; unlockAsync()</td><td>异步释放锁。<br />在高性能场景下，避免阻塞当前线程。</td></tr><tr><td>RFuture&lt;Void&gt; lockAsync()</td><td>异步获取锁。<br />需要非阻塞地尝试获取锁。</td></tr><tr><td>RFuture&lt;Boolean&gt; tryLockAsync()</td><td>异步尝试获取锁。<br />需要非阻塞地尝试获取锁，并在获取后执行操作。</td></tr></tbody></table><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><p>以用户为锁粒度，对创建订单进行加锁处理：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-comment">// RLock lock = redissonClient.getLock(&quot;createOrder&quot; + getUserId());</span><br>    <span class="hljs-comment">// 获取公平锁</span><br>    RLock lock = redissonClient.getFairLock(<span class="hljs-string">&quot;createOrder&quot;</span> + getUserId());<br>    <span class="hljs-comment">// 尝试获取锁，最多等待10秒，超时时间为20秒</span><br>    <span class="hljs-keyword">long</span> waitTime = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">long</span> leaseTime = <span class="hljs-number">20000</span>;<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，直接返回</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取锁成功，模拟创建订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 创建订单结束后，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读写锁（Read-Write-Lock）"><a href="#读写锁（Read-Write-Lock）" class="headerlink" title="读写锁（Read/Write Lock）"></a>读写锁（Read/Write Lock）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>读写锁（Read/Write Lock）是一种同步机制，允许多个线程同时读共享资源，但在写入时必须独占访问权。具体而言：</p><ul><li><strong>读锁（Read Lock）</strong>：允许多个线程同时持有，适用于读取操作。当没有线程持有写锁时，多个线程可以并行地获取读锁。</li><li><strong>写锁（Write Lock）</strong>：独占锁，只有一个线程可以持有写锁，同时在写锁被持有期间，其他线程无法获取读锁或写锁。</li></ul><p>读写锁的目的在于保持数据的一致性和防止脏读，特别是分布式系统中，读写操作可能发生在不同的节点上，这种机制就尤为重要。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>读写分离</strong>：支持同时多个线程获取读锁，但写锁是排他的。</li><li><strong>可重入性</strong>：同一线程可以多次获取读锁或写锁，计数器会相应增加。</li><li><strong>分布式支持</strong>：锁的状态存储在Redis中，可在不同的应用实例间共享。</li><li><strong>自动续期</strong>：锁持有期间会自动续期，防止锁意外过期。</li><li><strong>公平锁支持</strong>：可配置为公平锁，按照请求的顺序获取锁。</li><li><strong>高可用性</strong>：通过Redis的高可用机制（如哨兵模式、集群模式）支持锁服务的高可用。</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><strong>分布式缓存更新</strong>：在缓存更新时，防止多个线程同时写入，使用写锁；读操作则可以并发进行，使用读锁。</li><li><strong>配置中心</strong>：当读取配置时，可以并发读取；当更新配置时，需要获取写锁，防止读操作读取到不一致的数据。</li><li><strong>实时数据分析与统计</strong>：获取统计数据时使用读锁，更新统计数据时使用写锁，确保统计数据在更新过程中，读取操作获取到的数据是一致且准确的，避免统计结果出现偏差。</li><li><strong>共享资源管理</strong>：获取资源时使用读锁，更新资源时使用写锁，确保资源状态在修改过程中保持一致，防止读取到不完整或错误的资源状态。</li></ol><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RReadWriteLock getReadWriteLock(String name)</td><td>获取指定名称的分布式读写锁。</td></tr></tbody></table><p><strong>RReadWriteLock</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RLock readLock()</td><td>返回用于分布式读写锁读取的锁。</td></tr><tr><td>RLock writeLock()</td><td>返回用于分布式读写锁写入的锁。</td></tr></tbody></table><p><strong>RLock</strong></p><p>详见可重入锁。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>为了确保订单数据的一致性，在更新订单时使用写锁，读取订单时使用读锁：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 使用写锁</span><br>    RLock lock = redissonClient.getReadWriteLock(<span class="hljs-string">&quot;order&quot;</span> + id).writeLock();<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(<span class="hljs-number">10000</span>, <span class="hljs-number">30000</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，直接返回</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取锁成功，模拟更新订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新订单失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 更新订单结束后，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 使用读锁</span><br>    RLock lock = redissonClient.getReadWriteLock(<span class="hljs-string">&quot;order&quot;</span> + id).readLock();<br>    <span class="hljs-keyword">boolean</span> locked = lock.tryLock(<span class="hljs-number">5000</span>, <span class="hljs-number">30000</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，直接返回</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取锁成功，模拟查询订单</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;订单信息&quot;</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 查询订单结束后，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>信号量（Semaphore）是一种用于控制多个线程对共享资源的访问的同步工具。它通过维护一个计数器来表示可用资源的数量。信号量有两种类型：</p><ol><li><strong>计数信号量（Counting Semaphore）</strong>：允许多个线程同时访问特定数量的资源。</li><li><strong>二元信号量（Binary Semaphore）</strong>：类似于互斥锁（<code>Mutex</code>），只允许一个线程访问资源。</li></ol><p>在分布式系统中，信号量需要跨多个进程或节点共享和管理，确保资源的有效利用和访问控制。</p><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>分布式支持</strong>：信号量的状态在Redis中共享，多个应用实例或节点可以共同管理和使用信号量。</li><li><strong>动态许可管理</strong>：允许动态调整信号量的许可数量，适应业务需求的变化。</li><li><strong>公平性配置</strong>：支持公平信号量，确保线程按请求顺序获取许可，避免“饥饿”现象。</li><li><strong>高可用性</strong>：通过Redis的高可用部署（如哨兵模式、集群模式），确保信号量服务的持续可用。</li><li><strong>线程安全</strong>：Redisson的信号量实现是线程安全的，适用于高并发场景。</li><li><strong>阻塞与非阻塞操作</strong>：支持阻塞获取许可（<code>acquire</code>）和非阻塞尝试获取许可（<code>tryAcquire</code>）。</li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><strong>API限流</strong>：限制单位时间内的API调用次数，保护后端服务不被过载。</li><li><strong>任务队列控制</strong>：控制任务队列中的并发任务数量，防止系统资源耗尽。</li><li><strong>资源池管理</strong>：控制同时资源池中的资源数量，优化系统资源利用。</li><li><strong>分布式锁辅助工具</strong>：与分布式锁结合使用，控制多个服务实例对关键资源的访问。</li></ol><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th align="left">API</th><th>说明</th></tr></thead><tbody><tr><td align="left">RSemaphore getSemaphore(String name)</td><td>获取指定名称的分布式信号量对象。</td></tr></tbody></table><p><strong>RSemaphore</strong></p><table><thead><tr><th align="left">API</th><th>说明</th></tr></thead><tbody><tr><td align="left">void trySetPermits(int permits)</td><td>尝试设置信号量的许可数量，仅在信号量未初始化时有效。</td></tr><tr><td align="left">void setPermits(int permits)</td><td>设置信号量的许可数量，覆盖当前许可数量。</td></tr><tr><td align="left">void acquire()</td><td>获取一个许可，阻塞直到许可可用。</td></tr><tr><td align="left">void acquire(int permits)</td><td>获取指定数量的许可，阻塞直到所有许可可用。</td></tr><tr><td align="left">boolean tryAcquire()</td><td>尝试获取一个许可，立即返回结果。</td></tr><tr><td align="left">boolean tryAcquire(int permits)</td><td>尝试获取指定数量的许可，立即返回结果。</td></tr><tr><td align="left">boolean tryAcquire(long timeout, TimeUnit unit)</td><td>在指定的等待时间内尝试获取一个许可。</td></tr><tr><td align="left">boolean tryAcquire(int permits, long timeout, TimeUnit unit)</td><td>在指定的等待时间内尝试获取指定数量的许可。</td></tr><tr><td align="left">void release()</td><td>释放一个许可，增加信号量的许可数量。</td></tr><tr><td align="left">void release(int permits)</td><td>释放指定数量的许可，增加信号量的许可数量。</td></tr><tr><td align="left">int availablePermits()</td><td>获取当前可用的许可数量。</td></tr><tr><td align="left">int drainPermits()</td><td>移除并返回当前可用的所有许可数量。</td></tr><tr><td align="left">void reducePermits(int reduction)</td><td>减少信号量的许可数量。</td></tr><tr><td align="left">void setFair(boolean fair)</td><td>设置信号量是否为公平信号量。公平信号量按照请求顺序分配许可，非公平信号量则不保证顺序。</td></tr><tr><td align="left">void addListener(SemaphoreListener listener)</td><td>添加许可变化监听器，监控许可的获取和释放。</td></tr></tbody></table><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><p>对订单导出进行限流（注意需要先初始化信号量）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ORDER_EXPORT_SEMAPHORE_KEY = <span class="hljs-string">&quot;orderExport&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化信号量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeSemaphore</span><span class="hljs-params">()</span> </span>&#123;<br>    RSemaphore semaphore = redissonClient.getSemaphore(ORDER_EXPORT_SEMAPHORE_KEY);<br>    semaphore.trySetPermits(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">export</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 信号量控制导出并发量</span><br>    RSemaphore semaphore = redissonClient.getSemaphore(ORDER_EXPORT_SEMAPHORE_KEY);<br>    <span class="hljs-keyword">boolean</span> acquire = semaphore.tryAcquire(<span class="hljs-number">10000</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 并发量数量超限</span><br>    <span class="hljs-keyword">if</span> (!acquire) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;并发量数量超限&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模拟导出操作</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;导出失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放信号量</span><br>        semaphore.release();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>初始化信号量</strong>：建议在组件初始化完成后，自动完成信号量的初始化。使用<code>trySetPermits</code>方法仅在信号量未初始化时设置许可数量，避免重复设置导致许可数量不准确。</li><li><strong>许可数量</strong>：根据业务需求合理设置许可数量。</li><li><strong>确保释放许可</strong>：无论业务逻辑是否成功执行，逻辑执行完成以后必须释放许可，防止许可被永久占用。</li><li><strong>公平性配置</strong>：根据业务需求选择是否启用公平信号量。公平信号量按照请求顺序分配许可，避免“饥饿”现象，但可能带来性能开销。</li></ol><h3 id="多锁（MultiLock）"><a href="#多锁（MultiLock）" class="headerlink" title="多锁（MultiLock）"></a>多锁（MultiLock）</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>多锁（MultiLock）是指在执行一个操作时，需要同时获取多个独立的锁，以确保这些操作的原子性和一致性。多锁通常用于需要同时访问或修改多个共享资源的场景，通过获取所有相关锁，可以防止部分操作成功而其他操作失败，避免数据不一致和资源冲突。</p><h4 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>原子性获取</strong>：<code>MultiLock</code>能够原子性地获取多个锁，确保在所有锁都成功获取之前，无法执行相关操作。</li><li><strong>容错性</strong>：在获取过程中，如果某一个锁无法获取，<code>MultiLock</code>会释放已获取的锁，避免死锁和资源占用。</li><li><strong>可重入性</strong>：支持可重入锁特性，允许同一线程多次获取同一锁。</li><li><strong>灵活性</strong>：可以组合任意数量和类型的锁（如单个锁、读写锁、公平锁等），满足不同业务需求。</li><li><strong>高可用性</strong>：基于Redis的高可用机制（如哨兵模式、集群模式），确保多锁服务的稳定性和可靠性。</li><li><strong>自动续期</strong>：支持锁的自动续期，防止在长时间业务处理中锁被错误释放。</li></ul><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><strong>复杂业务流程同步</strong>：在执行需要多个步骤的业务流程时，锁定相关资源，确保流程的完整性和数据的一致性。</li><li><strong>配置更新系统</strong>：在更新分布式配置时，同时锁定多个配置节点，确保配置的同步和一致性。</li></ol><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RLock getMultiLock(RLock… locks)</td><td>通过多个RLock对象获取一个多锁对象。</td></tr></tbody></table><p><strong>RLock</strong></p><p>详见可重入锁。</p><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>更新订单涉及订单以及用户，因此使用多锁重构更新订单方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 订单锁及用户锁</span><br>    RLock orderLock = redissonClient.getLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    RLock userLock = redissonClient.getLock(<span class="hljs-string">&quot;user&quot;</span> + getUserId());<br>    <span class="hljs-comment">// 尝试获取多个锁</span><br>    RLock multiLock = redissonClient.getMultiLock(orderLock, userLock);<br>    <span class="hljs-keyword">boolean</span> locked = multiLock.tryLock();<br>    <span class="hljs-comment">// 如果获取锁失败，抛出异常</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模拟更新订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新订单失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放多个锁</span><br>        multiLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>在分布式系统中，选择不同的锁策略取决于业务需求和资源管理的复杂性。以下是两种常见的多锁应用策略及其区别：</p><ol><li><strong>同时锁定所有资源（使用<code>MultiLock</code>）</strong><ul><li><strong>适用场景</strong>：<ul><li><strong>跨资源操作</strong>：需要同时访问或修改多个资源，确保操作的原子性。</li><li><strong>资源依赖操作</strong>：操作之间存在资源依赖关系，必须同时获取相关资源的锁。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>原子性保障</strong>：确保所有资源在操作过程中保持一致性。</li><li><strong>避免部分成功</strong>：防止部分操作成功而其他操作失败，保持数据的一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>锁竞争增加</strong>：需要同时获取多个锁，可能增加锁竞争的概率，影响系统性能。</li></ul></li></ul></li><li><strong>分别锁定各个资源（单独使用多个<code>RLock</code>）</strong><ul><li><strong>适用场景</strong>：<ul><li><strong>独立资源操作</strong>：多个资源之间操作相互独立，可以分别锁定。</li><li><strong>高并发读写</strong>：在需要高并发访问的场景下，分别锁定资源以提高并发性能。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>更高的并发性</strong>：可以独立管理各个资源的锁，减少锁的粒度，提高系统的并发性能。</li><li><strong>灵活性</strong>：可以针对不同资源采用不同的锁策略（不单单是<code>RLock</code>），满足多样化的业务需求。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>复杂性增加</strong>：需要管理多个锁的获取与释放，增加了代码的复杂性。</li><li><strong>一致性保障困难</strong>：在需要跨资源一致性的场景下，难以保证所有操作的原子性。</li></ul></li></ul></li></ol><h3 id="红锁（RedLock）"><a href="#红锁（RedLock）" class="headerlink" title="红锁（RedLock）"></a>红锁（RedLock）</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>红锁是由Redis提出的一个分布式锁算法。它要求使用多个独立的Redis节点来完成分布式锁的获取和释放，具备比传统单节点锁更高的可靠性和容错性。RedLock的核心思想是通过多个Redis实例来共同保证锁的有效性。</p><p>具体来说，RedLock锁定机制的步骤如下：</p><ol><li>客户端尝试在多个独立的Redis实例上获取锁。</li><li>如果至少有多数（通常是 N/2 + 1）Redis实例成功获得锁，那么就认为获得锁成功。</li><li>如果客户端能够成功获取到锁，则开始执行保护的资源操作。</li><li>若无法获得锁，则可以选择等待或立即返回。</li></ol><h4 id="特性-4"><a href="#特性-4" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>高可用性</strong>：由于使用多个Redis实例，红锁能够避免单点故障。如果某个Redis实例不可用，其他实例仍可保证锁的正常工作。</li><li><strong>可靠性</strong>：相较于基于单一Redis实例的分布式锁，红锁可以在网络延迟、节点宕机等异常情况下提供更强的保证。</li><li><strong>容错性</strong>：即使某些Redis节点发生故障，红锁依然能够有效地工作。</li></ul><h4 id="常用API-4"><a href="#常用API-4" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RLock getRedLock(RLock… locks)</td><td>通过多个RLock对象获取一个红锁对象。</td></tr></tbody></table><p><strong>RLock</strong></p><p>详见可重入锁。</p><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><p>配置多个<code>RedissonClient</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建RedissonClient连接到第一个Redis节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean(name = &quot;redissonClient1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient1</span><span class="hljs-params">()</span> </span>&#123;<br>    Config config = <span class="hljs-keyword">new</span> Config();<br>    config.useSingleServer()<br>          .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>)<br>          .setPassword(<span class="hljs-string">&quot;password1&quot;</span>) <span class="hljs-comment">// 如果没有密码，可以省略</span><br>          .setTimeout(<span class="hljs-number">3000</span>)<br>          .setRetryAttempts(<span class="hljs-number">3</span>)<br>          .setRetryInterval(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">return</span> Redisson.create(config);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建RedissonClient连接到第二个Redis节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean(name = &quot;redissonClient2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient2</span><span class="hljs-params">()</span> </span>&#123;<br>    Config config = <span class="hljs-keyword">new</span> Config();<br>    config.useSingleServer()<br>          .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6380&quot;</span>)<br>          .setPassword(<span class="hljs-string">&quot;password2&quot;</span>) <span class="hljs-comment">// 如果没有密码，可以省略</span><br>          .setTimeout(<span class="hljs-number">3000</span>)<br>          .setRetryAttempts(<span class="hljs-number">3</span>)<br>          .setRetryInterval(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">return</span> Redisson.create(config);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建RedissonClient连接到第三个Redis节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean(name = &quot;redissonClient3&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient3</span><span class="hljs-params">()</span> </span>&#123;<br>    Config config = <span class="hljs-keyword">new</span> Config();<br>    config.useSingleServer()<br>          .setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6381&quot;</span>)<br>          .setPassword(<span class="hljs-string">&quot;password3&quot;</span>) <span class="hljs-comment">// 如果没有密码，可以省略</span><br>          .setTimeout(<span class="hljs-number">3000</span>)<br>          .setRetryAttempts(<span class="hljs-number">3</span>)<br>          .setRetryInterval(<span class="hljs-number">1500</span>);<br>    <span class="hljs-keyword">return</span> Redisson.create(config);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>业务代码中使用多个<code>RedissonClient</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;redissonClient1&quot;)</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient1;<br><br><span class="hljs-meta">@Resource(name = &quot;redissonClient2&quot;)</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient2;<br><br><span class="hljs-meta">@Resource(name = &quot;redissonClient3&quot;)</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient3;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 配置多个RedissonClient连接不同Redis节点</span><br>    RLock orderLock1 = redissonClient1.getLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    RLock orderLock2 = redissonClient2.getLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    RLock orderLock3 = redissonClient3.getLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    <span class="hljs-comment">// 尝试获取多个锁</span><br>    RLock rLock = redissonClient.getRedLock(orderLock1, orderLock2, orderLock3);<br>    <span class="hljs-keyword">boolean</span> locked = rLock.tryLock();<br>    <span class="hljs-comment">// 如果获取锁失败，抛出异常</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模拟更新订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新订单失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        rLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="对比多锁"><a href="#对比多锁" class="headerlink" title="对比多锁"></a>对比多锁</h4><p>看起来红锁和多锁类似，也能够支持多个锁的同时加锁，但它们的实现原理、适用场景和容错能力有很大的区别。</p><table><thead><tr><th>特性</th><th>多锁</th><th>红锁</th></tr></thead><tbody><tr><td><strong>锁粒度</strong></td><td>是针对多个RLock 对象进行的组合锁，多个锁在同一 Redis 实例中。</td><td>是针对多个Redis 实例进行的分布式锁。</td></tr><tr><td><strong>容错性</strong></td><td>无容错性，仅对单一Redis实例提供锁保护，多个锁操作的失败会导致整体回滚。</td><td>容错性高，通过多个Redis实例来保证锁的高可用性。</td></tr><tr><td><strong>应用场景</strong></td><td>适用于单个Redis实例中对多个资源加锁的场景，主要用于资源的组合加锁。</td><td>适用于需要分布式高可用锁，且需要跨多个Redis实例管理锁的场景。</td></tr><tr><td><strong>实现复杂度</strong></td><td>简单，通过<code>RLock</code>对象组合进行加锁，适用于同一 Redis 实例。</td><td>相对较复杂，需要多个Redis实例，并且涉及时钟同步和网络延迟。</td></tr><tr><td><strong>性能</strong></td><td>性能较好，只需要在单个Redis实例中加锁。</td><td>相对较差，需要访问多个Redis实例，开销较大。</td></tr><tr><td><strong>使用场景的可靠性要求</strong></td><td>对可靠性要求较低的场景，适合较为简单的组合锁需求。</td><td>高可靠性、高可用性要求的分布式场景。</td></tr></tbody></table><h3 id="FencedLock"><a href="#FencedLock" class="headerlink" title="FencedLock"></a>FencedLock</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p><code>FencedLock</code>是<code>Redisson</code>提供的分布式锁，旨在防止由于客户端崩溃或网络分区而导致的锁的错误释放。它与普通的<code>RLock</code>类似，但加入了锁版本控制，使得即使客户端崩溃或断开连接，其他客户端也不会误释放该锁。</p><p>其核心概念是锁版本（Fence），每次获取锁时，都会生成一个唯一的版本号，并且只有持有最新版本的锁的客户端才能成功释放锁。如果客户端持有的锁版本过期或已被其他客户端更新，则无法释放锁，从而避免了死锁或资源竞争。</p><h4 id="特性-5"><a href="#特性-5" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>锁版本控制</strong>：<code>FencedLock</code>为每个锁引入了版本号，每次客户端获得锁时，都会得到一个唯一的版本号。客户端在释放锁时，需要确保自己持有的是最新版本的锁。</li><li><strong>客户端崩溃保护</strong>：当客户端崩溃或者因为某些原因失去连接时，<code>FencedLock</code>通过fence（栅栏机制）防止其他客户端释放锁，避免了可能的锁误释放问题。</li><li><strong>避免误释放锁</strong>：通过检查锁的版本，<code>FencedLock</code>确保只有当前持有锁的客户端能够释放锁。如果锁的版本号不同，释放锁会失败，从而避免了锁的误释放。</li><li><strong>适用于高并发和长时间持锁的场景</strong>：<code>FencedLock</code>特别适用于需要长时间持锁并且对锁的可靠性有高要求的场景。例如在高并发的环境下，确保锁在分布式系统中的安全性和一致性。</li></ul><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><strong>高并发任务</strong>：在需要对共享资源进行并发访问控制的场景中，如分布式队列的消费，或者多个线程需要协调对某个数据库表的访问时，<code>FencedLock</code>可以确保锁的可靠性，避免由于节点宕机或者崩溃导致的锁的误释放。</li><li><strong>长时间任务</strong>：如果锁持有的时间比较长，例如批量处理任务、定时任务等，<code>FencedLock</code>可以确保在任务执行过程中，不会出现因为客户端崩溃或其他原因导致锁释放的问题。</li><li><strong>分布式系统中的资源访问</strong>：在多节点的分布式环境中，如果不同的节点要访问某些共享资源，使用<code>FencedLock</code>可以有效避免锁丢失的情况，从而保证系统的稳定性和一致性。</li><li><strong>防止死锁</strong>：<code>FencedLock</code>可以避免在客户端崩溃时，由于其他客户端误释放锁而导致的死锁现象。</li></ol><h4 id="常用API-5"><a href="#常用API-5" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RFencedLock getFencedLock(String name)</td><td>获取指定名称的FencedLock对象。</td></tr></tbody></table><p><strong>RFencedLock</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>Long getToken()</td><td>返回当前FencedLock令牌。</td></tr><tr><td>Long lockAndGetToken()</td><td>阻塞地获取锁并返回当前FencedLock令牌。</td></tr><tr><td>Long lockAndGetToken(long leaseTime, TimeUnit unit)</td><td>阻塞地获取锁，并设置锁地超时时间并返回当前FencedLock令牌。</td></tr><tr><td>Long tryLockAndGetToken()</td><td>尝试获取FencedLock，立刻返回结果。</td></tr><tr><td>Long tryLockAndGetToken(long waitTime, TimeUnit unit)</td><td>尝试获取FencedLock，并设置锁地自动释放时间，立刻返回结果。</td></tr><tr><td>Long tryLockAndGetToken(long waitTime, long leaseTime, TimeUnit unit)</td><td>尝试获取FencedLock，并设置锁地自动释放时间，等待指定时间后返回结果。</td></tr></tbody></table><p><strong>RLock</strong></p><p>详见可重入锁。</p><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    RFencedLock orderLock = redissonClient.getFencedLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    Long token = orderLock.tryLockAndGetToken(<span class="hljs-number">10000</span>, <span class="hljs-number">30000</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，抛出异常</span><br>    <span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模拟更新订单</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新订单失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        orderLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="对比RLock"><a href="#对比RLock" class="headerlink" title="对比RLock"></a>对比RLock</h4><p><strong>RLock</strong>：<code>Redisson</code>提供的一个常见的可重入分布式锁。它通过Redis来管理锁状态，当客户端持有锁时，其他客户端无法获取该锁。通常，它是基于Redis的键值对实现的，因此会有一些失效时间（TTL）来防止死锁。</p><p><strong>RFencedLock</strong>：<code>Redisson</code>提供的一种更安全、更可靠的锁实现，引入了锁版本（Fence）和栅栏机制。它的主要目的是避免因为客户端崩溃或异常退出，导致锁无法正常释放的问题。即使Redis节点失败或客户端崩溃，其他客户端也能基于锁版本进行可靠的获取和释放。</p><p><strong>Redis集群或分布式架构</strong>：在Redis是分布式架构（如Redis集群或主从复制）时，推荐使用<code>RFencedLock</code>，因为它具备更高的可靠性和容错性，能够处理Redis节点故障和网络分区等问题，确保分布式锁的安全性和一致性。</p><p><strong>Redis单节点架构</strong>：对于Redis单节点环境，使用<code>RLock</code>完全足够，它足够简单高效，可以很好地满足大多数分布式锁需求。并且，<code>RLock</code>在单节点环境下没有额外的性能开销，锁的获取和释放速度较快。</p><h3 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>自旋锁是一种轻量级锁，它的基本原理是在尝试获取锁时，如果锁已经被占用，当前线程不会被阻塞，而是会持续地检查锁的状态，直到获取到锁为止。这种方式的优点是避免了上下文切换的开销，适用于锁持有时间非常短且锁竞争不激烈的场景。</p><h4 id="特性-6"><a href="#特性-6" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>轻量级</strong>：实现相对轻量，没有阻塞机制，适合锁持有时间短，竞争不激烈的场景。</li><li><strong>避免线程阻塞</strong>：与传统的阻塞锁不同，自旋锁会不断地尝试获取锁，直到锁被释放，这避免了线程的上下文切换。</li><li><strong>适用于低竞争场景</strong>：当锁竞争较少时，自旋锁能够提供更好的性能，避免了进入等待队列的延迟。</li><li><strong>分布式锁实现</strong>：基于Redis实现，可以跨进程、跨机器共享同一个锁，确保分布式环境下的同步。</li><li><strong>减少上下文切换</strong>：自旋锁避免了线程的阻塞，减少了上下文切换的性能开销。</li></ul><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>高并发、低锁竞争的场景</strong>：在锁的竞争较少且操作迅速的环境中，自旋锁可以避免线程阻塞，提高性能。比如某些高吞吐量的消息队列或数据缓存的操作。</li><li><strong>锁占用时间极短的场景</strong>：当锁的持有时间非常短（如几毫秒），传统的阻塞锁会造成较大性能损失，而自旋锁可以避免这种损失。比如频繁的缓存更新、短小的临界区操作等。</li><li><strong>低延迟要求的应用</strong>：在对低延迟要求较高的系统中，自旋锁能够减少等待时间，尤其是当锁的竞争较少时。比如在线支付系统、实时数据处理等场景。</li><li><strong>小规模并发环境</strong>：在并发线程较少的环境中，自旋锁的性能表现较好。自旋不会带来过多的 CPU 资源浪费。比如在小规模的微服务架构中，较少的线程竞争可以使用自旋锁。</li></ul><h4 id="常用API-6"><a href="#常用API-6" class="headerlink" title="常用API"></a>常用API</h4><p><strong>Redisson</strong></p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>RLock getSpinLock(String name)</td><td>获取指定名称的自旋锁对象。</td></tr></tbody></table><p><strong>RLock</strong></p><p>详见可重入锁。</p><h4 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 自旋锁</span><br>    RLock cacheLock = redissonClient.getSpinLock(<span class="hljs-string">&quot;order&quot;</span> + id);<br>    <span class="hljs-keyword">boolean</span> locked = cacheLock.tryLock(<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 如果获取锁失败，抛出异常</span><br>    <span class="hljs-keyword">if</span> (!locked) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模拟更新缓存</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新缓存失败&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        cacheLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用自旋锁的前提是锁持有时间极短且竞争不激烈。若锁竞争激烈或持有时间较长，自旋锁会消耗大量CPU资源，得不偿失。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的学习，开发者应能够充分理解<code>Redisson</code>提供的分布式锁的强大功能和灵活应用。文章不仅提供了关于各类型锁的详细信息，还展示了如何在实际项目中应用这些锁来解决复杂的同步问题，从基本的锁配置到高级功能如锁的自动续期和公平性处理。此外，通过提供的代码示例和配置方法，开发者可以快速在自己的项目中集成<code>Redisson</code>分布式锁，提升应用的性能和可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>Redisson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——分布式锁</title>
    <link href="/2024/12/13/redis-distributed-lock/"/>
    <url>/2024/12/13/redis-distributed-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在分布式系统中，管理并发访问共享资源是一个挑战，需要确保系统的一致性和可靠性。分布式锁提供了一种机制，通过锁定资源来控制跨多个节点的并发访问。Redis，作为高性能的NoSQL数据库，由于其内存操作的特性和灵活的数据结构，被广泛用于实现分布式锁。本文详细介绍了分布式锁的概念、设计原则、实现方式，以及如何利用Redis和Lua脚本来实现高效且安全的分布式锁。</p><h2 id="分布式锁简介"><a href="#分布式锁简介" class="headerlink" title="分布式锁简介"></a>分布式锁简介</h2><p>分布式锁是一种在分布式系统中用于避免多个进程或服务同时访问共享资源的同步机制。它是一种在单体应用中常见的互斥锁（Mutex）的扩展，特别是在需要确保跨多个节点的数据一致性和顺序时。</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/distributed-lock.png" alt="分布式锁"></p><h3 id="对比JVM锁"><a href="#对比JVM锁" class="headerlink" title="对比JVM锁"></a>对比JVM锁</h3><table><thead><tr><th></th><th>JVM锁</th><th>分布式锁</th></tr></thead><tbody><tr><td>**应用范围 **</td><td>单个JVM进程内部，如单个应用的多线程环境中</td><td>多个独立进程或服务，如微服务架构、集群应用和任何多个节点协作的场景</td></tr><tr><td><strong>性能</strong></td><td>单个进程内线程调度和内存访问，性能高、延迟低</td><td>受网络状况和锁实现机制的影响较大，网络延迟和外部服务处理速度为性能瓶颈</td></tr><tr><td><strong>容错</strong></td><td>处理单个JVM内的线程，JVM崩溃后锁自然消失，容错性通常没有问题</td><td>需要设计考虑节点故障、网络分区和其他分布式系统问题，确保锁的一致性和可恢复性</td></tr><tr><td><strong>复杂性</strong></td><td>相对简单，只需要理解Java多线程</td><td>设计和维护相对复杂，涉及到网络通信、错误处理、状态同步等分布式系统的问题</td></tr></tbody></table><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li><strong>互斥性</strong>：确保在同一时间内，只有一个进程或服务可以执行关键段（critical section）的代码或操作特定的资源。</li><li><strong>避免死锁</strong>：通过合理设计和使用超时机制，分布式锁可以避免死锁情况的发生。</li><li><strong>保持一致性</strong>：在分布式系统中，不同节点上的进程可能会试图同时修改同一个数据源，使用分布式锁可以保持数据操作的一致性。</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>电子商务系统中的库存管理</strong>：在高并发环境下，多个用户可能同时尝试购买限量的商品。分布式锁可以确保在处理订单和减库存操作时的数据一致性。</li><li><strong>支付系统</strong>：在处理支付操作时，分布式锁可以保证同一账户的支付操作不会同时进行，避免余额出现错误。</li><li><strong>任务调度</strong>：在分布式任务调度系统中，分布式锁用来保证同一任务不会被多个调度实例同时执行。</li><li><strong>数据聚合</strong>：在一个大数据平台中，多个进程可能需要对同一数据集进行处理和更新，使用分布式锁可以防止数据在更新时发生冲突。</li></ol><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li><strong>互斥性：</strong>在任何时刻，只有一个客户端可以持有锁。这是实现并发控制的基本要求，确保共享资源不会被多个进程同时修改，从而避免数据不一致。</li><li><strong>死锁防范：</strong>需要考虑到死锁的可能性并提供解决方案。这通常通过引入锁超时机制来实现，这样可以防止因为某个持锁进程的故障导致资源被无限期锁定。</li><li><strong>高可用：</strong>必须高度可用，任何不可用都可能导致依赖它的应用发生阻塞或失败。通常通过冗余部署（如使用主从复制或多节点集群）来增强锁服务的可用性。</li><li><strong>容错性：</strong>分布式锁应该能够处理节点故障。如果一个持有锁的节点突然崩溃或网络分区，锁服务需要能够检测到这种情况并将锁释放，以免影响系统的整体功能。</li><li><strong>高性能：</strong>锁的获取和释放操作应尽可能高效。设计时需要优化网络交互，减少锁操作的延迟，例如通过减少请求的往返次数、使用更快的序列化机制等</li><li><strong>重入性：</strong>同一个线程可能需要多次获取同一把锁（递归锁定）。分布式锁的设计可考虑支持重入性，使得同一个节点或线程可以安全地多次申请同一资源。</li><li><strong>公平性：</strong>设计分布式锁时可以考虑锁的公平性，即确保按照请求锁的顺序来分配锁。这可以防止某些节点因长时间得不到锁而产生的“饥饿”问题。</li><li><strong>可伸缩性：</strong>随着系统规模的扩大，分布式锁的实现也应能够扩展以处理更高的并发请求，这可能意味着在多个锁服务节点之间有效分配请求，或是合理的资源分区策略。</li><li><strong>安全性：</strong>尤其在公开或不完全受信的环境中，分布式锁的通信应该加密，防止恶意攻击如重放攻击或锁篡改。</li></ol><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><ul><li><p><strong>优点：</strong></p><ul><li><p><strong>强一致性</strong>：可以通过数据库事务保证操作的原子性和一致性。</p></li><li><p><strong>熟悉度高</strong>：许多开发者对SQL和关系数据库非常熟悉，容易实现和维护。</p></li></ul></li><li><p><strong>缺点：</strong></p><ul><li><p><strong>性能限制</strong>：数据库锁可能在高并发场景下性能较低，因为锁操作需要磁盘I/O，且通常涉及网络延迟。</p></li><li><p><strong>可扩展性问题</strong>：随着请求量的增加，扩展关系数据库通常比较困难和昂贵。</p></li></ul></li></ul><h4 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h4><ul><li><strong>优点：</strong><ul><li><strong>高性能</strong>：基于内存操作，响应速度快，适合高并发环境。</li><li><strong>自然的超时机制</strong>：Redis键值可以设置过期时间，自然支持锁的超时释放。</li><li><strong>高可用和扩展性</strong>：通过哨兵模式和集群模式，Redis可以提供高可用性和水平扩展。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>数据持久性问题</strong>：虽然Redis有持久化机制，但在极端情况下仍可能丢失数据。</li><li><strong>锁不是自然的可重入</strong>：需要在客户端实现可重入逻辑。</li></ul></li></ul><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><ul><li><strong>优点：</strong><ul><li><strong>设计用于协调</strong>：ZooKeeper提供原生支持的分布式锁和其他同步原语，非常适合做分布式协调任务。</li><li><strong>强一致性</strong>：ZooKeeper保证跨集群的数据一致性和顺序性。</li><li><strong>容错性高</strong>：通过集群模式运行，能够处理节点失败的情况。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>复杂性高</strong>：比起Redis和MySQL，ZooKeeper的部署和维护更为复杂。</li><li><strong>性能较低</strong>：由于强一致性的保证，性能可能不如基于内存的Redis。</li></ul></li></ul><h4 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h4><p>在选择分布式锁的实现技术时，需要考虑锁的性能需求、一致性要求、系统的可用性和容错性。MySQL提供了强一致性但可能在高并发下表现不佳；Redis提供了极高的性能和良好的扩展性，适合需要快速响应的场景；ZooKeeper提供了专门的协调服务，适合需要严格一致性和顺序保证的场景。每种技术都有其适用的场景和局限性，正确的选择应基于具体的应用需求和环境特点。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基于Redis实现分布式锁主要有两点：</p><ol><li><p>获取锁</p><p>互斥：确保只有一个线程获取锁</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">SETNX lock threadId<br></code></pre></div></td></tr></table></figure><p>添加超时时间，避免死锁</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">EXPIRED lock 10<br></code></pre></div></td></tr></table></figure><p>注意获取锁和添加超时时间这两步必须是一个原子操作，避免设置超时时间前服务器宕机引发死锁问题，因此可以将两步合并为：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">SET lock threadId EX 10 NX<br></code></pre></div></td></tr></table></figure></li><li><p>释放锁</p><p>手动释放</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">DEL lock<br></code></pre></div></td></tr></table></figure></li></ol><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-distributed-locks.png" alt="Redis分布式锁简单流程"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据以上实现思路编写Java程序如下：</p><ol><li><p>创建接口RedisLock，接口包含获取锁以及解锁的方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RedisLock</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean 是否获取到锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>创建该接口的一个实现类SimpleRedisLock</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RedisLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX = <span class="hljs-string">&quot;REDIS_LOCK_&quot;</span>;<br><br>    <span class="hljs-comment">// 类的成员变量，用于存储锁的key</span><br>    <span class="hljs-keyword">private</span> String key;<br><br>    <span class="hljs-comment">// 用于操作redis的组件</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取锁</span><br><span class="hljs-comment">     * 1. 获取当前线程的id</span><br><span class="hljs-comment">     * 2. 尝试将当前线程的id存入redis，并设置过期时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean 是否获取到锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> threadId = Thread.currentThread().getId();<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX +key, String.valueOf(threadId), timeout, TimeUnit.MILLISECONDS));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁：删除redis中的key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        stringRedisTemplate.delete(KEY_PREFIX + key);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>业务：用户同一时间多次下单的场景，使用互斥锁保证只有一个请求成功</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        SimpleRedisLock simpleRedisLock = <span class="hljs-keyword">new</span> SimpleRedisLock(<span class="hljs-string">&quot;createOrder&quot;</span> + getUserId(), stringRedisTemplate);<br>        <span class="hljs-keyword">boolean</span> locked = simpleRedisLock.tryLock(<span class="hljs-number">20000</span>);<br>        <span class="hljs-comment">// 如果获取锁失败，直接返回</span><br>        <span class="hljs-keyword">if</span> (!locked) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取锁失败&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取锁成功，模拟创建订单</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;创建订单成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;创建订单失败&quot;</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 创建订单结束后，释放锁</span><br>            simpleRedisLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟获取用户id</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>运行两个应用实例，用两次HTTP请求模拟同一时间多次下单，请求结果如下</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-distributed-lock-test-1.png"></p><p>查看Redis数据库</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;REDIS_LOCK_createOrder1&quot;</span><br>127.0.0.1:6379&gt; get REDIS_LOCK_createOrder1<br><span class="hljs-string">&quot;38&quot;</span><br>127.0.0.1:6379&gt; ttl REDIS_LOCK_createOrder1<br>(<span class="hljs-built_in">integer</span>) 7<br></code></pre></div></td></tr></table></figure></li><li><p>由以上结果可知，OrderServiceImpl#createOrder已满足我们的业务需求，做到了用户同一时间只能下单一次，且从Redis数据库的查询结果也看出了SimpleRedisLock的工具类是按照我们上节提到的思路进行实现的。</p></li></ol><h2 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h2><p>以上SimpleRedisLock看似已经满足了需求，但在某些极端条件下仍然会出错，如下图所示：</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-distributed-lock-disadvantage-1.png" alt="Redis分布式锁弊端一"></p><p>当线程1执行业务期间，锁超时释放，与此同时线程2获取到了相同key的锁，且在线程2的执行期间，线程1执行完成，对锁进行了释放，那么就会出现问题，<strong>线程1解锁了不属于自己的锁</strong>。</p><p>其实解决这个问题很简单，只需要对锁的值进行标记，在释放锁时对锁的值和本线程持有的值进行比较，相同才能解锁，即可解决这个“跨线程解锁”的问题。</p><p>修改SimpleRedisLock如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RedisLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX = <span class="hljs-string">&quot;REDIS_LOCK_&quot;</span>;<br><br>    <span class="hljs-comment">// 对锁的值进行设置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOCK_VALUE = UUID.randomUUID().toString();<br><br>    <span class="hljs-comment">// 用于存储锁的key</span><br>    <span class="hljs-keyword">private</span> String key;<br><br>    <span class="hljs-comment">// 用于操作redis的组件</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取锁</span><br><span class="hljs-comment">     * 1. 获取当前线程的id</span><br><span class="hljs-comment">     * 2. 尝试将当前线程的id存入redis，并设置过期时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean 是否获取到锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-comment">// long threadId = Thread.currentThread().getId();  替换为LOCK_VALUE</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + key, LOCK_VALUE, timeout, TimeUnit.MILLISECONDS));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁：删除redis中的key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 解锁时，判断当前线程是否持有锁，如果持有锁，则删除锁</span><br>        <span class="hljs-keyword">if</span> (LOCK_VALUE.equals(stringRedisTemplate.opsForValue().get(KEY_PREFIX + key))) &#123;<br>            stringRedisTemplate.delete(KEY_PREFIX + key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;解锁失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>修改的核心逻辑为：</strong>添加成员变量LOCK_VALUE（取值为UUID），拿到互斥锁时需要将该值设置为Redis KEY的VALUE，分布式锁解锁时需要拿出Redis中对应分布式锁的VALUE值，与持有者的LOCK_VALUE进行比较，值相等时才能进行解锁，否则抛出异常（业务代码需要做对应处理）。</p><p>修复后，分布式锁的流程如下：</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-distributed-lock-improvement-1.png" alt="Redis分布式锁改进一"></p><h2 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h2><p>刚才我们解决了锁超时释放后、前一个线程解锁当前正在运行的线程的锁的问题。</p><p>现在还有一个极端情况：解锁逻辑中，线程A判断完Redis中锁的VALUE值与持有者的LOCK_VALUE值相等后，本来可以解锁，但是系统突然阻塞了（FULL GC）且阻塞时间极长，分布式锁都超时释放了，此时又有另一个线程B拿到了相同KEY的锁，且在执行业务期间，线程A停止阻塞解锁了分布式锁，如下图所示：</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-distributed-lock-disadvantage-2.png" alt="Redis分布式锁弊端二"></p><p>不难看出，这个问题的根因是<strong>比较持有者与Redis的锁值、释放锁这两步动作不是一个原子操作</strong>。因此下一步我们要实现的是解锁逻辑中的原子操作。</p><h2 id="调用Lua脚本"><a href="#调用Lua脚本" class="headerlink" title="调用Lua脚本"></a>调用Lua脚本</h2><p>Redis提供了执行Lua脚本的功能，这是一种强大的机制，用于处理多个操作需要在单个原子事务中执行的情况。</p><h3 id="为什么使用Lua脚本"><a href="#为什么使用Lua脚本" class="headerlink" title="为什么使用Lua脚本"></a>为什么使用Lua脚本</h3><ol><li><strong>原子性</strong>：Lua脚本在执行时不会被其他命令中断，确保了脚本中所有操作的原子性。这是因为Redis是单线程的，一旦开始执行脚本，就会执行到结束，中间不会插入其他操作。</li><li><strong>减少网络开销</strong>：通过将多个命令封装在一个脚本中发送，可以减少客户端与服务器之间的通信次数。这对于网络延迟敏感的应用尤其重要。</li><li><strong>复杂逻辑处理</strong>：Lua脚本提供了比简单的Redis命令更复杂的逻辑处理能力，允许进行条件判断、循环处理等。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>复杂的事务</strong>：需要执行多个操作，这些操作要么全部完成，要么全部不做。</li><li><strong>性能优化</strong>：减少多次网络往返带来的延迟。</li><li><strong>安全性</strong>：例如，在分布式锁的实现中，确保只有锁的持有者才能释放锁。</li></ul><h3 id="分布式锁整合"><a href="#分布式锁整合" class="headerlink" title="分布式锁整合"></a>分布式锁整合</h3><p>以下是一个使用Lua脚本来安全释放Redis锁的例子。这个脚本检查锁是否由调用者持有，如果是，则释放锁：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><ul><li><code>KEYS[1]</code> 表示锁KEY的名称。</li><li><code>ARGV[1]</code> 表示调用者认为的锁的值。</li><li>如果锁的当前值与提供的值匹配，则删除该键（释放锁），否则不执行任何操作。</li></ul><p>同时改进SimpleRedisLock的解锁逻辑：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 获取lua脚本</span><br>    ClassPathResource unlockLuaRes = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;redis_unlock.lua&quot;</span>);<br>    String unlockScriptStr = StreamUtils.copyToString(unlockLuaRes.getInputStream(), StandardCharsets.UTF_8);<br>    DefaultRedisScript&lt;Long&gt; unlockScript = <span class="hljs-keyword">new</span> DefaultRedisScript&lt;&gt;(unlockScriptStr, Long.class);<br>    <br>    <span class="hljs-comment">// 执行lua脚本</span><br>    Long result = stringRedisTemplate.execute(unlockScript, Collections.singletonList(KEY_PREFIX + key), LOCK_VALUE);<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;释放锁失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上代码中，修改了在Java程序中取值判断，将<strong>取值</strong>、<strong>判断</strong>、<strong>删除</strong>都整合到Lua脚本中，实现了三步操作的原子性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章通过对分布式锁的全面介绍和深入的技术分析，提供了实现高效和安全分布式锁的详细方法。特别是通过Redis和Lua脚本实现的锁，不仅保证了操作的原子性，还解决了如锁超时和异常解锁的常见问题。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——基础篇</title>
    <link href="/2024/12/04/redis-base/"/>
    <url>/2024/12/04/redis-base/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Redis，作为一种高性能的键值数据库，自2009年诞生以来，因其出色的性能和丰富的数据结构支持，已成为现代数据处理中不可或缺的工具。它的设计为处理高速数据操作和实时应用提供了理想的解决方案。本文将介绍Redis的主要特性、安装过程、基本命令、以及如何通过Java客户端与之交互，帮助读者快速掌握Redis的使用和应用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Redis</code>诞生于2009年，全称为<code>Remote Dictionary Server</code>，即远程词典服务器，是一个开源的高性能键值数据库。因其支持字符串、哈希、列表、集合、有序集合、位图、地理空间索引等多种类型的数据结构，又被称为数据结构服务器。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><strong>高性能</strong>： Redis将其数据主要存储在内存中，同时大部分操作都是单线程的、避免了不必要的上下文切换和竞态条件，加上搞笑的数据结构和算法，使得它提供极高的性能，能够支持每秒高达数十万次的读写操作。</li><li><strong>持久化</strong>： 尽管是基于内存的，Redis也提供了灵活的持久化选项，如<code>RDB</code>（Redis 数据库文件）快照和<code>AOF（Append Only File）</code>日志，确保数据安全。</li><li><strong>数据结构丰富</strong>： Redis支持多种数据结构，使得它在应对不同场景时非常灵活，比如缓存、消息队列系统、应用排行榜、计数器等。</li><li><strong>发布/订阅消息系统</strong>： Redis支持发布/订阅模式，能够构建实时的消息系统。</li><li><strong>原子操作</strong>： Redis中的大多数操作都是原子性的，这意味着在并发环境中执行时，Redis可以保证这些命令的安全执行。</li><li><strong>事务支持</strong>： Redis支持事务功能，允许通过一系列命令的批量执行来进行复合操作。</li><li><strong>高可用和分布式</strong>： 通过<code>Redis Sentinel</code>提供高可用性，并且通过<code>Redis Cluster</code>提供自动分区的支持。</li><li><strong>多语言客户端</strong>：广泛的客户端支持，几乎所有的编程语言都有成熟的Redis客户端库，使得Redis可以轻松集成到各种应用程序和开发环境中。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>缓存系统</strong>： 利用Redis的高速数据访问能力，常用作应用的缓存层，减轻后端数据库的压力，提高数据访问速度。</li><li><strong>会话缓存（Session Cache）</strong>： 在Web应用中广泛用于存储用户会话。</li><li><strong>消息队列系统</strong>： 利用Redis的发布/订阅功能以及列表操作，实现消息队列的功能，支持高并发消息传递。</li><li><strong>实时计数系统</strong>： 如网站访问计数、在线用户统计等，Redis的原子操作非常适合。</li><li><strong>排行榜或计数器</strong>： 利用Redis的有序集合，可以非常方便地实现各类排行榜功能。</li></ul><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ol><li><p>安装编译Redis所需的基础工具和开发库</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo yum install -y gcc make<br></code></pre></div></td></tr></table></figure></li><li><p>下载源码压缩包</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">wget http://download.redis.io/releases/redis-6.2.6.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>解压源码压缩包</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tar -zxvf redis-6.2.6.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>编译及测试</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">make<br>make <span class="hljs-built_in">test</span><br>make install<br></code></pre></div></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo mkdir /etc/redis<br>sudo cp redis.conf /etc/redis/redis.conf<br></code></pre></div></td></tr></table></figure></li><li><p>可选：编辑配置文件，设置外网访问及后台运行</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini">bind 0.0.0.0<br><br>requirepass <span class="hljs-section">[redis连接密码]</span><br><br>daemonize yes<br></code></pre></div></td></tr></table></figure></li><li><p>可选：创建systemd服务文件，确保redis在系统重启后自动启动</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vim /etc/systemd/system/redis.service<br></code></pre></div></td></tr></table></figure><p>粘贴以下内容</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Redis In-Memory Data Store<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=root<br><span class="hljs-attr">Group</span>=root<br><span class="hljs-attr">ExecStart</span>=/usr/local/bin/redis-server /etc/redis/redis.conf<br><span class="hljs-attr">ExecStop</span>=/usr/local/bin/redis-cli shutdown<br><span class="hljs-attr">Restart</span>=always<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></div></td></tr></table></figure><p>保存并退出，重新加载systemd管理器配置并启动redis服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> redis<br>sudo systemctl start redis<br></code></pre></div></td></tr></table></figure><p>需要注意：如果使用systemd来管理Redis服务，应该让systemd完全控制服务的启动、停止和重启，此时redis配置文件中的daemonize应设置为no。如果Redis配置为守护进程模式（即 <code>daemonize yes</code>），这会与systemd的操作发生冲突。因为Redis尝试自己分离出一个守护进程，systemd可能会认为主进程已经退出，这导致systemd认为服务已经“停止”，然后根据配置尝试重新启动它，从而形成一个不断的重启循环。</p></li><li><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl status redis<br><br>redis-cli<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="系统级命令"><a href="#系统级命令" class="headerlink" title="系统级命令"></a>系统级命令</h2><h3 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h3><p><strong>命令说明</strong>：用于启动Redis服务器实例的命令行工具，通过多种方式配置和启动Redis服务。</p><p><strong>常用选项</strong>：</p><ul><li><p><code>/path/redis.config</code>：通过指定的配置文件启动。</p></li><li><p><code>--port &lt;port&gt;</code>：设置Redis侦听的端口号。</p></li><li><p><code>--bind &lt;address&gt;</code> ：绑定到一个或多个接口，如果需要多个地址，可以重复这个选项。</p></li><li><p><code>--conf &lt;file&gt;</code>：指定配置文件的路径。</p></li><li><p><code>--loglevel &lt;level&gt;</code>：设置日志级别（debug、verbose、notice、warning）。</p></li><li><p><code>--logfile &lt;filename&gt;</code>：指定日志文件路径。如果设置为<code>stdout</code>，日志将输出到标准输出。</p></li><li><p><code>--daemonize yes</code>：指示Redis以守护进程模式运行。</p></li><li><p><code>--pidfile &lt;file&gt;</code>：设置PID文件的路径，这在以守护进程形式运行时非常有用。</p></li><li><p><code>--protected-mode [yes|no]</code>：设置保护模式，当Redis没有设置密码，并且绑定到公共接口时，拒绝客户端的连接。</p></li><li><p><code>--dir &lt;directory&gt;</code>：指定持久化文件存储的目录。</p></li><li><p><code>--dbfilename &lt;filename&gt;</code>：指定持久化文件的文件名。</p></li><li><p><code>--appendonly [yes|no]</code>：是否开启<code>AOF (Append Only File) </code>持久化模式。</p></li></ul><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><p><strong>命令说明</strong>：Redis的命令行接口客户端，它用于与Redis服务器进行交互。通过<code>redis-cli</code>可以执行各种 Redis 命令，查看服务器状态，进行调试，以及管理数据。</p><p><strong>常用选项</strong>：</p><ul><li><code>-h</code>：指定服务器的主机名。</li><li><code>-p</code>：指定服务器的端口。</li><li><code>-a</code>：指定连接密码。</li><li><code>--raw</code>：以原始格式输出（例如，不转义字符串中的特殊字符）。</li><li><code>-c</code>：启用集群模式，允许 <code>redis-cli</code> 在Redis集群节点间自动重定向。</li><li><code>--scan</code>：以迭代方式列出所有的键，可以与<code>-p</code> 和<code>--pattern</code>参数一起使用。</li><li><code>--pipe</code>：使用管道模式，可以通过标准输入批量执行命令。</li><li><code>--stat</code>：提供Redis服务器的统计信息，如每秒命令执行数等。</li><li><code>--bigkeys</code>：找出并报告数据库中的大键。</li><li><code>--help</code>：显示帮助信息，列出所有可用的命令和选项。</li><li><code>--version</code>：显示<code>redis-cli</code>的版本信息。</li></ul><h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h3><p><strong>命令说明</strong>：Redis提供的一个性能测试工具，用于通过运行特定的命令序列来测试Redis服务器的性能。它可以快速生成大量请求，测量Redis实例在不同负载下的响应速度和处理能力。这个工具对于评估Redis配置的性能、比较不同硬件或软件设置的影响，或者进行压力测试等都非常有用。</p><p><strong>常用选项</strong>：</p><ul><li><code>-n &lt;requests&gt;</code>：设置要执行的请求总数，默认是 100000。</li><li><code>-c &lt;clients&gt;</code>：设置并发客户端的数量，默认是 50。</li><li><code>-t &lt;tests&gt;</code>：指定要运行的测试类型，例如<code>set</code>、<code>get</code>、<code>incr</code>、<code>lpush</code>等等。</li><li><code>-d &lt;size&gt;</code>：数据大小（以字节为单位），用于测试<code>SET/GET</code>等命令，默认是 3 字节。</li><li><code>--csv</code>：输出结果以<code>CSV</code>格式，适合导入到表格或数据库中分析。</li><li><code>-k &lt;0/1&gt;</code>：1（默认）表示保持连接开启<code>（pipelining）</code>，0 表示每个请求后关闭连接。</li><li><code>-P &lt;number&gt;</code>：使用<code>pipelining</code>的方式来增加每个请求的响应时间，默认不启用。</li><li><code>-r</code>：对<code>set</code>、<code>get</code>、<code>incr</code>、<code>lpush</code>、<code>rpop</code>、<code>sadd</code>、<code>spop</code>、<code>lrem</code>、<code>lpop</code>、<code>rpop</code>等命令使用随机 key，避免对同一个 key 的重复操作。</li></ul><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 选择数据库</span><br>select &lt;num&gt;<br><br><span class="hljs-comment"># 查看当前数据库的key数量</span><br>dbsize<br><br><span class="hljs-comment"># 清空当前数据库</span><br>flushdb<br><br><span class="hljs-comment"># 清空所有数据库</span><br>flushall<br><br><span class="hljs-comment"># 查看所有key</span><br>keys *<br><br><span class="hljs-comment"># 查看是否存在key</span><br>exists key<br><br><span class="hljs-comment"># 将key转移到指定的数据库</span><br>move key index<br><br><span class="hljs-comment"># 设置过期时间</span><br>expire key second<br><br><span class="hljs-comment"># 查看key的存活时间</span><br>ttl key<br><br><span class="hljs-comment"># 查看key的类型</span><br><span class="hljs-built_in">type</span> key<br></code></pre></div></td></tr></table></figure><h2 id="数据结构及常用命令"><a href="#数据结构及常用命令" class="headerlink" title="数据结构及常用命令"></a>数据结构及常用命令</h2><h3 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 (Strings)"></a>字符串 (Strings)</h3><ul><li><p><strong>概述</strong>：字符串是Redis中最基本的类型，它可以存储任何形式的字符串（包括二进制数据），最大可以支持存储<code>512MB</code>。</p></li><li><p><strong>用途</strong>：常用于存储文本或二进制数据，如缓存用户的邮箱、序列化的对象、图片或小文件等。</p></li><li><p><strong>操作</strong>：提供设置（SET）、获取（GET）、追加（APPEND）、多键获取（MGET）等操作。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 设置键key的值为value</span><br><span class="hljs-built_in">set</span> key value<br><br><span class="hljs-comment"># 获取键key对应的值</span><br>get key<br><br><span class="hljs-comment"># 删除键key</span><br>del key<br><br><span class="hljs-comment"># 若键key存在，则对值后面拼接字符串value，若键key不存在，设置键key的值为value</span><br>append key value<br><br><span class="hljs-comment"># 获取键key对应的值的字符串长度</span><br>strlen key<br><br><span class="hljs-comment"># 将键key对应的值自增（只针对Integer类型的值）</span><br>incr key<br><br><span class="hljs-comment"># 将键key对应的值自减（只针对Integer类型的值）</span><br>decr key<br><br><span class="hljs-comment"># 将键key对应的值增加incrment（只针对Integer类型的值）</span><br>incrby key incrment<br><br><span class="hljs-comment"># 将键key对应的值减少decrment（只针对Integer类型的值）</span><br>decrby key decrment<br><br><span class="hljs-comment"># 获取键key对应的值特定范围的内容，下标区间为[start,end]，end为-1代表到字符串结束</span><br>getrange key start end<br><br><span class="hljs-comment"># 设置键key指定下标的内容为value，替换区间为[offset, offset + value.length]</span><br>setrange key offset value<br><br><span class="hljs-comment"># 设置键key的值为value，且过期时间为seconds（秒）</span><br>setex key seconds value<br><br><span class="hljs-comment"># 如果键key不存在，则设置键key对应的值为value，键key存在不进行设置</span><br>setnx key value<br><br><span class="hljs-comment"># 设置多个键值对，如果命令后面出现前面已存在的键key，则会覆盖前面设置的值</span><br>mset key value [key value...]<br><br><span class="hljs-comment"># 获取多个值</span><br>mget key [key]<br><br><span class="hljs-comment"># 如果键key不存在（于数据库中），则设置键key对应的值为value，键key存在不进行设置</span><br>msetnx key value [key value...]<br><br><span class="hljs-comment"># 设置键key对应的值为value，返回上一次设置的值</span><br>getset key value<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="哈希-Hashes"><a href="#哈希-Hashes" class="headerlink" title="哈希 (Hashes)"></a>哈希 (Hashes)</h3><ul><li><p><strong>概述</strong>：哈希是键值对集合，适用于存储对象。</p></li><li><p><strong>用途</strong>：非常适合存储和表示对象（类似于编程语言中的字典）。例如，可以用哈希存储用户的属性，如name、age等。</p></li><li><p><strong>操作</strong>：可以一次性设置或获取多个字段（HSET, HGET, HMSET, HMGET），删除字段（HDEL），检查字段是否存在（HEXISTS）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 设置键值对key，对应的值为键值对&lt;field,value&gt;</span><br>hset key field value<br><br><span class="hljs-comment"># 获取键值对key中键field的值</span><br>hget key field<br><br><span class="hljs-comment"># 设置键值对key的多个键及其对应值</span><br>hmset key filed value [field value ...]<br><br><span class="hljs-comment"># 获取键值对key的多个键的对应值</span><br>hmget key field [filed ...]<br><br><span class="hljs-comment"># 获取键值对key中所有的键及其对应值</span><br>hgetallkey<br><br><span class="hljs-comment"># 删除键值对key中的键field</span><br>hdel key field [field ...]<br><br><span class="hljs-comment"># 获取键值对key中键的数量</span><br>hlen key<br><br><span class="hljs-comment"># 查询键值对key中是否存在键field</span><br>hexists key field<br><br><span class="hljs-comment"># 获取键值对key中的所有键</span><br>hkeys key<br><br><span class="hljs-comment"># 获取键值对key中的所有值</span><br>hvals key<br><br><span class="hljs-comment"># 将键值对key对应的键field对应值增加incrment</span><br>hincrby key field incrment<br><br><span class="hljs-comment"># 如果键值对key中不存在键field，则设置键field的值为value，存在则不进行设置</span><br>hsetnx key field value<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 (Lists)"></a>列表 (Lists)</h3><ul><li><p><strong>概述</strong>：列表是简单的字符串列表，按插入顺序排序。你可以在列表的头部或尾部添加元素。</p></li><li><p><strong>用途</strong>：适合实现消息队列，通过将元素从列表头部插入，并从尾部移除来模拟队列的操作。</p></li><li><p><strong>操作</strong>：添加元素到头部（LPUSH）或尾部（RPUSH），移除并获取头部（LPOP）或尾部元素（RPOP），修剪（LTRIM）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 往列表key头部添加值value</span><br>lpush key value [value...]<br><br><span class="hljs-comment"># 往列表key尾部添加值value</span><br>rpush key value [value...]<br><br><span class="hljs-comment"># 获取列表key下表范围为[start,stop]的值，stop为-1代表到列表结尾</span><br>lrange key start stop<br><br><span class="hljs-comment"># 弹出列表key的第一个值</span><br>lpop key<br><br><span class="hljs-comment"># 弹出列表key的最后一个值</span><br>rpop key<br><br><span class="hljs-comment"># 获取列表key下标为index的值</span><br>lindex key index<br><br><span class="hljs-comment"># 获取列表key的长度</span><br>llen key<br><br><span class="hljs-comment"># （从头开始）移除列表key中count个与value相等的值</span><br>lrem key count value<br><br><span class="hljs-comment"># 移除列表key中下标[start,stop]以外的值</span><br>ltrim key start stop<br><br><span class="hljs-comment"># 将列表source的最后一个值弹出并添加到列表destination头部</span><br>rpoplpush <span class="hljs-built_in">source</span> destination<br><br><span class="hljs-comment"># 将列表key下标为index处的值设置为value</span><br>lset key index value<br><br><span class="hljs-comment"># 在列表元素pivot前面|后面插入value</span><br>linsert key before|after pivot value<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合 (Sets)"></a>集合 (Sets)</h3><ul><li><p><strong>概述</strong>：集合是字符串的无序集合，它保证内部存储的元素是唯一的。</p></li><li><p><strong>用途</strong>：适合存储没有重复的元素，例如，存储一个用户所有喜欢的标签，集合可以自动去重。</p></li><li><p><strong>操作</strong>：添加（SADD）、移除（SREM）、检查存在性（SISMEMBER）、集合间的运算如交集（SINTER）、并集（SUNION）和差集（SDIFF）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 往集合key中添加元素member</span><br>sadd key member [member...]<br><br><span class="hljs-comment"># 获取集合key中的所有元素</span><br>smenbers key<br><br><span class="hljs-comment"># 查询集合key中是否含有元素member的成员之一</span><br>sismember key member<br><br><span class="hljs-comment"># 获取集合key里面的元素个数</span><br>scard key<br><br><span class="hljs-comment"># 移除集合key中的元素member</span><br>srem key member [member...]<br><br><span class="hljs-comment"># 随机获取集合key中的count个元素，count为空则代表1</span><br>srandmember key [count]<br><br><span class="hljs-comment"># 随机弹出集合key中的count个元素，count为空则代表1</span><br>spop key [count]<br><br><span class="hljs-comment"># 将集合source中的元素member转移到集合destination中</span><br>smove <span class="hljs-built_in">source</span> destination member<br><br><span class="hljs-comment"># 获取存在于集合key1但不存在于集合key2的所有元素</span><br>sdiff key1 [key2...]<br><br><span class="hljs-comment"># 获取集合key1和集合key2的交集</span><br>sinter key1 key2<br><br><span class="hljs-comment"># 获取集合key1和集合key2的并集</span><br>sunion key1 key2<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="有序集合-Sorted-Sets"><a href="#有序集合-Sorted-Sets" class="headerlink" title="有序集合 (Sorted Sets)"></a>有序集合 (Sorted Sets)</h3><ul><li><p><strong>概述</strong>：有序集合类似于集合，但每个元素都会关联一个浮点数分数，Redis正是通过分数来为集合中的元素提供了顺序。</p></li><li><p><strong>用途</strong>：非常适合需要按顺序访问数据的场景，如排行榜、带权重的队列等。</p></li><li><p><strong>操作</strong>：添加元素（ZADD）、删除元素（ZREM）、修改元素的分数（ZINCRBY）、获取元素的排名（ZRANK）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 往有序集合key中添加分数为score的元素member，集合中的元素会根据分数从小到大排序，分数相同则按首字母排序</span><br>zadd key score member [score member ...]<br><br><span class="hljs-comment"># 获取有序集合key中排名为[start,stop]的元素，withscores不为空则可显示对应分数</span><br>zrange key start stop [withscores]<br><br><span class="hljs-comment"># 获取有序集合key中分数为[min,max]的元素，withscores不为空则可显示对应分数，limit可指定从offset处开始截取count个元素，min为-inf表示负无穷，+inf表示正无穷</span><br>zrangebyscore key min max [withscores] [<span class="hljs-built_in">limit</span> offset count]<br><br><span class="hljs-comment"># 移除有序集合key中元素member</span><br>zrem key member [member...]<br><br><span class="hljs-comment"># 获取有序集合key的元素数量</span><br>zcard key<br><br><span class="hljs-comment"># 获取有序集合key中元素member的排位（从小到大顺序，起始为0）</span><br>zrank key member<br><br><span class="hljs-comment"># 获取有序集合key中元素member的排位（从大到小顺序，起始为0）</span><br>zrevrank key member<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="位图-Bitmaps"><a href="#位图-Bitmaps" class="headerlink" title="位图 (Bitmaps)"></a>位图 (Bitmaps)</h3><ul><li><p><strong>概述</strong>：位图本质上不是一种独立的数据结构，它是字符串的一种特殊操作方式，通过位来表示二进制数据。</p></li><li><p><strong>用途</strong>：适合进行大规模的位运算，常用于统计和分析，如用户登录、签到等。</p></li><li><p><strong>操作</strong>：设置位（SETBIT）、获取位（GETBIT）、统计位（BITCOUNT）、位运算（BITOP）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># （以字节为单位分配字符串）设置位图key下标为offset的位的值为value，value默认为0，可设置为1</span><br>setbit key offset value<br><br><span class="hljs-comment"># 获取位图key下标为offset的位的值</span><br>getbit key offset<br><br><span class="hljs-comment"># 获取位图key上位为1的个数，可指定下标范围为[start, end]</span><br>bitcount key [start end]<br><br><span class="hljs-comment"># 对位图key进行操作（operation为and、or、xor、not运算），将结果存储到destkey</span><br>bitop operation destkey key [key ...]<br><br><span class="hljs-comment"># 查询位图key中第一个为bit（0或1）的下标位置，可指定字节的开始与结束范围为[start,end]</span><br>bitpos key bit [start] [end]<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="HyperLogLogs"><a href="#HyperLogLogs" class="headerlink" title="HyperLogLogs"></a>HyperLogLogs</h3><ul><li><p><strong>概述</strong>：HyperLogLog是一种概率型数据结构，用于高效地估计数据集中唯一元素的数量。</p></li><li><p><strong>用途</strong>：非常适合需要统计大量数据的去重数量，而对精确值要求不是非常严格的场景。</p></li><li><p><strong>操作</strong>：添加元素（PFADD）、计数（PFCOUNT）、合并多个HyperLogLog（PFMERGE）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 往集合key中添加元素element</span><br>pfadd key element [element...]<br><br><span class="hljs-comment"># 获取多个集合key的技术估算值</span><br>pfcount key [key...]<br><br><span class="hljs-comment"># 将多个集合sourcekey合并为一个集合destkey</span><br>pfmerge destkey sourcekey [sourcekey...]<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="地理空间索引-Geospatial-Indexes"><a href="#地理空间索引-Geospatial-Indexes" class="headerlink" title="地理空间索引 (Geospatial Indexes)"></a>地理空间索引 (Geospatial Indexes)</h3><ul><li><p><strong>概述</strong>：Redis的地理空间索引是通过有序集合实现的，允许你存储经度和纬度坐标作为元素。</p></li><li><p><strong>用途</strong>：适用于地理位置的存储、查询和半径搜索，如查询某范围内的位置点。</p></li><li><p><strong>操作</strong>：添加地理空间坐标（GEOADD）、查询半径内的元素（GEORADIUS）、获取两点之间的距离（GEODIST）等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 往集合key中添加经度为longitudu、纬度为latitude的元素member</span><br>geoadd key longitudu latitude member [longitudu latitude member ...]<br><br><span class="hljs-comment"># 获取集合key中指定元素member的经纬度信息</span><br>geopos key member [member...]<br><br><span class="hljs-comment"># 获取集合key中元素member1和元素member2的距离，单位为空时代表“m”</span><br>geodist key member1 member2 [m|km|ft|mi]<br><br><span class="hljs-comment"># 获取集合key中的元素经纬度字符串</span><br>geohash key member [member...]<br><br><span class="hljs-comment"># 获取集合key中在经度longitude、维度latitude、半径radius[m|km|ft|mi]内的元素，withdist可显示距离，withcoord可显示经纬度，count n可限制数量为n，asc升序或desc降序</span><br>georadius key longitude latitude radius [m|km|ft|mi] [withcoord] [withdist] [withhash] [asc|desc] [count n]<br><br><span class="hljs-comment"># 获取集合key中在元素member半径radius[m|km|ft|mi]内的元素（含自身）</span><br>georadiusbymember key member radius [m|km|ft|mi] [withcoord] [withdist] [withhash] [asc|desc] [count n]<br><br><span class="hljs-comment"># 删除集合key中的元素member（geo并没有删除，底层通过zset实现，因此用zrem）</span><br>zrem key member [member...]<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><code>Jedis</code>是一个比较直接和轻量级的Redis客户端实现，提供了简单直接的API来与Redis进行交互。它支持几乎所有的Redis特性，并且由于其简洁性，是学习和实现Redis操作的好选择。 官方文档地址：<a href="https://redis.io/docs/latest/develop/connect/clients/java/jedis/">Jedis guide | Docs (redis.io)</a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>轻量级和易于使用。</li><li>支持连接池。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不支持异步和非阻塞 I/O。</li><li>多线程环境下管理连接池较为复杂。</li><li>API较为基础，没有分布式护具结构和高级事务处理等功能。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>单个连接</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">// jedis.auth(&quot;xxxx&quot;);</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span> </span>&#123;<br>        String result = jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;yang&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        String name = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">result = OK<br>name = yang<br></code></pre></div></td></tr></table></figure><p>Jedis也支持连接池，示例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisConnectionFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool JEDIS_POOL;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        <span class="hljs-comment">// 最大连接数</span><br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 最大空闲连接</span><br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 最小空闲链接</span><br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 等待时长</span><br>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        JEDIS_POOL = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取连接资源</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> JEDIS_POOL.getResource();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = JedisConnectionFactory.getJedis();<br>        String result = jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;yang2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        String name = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>        jedis.close();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">result = OK<br>name = yang2<br></code></pre></div></td></tr></table></figure><h3 id="lettuce"><a href="#lettuce" class="headerlink" title="lettuce"></a>lettuce</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>Lettuce</code>是一个高级Redis客户端，提供异步、基于事件的API，并且内部使用Netty实现非阻塞通信。Lettuce可以在多个线程间共享单个连接，而不是使用传统的连接池。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>支持同步、异步和反应式编程模型。</li><li>内部使用Netty，实现了高效的非阻塞I/O。</li><li>允许连接多路复用，大大减少线程和连接的使用。</li><li>支持自动重连和命令重试。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>使用了异步网络应用框架Netty，在处理大量并发连接时可能会消耗更多系统资源。</li><li>API和配置相对复杂，尤其是高级功能的配置和优化。</li><li>要求开发者在错误处理和回调管理上更加小心，否则可能导致难以追踪的错误和内存泄漏。</li></ul><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p><code>Redisson</code>是Redis的高级客户端之一，提供了丰富的Redis对象和服务，如分布式锁、集合、映射、有序集合、发布/订阅、Bloom filter 等高级功能。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了许多Jedis和Lettuce中不包含的高级分布式Java对象和服务。</li><li>支持同步、异步和反应式接口。</li><li>内置Redis命令的高级抽象。</li><li>非常适合需要利用Redis提供分布式数据结构和服务的应用程序。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于提供了大量高级功能和抽象，Redisson可能会比其他更轻量级的客户端使用更多的内存。</li><li>一些高级特性，如分布式锁或数据结构，可能引入额外的性能开销，特别是在高负载或大规模部署情况下。</li></ul><h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><h4 id="性能和并发处理"><a href="#性能和并发处理" class="headerlink" title="性能和并发处理"></a>性能和并发处理</h4><ul><li><code>Lettuce</code>和<code>Redisson</code>提供异步处理能力，对于需要处理高并发请求的应用更加合适。</li><li><code>Jedis</code>由于其同步的实现方式，适合简单的应用场景，对于复杂的或高并发的场景则可能成为瓶颈。</li></ul><h4 id="API丰富度"><a href="#API丰富度" class="headerlink" title="API丰富度"></a>API丰富度</h4><ul><li><code>Redisson</code>提供的API最为丰富，支持大量的分布式数据结构和服务。</li><li><code>Lettuce</code>和<code>Jedis</code>提供的API较为基础，主要围绕Redis的核心功能。</li></ul><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><ul><li><code>Lettuce</code>提供连接多路复用，减少了连接总数的需求。</li><li><code>Jedis</code>依赖于传统的连接池来管理多个连接。</li><li><code>Redisson</code>支持连接池和单个连接的多路复用。</li></ul><h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p><code>Spring Data Redis</code>是Spring框架为Redis数据库提供的一个高级抽象模块，它简化了在Java应用中使用Redis的方式。通过Spring Data Redis，可以利用Spring框架提供的各种便利功能，如声明式事务支持、简化的数据访问模式和数据存取的透明化，从而使得与Redis的交互更加简单和高效。官方文档地址：<a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a></p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>简化配置</strong>：Spring Data Redis提供了易于使用的配置方式，可以快速集成Redis到Spring应用中。</li><li><strong>模板 API</strong>：<code>RedisTemplate</code> 和 <code>StringRedisTemplate</code> 提供了丰富的方法来操作Redis，包括对<code>keys</code>、<code>strings</code>、<code>lists</code>、<code>sets</code>、<code>hashes</code>等数据结构的操作。</li><li><strong>存储库支持</strong>：类似于其他Spring Data模块，Spring Data Redis支持通过创建接口来定义存储库，用于访问Redis keys`和进行复杂查询。</li><li><strong>对象映射</strong>：通过Spring Data的对象映射特性，可以将对象透明地存储在Redis中，而无需手动转换数据格式。</li><li><strong>事务支持</strong>：支持Redis事务，并能与Spring的声明式事务管理无缝整合。</li><li><strong>发布订阅</strong>：支持Redis的发布/订阅功能，可以在应用中实现消息通信模式。</li><li><strong>高级序列化</strong>：支持多种序列化和反序列化机制，如JDK序列化、JSON序列化等。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>缓存实现</strong>：利用Redis强大的性能作为应用的缓存，减少数据库访问，提高响应速度。</li><li><strong>会话存储</strong>：在分布式系统中，使用Redis存储会话信息，确保各个节点之间会话的一致性。</li><li><strong>全局锁</strong>：使用Redis实现分布式锁，确保分布式环境下资源同步访问。</li><li><strong>实时消息系统</strong>：利用Redis的发布/订阅功能实现实时消息系统。</li></ul><h3 id="与Jedis、Lettuce的关系"><a href="#与Jedis、Lettuce的关系" class="headerlink" title="与Jedis、Lettuce的关系"></a>与Jedis、Lettuce的关系</h3><h4 id="客户端库作为依赖"><a href="#客户端库作为依赖" class="headerlink" title="客户端库作为依赖"></a>客户端库作为依赖</h4><ul><li><strong>Jedis</strong>：在Spring Data Redis的早期版本中，Jedis是主要使用的客户端。它是一个简单且直接的客户端库，提供了同步的API来与Redis进行交互。Spring Data Redis通过封装Jedis提供了一套更为简洁和Spring风格的操作方式。</li><li><strong>Lettuce</strong>：随着对响应式编程的支持和需求的增加，Lettuce成为了Spring Data Redis的首选客户端。Lettuce提供非阻塞和异步的API，且基于Netty实现、支持连接多路复用，适合需要高并发处理的场景。Spring Data Redis利用Lettuce提供了包括响应式编程在内的高级特性。</li></ul><h4 id="配置与抽象层"><a href="#配置与抽象层" class="headerlink" title="配置与抽象层"></a>配置与抽象层</h4><ul><li>在Spring Data Redis中，可以自由选择使用Jedis或Lettuce作为底层连接库。Spring提供了统一的配置接口和操作模板（如<code>RedisTemplate</code>和响应式的<code>ReactiveRedisTemplate</code>），这些模板抽象出了底层客户端的具体实现细节，使得开发者可以不必关心底层连接库是使用的Jedis还是Lettuce。</li><li>开发者在使用Spring Data Redis时，可以通过简单的配置更改所使用的客户端库，而不需要修改业务代码，这提供了极大的灵活性和便利性。</li></ul><h4 id="实际开发"><a href="#实际开发" class="headerlink" title="实际开发"></a>实际开发</h4><p>在选择<code>RedisTemplate</code>的底层实现时，可以根据以下几个方面来决定：</p><ol><li><strong>性能需求</strong>：<ul><li>如果应用需要高性能的阻塞操作，且并发需求不高，可以选择Jedis。</li><li>对于需要高并发访问的应用，Lettuce的非阻塞和多路复用特性可能更适合。</li></ul></li><li><strong>并发模型</strong>：<ul><li>在微服务架构中，服务通常需要处理大量并发请求，因此选择支持异步处理的客户端（如Lettuce）会更合适。</li></ul></li><li><strong>功能支持</strong>：<ul><li>根据应用需求选择支持特定功能的客户端，例如，如果需要详细的连接管理、自动重连等高级功能，Lettuce 可能是更好的选择。</li></ul></li><li><strong>资源利用</strong>：<ul><li>考虑到资源利用效率，Lettuce的连接多路复用可以减少连接总数，从而降低资源消耗。</li></ul></li></ol><p><strong>示例：</strong>项目中Redis配置类（使用Lettuce）</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">spring.redis.username</span>=<span class="hljs-string">xxx</span><br><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">xxx</span><br><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># 由于Lettuce 自身支持连接多路复用，因此不需要传统意义上的连接池</span><br><span class="hljs-comment">#spring.redis.lettuce.pool.enabled=true</span><br><span class="hljs-comment">#spring.redis.lettuce.pool.max-active=8</span><br><span class="hljs-comment">#spring.redis.lettuce.pool.max-idle=8</span><br><span class="hljs-comment">#spring.redis.lettuce.pool.min-idle=0</span><br><span class="hljs-comment">#spring.redis.lettuce.pool.max-wait=-1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LettuceConnectionFactory <span class="hljs-title">redisConnectionFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LettuceConnectionFactory(); <span class="hljs-comment">// Spring Boot默认使用Lettuce，可不用显式配置</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        <span class="hljs-comment">// 使用Letture连接工厂</span><br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>不同于Jedis将所有的方法都封装到一个类中，Spring Data Redis提供了<code>RedisTemplate</code>工具类，这个类中封装了各种对Redis的操作，把不同数据类型的操作API封装到不同的<code>Operations</code>对象中</p><table><thead><tr><th>API</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td>redisTemplate.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td>redisTemplate.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td>redisTemplate.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td>redisTemplate</td><td></td><td>通用命令</td></tr></tbody></table><p><strong>Demo：</strong>注入一个<code>RedisTemplate</code>对象，先设置键值对，再获取</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTemplateTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span> </span>&#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;yangtao&quot;</span>);<br>        Object name = redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">name = yangtao<br></code></pre></div></td></tr></table></figure><p>由控制台输出可知，RedisTemplate已正确设置键值对。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><p>上一个DEMO中设置了一个key为<code>name</code>的键值对，但是通过命令行却看不到这个key</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span><br></code></pre></div></td></tr></table></figure><p>可以看到设置的键并不是<code>name</code>，这是因为<code>RedisTemplate</code>默认的序列化器为JDK的序列化器（通过<code>org.springframework.data.redis.core.AbstractOperations</code>的<code>keySerializer()</code>和<code>valueSerializer()</code>方法可以查看）</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/redis-serializer.png" alt="Redis序列化器"></p><p>我们可以将key的序列化器设置为更加常用的字符串序列化器<code>StringRedisSerializer</code>，而对于value通常设置为JSON序列化器<code>GenericJackson2JsonRedisSerializer</code>，Redis的配置类添加配置后如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LettuceConnectionFactory <span class="hljs-title">redisConnectionFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LettuceConnectionFactory();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        <span class="hljs-comment">// 使用Letture连接工厂</span><br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">// 设置key序列化方式为String，value序列化方式为json</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setValueSerializer(redisSerializer());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setHashValueSerializer(redisSerializer());<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisSerializer&lt;Object&gt; <span class="hljs-title">redisSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建JSON序列化器</span><br>        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        <span class="hljs-comment">// 设置可见度</span><br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer(objectMapper);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>再次运行测试程序，这次<code>RedisTemplate</code>会使用字符换序列化器和JSON序列化器在redis中存入一个键值对，通过Redis控制台查看如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span><br>2) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;\&quot;yangtao\&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><h4 id="类标识"><a href="#类标识" class="headerlink" title="类标识"></a>类标识</h4><p>在使用<code>RedisTemplate</code>配置为JSON序列化器存储数据时，存入Redis的数据中包含类的标识信息（<code>@class</code>属性），如运行以下程序后，往Redis中存入一个HashMap对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; user1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>user1.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;yangtao&quot;</span>);<br>user1.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user1&quot;</span>, user1);<br></code></pre></div></td></tr></table></figure><p>查看Redis数据库中键user1对应的值</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; get user1<br><span class="hljs-string">&quot;[\&quot;java.util.HashMap\&quot;,&#123;\&quot;name\&quot;:\&quot;yangtao\&quot;,\&quot;age\&quot;:18&#125;]&quot;</span><br></code></pre></div></td></tr></table></figure><p>从结果可以看到值中包含了对象的类标识<code>java.util.HashMap</code>，这是因为JSON序列化器<code>GenericJackson2JsonRedisSerializer</code>被配置为存储类型信息，这种配置便于反序列化过程中能够精确地恢复出原始对象的类型。</p><p><strong>注意事项：</strong>通过匿名内部类创建的<code>HashMap</code>对象，创建的是<code>HashMap</code>的一个匿名子类的实例，因此这个对象存入Redis后，值标识的类名是外部类信息的名称及其匿名类，如运行以下程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; user2 = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>    put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>    put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">19</span>);<br>&#125;&#125;;<br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user2&quot;</span>, user2);<br>Object user2Obj = redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;user2 = &quot;</span> + user2Obj);<br></code></pre></div></td></tr></table></figure><p>运行出错，对应的错误日志为：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">org.springframework.data.redis.serializer.SerializationException: Could not <span class="hljs-built_in">read</span> JSON: Cannot construct instance of `space.yangtao.client.RedisTemplateTest<span class="hljs-variable">$1</span>` (no Creators, like default constructor, exist): no default constructor found<br> at [Source: (byte[])<span class="hljs-string">&quot;[&quot;</span>space.yangtao.client.RedisTemplateTest<span class="hljs-variable">$1</span><span class="hljs-string">&quot;,&#123;&quot;</span>name<span class="hljs-string">&quot;:&quot;</span>zhangsan<span class="hljs-string">&quot;,&quot;</span>age<span class="hljs-string">&quot;:19&#125;]&quot;</span>; line: 1, column: 45]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `space.yangtao.client.RedisTemplateTest<span class="hljs-variable">$1</span>` (no Creators, like default constructor, exist): no default constructor found<br> at [Source: (byte[])<span class="hljs-string">&quot;[&quot;</span>space.yangtao.client.RedisTemplateTest<span class="hljs-variable">$1</span><span class="hljs-string">&quot;,&#123;&quot;</span>name<span class="hljs-string">&quot;:&quot;</span>zhangsan<span class="hljs-string">&quot;,&quot;</span>age<span class="hljs-string">&quot;:19&#125;]&quot;</span>; line: 1, column: 45]<br></code></pre></div></td></tr></table></figure><p>可以看到程序报错的原因为<code>space.yangtao.client.RedisTemplateTest$1</code>（<code>RedisTemplateTest</code>的第一个匿名类）缺少默认的构造器，从Redis中查看对应的值为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; get user2<br><span class="hljs-string">&quot;[\&quot;space.yangtao.client.RedisTemplateTest<span class="hljs-variable">$1</span>\&quot;,&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:19&#125;]&quot;</span><br></code></pre></div></td></tr></table></figure><p>可以看到值中类标识并不是<code>HashMap</code>，而是<code>RedisTemplateTest</code>的第一个匿名类。</p><p>因此，在使用<code>RedisTemplate</code>操作对象时，要尽量避免使用匿名类创建对象。</p><p>当然，这种问题也有解决方案，那就是类型擦除或手动序列化。</p><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>配置<code>RedisTemplate</code>的序列化器为<code>Jackson2JsonRedisSerializer</code>，或对<code>GenericJackson2JsonRedisSerializer</code>的<code>ObjectMapper</code>对象进行设置，使其序列化以后不包含类型信息</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);<br>template.setValueSerializer(serializer);<br>template.setHashValueSerializer(serializer);<br><br><span class="hljs-comment">// 或</span><br><br>ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>objectMapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);<br>RedisSerializer&lt;Object&gt; serializer = <span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer(objectMapper);<br>template.setValueSerializer(serializer);<br>template.setHashValueSerializer(serializer);<br></code></pre></div></td></tr></table></figure><p>类型擦除以后，存入Redis中的值没有类型，程序的反序列化便可成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">user2 = &#123;name=zhangsan, age=19&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; get user2<br><span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:19&#125;&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意事项：</strong>不存储类型信息可能会在反序列化时导致问题，特别是在处理多态和复杂对象结构时。如果序列化的数据结构比较复杂或涉及继承，不包含类型信息可能会导致反序列化失败或数据不正确。</p><h4 id="手动序列化"><a href="#手动序列化" class="headerlink" title="手动序列化"></a>手动序列化</h4><p>在操作<code>RedisTemplate</code>往Redis存入对象时，可以先将其进行序列化，从Redis取出对象时，再将其反序列化，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; user3 = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>    put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br>    put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>);<br>&#125;&#125;;<br>ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user3&quot;</span>, objectMapper.writeValueAsString(user3));<br>Object user3Obj = redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user3&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;user3 = &quot;</span> + objectMapper.readValue((String) user3Obj, Map.class));<br></code></pre></div></td></tr></table></figure><p>相比于自动序列化，这种方法具有</p><p><strong>优点</strong>：</p><ol><li><strong>灵活性：</strong>开发者可以自由选择什么时候以及如何转换数据，适合特定的需求，如减小数据大小或处理复杂的数据结构。</li><li><strong>减少数据冗余：</strong>手动转换可以避免存储不必要的类型信息，使存储在Redis中的数据更加精简。</li><li><strong>依赖性：</strong>不会依赖序列化库（如Jackson）的更新对存取和更新有兼容性和稳定性有影响。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>代码复杂性：</strong>需要手动管理数据的序列化和反序列化，增加了代码的复杂度和出错概率。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的学习，读者应能够对Redis有一个全面的认识，从其基本概念到复杂的应用实现。Redis不仅支持多种数据结构，如字符串、列表、集合、哈希表、有序集合等，还提供了事务、消息订阅与发布和持久化等高级功能，满足现代应用的各种需求。此外，文章还探讨了如何在Java环境中利用Jedis、Lettuce和Redisson等客户端与Redis交互，以及如何通过Spring Data Redis简化代码和提高开发效率。掌握这些知识将极大地增强开发者在数据处理和应用开发中的能力。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springdoc——根据JavaDoc生成接口文档</title>
    <link href="/2024/10/17/springdoc-javadoc/"/>
    <url>/2024/10/17/springdoc-javadoc/</url>
    
    <content type="html"><![CDATA[<p>在现代应用程序开发中，API文档是非常重要的一部分，它不仅帮助开发者更好地理解接口的使用，也有助于跨团队协作。本文将介绍如何使用<code>Springdoc</code>自动地、无侵入地生成基于<code>Javadoc</code>的<code>API</code>文档，帮助你在开发中更简单地维护API文档。                                                                                                                                                                                                                                                                                                                      </p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>为了实现根据<code>Javadoc</code>自动生成API文档，需要在项目中引用<code>Springdoc</code>提供的<code>springdoc-openapi-webmvc-core</code>和<code>springdoc-openapi-javadoc</code>依赖，在POM文件中添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-webmvc-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springdoc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-javadoc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springdoc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>为了保留运行时的注释信息，使用了<code>Maven Compiler Plugin</code>并进行了如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.therapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>therapi-runtime-javadoc-scribe<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.15.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>该依赖用于在编译时处理<code>Javadoc</code>注释并将其保留在运行时，方便<code>Springdoc</code>生成基于<code>Javadoc</code>的 API 文档。这使得文档信息可以在应用程序运行时动态提取。</p><h2 id="Springdoc配置"><a href="#Springdoc配置" class="headerlink" title="Springdoc配置"></a>Springdoc配置</h2><p>为了更好地控制API文档的生成，我们可以创建一个配置类<code>SpringDocProperties</code>来定义文档的属性</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;springdoc&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringDocProperties</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文档基本信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@NestedConfigurationProperty</span><br>    <span class="hljs-keyword">private</span> InfoProperties info = <span class="hljs-keyword">new</span> InfoProperties();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩展文档地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@NestedConfigurationProperty</span><br>    <span class="hljs-keyword">private</span> ExternalDocumentation externalDocs;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 标签</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> List&lt;Tag&gt; tags = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@NestedConfigurationProperty</span><br>    <span class="hljs-keyword">private</span> Paths paths = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@NestedConfigurationProperty</span><br>    <span class="hljs-keyword">private</span> Components components = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfoProperties</span> </span>&#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 标题</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String title = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 描述</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String description = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 联系人信息</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@NestedConfigurationProperty</span><br>        <span class="hljs-keyword">private</span> Contact contact = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 许可证</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@NestedConfigurationProperty</span><br>        <span class="hljs-keyword">private</span> License license = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 版本</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String version = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="配置Springdoc"><a href="#配置Springdoc" class="headerlink" title="配置Springdoc"></a>配置Springdoc</h2><p>接下来，创建<code>SpringDocConfig</code>配置类，这个类将根据前面的<code>SpringDocProperties</code>来配置生成的文档信息</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@AutoConfigureBefore(SpringDocConfiguration.class)</span> <span class="hljs-comment">// 在 SpringDocConfiguration 配置类之前自动配置</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;springdoc.api-docs.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span> <span class="hljs-comment">// 只有在属性 springdoc.api-docs.enabled 设置为true或缺省时，才启用此配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringDocConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">// 注入SpringDocProperties配置类，用于获取文档的基本属性配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SpringDocProperties springDocProperties;<br>    <br>    <span class="hljs-comment">// 注入ServerProperties用于获取服务器的上下文路径等信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerProperties serverProperties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(OpenAPI.class)</span> <span class="hljs-comment">// 如果没有OpenAPI的Bean实例，则创建一个</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title">openApi</span><span class="hljs-params">()</span> </span>&#123;<br>        OpenAPI openApi = <span class="hljs-keyword">new</span> OpenAPI();<br>        <span class="hljs-comment">// 设置文档基本信息</span><br>        SpringDocProperties.InfoProperties infoProperties = springDocProperties.getInfo();<br>        Info info = convertInfo(infoProperties);<br>        openApi.info(info);<br>        <span class="hljs-comment">// 设置扩展文档信息</span><br>        openApi.externalDocs(springDocProperties.getExternalDocs());<br>        <span class="hljs-comment">// 设置文档标签</span><br>        openApi.tags(springDocProperties.getTags());<br>        <span class="hljs-comment">// 设置路径信息</span><br>        openApi.paths(springDocProperties.getPaths());<br>        <span class="hljs-comment">// 设置组件信息</span><br>        openApi.components(springDocProperties.getComponents());<br>        <br>        <span class="hljs-comment">// 配置安全需求</span><br>        Set&lt;String&gt; keySet = springDocProperties.getComponents().getSecuritySchemes().keySet();<br>        List&lt;SecurityRequirement&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        SecurityRequirement securityRequirement = <span class="hljs-keyword">new</span> SecurityRequirement();<br>        <span class="hljs-comment">// 将每个安全方案添加到安全需求列表中</span><br>        keySet.forEach(securityRequirement::addList);<br>        list.add(securityRequirement);<br>        openApi.security(list);<br><br>        <span class="hljs-keyword">return</span> openApi;<br>    &#125;<br><br>    <span class="hljs-comment">// 将SpringDocProperties的InfoProperties转换为OpenAPI 的Info对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Info <span class="hljs-title">convertInfo</span><span class="hljs-params">(SpringDocProperties.InfoProperties infoProperties)</span> </span>&#123;<br>        Info info = <span class="hljs-keyword">new</span> Info();<br>        info.setTitle(infoProperties.getTitle()); <span class="hljs-comment">// 设置标题</span><br>        info.setDescription(infoProperties.getDescription()); <span class="hljs-comment">// 设置描述</span><br>        info.setContact(infoProperties.getContact()); <span class="hljs-comment">// 设置联系人信息</span><br>        info.setLicense(infoProperties.getLicense()); <span class="hljs-comment">// 设置许可证信息</span><br>        info.setVersion(infoProperties.getVersion()); <span class="hljs-comment">// 设置版本信息</span><br>        <span class="hljs-keyword">return</span> info;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义openapi处理器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OpenAPIService <span class="hljs-title">openApiBuilder</span><span class="hljs-params">(Optional&lt;OpenAPI&gt; openAPI,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         SecurityService securityParser,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         SpringDocConfigProperties springDocConfigProperties, PropertyResolverUtils propertyResolverUtils,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         Optional&lt;List&lt;OpenApiBuilderCustomizer&gt;&gt; openApiBuilderCustomisers,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         Optional&lt;List&lt;ServerBaseUrlCustomizer&gt;&gt; serverBaseUrlCustomisers, Optional&lt;JavadocProvider&gt; javadocProvider)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OpenApiHandler(openAPI, securityParser, springDocConfigProperties, propertyResolverUtils, openApiBuilderCustomisers, serverBaseUrlCustomisers, javadocProvider);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对已经生成好的OpenApi进行自定义操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OpenApiCustomiser <span class="hljs-title">openApiCustomiser</span><span class="hljs-params">()</span> </span>&#123;<br>        String contextPath = serverProperties.getServlet().getContextPath();<br>        String finalContextPath;<br>        <span class="hljs-comment">// 如果上下文路径为空或为&quot;/&quot;，则设置为空字符串，否则使用原始上下文路径</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(contextPath) || <span class="hljs-string">&quot;/&quot;</span>.equals(contextPath)) &#123;<br>            finalContextPath = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            finalContextPath = contextPath;<br>        &#125;<br>        <span class="hljs-comment">// 对所有路径增加前置上下文路径</span><br>        <span class="hljs-keyword">return</span> openApi -&gt; &#123;<br>            Paths oldPaths = openApi.getPaths();<br>            <span class="hljs-keyword">if</span> (oldPaths <span class="hljs-keyword">instanceof</span> PlusPaths) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            PlusPaths newPaths = <span class="hljs-keyword">new</span> PlusPaths();<br>            <span class="hljs-comment">// 将旧路径增加上下文路径后存入新路径对象中</span><br>            oldPaths.forEach((k,v) -&gt; newPaths.addPathItem(finalContextPath + k, v));<br>            openApi.setPaths(newPaths);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单独使用一个类便于判断，解决springdoc路径拼接重复问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlusPaths</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Paths</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlusPaths</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="自定义API处理器"><a href="#自定义API处理器" class="headerlink" title="自定义API处理器"></a>自定义API处理器</h2><p>为了更好地生成文档信息，我们可以实现一个自定义的<code>OpenAPI</code>处理器：<code>OpenApiHandler</code>。这个类可以从<code>Javadoc</code>中提取注释信息，并将其添加到<code>OpenAPI</code>文档中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OpenAPIService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志记录器，用于记录处理过程中的信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(OpenAPIService.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 应用程序上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ApplicationContext context;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 安全解析器，用于处理安全相关的配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SecurityService securityParser;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储映射信息的映射表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; mappingsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储Springdoc标签信息的映射表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;HandlerMethod, io.swagger.v3.oas.models.tags.Tag&gt; springdocTags = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * OpenAPI构建自定义器列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;List&lt;OpenApiBuilderCustomizer&gt;&gt; openApiBuilderCustomisers;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器基础URL自定义器列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;List&lt;ServerBaseUrlCustomizer&gt;&gt; serverBaseUrlCustomizers;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SpringDoc配置属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SpringDocConfigProperties springDocConfigProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * OpenAPI对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> OpenAPI openAPI;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的OpenAPI映射表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, OpenAPI&gt; cachedOpenAPI = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 标识是否存在服务器配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isServersPresent;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器基础URL</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String serverBaseUrl;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 属性解析工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PropertyResolverUtils propertyResolverUtils;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Javadoc提供者，用于从Javadoc中提取注释信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;JavadocProvider&gt; javadocProvider;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基础错误控制器类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; basicErrorController;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试加载Spring Boot 2的基础错误控制器类</span><br>            basicErrorController = Class.forName(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果找不到，尝试加载Spring Boot 1的基础错误控制器类</span><br>                basicErrorController = Class.forName(<span class="hljs-string">&quot;org.springframework.boot.autoconfigure.web.BasicErrorController&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>                <span class="hljs-comment">// 如果仍然找不到，记录错误信息</span><br>                LOGGER.trace(classNotFoundException.getMessage());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，初始化各个属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenApiHandler</span><span class="hljs-params">(Optional&lt;OpenAPI&gt; openAPI, SecurityService securityParser,</span></span><br><span class="hljs-params"><span class="hljs-function">                          SpringDocConfigProperties springDocConfigProperties, PropertyResolverUtils propertyResolverUtils,</span></span><br><span class="hljs-params"><span class="hljs-function">                          Optional&lt;List&lt;OpenApiBuilderCustomizer&gt;&gt; openApiBuilderCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">                          Optional&lt;List&lt;ServerBaseUrlCustomizer&gt;&gt; serverBaseUrlCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">                          Optional&lt;JavadocProvider&gt; javadocProvider)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(openAPI, securityParser, springDocConfigProperties, propertyResolverUtils, openApiBuilderCustomizers, serverBaseUrlCustomizers, javadocProvider);<br>        <span class="hljs-keyword">if</span> (openAPI.isPresent()) &#123;<br>            <span class="hljs-keyword">this</span>.openAPI = openAPI.get();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.openAPI.getComponents() == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">this</span>.openAPI.setComponents(<span class="hljs-keyword">new</span> Components());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.openAPI.getPaths() == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">this</span>.openAPI.setPaths(<span class="hljs-keyword">new</span> Paths());<br>            <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.openAPI.getServers()))<br>                <span class="hljs-keyword">this</span>.isServersPresent = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.propertyResolverUtils = propertyResolverUtils;<br>        <span class="hljs-keyword">this</span>.securityParser = securityParser;<br>        <span class="hljs-keyword">this</span>.springDocConfigProperties = springDocConfigProperties;<br>        <span class="hljs-keyword">this</span>.openApiBuilderCustomisers = openApiBuilderCustomizers;<br>        <span class="hljs-keyword">this</span>.serverBaseUrlCustomizers = serverBaseUrlCustomizers;<br>        <span class="hljs-keyword">this</span>.javadocProvider = javadocProvider;<br>        <span class="hljs-keyword">if</span> (springDocConfigProperties.isUseFqn())<br>            TypeNameResolver.std.setUseFqn(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建操作标签</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handlerMethod 处理方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operation     操作对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> openAPI       OpenAPI 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> locale        语言环境</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 构建后的操作对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Operation <span class="hljs-title">buildTags</span><span class="hljs-params">(HandlerMethod handlerMethod, Operation operation, OpenAPI openAPI, Locale locale)</span> </span>&#123;<br>        Set&lt;Tag&gt; tags = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Set&lt;String&gt; tagsStr = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-comment">// 从方法和类中构建标签</span><br>        buildTagsFromMethod(handlerMethod.getMethod(), tags, tagsStr, locale);<br>        buildTagsFromClass(handlerMethod.getBeanType(), tags, tagsStr, locale);<br><br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(tagsStr))<br>            tagsStr = tagsStr.stream()<br>                    .map(str -&gt; propertyResolverUtils.resolve(str, locale))<br>                    .collect(Collectors.toSet());<br><br>        <span class="hljs-comment">// 处理自定义的Springdoc标签</span><br>        <span class="hljs-keyword">if</span> (springdocTags.containsKey(handlerMethod)) &#123;<br>            io.swagger.v3.oas.models.tags.Tag tag = springdocTags.get(handlerMethod);<br>            tagsStr.add(tag.getName());<br>            <span class="hljs-keyword">if</span> (openAPI.getTags() == <span class="hljs-keyword">null</span> || !openAPI.getTags().contains(tag)) &#123;<br>                openAPI.addTagsItem(tag);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置操作的标签</span><br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(tagsStr)) &#123;<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(operation.getTags()))<br>                operation.setTags(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tagsStr));<br>            <span class="hljs-keyword">else</span> &#123;<br>                Set&lt;String&gt; operationTagsSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(operation.getTags());<br>                operationTagsSet.addAll(tagsStr);<br>                operation.getTags().clear();<br>                operation.getTags().addAll(operationTagsSet);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 自动从类名生成标签</span><br>        <span class="hljs-keyword">if</span> (isAutoTagClasses(operation)) &#123;<br>            <span class="hljs-keyword">if</span> (javadocProvider.isPresent()) &#123;<br>                <span class="hljs-comment">// 使用Javadoc提供者从类中提取注释作为标签</span><br>                String description = javadocProvider.get().getClassJavadoc(handlerMethod.getBeanType());<br>                <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(description)) &#123;<br>                    io.swagger.v3.oas.models.tags.Tag tag = <span class="hljs-keyword">new</span> io.swagger.v3.oas.models.tags.Tag();<br>                    List&lt;String&gt; list = IoUtil.readLines(<span class="hljs-keyword">new</span> StringReader(description), <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>                    tag.setName(list.get(<span class="hljs-number">0</span>));<br>                    operation.addTagsItem(list.get(<span class="hljs-number">0</span>));<br>                    tag.setDescription(description);<br>                    <span class="hljs-keyword">if</span> (openAPI.getTags() == <span class="hljs-keyword">null</span> || !openAPI.getTags().contains(tag)) &#123;<br>                        openAPI.addTagsItem(tag);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                String tagAutoName = splitCamelCase(handlerMethod.getBeanType().getSimpleName());<br>                operation.addTagsItem(tagAutoName);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(tags)) &#123;<br>            <span class="hljs-comment">// Existing tags</span><br>            List&lt;io.swagger.v3.oas.models.tags.Tag&gt; openApiTags = openAPI.getTags();<br>            <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(openApiTags))<br>                tags.addAll(openApiTags);<br>            openAPI.setTags(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tags));<br>        &#125;<br><br>        <span class="hljs-comment">// 添加安全需求到操作级别</span><br>        io.swagger.v3.oas.annotations.security.SecurityRequirement[] securityRequirements = securityParser<br>                .getSecurityRequirements(handlerMethod);<br>        <span class="hljs-keyword">if</span> (securityRequirements != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (securityRequirements.length == <span class="hljs-number">0</span>)<br>                operation.setSecurity(Collections.emptyList());<br>            <span class="hljs-keyword">else</span><br>                securityParser.buildSecurityRequirement(securityRequirements, operation);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> operation;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildTagsFromMethod</span><span class="hljs-params">(Method method, Set&lt;io.swagger.v3.oas.models.tags.Tag&gt; tags, Set&lt;String&gt; tagsStr, Locale locale)</span> </span>&#123;<br>        <span class="hljs-comment">// method tags</span><br>        Set&lt;Tags&gt; tagsSet = AnnotatedElementUtils<br>                .findAllMergedAnnotations(method, Tags.class);<br>        Set&lt;io.swagger.v3.oas.annotations.tags.Tag&gt; methodTags = tagsSet.stream()<br>                .flatMap(x -&gt; Stream.of(x.value())).collect(Collectors.toSet());<br>        methodTags.addAll(AnnotatedElementUtils.findAllMergedAnnotations(method, io.swagger.v3.oas.annotations.tags.Tag.class));<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(methodTags)) &#123;<br>            tagsStr.addAll(methodTags.stream().map(tag -&gt; propertyResolverUtils.resolve(tag.name(), locale)).collect(Collectors.toSet()));<br>            List&lt;io.swagger.v3.oas.annotations.tags.Tag&gt; allTags = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(methodTags);<br>            addTags(allTags, tags, locale);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTags</span><span class="hljs-params">(List&lt;io.swagger.v3.oas.annotations.tags.Tag&gt; sourceTags, Set&lt;io.swagger.v3.oas.models.tags.Tag&gt; tags, Locale locale)</span> </span>&#123;<br>        Optional&lt;Set&lt;io.swagger.v3.oas.models.tags.Tag&gt;&gt; optionalTagSet = AnnotationsUtils<br>                .getTags(sourceTags.toArray(<span class="hljs-keyword">new</span> io.swagger.v3.oas.annotations.tags.Tag[<span class="hljs-number">0</span>]), <span class="hljs-keyword">true</span>);<br>        optionalTagSet.ifPresent(tagsSet -&gt; &#123;<br>            tagsSet.forEach(tag -&gt; &#123;<br>                tag.name(propertyResolverUtils.resolve(tag.getName(), locale));<br>                tag.description(propertyResolverUtils.resolve(tag.getDescription(), locale));<br>                <span class="hljs-keyword">if</span> (tags.stream().noneMatch(t -&gt; t.getName().equals(tag.getName())))<br>                    tags.add(tag);<br>            &#125;);<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为服务添加<code>Springdoc</code>的配置</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">springdoc.api-docs.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">springdoc.api-docs.path</span>=<span class="hljs-string">/v3/api-docs</span><br><span class="hljs-meta">springdoc.info.title</span>=<span class="hljs-string">System API</span><br><span class="hljs-meta">springdoc.info.description</span>=<span class="hljs-string">System API</span><br><span class="hljs-meta">springdoc.info.version</span>=<span class="hljs-string">1.0.0</span><br></code></pre></div></td></tr></table></figure><p>编写<code>Controller</code>接口如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Controller</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queryDTO 查询条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> List &#125;&lt;&#123;<span class="hljs-doctag">@link</span> TestVO &#125;&gt; 查询结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/query&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TestVO&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestQueryDTO queryDTO)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>接口参数DTO和返回结果VO定义如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试DTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestQueryDTO</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 年龄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生日</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> LocalDate birthday;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVO</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 年龄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生日</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> LocalDate birthday;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 其他</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String others;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动项目，使用<code>Postman</code>导入接口<code>api-docs</code>，<code>api-docs</code>的路径为服务配置的<code>/v3/api-docs</code></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/springdoc-javadoc-postman.png"></p><p>或者使用<code>ApiFox</code>等对API文档支持更好的软件，能看到接口的详细信息</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/springdoc-javadoc-apifox.png"></p><p>如图，接口、实体类的<code>JavaDoc</code>信息已被提取到API文档中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过结合<code>Springdoc</code>和<code>Javadoc</code>，你可以轻松地生成完整的API文档，不仅节省了手动编写文档的时间，也减少了维护文档的工作量。结合本文中的配置方法，你可以自定义文档的各个部分，使项目协作更加高效便捷。</p>]]></content>
    
    
    <categories>
      
      <category>Springdoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springdoc</tag>
      
      <tag>OpenAPI，项目协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-ApplicationContext-Web</title>
    <link href="/2024/09/23/spring-application-web/"/>
    <url>/2024/09/23/spring-application-web/</url>
    
    <content type="html"><![CDATA[<p>我们将以常见的Web应用开发对ApplicationContext进行展开，本篇文章将初步介绍Spring Boot提供了构建两种主要Web应用模型的能力：传统的基于Servlet的模型和新兴的基于响应式编程的模型。本文将探索这两种模型的特点、适用场景以及对应的类图。                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于Spring Boot实现的Web应用可分为两类</p><ul><li>传统的Servlet Web应用</li><li>响应式Web应用</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="Servlet-Web"><a href="#Servlet-Web" class="headerlink" title="Servlet Web"></a>Servlet Web</h3><ul><li>当应用不需要处理大量的并发请求或实时数据流。</li><li>当与传统数据库进行频繁交互，且数据库交互本身是阻塞式的。</li><li>企业内部管理系统，用户交互不频繁，数据处理量大但并发需求低。</li></ul><h3 id="响应式Web"><a href="#响应式Web" class="headerlink" title="响应式Web"></a>响应式Web</h3><ul><li>当应用需处理大量的并发请求，且每个请求涉及的数据处理不会阻塞线程，如请求可以异步处理。</li><li>在微服务之间需要高吞吐量的消息传递时。</li><li>需要与非阻塞的客户端（如现代Web浏览器）或服务进行交互，特别是使用WebSockets或Server-Sent Events。</li></ul><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><h3 id="Servlet-Web-1"><a href="#Servlet-Web-1" class="headerlink" title="Servlet Web"></a>Servlet Web</h3><ul><li><strong>传统的企业级应用</strong>：例如，需要与JDBC、JPA等传统数据库交互，以及集成多种服务（如JMS、Email服务等）的系统。</li><li><strong>阻塞式操作</strong>：应用中大量操作是阻塞式的，如文件处理、同步HTTP调用等，且这些操作没有明显的性能瓶颈或需求。</li><li><strong>成熟的技术栈支持</strong>：利用广泛的第三方库和框架，这些通常是为阻塞式环境设计的。</li></ul><h3 id="响应式Web-1"><a href="#响应式Web-1" class="headerlink" title="响应式Web"></a>响应式Web</h3><ul><li><strong>实时数据处理应用</strong>：如实时消息服务、实时数据监控和分析等。</li><li><strong>高并发应用</strong>：适用于需要高效处理大量并发连接和网络交互的应用，如在线游戏服务器、大规模聊天应用。</li><li><strong>微服务架构</strong>：在基于微服务的架构中，响应式编程可以提高服务之间的通信效率，尤其是在使用事件驱动架构时。</li></ul><h2 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h2><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>检查项目的构建配置文件，确定项目引用了哪些<code>Spring Boot Starter</code></p><ul><li><p><strong>Servlet Web应用</strong>：通常会包含<code>spring-boot-starter-web</code>，它依赖于<code>spring-webmvc</code>，这表明使用的是 <code>Servlet API</code>。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>响应式Web应用</strong>：则会包含<code>spring-boot-starter-webflux</code>，它依赖于<code>spring-webflux</code>模块。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="启动日志"><a href="#启动日志" class="headerlink" title="启动日志"></a>启动日志</h3><ul><li><p><strong>Servlet Web应用</strong>：使用Servlet API，默认使用的Java Web应用服务器为Tomcat，启动时会报如下日志</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">INFO 14560 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)<br>INFO 14560 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]<br>INFO 14560 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.83]<br>INFO 14560 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext<br>INFO 14560 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> 563 ms<br>INFO 14560 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>响应式Web应用</strong>：使用响应式Web框架Web Flux，默认使用Netty作为服务器，启动时会报如下日志</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">INFO 13688 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 8080<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>观察应用中的控制器实现：</p><ul><li><p><strong>Servlet Web应用</strong>：控制器可能使用<code>@RestController</code>和<code>@RequestMapping</code>或 <code>@GetMapping</code>、<code>@PostMapping</code>等注解，且处理方法通常返回<code>ModelAndView</code>、<code>String</code>或<code>ResponseEntity</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>响应式Web应用</strong>：控制器可能使用<code>@RestController</code>和<code>@GetMapping</code>等注解，但处理方法返回的是<code>Mono&lt;T&gt;</code>或<code>Flux&lt;T&gt;</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactiveController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p>关于应用上下文的最终实现：</p><h3 id="Servlet-Web-2"><a href="#Servlet-Web-2" class="headerlink" title="Servlet Web"></a>Servlet Web</h3><p>最终实现为<code>AnnotationConfigServletWebServerApplicationContext</code>，类图如下</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/annotation-config-servlet-web-server-application-context-diagram.png" alt="AnnotationConfigServletWebServerApplicationContext类图"></p><h3 id="响应式Web-2"><a href="#响应式Web-2" class="headerlink" title="响应式Web"></a>响应式Web</h3><p>最终实现为<code>AnnotationConfigReactiveWebServerApplicationContext</code>，类图如下</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/annotation-config-reactive-web-server-application-context-diagram.png" alt="AnnotationConfigReactiveWebServerApplicationContext类图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章简单介绍了基于Spring Boot的Servlet Web应用和响应式Web应用的设计理念和实现方式，这也是开发中最常见的Spring Boot开发模型，下一篇我们将对两种Web应用的ApplicationContext实现进行展开，探究各类应用上下文的特点。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-ApplicationContext初认识</title>
    <link href="/2024/09/18/spring-application-context-interface/"/>
    <url>/2024/09/18/spring-application-context-interface/</url>
    
    <content type="html"><![CDATA[<p>Spring的<code>ApplicationContext</code>提供了一个功能丰富的环境。本文将对<code>ApplicationContext</code>做一个初步的介绍，主要是对其实现的接口做一个详细说明。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>SpringBoot项目的启动方法会返回一个<code>ConfigurableApplicationContext</code>类型的对象，其类图如下：</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/configurable-application-context-diagram.png" alt="ConfigurableApplicationContext类图"></p><p>由图可知<code>ApplicationContext</code>主要实现了以下接口，分别为：</p><ol><li><strong><code>BeanFactory</code></strong></li><li><strong><code>MessageSource</code></strong></li><li><strong><code>ResourcePatternResolver</code></strong></li><li><strong><code>EnvironmentCapable</code></strong></li><li><strong><code>ApplicationEventPublisher</code></strong></li></ol><p>下面将依次对这些接口进行说明。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>Spring框架中最基础、最核心的组件，用于管理Java对象（beans）。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><code>BeanFactory</code>中提供了许多有关于Bean的API</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/bean-factory-api.png" alt="bean-factory-api"></p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><strong>依赖注入</strong>：<code>BeanFactory</code>通过控制反转（<code>IoC</code>）的方式管理bean，即bean的创建和依赖关系不是由bean自己控制，而是由<code>BeanFactory</code>进行管理。这有助于降低组件间的耦合度。</li><li><strong>生命周期管理</strong>：<code>BeanFactory</code>管理bean的整个生命周期，从创建、初始化、使用到销毁，包括调用初始化和销毁回调。</li><li><strong>bean的后处理</strong>：通过<code>BeanPostProcessor</code>接口，<code>BeanFactory</code>允许对bean实例进行额外的处理，比如检查bean属性的完整性或者对bean进行代理。</li></ul><h3 id="实现类和用法"><a href="#实现类和用法" class="headerlink" title="实现类和用法"></a>实现类和用法</h3><ul><li><p>**<code>XmlBeanFactory</code>**（现已废弃）：这是早期版本的Spring中使用的一个实现，它从XML文件中读取bean定义。</p></li><li><p>**<code>DefaultListableBeanFactory</code>**：这是一个全功能的bean容器，支持从XML文件、Java注解等多种配置源加载bean。它还支持按类型和按名称自动装配依赖。</p></li><li><p>**<code>GenericApplicationContext</code>**：配合<code>DefaultListableBeanFactory</code>使用，提供了一个灵活的应用上下文实现。</p></li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>查看<code>DefaultListableBeanFactory</code>的类图，如下</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/default-listable-bean-factory.png" alt="default-listable-bean-factory"></p><p>由图可知，<code>DefaultListableBeanFactory</code>类继承了<code>DefaultSingletonBeanRegistry</code>类，这个类中包含一个成员变量<code>singletonObjects</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></div></td></tr></table></figure><p>这个成员变量就存放着我们所熟知的单例bean</p><p>我们可以先自定义两个组件</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;component1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component1</span> </span>&#123;<br>&#125;<br><br><span class="hljs-meta">@Component(&quot;component2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component2</span> </span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在项目启动以后，通过<code>ApplicationContext</code>拿到<code>BeanFactory</code>的实例对象，再通过反射的方法读取到所有的单例bean</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 使用反射获取DefaultSingletonBeanRegistry中的singletonObjects成员变量</span><br>Class&lt;DefaultSingletonBeanRegistry&gt; clazz = DefaultSingletonBeanRegistry.class;<br>Field singletonObjects = clazz.getDeclaredField(<span class="hljs-string">&quot;singletonObjects&quot;</span>);<br>singletonObjects.setAccessible(<span class="hljs-keyword">true</span>);<br>ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>Map&lt;String, Object&gt; singletonObjectsValue = (Map&lt;String, Object&gt;)singletonObjects.get(beanFactory);<br>singletonObjectsValue.forEach((k, v) -&gt; &#123;<br><span class="hljs-keyword">if</span> (k.startsWith(<span class="hljs-string">&quot;component&quot;</span>)) &#123;<br>System.out.println(k + <span class="hljs-string">&quot; : &quot;</span> + v);<br>&#125;<br>&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行SpringBoot项目，控制台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">component1 : space.yangtao.spring.component.Component1@55dfcc6<br>component2 : space.yangtao.spring.component.Component2@222eb8aa<br></code></pre></div></td></tr></table></figure><h2 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h2><p><code>MessageSource</code> 是一个用于解决国际化（<code>i18n</code>）和本地化（<code>l10n</code>）消息的接口。它提供了一种从多种源加载消息的方式，并支持消息的国际化，即根据不同的地区显示不同的消息。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>国际化和本地化</strong>：<code>MessageSource</code>允许应用程序根据用户的地区（<code>Locale</code>）加载特定的消息。这使得创建多语言应用变得简单。</li><li><strong>消息格式化</strong>：支持带有参数的消息，可以在运行时传递变量，实现动态消息文本。</li><li><strong>继承结构</strong>：<code>MessageSource</code>可以配置为层级结构，如果在一个<code>MessageSource</code>中找不到消息，它会查询其父<code>MessageSource</code>。</li></ul><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li><code>String getMessage(String code, Object[] args, String defaultMessage, Locale locale)</code>：尝试根据消息代码、参数、默认消息和地区解析消息。如果找不到对应代码的消息，则返回默认消息。</li><li><code>String getMessage(String code, Object[] args, Locale locale) throws NoSuchMessageException</code>：根据消息代码、参数和地区解析消息。如果找不到消息，则抛出异常。</li><li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException</code>：这是一个更高级的方法，允许通过<code>MessageSourceResolvable</code>对象，对象中包含多个消息代码和参数，对消息代码进行遍历解析，找到对应的消息后立即返回。如果找不到消息，则抛出异常。</li></ul><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><ol><li><p>在<code>resources</code>目录下新建配置文件</p><p><code>message.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">hello</span>=<span class="hljs-string">接收 &#123;0&#125; ，返回 你好</span><br></code></pre></div></td></tr></table></figure><p><code>message_en_US.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">hello</span>=<span class="hljs-string">get &#123;0&#125; and return hello</span><br></code></pre></div></td></tr></table></figure><p>这两个配置文件中通过占位符，支持了动态传参</p></li><li><p>项目配置文件<code>application.properties</code>中配置消息的基名以及编码格式，如果此步不配置，则SpringBoot的自动装配会默认将<code>basename</code>取值为<code>“message”</code>，默认编码格式为<code>“UTF-8”</code></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.messages.basename</span>=<span class="hljs-string">message</span><br><span class="hljs-meta">spring.messages.encoding</span>=<span class="hljs-string">UTF-8</span><br></code></pre></div></td></tr></table></figure></li><li><p>新建接口，获取<code>message</code>参数，通过<code>getMessage</code>方法获取其国际化的值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> MessageSource messageSource;<br><br><span class="hljs-meta">@GetMapping(&quot;/&#123;message&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message, Locale locale)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> messageSource.getMessage(message, <span class="hljs-keyword">new</span> Object[]&#123;message&#125;, <span class="hljs-string">&quot;No Such Message&quot;</span>, locale);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl -XGET http://localhost:8080/message/hello<br>接收 hello ，返回 你好<br><br>curl -XGET -H <span class="hljs-string">&quot;Accept-Language&quot;</span>:<span class="hljs-string">&quot;en-US&quot;</span> http://localhost:8080/message/hello<br>get hello and <span class="hljs-built_in">return</span> hello<br><br>curl -XGET -H <span class="hljs-string">&quot;Accept-Language&quot;</span>:<span class="hljs-string">&quot;en-US&quot;</span> http://localhost:8080/message/hello2<br>No Such Message<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h2><p><code>ResourcePatternResolver</code>是一个用于加载资源（如配置文件、图像文件等）的接口，它扩展了<code>ResourceLoader</code>接口的功能，提供了一种在<code>classpath</code>或其他位置查找资源的更灵活方式。<code>ResourcePatternResolver</code>可以解析特定模式的资源路径，可以一次性查找符合特定模式的所有资源。</p><h3 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>模式匹配</strong>：<code>ResourcePatternResolver</code>支持使用通配符和其他模式来匹配资源路径，如<code>classpath*:</code>、<code>file:</code>和<code>ant</code>风格的路径模式（如<code>**/*.xml</code>）。</li><li><strong>资源查找</strong>：它能够查找并返回符合指定模式的所有<code>Resource</code>实例，这些<code>Resource</code>实例可以代表文件系统中的文件、<code>classpath</code>中的元素或其他任何形式的资源。</li></ul><h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li><code>Resource[] getResources(String locationPattern)</code>方法用于根据提供的路径模式返回<code>Resource</code>数组。这个方法是用来解析资源模式并加载所有匹配的资源。</li></ul><h3 id="常用的资源模式"><a href="#常用的资源模式" class="headerlink" title="常用的资源模式"></a>常用的资源模式</h3><ul><li><strong>单一路径</strong>：使用<code>classpath:</code>（类路径）、<code>classpath*:</code>（含jar包类路径）、<code>file:</code>（磁盘路径）。</li><li><strong>所有匹配资源</strong>：使用<code>classpath*:</code> 等前缀配合<code>**</code>（表示多层路径）和<code>*</code>（表示任意字符）的组合，查找所有匹配的资源。例如，<code>classpath*:/**/*.xml</code>可以查找所有<code>classpath</code>路径及其子路径下的<code>XML</code>文件。</li></ul><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><p>项目启动时获取SpringBoot自动配置的相关文件（<code>META-INFO</code>下<code>spring.factories</code>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);<br><br>Resource[] resources = context.getResources(<span class="hljs-string">&quot;classpath*:META-INF/spring.factories0&quot;</span>);<br><span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>    System.out.println(resource);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">URL [jar:file:/C:/Users/yangtao/.m2/repository/org/springframework/boot/spring-boot/2.7.18/spring-boot-2.7.18.jar!/META-INF/spring.factories]<br>URL [jar:file:/C:/Users/yangtao/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.7.18/spring-boot-autoconfigure-2.7.18.jar!/META-INF/spring.factories]<br>URL [jar:file:/C:/Users/yangtao/.m2/repository/org/springframework/spring-beans/5.3.31/spring-beans-5.3.31.jar!/META-INF/spring.factories]<br></code></pre></div></td></tr></table></figure><h2 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h2><p><code>EnvironmentCapable</code>的主要用途是提供对<code>Environment</code>对象的访问。<code>Environment</code>是Spring中用于封装所有与环境相关的属性，例如配置文件、系统属性、环境变量等的抽象。</p><h3 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h3><p>获取当前应用上下文或组件相关联的<code>Environment</code>对象，该对象具有如下功能：</p><ul><li><strong>属性解析</strong>：<code>Environment</code>提供方法来解析属性，支持从多种源读取，如<code>JVM</code>系统属性、环境变量、配置文件等。</li><li><strong>配置文件管理</strong>：在基于SpringBoot的应用中，<code>Environment</code>接口特别有用，因为它可以管理和激活不同的配置文件（如<code>application-dev.properties</code>，<code>application-prod.properties</code>等）。</li><li><strong>属性覆盖</strong>：<code>Environment</code>允许对同一属性的不同值进行覆盖，按照特定的优先级排序（如系统属性可以覆盖配置文件中的值）。SpringBoot属性加载顺序优先级由高到低依次为：<ul><li><code>Devtools</code>全局设置（仅在使用<code>Spring Boot Devtools</code>时适用）</li><li>命令行参数（如：<code>java -jar app.jar --app.name=&quot;My App&quot;</code>）</li><li>系统环境变量</li><li><code>JVM</code>系统属性（如：<code>java -Dapp.name=&quot;My App&quot; -jar app.jar</code>）</li><li>应用属性文件（如：<code>application.properties</code>或<code>application.yml</code>）</li><li>应用内部默认属性（如：通过<code>@PropertySource</code>注解或在配置类中以编程方式设置的属性）</li></ul></li><li><strong>条件化配置</strong>：Spring的条件化配置（<code>@Conditional</code>注解）可以使用<code>Environment</code>对象来检查某些属性是否存在或满足特定值，从而决定是否激活某个配置或组件。</li></ul><h3 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo"></a>Demo</h3><ol><li><p>读取系统变量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);<br><br>ConfigurableEnvironment environment = context.getEnvironment();<br>String javaHome = environment.getProperty(<span class="hljs-string">&quot;JAVA_HOME&quot;</span>);<br>String port = environment.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;JAVA_HOME: &quot;</span> + javaHome);<br>System.out.println(<span class="hljs-string">&quot;server.port: &quot;</span> + port);<br></code></pre></div></td></tr></table></figure><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">JAVAE_HOME: /usr/lib/jvm/java-8-openjdk-amd64<br>server.port: 8080<br></code></pre></div></td></tr></table></figure></li><li><p>创建配置文件application-prod.properties</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><br></code></pre></div></td></tr></table></figure><p>SpringBoot应用添加启动的参数</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">--spring.profiles.active=prod<br></code></pre></div></td></tr></table></figure><p>添加以上参数以后，即可更换应用的配置项，运行项目后控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">JAVA_HOME: C:\Program Files\Java\jdk1.8.0_281<br>server.port: 8081<br></code></pre></div></td></tr></table></figure></li><li><p>启动参数中指定<code>JAVA_HOME</code>属性</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">--JAVA_HOME=<span class="hljs-string">&quot;/usr/local/java&quot;</span><br></code></pre></div></td></tr></table></figure><p>运行项目后控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">JAVA_HOME: /usr/<span class="hljs-built_in">local</span>/java<br></code></pre></div></td></tr></table></figure></li><li><p>创建条件类<code>ProdCondition</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;prod&quot;</span>.equals(context.getEnvironment().getProperty(<span class="hljs-string">&quot;env&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建组件<code>ProdComponent</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Conditional(ProdCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdComponent</span> </span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>项目启动时指定参数 <code>env</code>值为<code>prod</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">--env=<span class="hljs-string">&quot;prod&quot;</span><br></code></pre></div></td></tr></table></figure><p>应用启动时检测应用中是否含有组件<code>ProdComponent</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);<br><br><span class="hljs-keyword">try</span> &#123;<br>    AtomicBoolean hasProdComponent = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>    Class&lt;DefaultSingletonBeanRegistry&gt; clazz = DefaultSingletonBeanRegistry.class;<br>    Field singletonObjects = clazz.getDeclaredField(<span class="hljs-string">&quot;singletonObjects&quot;</span>);<br>    singletonObjects.setAccessible(<span class="hljs-keyword">true</span>);<br>    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>    Map&lt;String, Object&gt; singletonObjectsValue = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);<br>    singletonObjectsValue.forEach((k, v) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> ProdComponent) &#123;<br>            hasProdComponent.set(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;hasProdComponent: &quot;</span> + hasProdComponent.get());<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动应用，控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hasProdComponent: <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>去除项目启动时的参数 <code>env</code> 或改变其值，则控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hasProdComponent: <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h2><p><code>ApplicationEventPublisher</code>提供了发布事件到应用程序中所有注册的监听器的功能。这是Spring事件驱动模型的核心部分，允许组件之间进行松耦合的通信。通过使用事件，可以在应用程序的不同部分传递状态信息或改变通知，而不需要直接调用其他部分的代码。</p><h3 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><strong>事件发布</strong>：<code>ApplicationEventPublisher</code>允许应用程序组件发布广泛的事件，这些事件可以是任何扩展自 <code>ApplicationEvent</code>的对象。</li><li><strong>松耦合的架构</strong>：事件发布者与事件监听者之间不需要直接的引用或知识，他们通过事件对象进行交互，从而降低了系统各部分之间的耦合度。</li></ul><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><ul><li><code>void publishEvent(ApplicationEvent event)</code>：发布一个继承自<code>ApplicationEvent</code>的事件。</li><li><code>void publishEvent(Object event)</code>：从Spring Framework 4.2开始，可以发布任何对象作为事件，不再限制于<code>ApplicationEvent</code>的子类。</li></ul><h3 id="Demo-4"><a href="#Demo-4" class="headerlink" title="Demo"></a>Demo</h3><ol><li><p>定义一个应用运行事件<code>AppRunEvent</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRunEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long timestamp;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AppRunEvent</span><span class="hljs-params">(Object source, Long timestamp)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(source);<br>        <span class="hljs-keyword">this</span>.timestamp = timestamp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTimeStamp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>创建这个监听这个事件的监听器<code>AppRunListener</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">AppRunEvent</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(AppRunEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AppRunListener: &quot;</span> + event.getTimeStamp());<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在项目启动时发布事件</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);<br>context.publishEvent(<span class="hljs-keyword">new</span> AppRunEvent(context, System.currentTimeMillis()));<br></code></pre></div></td></tr></table></figure></li><li><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">AppRunListener: 1726590020427<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了Spring框架的核心组件<code>ApplicationContext</code>及其扩展接口，通过对这些接口的了解，开发者可以更好地利用Spring框架提供的强大功能，以构建灵活、可维护的应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂运算</title>
    <link href="/2024/08/13/alg-fast-exponentiation/"/>
    <url>/2024/08/13/alg-fast-exponentiation/</url>
    
    <content type="html"><![CDATA[<p>在计算机科学和数值计算中，快速幂运算是一种非常高效的算法，用于计算幂运算a<sup>n</sup>，尤其是当n非常大时。传统的幂运算方法通过连续乘法实现，时间复杂度为O(n)。然而，快速幂算法通过减少乘法的次数，将时间复杂度降低到O(log⁡ n)，显著提高了计算效率。本文详细介绍了快速幂算法的原理、实现方法及其在取模运算中的应用。</p><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>快速幂算法的核心是“倍增法”，也就是连续平方。例如，计算a<sup>64</sup>可以通过以下步骤实现：</p><p>a<sup>1</sup> × a<sup>1</sup> = a<sup>2</sup></p><p>a<sup>2</sup> × a<sup>2</sup> = a<sup>4</sup></p><p>a<sup>4</sup> × a<sup>4</sup> = a<sup>8</sup></p><p>a<sup>8</sup> × a<sup>8</sup> = a<sup>16</sup></p><p>a<sup>16</sup> × a<sup>16</sup> = a<sup>32</sup></p><p>a<sup>32</sup> × a<sup>32</sup> = a<sup>64</sup></p><p>这种方法将时间复杂度降低到了O(log n)。</p><h2 id="扩展算法"><a href="#扩展算法" class="headerlink" title="扩展算法"></a>扩展算法</h2><p>当n不是2的幂时，如何计算a<sup>27</sup>呢？关键在于将指数n分解为2的幂之和。例如 a<sup>27</sup> = a<sup>1</sup> × a<sup>2</sup> × a<sup>8</sup> × a<sup>16</sup>。这需要将27分解为二进制形式，每个1的位置对应一个幂，即：</p><table><thead><tr><th>十进制</th><th>二进制</th></tr></thead><tbody><tr><td>27</td><td>0  1  1  0  1  1</td></tr><tr><td>1</td><td>0  0  0  0  0  1</td></tr><tr><td>2</td><td>0  0  0  0  1  0</td></tr><tr><td>8</td><td>0  0  1  0  0  0</td></tr><tr><td>16</td><td>0  1  0  0  0  0</td></tr></tbody></table><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><p>下面是快速幂运算的Java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>) &#123;<br>            result *= a;<br>        &#125;<br>        a *= a;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="运算过程"><a href="#运算过程" class="headerlink" title="运算过程"></a>运算过程</h2><table><thead><tr><th>循环次数</th><th>二进制的n</th><th>a</th><th>n mod 2 == 1?</th><th>result</th></tr></thead><tbody><tr><td>1</td><td>0 1 1 0 1 1</td><td>2^1</td><td>true</td><td>2^1</td></tr><tr><td>2</td><td>0 1 1 0 1</td><td>2^2</td><td>true</td><td>2^1 × 2^2</td></tr><tr><td>3</td><td>0 1 1 0</td><td>2^4</td><td>false</td><td>2^1 × 2^2</td></tr><tr><td>4</td><td>0 1 1</td><td>2^8</td><td>true</td><td>2^1 × 2^2 × 2^8</td></tr><tr><td>5</td><td>0 1</td><td>2^16</td><td>true</td><td>2^1 × 2^2 × 2^8 × 2^16</td></tr><tr><td>6</td><td>0 （退出）</td><td></td><td></td><td></td></tr></tbody></table><h2 id="应用：快速幂取模"><a href="#应用：快速幂取模" class="headerlink" title="应用：快速幂取模"></a>应用：快速幂取模</h2><p>当涉及到取模运算时（如a<sup>n</sup> mod m），可以使用快速幂取模的方法，根据a<sup>n</sup> mod m = (a<sup>1</sup> × a<sup>n-1</sup>) mod m = ((a<sup>1</sup> mod m) × (a<sup>n-1</sup> mod m)) mod m可得其Java代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>) &#123;<br>            res = (res * a) mod m;<br>        &#125;<br>        a = (a * a) mod m;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速幂算法是处理大数幂运算中不可或缺的工具，它不仅优化了运算效率，还广泛应用于密码学、图形学和其他需要快速计算幂的领域。文章中介绍的方法和技巧，特别是对模运算的应用，为解决实际编程问题提供了强有力的工具。掌握快速幂算法，将帮助开发者在需要进行高效幂运算的场景中，实现快速和准确的计算。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>幂运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/08/11/alg-binary-search/"/>
    <url>/2024/08/11/alg-binary-search/</url>
    
    <content type="html"><![CDATA[<p>二分查找是计算机科学中一种基本而强大的算法，它允许在对数时间内快速查找有序集合中的元素。这种方法通过不断将搜索区间分成两半来快速定位目标值，广泛应用于算法竞赛和软件开发中，接下来本文将对二分查找进行详细的介绍。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>二分查找（Binary Search）</strong>，也称为折半查找，是一种在有序数组中查找某一特定元素的搜索算法。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>目标target</strong>：要查找的值。</li><li><strong>索引index</strong>：查找的当前位置。</li><li><strong>左右指示符left、right</strong>：维持查找空间的指标。</li><li><strong>中间指示符mid</strong>：用来应用条件以确定向左查找还是向右查找的索引。</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>通过不断将待查找的数据范围分成两半，然后根据中间值与目标值的比较，决定下一步在哪一半中继续查找，由于每次都能将搜索范围缩小一半，所以能加快搜索速度。</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li><strong>初始化</strong>：设定两个指针，一个指向数组的起始位置（<code>left</code>），另一个指向数组的结束位置（<code>right</code>）。</li><li><strong>中间元素比较</strong>：计算中间位置的索引 <code>mid = left + (right - left) / 2</code>，并比较中间元素与目标值：<ul><li>如果中间元素等于目标值，搜索结束，返回该位置的索引。</li><li>如果中间元素小于目标值，说明目标值位于数组的后半段，调整 <code>left</code> 指针到 <code>mid + 1</code>。</li><li>如果中间元素大于目标值，说明目标值位于数组的前半段，调整 <code>right</code> 指针到 <code>mid - 1</code>。</li></ul></li><li><strong>迭代或递归</strong>：重复上述步骤，每次都根据比较结果调整查找范围，直到 <code>left</code> 指针超过 <code>right</code> 指针，这时如果仍未找到目标值，则表示数组中不存在该元素，返回 -1 或其他标识未找到的结果。</li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：<code>O(log n)</code>，因为每次查找都将查找范围缩小为原来的一半。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了常数空间。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>高效</strong>：二分查找的时间复杂度为 <code>O(log n)</code>，其中 n 是数组的长度。相较于线性查找的 <code>O(n)</code>，二分查找在大数据集上表现更优。</li><li><strong>前提条件</strong>：二分查找要求数据结构是有序的。对于无序数据集，必须先进行排序，这可能会增加额外的时间成本。</li><li><strong>适用场景</strong>：最适合用于不经常变动但频繁搜索的数据集。例如，数据库的索引通常就是利用类似二分查找的算法进行优化的。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>用以下这道标准的二分查找为例，根据指针边界的定义（即区间的开闭情况），可分为4个模板。</p><p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（LeetCode）</a></p><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p></blockquote><h3 id="Ⅰ-左闭右闭"><a href="#Ⅰ-左闭右闭" class="headerlink" title="Ⅰ 左闭右闭"></a>Ⅰ 左闭右闭</h3><p>搜索区间包含左右边界，即<code>[left, right]</code>，适用于大多数基本的二分查找问题，其中目标值可能刚好位于数组的端点。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化左指针为0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化右指针为数组长度减1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 当处于合法区间（左指针不大于右指针）时，继续循环</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 计算中间位置</span><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 如果中间元素大于目标值，则将新的二分查找范围缩减为mid的左区间</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// mid已经明确不符合条件，为了满足新区间的右闭，所以新区间取值为[left, mid - 1]</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果中间元素小于目标值，则将新的二分查找范围缩减为mid右区间</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// mid已经明确不符合条件，为了满足新区间的左闭，所以新区间取值为[mid + 1, right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果中间元素等于目标值, 则返回中间位置，即找到目标值</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值，返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Ⅱ-左闭右开"><a href="#Ⅱ-左闭右开" class="headerlink" title="Ⅱ 左闭右开"></a>Ⅱ 左闭右开</h3><p>搜索区间包括左边界但不包括右边界，即<code>[left, right)</code>，常见于某些编程语言的标准库实现中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// mid已经明确不符合条件，为了满足新区间的右开，所以新区间取值为[left, mid)</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Ⅲ-左开右闭"><a href="#Ⅲ-左开右闭" class="headerlink" title="Ⅲ 左开右闭"></a>Ⅲ 左开右闭</h3><p>搜索区间不包括左边界但包括右边界，即<code>(left, right]</code>，比较少见，但可能适用于某些需要初始边界外扩展的特定算法设计，如处理某些周期性边界问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt;= right) &#123;<br>            <span class="hljs-comment">// 注意此处 +1 处理：mid的计算方式向右收缩更加积极，规避程序除法向下取整导致无法缩小范围的死循环</span><br>            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// mid已经明确不符合条件，为了满足新区间的左开，所以新区间取值为(mid, right]</span><br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Ⅳ-左开右开"><a href="#Ⅳ-左开右开" class="headerlink" title="Ⅳ 左开右开"></a>Ⅳ 左开右开</h3><p>搜索区间既不包括左边界也不包括右边界，即<code>(left, right)</code>，较少使用，适合于需要频繁调整边界判定逻辑的复杂查找或特殊情况处理。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-comment">// mid已经明确不符合条件，且为了满足新区间的左开右开，因此新区间取值为(left, mid)或(mid, right)</span><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="标准二分"><a href="#标准二分" class="headerlink" title="标准二分"></a>标准二分</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/search-insert-position/description/">35. 搜索插入位置 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811223220561.png"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个问题是典型的二分查找应用。给定一个无重复元素的升序数组和一个目标值，需要找到目标值在数组中的索引或者应该插入的位置。二分查找是解决这类问题的理想方法，因为它能够在对数时间内缩小搜索范围。</p><h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>初始化指针</strong>：设置两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的开始和结束位置。</li><li><strong>二分搜索</strong>：计算中点 <code>mid</code> 并比较 <code>nums[mid]</code> 和 <code>target</code>：<ol><li>如果 <code>nums[mid]</code> 等于 <code>target</code>，直接返回 <code>mid</code> 作为答案。</li><li>如果 <code>nums[mid]</code> 大于 <code>target</code>，调整 <code>right</code> 指针到 <code>mid - 1</code>，因为目标值在左半边。</li><li>如果 <code>nums[mid]</code> 小于 <code>target</code>，调整 <code>left</code> 指针到 <code>mid + 1</code>，因为目标值在右半边。</li></ol></li><li><strong>找到插入位置</strong>：如果循环结束还没有找到目标值，<code>left</code> 指针将指向应该插入目标值的位置。因为循环终止时，<code>left</code> 是第一个大于 <code>target</code> 的位置的索引。</li></ol><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(logn)</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度。二分查找确保了对数级的搜索时间。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了有限的额外空间。</li></ul><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;  <span class="hljs-comment">// left 是第一个大于 target 的位置</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="数组中查找"><a href="#数组中查找" class="headerlink" title="数组中查找"></a>数组中查找</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/find-right-interval/description/">436. 寻找右区间 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811221144973.png"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>解决这个问题的关键是能够快速找到每个区间的右侧区间。为了实现这一点，可以利用数组的排序和二分搜索。首先，我们需要对区间按起始位置进行排序。然后，对每个区间使用二分搜索来找到第一个起始位置不小于该区间结束位置的其他区间的索引值。</p><h4 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>构建辅助数组</strong>：创建一个数组 <code>arr</code> 来保存原始区间的索引和起始位置。这样在排序后我们仍能追踪到每个区间的原始位置。</li><li><strong>排序</strong>：对 <code>arr</code> 按照区间的起始位置进行排序。排序后，对于任意区间 <code>i</code>，所有在 <code>i</code> 之后的区间都有不小于 <code>i</code> 的起始位置。</li><li><strong>二分搜索</strong>：对于排序后的每个区间，使用二分搜索在 <code>arr</code> 中找到第一个起始位置大于等于该区间结束位置的区间。这个区间就是所求的右侧区间。</li><li><strong>特殊处理</strong>：处理没有右侧区间的情况，即如果二分搜索没有找到符合条件的区间，则为该区间返回 <code>-1</code>。</li></ol><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(nlogn)</code>，主要由排序和对每个区间进行二分搜索的操作组成，每次二分搜索的时间复杂度为 <code>O(log n)</code>，总共需要进行 <code>n</code> 次。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储辅助数组 <code>arr</code> 以及最终的答案数组。</li></ul><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRightInterval(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">int</span> l = intervals.length;<br>        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[l][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>            <span class="hljs-comment">// 保存原始索引</span><br>            arr[i][<span class="hljs-number">0</span>] = i;<br>            arr[i][<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">0</span>];<br>            arr[i][<span class="hljs-number">2</span>] = intervals[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        Arrays.sort(arr, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>            <span class="hljs-comment">// 在arr中查找第一个满足intervals[i][1]&lt;arr[?][1]的arr[?][0]</span><br>            ans[i] = binarySearch(arr, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = arr.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid][<span class="hljs-number">1</span>] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left == arr.length ? -<span class="hljs-number">1</span> : arr[left][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811221419936.png"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>此题要求在一个旋转排序数组中寻找目标值的索引。由于数组原本是升序的，但在某个未知下标上进行了旋转，使得该问题的解决需要考虑旋转的影响。该问题可以通过二分查找的方式解决，首先确定旋转点，然后在适当的半边数组中进行标准的二分查找。</p><h4 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>寻找旋转点</strong>：旋转点是数组中唯一的点，它比其右侧的元素大。通过二分查找来寻找这个点。此过程中，如果中间元素大于数组最右端的元素，旋转点必定在中间元素的右侧；否则，旋转点在左侧或就是中间元素本身。</li><li><strong>判断搜索区域</strong>：确定旋转点后，需要判断目标值位于旋转点的左侧还是右侧。如果目标值在旋转点的值和数组最右端值之间，应在旋转点右侧搜索；否则，在左侧搜索。</li><li><strong>执行二分查找</strong>：在确定的区域内执行标准的二分查找。如果找到目标值，返回其索引；否则，返回 <code>-1</code> 表示目标值不存在。</li></ol><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(logn)</code>，这里 <code>n</code> 是数组的长度。整个过程中，寻找旋转点和在一半的数组中查找目标值都是通过二分查找实现的，每个操作的时间复杂度都是 <code>O(log n)</code>。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了常数个额外空间用于存储变量。</li></ul><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> revIdx = findRevIdx(nums);<br>        <span class="hljs-keyword">if</span> (nums[revIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> revIdx;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[right] &gt;= target) &#123;<br>            <span class="hljs-keyword">return</span> bs(revIdx + <span class="hljs-number">1</span>, right, nums, target);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> bs(left, revIdx - <span class="hljs-number">1</span>, nums, target);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 二分查找返回下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> bs(mid + <span class="hljs-number">1</span>, right, nums, target);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> bs(left, mid - <span class="hljs-number">1</span>, nums, target);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找数组翻转下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRevIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/sqrtx/description/">69. x 的平方根 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811225241200.png"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>计算整数 <code>x</code> 的算术平方根可以通过二分查找实现。问题的关键是找到一个数 <code>m</code>，使得 <code>m^2</code> 最接近且不大于 <code>x</code>。根据题意 <code>x</code> 的取值不会大于 <code>2^31 - 1</code>，可知结果的范围不会超过 <code>2^16</code>，我们可以在 <code>0</code> 到这个数的范围内使用二分查找来寻找这个数。</p><h4 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>初始化二分查找边界</strong>：<code>left</code> 初始化为 <code>0</code>，<code>right</code> 初始化为 <code>65535</code>，或者一个足够大的数（例如 <code>65536</code>，对于本题足够覆盖输入范围内的平方根）。</li><li><strong>二分查找</strong>：在每次迭代中，计算 <code>mid</code> 作为 <code>left</code> 和 <code>right</code> 的平均值 <code>mid</code>，进而计算 <code>mid</code> 的平方 <code>res</code>。为避免整型溢出，使用 <code>long</code> 类型进行计算。<ol><li>如果 <code>res</code> 小于 <code>x</code>，则 <code>mid</code> 可能是答案，但需要尝试更大的数，所以将 <code>left</code> 设置为 <code>mid</code>。</li><li>如果 <code>res</code> 大于 <code>x</code>，说明 <code>mid</code> 太大，需要尝试更小的数，所以将 <code>right</code> 设置为 <code>mid</code>。</li><li>如果 <code>res</code> 等于 <code>x</code>，直接返回 <code>mid</code> 作为答案。</li></ol></li><li><strong>返回结果</strong>：如果循环结束还没有找到恰好等于 <code>x</code> 的平方根，返回 <code>left</code>。这是因为当 <code>left + 1</code> 等于 <code>right</code> 时，已经确认 <code>left</code> 是小于等于 <code>x</code> 平方根的最大整数。</li></ol><h4 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(logx)</code>，二分查找的时间复杂度为对数级。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了固定的额外空间。</li></ul><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> right = <span class="hljs-number">65536</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-keyword">long</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">long</span> res = mid * mid;<br>            <span class="hljs-keyword">if</span> (res &lt; x) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &gt; x) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) left;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/h-index-ii/description/">275. H 指数 II - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811225905952.png"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>这道题目要求计算科研人员的 <code>h</code> 指数，<code>h</code> 指数的定义是至少有 <code>h</code> 篇论文分别被引用了至少 <code>h</code> 次。数组已经按照升序排列，因此我们可以利用二分搜索来加速查找过程。</p><h4 id="解题过程-4"><a href="#解题过程-4" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>初始化</strong>：设定二分搜索的边界，<code>left</code> 为 <code>0</code>，<code>right</code> 为论文总数减一（<code>length - 1</code>）。</li><li><strong>二分搜索</strong>：<ol><li>计算中点 <code>mid</code>，以及中点论文的引用次数 <code>midVal = citations[mid]</code>。</li><li>根据 <code>h</code> 指数的定义，如果 <code>midVal</code> 大于等于从当前论文到数组末尾的论文数量（<code>length - mid</code>），这意味着至少有 <code>length - mid</code> 篇论文被引用了至少 <code>midVal</code> 次。这种情况下，我们尝试查看是否可以有更大的 <code>h</code> 指数，即向左移动 <code>right</code> 边界。</li><li>否则，向右移动 <code>left</code> 边界，尝试找到满足条件的较小论文集合。</li></ol></li><li><strong>更新结果</strong>：如果找到符合条件的 <code>h</code> 指数，更新 <code>ans</code>。</li></ol><h4 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(logn)</code>，这里 <code>n</code> 是数组 <code>citations</code> 的长度。使用二分查找来优化查找过程。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，算法只使用常数额外空间。</li></ul><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] citations)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = citations.length;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> midVal = citations[mid];<br>            <span class="hljs-keyword">if</span> (midVal &gt;= length - mid) &#123;<br>                ans = length - mid;  <span class="hljs-comment">// 更新潜在的 h 指数</span><br>                right = mid - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 尝试寻找一个更大的 h 指数</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 寻找满足条件的更小的集合</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="作为一种方法"><a href="#作为一种方法" class="headerlink" title="作为一种方法"></a>作为一种方法</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811231048103.png"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>为了使递增序列更长，我们要尽量让序列“增长地更慢”，即保证序列中的元素尽可能小，增加后续元素扩展序列的可能性。为此维护一个辅助数组 <code>arr</code>，其中 <code>arr[i]</code> 表示长度为 <code>i+1</code> 的所有递增子序列中末尾元素的最小值。这个方法保证了 <code>arr</code> 数组是单调递增的，使得可以通过二分搜索来优化查找和替换操作。</p><h4 id="解题过程-5"><a href="#解题过程-5" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>初始化</strong>：创建一个数组 <code>arr</code>，用来存储在扫描过程中遇到的递增序列的最小可能末尾值。<code>arrLength</code> 记录 <code>arr</code> 的有效长度，即最长递增子序列的当前最大长度。</li><li><strong>迭代更新</strong>，遍历原数组 <code>nums</code>，对于每个元素<ol><li>如果当前元素 <code>nums[i]</code> 大于 <code>arr</code> 的最后一个元素，则将其添加到 <code>arr</code> 的末尾，因为它可以扩展当前最长的递增子序列。</li><li>如果 <code>nums[i]</code> 小于或等于 <code>arr</code> 的最后一个元素，则使用二分搜索找到第一个不小于 <code>nums[i]</code> 的元素在 <code>arr</code> 中的位置，并替换它。这样做是为了保持 <code>arr</code> 中元素尽可能小，增加后续元素扩展序列的可能性。</li></ol></li><li><strong>二分搜索</strong>：利用二分搜索优化查找和替换操作，确保 <code>arr</code> 中的元素是有序的。</li></ol><h4 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(nlogn)</code>，其中 <code>n</code> 是 <code>nums</code> 数组的长度。每个元素最多进行一次二分搜索，每次搜索的时间复杂度为 <code>O(log n)</code>。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，需要额外的空间来存储 <code>arr</code> 数组。</li></ul><h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        arr[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> arrLength = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; arr[arrLength - <span class="hljs-number">1</span>]) &#123;<br>                arr[arrLength] = nums[i];<br>                arrLength++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> index = binarySearch(arr, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>, nums[i]);<br>                arr[index] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrLength;<br>    &#125;<br><br>    <span class="hljs-comment">// 二分查找target应插入的位置或替换的位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="结合贪心"><a href="#结合贪心" class="headerlink" title="结合贪心"></a>结合贪心</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/split-array-largest-sum/description/">410. 分割数组的最大值 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811231709590.png"></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>此问题要求将一个非负整数数组分割成 <code>k</code> 个连续子数组，使得这些子数组中的最大和最小。为实现此目标，我们采用二分搜索与贪心算法的结合。二分搜索确定最大子数组和的可能最小值，而贪心算法用来验证在给定最大子数组和的约束下是否能有效地分割数组。</p><h4 id="解题过程-6"><a href="#解题过程-6" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>确定二分搜索范围</strong>：<ol><li>下界为数组中的最大值，因为任何有效的分割方式中，最大子数组的和不可能小于数组中的最大单个元素。</li><li>上界为所有数组元素的总和，因为在极端情况下，所有元素都可以在一个子数组中。</li></ol></li><li><strong>二分搜索</strong>：对上述范围进行二分搜索，寻找可以满足条件的最小可能的最大子数组和。</li><li><strong>贪心验证</strong>：对于每个中间值（即二分搜索的当前中值），尝试使用该值作为最大子数组和来分割数组。如果能将数组分割成不超过 <code>k</code> 个这样的子数组，则该中值可行。</li></ol><h4 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(nlogS)</code>，其中 <code>n</code> 是数组的长度，<code>S</code> 是二分搜索的范围，即从 <code>max(nums)</code> 到 <code>sum(nums)</code>。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了有限的额外空间。</li></ul><h4 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            right += num;<br>            <span class="hljs-keyword">if</span> (num &gt; left) &#123;<br>                left = num; <span class="hljs-comment">// 最大的一个元素是最小可能的最大子数组和的下界</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (valid(nums, k, mid)) &#123;<br>                right = mid; <span class="hljs-comment">// 如果可以实现，尝试更小的值</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果不可以实现，尝试更大的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> maxSum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> currentSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 至少需要一个子数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (currentSum + num &gt; maxSum) &#123;<br>                count++;<br>                currentSum = num; <span class="hljs-comment">// 重新开始一个新的子数组</span><br>                <span class="hljs-keyword">if</span> (count &gt; k) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 如果子数组数量超过 k，则不满足条件</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                currentSum += num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="结合动态规划"><a href="#结合动态规划" class="headerlink" title="结合动态规划"></a>结合动态规划</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/description/">1235. 规划兼职工作 - 力扣（LeetCode）</a></p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240811232718366.png"></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>这个问题要求解决的是一种典型的动态规划问题，结合了时间管理和最大化利润。任务是选择一系列不冲突的工作以获得最大收益。这可以通过排序和使用动态规划表来解决，其中利用二分搜索优化了寻找不冲突工作的过程。</p><h4 id="解题过程-7"><a href="#解题过程-7" class="headerlink" title="解题过程"></a>解题过程</h4><ol><li><strong>构造工作数组</strong>：将 <code>startTime</code>，<code>endTime</code> 和 <code>profit</code> 整合到一个数组 <code>jobs</code> 中，每个工作作为一个三元组 [开始时间, 结束时间, 利润]。</li><li><strong>排序</strong>：按工作的结束时间对 <code>jobs</code> 进行排序。这样做可以更容易地管理工作之间的时间冲突。</li><li><strong>动态规划初始化</strong>：创建一个动态规划数组 <code>f</code>，其中 <code>f[i]</code> 表示考虑到第 <code>i</code> 个工作时可以获得的最大利润。初始化 <code>f[0] = 0</code>。</li><li><strong>填充动态规划表</strong>：<ol><li>排序后的工作，对于每个工作，使用二分搜索找到最后一个结束时间不晚于当前工作开始时间的工作的索引 <code>j</code>。</li><li>更新 <code>f[i]</code> 为不选择当前工作时的最大利润 <code>f[i-1]</code> 与选择当前工作后的总利润 <code>f[j + 1]</code> + 当前工作的利润 中的较大值。</li></ol></li><li><strong>二分搜索实现</strong>：对于每个工作，查找不晚于该工作开始时间的最后一个工作的索引，这个索引用于确定不与当前工作冲突的前一个工作。</li></ol><h4 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：<code>O(nlogn)</code>，其中 n 是工作的数量。排序需要 <code>O(nlogn)</code> 时间，每次插入动态规划表需要 <code>O(logn)</code> 时间进行二分搜索。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储排序后的工作和动态规划表。</li></ul><h4 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jobScheduling</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] startTime, <span class="hljs-keyword">int</span>[] endTime, <span class="hljs-keyword">int</span>[] profit)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = startTime.length;<br>        <span class="hljs-keyword">int</span>[][] jobs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            jobs[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;<br>        &#125;<br>        Arrays.sort(jobs, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">1</span>])); <span class="hljs-comment">// 按照结束时间排序</span><br><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = search(jobs, i, jobs[i][<span class="hljs-number">0</span>]);<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i], f[j + <span class="hljs-number">1</span>] + jobs[i][<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 endTime &lt;= upper 的最大下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] jobs, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (jobs[mid][<span class="hljs-number">1</span>] &lt;= upper) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的学习，读者不仅可以掌握二分查找的基本方法和几种常见的变体，还可以通过实际的编程题加深理解和应用。掌握二分查找对于提高编程效率和解决复杂问题具有重要意义，是每个软件开发者必备的技能之一。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cache</title>
    <link href="/2024/07/15/spring-cache/"/>
    <url>/2024/07/15/spring-cache/</url>
    
    <content type="html"><![CDATA[<p><code>Spring Cache</code>是<code>Spring Framework</code>中提供的缓存抽象机制，它允许开发者通过注解或<code>XML</code>配置简化缓存的使用。<code>Spring Cache</code>支持多种缓存实现，包括<code>Ehcache</code>、<code>Caffeine</code>、<code>Redis</code>、<code>Guava</code>等。下面将对<code>Spring Cache</code>展开详细的介绍。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a>为什么使用缓存</h3><ol><li><strong>性能提升</strong>：缓存主要用于减少重复的数据处理和数据检索操作，特别是减少对数据库的直接访问，从而加快数据的访问速度，提高应用程序的响应性能。</li><li><strong>减少成本</strong>：通过减少对后端系统如数据库的请求，缓存可以帮助降低运营成本。尤其是在高流量的应用中，适当的缓存策略可以显著减少需要的资源和相关的成本。</li><li><strong>提高可伸缩性</strong>：缓存可以帮助应对高并发场景，通过缓存常用数据来避免在高流量下数据库成为瓶颈。</li></ol><h3 id="Java-缓存管理痛点"><a href="#Java-缓存管理痛点" class="headerlink" title="Java 缓存管理痛点"></a>Java 缓存管理痛点</h3><ol><li><strong>缺乏统一标准</strong>：在<code>Spring Cache</code>出现之前，Java应用通常需要依赖于具体的缓存实现（如<code>Ehcache</code>、<code>Guava Cache</code>等）或自定义解决方案。这些实现各自有自己的API和配置方式，缺乏统一标准，使得在不同项目或组件间共享缓存逻辑变得复杂。</li><li><strong>集成复杂性</strong>：不同的缓存解决方案需要不同的集成策略，对开发者来说，这意味着需要对每一种技术都有深入的理解。这种复杂性增加了开发和维护的难度，也提高了学习成本。</li><li><strong>功能局限</strong>：许多早期的缓存库专注于缓存数据，但缺乏高级功能，如声明式的缓存操作、自动的缓存刷新和条件缓存等。</li></ol><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p>为了解决Java缓存管理中存在的多种问题，提供一个简单、统一且功能强大的缓存管理解决方案，以适应现代应用对性能和可伸缩性的高要求，<code>Spring Cache</code>诞生了，带来的改变包括：</p><ol><li><strong>统一的抽象层</strong>：<code>Spring Cache</code>提供了一个清晰的缓存抽象层，使得开发者可以不关心具体的缓存实现细节，统一使用缓存注解来控制缓存行为。</li><li><strong>简化配置和使用</strong>：通过<code>Spring</code>的配置和注解支持，开发者可以很容易地配置和使用缓存，而无需编写大量的模板代码。这降低了使用缓存的门槛，提高了开发效率。</li><li><strong>灵活性和扩展性</strong>：<code>Spring Cache</code>不仅支持多种流行的缓存技术，还允许通过自定义 <code>CacheManager</code> 来扩展新的缓存实现，提供了极大的灵活性。</li><li><strong>与Spring生态系统的整合</strong>：<code>Spring Cache</code>的引入使得缓存策略能够更好地与<code>Spring</code>的其他项目（如 <code>Spring Data</code>、<code>Spring Security</code>）整合，提供一致的开发体验。</li></ol><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="缓存抽象"><a href="#缓存抽象" class="headerlink" title="缓存抽象"></a>缓存抽象</h3><p><code>Spring Cache</code>通过一组接口来定义缓存的操作，主要包括存储、获取、更新和清除缓存数据。这种抽象层让开发者可以不用关心具体的缓存实现细节，比如使用内存缓存、文件缓存或是分布式缓存系统。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><code>Spring Cache</code>提供以下几种注解来简化缓存操作的实现：</p><ul><li>**<code>@Cacheable</code>**：最常用的注解，用于表示某个方法的返回值是可缓存的。如果缓存中已有相应的值，则方法不会执行，直接从缓存返回数据。</li><li>**<code>@CacheEvict</code>**：用于清除缓存数据，支持在方法执行前或执行后清除。</li><li>**<code>@CachePut</code>**：总是会执行方法，并将结果放入指定的缓存。这常用于更新缓存数据。</li><li>**<code>@Caching</code>**：复合注解，可以同时应用多个其他缓存注解。</li></ul><h3 id="缓存解析和存储"><a href="#缓存解析和存储" class="headerlink" title="缓存解析和存储"></a>缓存解析和存储</h3><p><code>Spring Cache</code>的工作方式是拦截基于注解的方法调用，根据方法的参数和注解的配置决定如何缓存方法的返回值或如何操作缓存。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="方法拦截"><a href="#方法拦截" class="headerlink" title="方法拦截"></a>方法拦截</h3><ul><li><code>Spring</code>使用代理模式或<code>AOP</code>拦截那些被<code>@Cacheable</code>、<code>@CacheEvict</code>等注解标记的方法。</li><li>当调用这些方法时，<code>Spring Cache</code>的拦截器会介入处理。</li></ul><h3 id="缓存键生成"><a href="#缓存键生成" class="headerlink" title="缓存键生成"></a>缓存键生成</h3><ul><li>默认情况下，<code>Spring Cache</code>使用方法的参数生成缓存键。开发者可以通过表达式自定义键值的生成策略。</li><li>对于 <code>@Cacheable</code> 和 <code>@CachePut</code> 注解，如果缓存中存在相应的键，则可以直接返回缓存中的数据或更新数据。</li></ul><h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><ul><li>当缓存命中时，即缓存中已存在对应的键值，对于<code>@Cacheable</code>注解的方法，直接从缓存返回数据，不执行方法体。</li><li>对于<code>@CachePut</code>注解，方法体将被执行，且新的返回值将替换缓存中的旧值。</li></ul><h3 id="缓存更新和失效"><a href="#缓存更新和失效" class="headerlink" title="缓存更新和失效"></a>缓存更新和失效</h3><ul><li><code>@CacheEvict</code>可以用来在适当的时候清除缓存，保持缓存数据的新鲜度。可以配置为方法执行前或执行后清除缓存。</li><li><code>@CachePut</code>用于更新缓存中的数据，确保缓存的数据是最新的。</li></ul><h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><ul><li><code>Spring</code>提供了<code>CacheManager</code>接口来管理不同的缓存库。每个缓存库可以配置不同的存储和过期策略。</li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>创建一个基础的<code>SpringBoot</code>项目，添加<code>spring-boot-starter-cache</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>启动类中添加<code>@EnableCaching</code>注解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringcacheApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringcacheApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="EHCache"><a href="#EHCache" class="headerlink" title="EHCache"></a>EHCache</h3><p><code>EHCache</code>是一种广泛使用的开源Java缓存库，适用于提升应用程序的性能，通过减少数据库访问、提供快速的访问速度来减轻后端系统的负载。</p><p><strong>概念</strong></p><ol><li><p><strong>内存和磁盘存储</strong>：</p><ul><li><p><code>EHCache</code>提供内存和磁盘两层存储机制，可以配置为仅内存、内存加磁盘持久化或仅磁盘存储。</p></li><li><p>内存存储提供快速访问，而磁盘存储则支持更大的缓存容量和重启后的数据恢复。</p></li></ul></li><li><p><strong>数据元素</strong>：</p><ul><li>在<code>EHCache</code>中，每个缓存条目称为一个元素（<code>Element</code>），每个元素有一个键（<code>Key</code>）和一个值（<code>Value</code>）。</li></ul></li><li><p><strong>缓存淘汰机制</strong>：</p><ul><li>支持多种缓存淘汰策略，包括最少使用（<code>LRU</code>）、最少访问（<code>LFU</code>）和先进先出（<code>FIFO</code>）。</li></ul></li></ol><p><strong>实现</strong></p><ol><li><p><code>SpringBoot</code>配置文件中设置<code>SpringCache</code>的类型设置为<code>ehcache</code></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.cache.type</span>=<span class="hljs-string">ehcache</span><br></code></pre></div></td></tr></table></figure></li><li><p>添加Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在资源目录下创建<code>ehcache.xml</code>配置文件，定义缓存的配置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置磁盘存储的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;java.io.tmpdir&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        1. maxElementsInMemory: 内存中缓存的最大条目数</span><br><span class="hljs-comment">        2. eternal: 是否永不过期</span><br><span class="hljs-comment">        3. timeToIdleSeconds: 元素在缓存中可以处于空闲状态的最大时间（秒），超过此时间未被访问的元素将被淘汰</span><br><span class="hljs-comment">        4. timeToLiveSeconds: 元素在缓存中可以存活的最大时间（秒），从元素被存入缓存开始计算</span><br><span class="hljs-comment">        5. overflowToDisk: 是否允许溢出到磁盘</span><br><span class="hljs-comment">        6. diskPersistent: 是否磁盘持久化</span><br><span class="hljs-comment">        7. diskExpiryThreadIntervalSeconds: 磁盘过期检查线程运行间隔（秒）</span><br><span class="hljs-comment">        8. memoryStoreEvictionPolicy: 内存存储淘汰策略（LRU最近最少使用、LFU最不频繁使用、FIFO先进先出）</span><br><span class="hljs-comment">     --&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 默认的缓存配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><br><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;300&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;600&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 定义名为 codeCache 的缓存 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;codeCache&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;300&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;600&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>新增配置类<code>EhCacheConfig</code>，读取配置文件<code>ehcache.xml</code>中的配置</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EhCacheConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        net.sf.ehcache.CacheManager ehCacheManager =<br>                <span class="hljs-keyword">new</span> net.sf.ehcache.CacheManager(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;ehcache.xml&quot;</span>).getInputStream());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EhCacheCacheManager(ehCacheManager);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>本次用于测试的<code>CodeService</code>，含有属性<code>codeMap</code>，以及对应的增删改查方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(CodeService.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, String&gt; codeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-meta">@Cacheable(value = &quot;codeCache&quot;, keyGenerator = &quot;customCacheKeyGenerator&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;getCode开始执行，id: &#123;&#125;&quot;</span>, id);<br>        <span class="hljs-keyword">return</span> codeMap.get(id);<br>    &#125;<br><br>    <span class="hljs-meta">@CachePut(value = &quot;codeCache&quot;, keyGenerator = &quot;customCacheKeyGenerator&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addOrUpdateCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String description)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;addOrUpdateCode开始执行，id: &#123;&#125;，description: &#123;&#125;&quot;</span>, id, description);<br>        codeMap.put(id, description);<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-meta">@CacheEvict(value = &quot;codeCache&quot;, keyGenerator = &quot;customCacheKeyGenerator&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;deleteCode开始执行，id: &#123;&#125;&quot;</span>, id);<br>        codeMap.remove(id);<br>    &#125;<br><br>    <span class="hljs-meta">@CacheEvict(value = &quot;codeCache&quot;, allEntries = true)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这里不需要操作codeMap，@CacheEvict注解已经处理了缓存清空</span><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>因为缓存是存在于内存或磁盘中的，为了避免缓存的键重复，可以在<code>Spring Cache</code>的注解中自定义键的生成策略，如以方法参数<code>id</code>为键</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;codeCache&quot;, key = &quot;#id&quot;)</span><br></code></pre></div></td></tr></table></figure><p>还可以通过实现<code>KeyGenerator</code>接口，对这个生成策略进行自定义、动态地生成键，且这种方式也能支持复用。例如创建一个<code>CustomCacheKeyGenerator</code>，生成策略为<code>simpleName::params[0]</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;customCacheKeyGenerator&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCacheKeyGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyGenerator</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> target.getClass().getSimpleName() + <span class="hljs-string">&quot;::&quot;</span> + params[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Spring Cache</code>注解中指定使用刚才自定义的<code>CustomCacheKeyGenerator</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;codeCache&quot;, keyGenerator = &quot;customCacheKeyGenerator&quot;)</span><br></code></pre></div></td></tr></table></figure></li><li><p>将<code>Spring Cache</code>的日志级别更改为<code>trace</code>，以便观察日志信息</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.org.springframework.cache</span>=<span class="hljs-string">trace</span><br></code></pre></div></td></tr></table></figure></li><li><p>单元测试如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">codeServiceTest1</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;初始化数据，调用addOrUpdateCode方法，设置id=1的值为one&quot;</span>);<br>    codeService.addOrUpdateCode(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;初始化后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;初始化后第二次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;调用deleteCode方法&quot;</span>);<br>    codeService.deleteCode(<span class="hljs-number">1</span>);<br>    logger.info(<span class="hljs-string">&quot;deleteCode后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;deleteCode后第二次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;第一次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;第二次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;调用clearCache方法&quot;</span>);<br>    codeService.clearCache();<br>    logger.info(<span class="hljs-string">&quot;clearCache后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;clearCache后第一次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;调用addOrUpdateCode方法，设置id=1的值为one&quot;</span>);<br>    codeService.addOrUpdateCode(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2024-07-15 00:41:05.629  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化数据，调用addOrUpdateCode方法，设置id=1的值为one<br>2024-07-15 00:41:05.637  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : addOrUpdateCode开始执行，id: 1，description: one<br>2024-07-15 00:41:05.638 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.addOrUpdateCode(int,java.lang.String)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span><br>2024-07-15 00:41:05.641 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:41:05.642  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化后第一次调用id=1的getCode方法：one<br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:41:05.642  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化后第二次调用id=1的getCode方法：one<br>2024-07-15 00:41:05.642  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用deleteCode方法<br>2024-07-15 00:41:05.642  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : deleteCode开始执行，id: 1<br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.deleteCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span><br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Invalidating cache key [CodeService::1] <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.deleteCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span> on method public void space.yangtao.springcache.service.CodeService.deleteCode(int)<br>2024-07-15 00:41:05.642 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 1<br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : deleteCode后第一次调用id=1的getCode方法：null<br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : deleteCode后第二次调用id=1的getCode方法：null<br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 2<br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 第一次调用id=2的getCode方法：null<br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.644 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:41:05.644  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 第二次调用id=2的getCode方法：null<br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用clearCache方法<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Invalidating entire cache <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.clearCache()] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span> on method public void space.yangtao.springcache.service.CodeService.clearCache()<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 1<br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : clearCache后第一次调用id=1的getCode方法：null<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 2<br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : clearCache后第一次调用id=2的getCode方法：null<br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用addOrUpdateCode方法，设置id=1的值为one<br>2024-07-15 00:41:05.645  INFO 39528 --- [           main] s.y.springcache.service.CodeService      : addOrUpdateCode开始执行，id: 1，description: one<br>2024-07-15 00:41:05.645 TRACE 39528 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.addOrUpdateCode(int,java.lang.String)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>分析：</p><ol><li>初始化数据，调用<code>addOrUpdateCode</code>方法，设置<code>id=1</code>的数据，并存入一个<code>key</code>为<code>CodeService::1</code>的缓存</li><li>初始化后的第一二次调用<code>getCode</code>，都从缓存中取到了<code>CodeService::1</code>的数据</li><li>调用<code>deleteCode</code>方法，这个方法会将缓存<code>CodeService::1</code>失效</li><li><code>deleteCode</code>后调用<code>getCode</code>方法，这次没有获取到<code>CodeService::1</code>的缓存，因此执行了<code>getCode</code>方法，并将结果缓存了起来</li><li><code>deleteCode</code>后第二次调用<code>getCode</code>方法取到了上一次<code>getCode</code>方法设置的缓存</li><li>第一次调用<code>getCode（id=2）</code>的方法，没有<code>CodeService::2</code>，因此执行了<code>getCode</code>方法并设置了对应的缓存，第二次调用的时候这个缓存被获取到</li><li>手动调用<code>clearCache</code>方法，清除了所有的缓存，之后调用<code>getCode</code>方法，<code>id=1</code>或<code>id=2</code>都无法获取到对应的缓存<code>CodeService::1</code>或<code>CodeService::2</code></li><li>调用<code>addOrUpdateCode</code>方法，重新设置<code>id=1</code>的数据并重新设置缓存</li></ol></li></ol><p>上述<code>EhCache</code>的缓存，都是在内存或磁盘级别，这就带来了一个问题，在多实例的情况下，同一个方法同一个参数的多次调用可能使用不了缓存</p><p>编写第二个测试方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">codeServiceTest2</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;实例2开始测试------------------------------------&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;第二个实例调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2024-07-15 00:43:12.122  INFO 37712 --- [           main] s.y.s.SpringcacheApplicationTests        : 实例2开始测试------------------------------------<br>2024-07-15 00:43:12.124 TRACE 37712 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:43:12.125 TRACE 37712 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:43:12.125 TRACE 37712 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:43:12.130  INFO 37712 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 1<br>2024-07-15 00:43:12.132  INFO 37712 --- [           main] s.y.s.SpringcacheApplicationTests        : 第二个实例调用id=1的getCode方法：null<br></code></pre></div></td></tr></table></figure><p>分析：运行第二次的测试方法，发现获取不到上次单元测试中最后设置的缓存<code>CodeService::1</code>，原因是因为之前的单元测试实例停止了，内存中找不到缓存，因此需要引入分布式缓存。分布式缓存支持跨多个实例共享缓存数据，常见的解决方法有<code>Redis</code>或<code>Memcached</code>。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><code>Redis</code>提供了高性能的数据结构服务，非常适合用作分布式缓存系统。需要注意的是，<code>Redis</code>作为一个独立的内存数据结构服务器，作为<code>Spring Cache</code>的后端时，配置选项与使用内存或本地缓存系统时有所不同，通常只配置过期时间<code>TTL</code>以及序列化方式，而其余参数（如最大使用内存、持久化、淘汰策略等）则由<code>Redis</code>服务器单独配置。</p><p><strong>实现</strong></p><ol><li><p><code>SpringBoot</code>配置文件中设置<code>Spring Cache</code>的类型设置为<code>Redis</code>、并配置<code>Redis</code>的连接信息</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.cache.type</span>=<span class="hljs-string">redis</span><br><br><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br></code></pre></div></td></tr></table></figure></li><li><p>引入Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>配置类<code>RedisCacheConfig</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()<br>                <span class="hljs-comment">// 设置缓存过期时间为10分钟</span><br>                .entryTtl(Duration.ofMinutes(<span class="hljs-number">10</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> StringRedisSerializer()))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer()))<br>                <span class="hljs-comment">// 不缓存空值</span><br>                .disableCachingNullValues();<br><br>        <span class="hljs-keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)<br>                .cacheDefaults(config)<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>其他的配置（如缓存<code>key</code>的生成类以及<code>service</code>方法中注解的使用）与<code>EhCache</code>中配置一致，保持不变</p></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">codeServiceTest1</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;初始化数据，调用addOrUpdateCode方法，设置id=1的值为one&quot;</span>);<br>    codeService.addOrUpdateCode(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;初始化后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;初始化后第二次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;调用deleteCode方法&quot;</span>);<br>    codeService.deleteCode(<span class="hljs-number">1</span>);<br>    logger.info(<span class="hljs-string">&quot;deleteCode后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;deleteCode后第二次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;第一次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;第二次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;调用clearCache方法&quot;</span>);<br>    codeService.clearCache();<br>    logger.info(<span class="hljs-string">&quot;clearCache后第一次调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>    logger.info(<span class="hljs-string">&quot;clearCache后第一次调用id=2的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">2</span>));<br>    logger.info(<span class="hljs-string">&quot;调用addOrUpdateCode方法，设置id=1的值为one&quot;</span>);<br>    codeService.addOrUpdateCode(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2024-07-15 00:54:45.618  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化数据，调用addOrUpdateCode方法，设置id=1的值为one<br>2024-07-15 00:54:45.630  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : addOrUpdateCode开始执行，id: 1，description: one<br>2024-07-15 00:54:45.632 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.addOrUpdateCode(int,java.lang.String)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span><br>2024-07-15 00:54:46.193 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.200 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:54:46.200  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化后第一次调用id=1的getCode方法：one<br>2024-07-15 00:54:46.200 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.201 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:54:46.201  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 初始化后第二次调用id=1的getCode方法：one<br>2024-07-15 00:54:46.201  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用deleteCode方法<br>2024-07-15 00:54:46.201  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : deleteCode开始执行，id: 1<br>2024-07-15 00:54:46.201 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.deleteCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span><br>2024-07-15 00:54:46.201 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Invalidating cache key [CodeService::1] <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.deleteCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span> on method public void space.yangtao.springcache.service.CodeService.deleteCode(int)<br>2024-07-15 00:54:46.204 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.205 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:54:46.206 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.206  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 1<br>2024-07-15 00:54:46.206  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : deleteCode后第一次调用id=1的getCode方法：null<br>2024-07-15 00:54:46.207 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.207 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:54:46.207  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : deleteCode后第二次调用id=1的getCode方法：null<br>2024-07-15 00:54:46.207 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.208 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:54:46.208 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.208  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 2<br>2024-07-15 00:54:46.208  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 第一次调用id=2的getCode方法：null<br>2024-07-15 00:54:46.208 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.208 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:54:46.208  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 第二次调用id=2的getCode方法：null<br>2024-07-15 00:54:46.208  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用clearCache方法<br>2024-07-15 00:54:46.210 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Invalidating entire cache <span class="hljs-keyword">for</span> operation Builder[public void space.yangtao.springcache.service.CodeService.clearCache()] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span> on method public void space.yangtao.springcache.service.CodeService.clearCache()<br>2024-07-15 00:54:46.213 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.215 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:54:46.215 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.215  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 1<br>2024-07-15 00:54:46.215  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : clearCache后第一次调用id=1的getCode方法：null<br>2024-07-15 00:54:46.215 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.216 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : No cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">in</span> cache(s) [codeCache]<br>2024-07-15 00:54:46.216 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::2&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:54:46.216  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : getCode开始执行，id: 2<br>2024-07-15 00:54:46.216  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : clearCache后第一次调用id=2的getCode方法：null<br>2024-07-15 00:54:46.216  INFO 27052 --- [           main] s.y.s.SpringcacheApplicationTests        : 调用addOrUpdateCode方法，设置id=1的值为one<br>2024-07-15 00:54:46.216  INFO 27052 --- [           main] s.y.springcache.service.CodeService      : addOrUpdateCode开始执行，id: 1，description: one<br>2024-07-15 00:54:46.217 TRACE 27052 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.addOrUpdateCode(int,java.lang.String)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p>可以发现与之前<code>EhCache</code>使用内存作为缓存方案的测试结果并没有什么差别，这就说明了<code>Spring Cache</code>提供的缓存抽象层使得开发者可以不关心具体的缓存实现细节</p></li><li><p>此时再运行第二个方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">codeServiceTest2</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;实例2开始测试------------------------------------&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;第二个实例调用id=1的getCode方法：&#123;&#125;&quot;</span>, codeService.getCode(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2024-07-15 00:55:49.319  INFO 30368 --- [           main] s.y.s.SpringcacheApplicationTests        : 实例2开始测试------------------------------------<br>2024-07-15 00:55:49.324 TRACE 30368 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Computed cache key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> <span class="hljs-keyword">for</span> operation Builder[public java.lang.String space.yangtao.springcache.service.CodeService.getCode(int)] caches=[codeCache] | key=<span class="hljs-string">&#x27;&#x27;</span> | keyGenerator=<span class="hljs-string">&#x27;customCacheKeyGenerator&#x27;</span> | cacheManager=<span class="hljs-string">&#x27;&#x27;</span> | cacheResolver=<span class="hljs-string">&#x27;&#x27;</span> | condition=<span class="hljs-string">&#x27;&#x27;</span> | unless=<span class="hljs-string">&#x27;&#x27;</span> | sync=<span class="hljs-string">&#x27;false&#x27;</span><br>2024-07-15 00:55:49.910 TRACE 30368 --- [           main] o.s.cache.interceptor.CacheInterceptor   : Cache entry <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;CodeService::1&#x27;</span> found <span class="hljs-keyword">in</span> cache <span class="hljs-string">&#x27;codeCache&#x27;</span><br>2024-07-15 00:55:49.910  INFO 30368 --- [           main] s.y.s.SpringcacheApplicationTests        : 第二个实例调用id=1的getCode方法：one<br></code></pre></div></td></tr></table></figure><p>可以发现这次使用分布式缓存以后，第二次测试也可以获取到之前的缓存<code>CodeService::1</code>，因为这个缓存是存在于<code>Redis</code>数据库中的，查看数据库也可以验证这一点，如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;codeCache::CodeService::2&quot;</span><br>2) <span class="hljs-string">&quot;codeCache::CodeService::1&quot;</span><br>127.0.0.1:6379&gt; get codeCache::CodeService::1<br><span class="hljs-string">&quot;\xac\xed\x00\x05t\x00\x03one&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="注解补充说明"><a href="#注解补充说明" class="headerlink" title="注解补充说明"></a>注解补充说明</h2><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><p><code>@Caching</code>注解可以组合多个缓存注解，使得在一个方法上可以同时应用<code>@Cacheable</code>、<code>@CachePut</code>和<code>@CacheEvict</code>注解。这对于需要对一个方法进行多重缓存逻辑处理的情况非常有用。</p><p>示例：在更新代码时同时更新缓存并在特定条件下删除另一个缓存条目</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Caching(</span><br><span class="hljs-meta">    put = &#123; @CachePut(value = &quot;codeCache&quot;, key = &quot;#id&quot;) &#125;,</span><br><span class="hljs-meta">    evict = &#123; @CacheEvict(value = &quot;otherCache&quot;, key = &quot;#id&quot;, condition = &quot;#id &gt; 10&quot;) &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addOrUpdateCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String description)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>@Caching</code>提供了组合多种缓存操作的能力，在复杂的缓存逻辑中非常有用，但对于简单的缓存需求，使用<code>@Caching</code>可能反而会引入不必要的复杂性。</p><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><ul><li><code>value/cacheNames</code>：指定缓存操作的缓存名称。至少需要指定一个缓存名称，因为缓存的目标是根据名称进行存储和检索。示例：<code>@Cacheable(value = &quot;myCache&quot;)</code></li><li><code>key</code>：使用<code>Spring Expression Language (SpEL)</code>表达式指定缓存的键。如果不指定，则默认使用所有的方法参数组合作为键。示例：<code>@Cacheable(value = &quot;myCache&quot;, key = &quot;#id&quot;)</code></li><li><code>keyGenerator</code>：指定用来生成缓存键的自定义 <code>KeyGenerator</code> bean 的名称。如果设置了这个属性，那么 <code>key</code> 属性应当忽略。示例：<code>@Cacheable(value = &quot;myCache&quot;, keyGenerator = &quot;myCustomKeyGenerator&quot;)</code></li><li><code>cacheManager</code>：指定用来管理缓存操作的<code>CacheManager</code> bean的名称。只在你配置了多个 <code>CacheManager</code> 的情况下需要使用。示例：<code>@Cacheable(value = &quot;myCache&quot;, cacheManager = &quot;myCacheManager&quot;)</code></li><li><code>cacheResolver</code>：指定用来解析使用哪个缓存的<code>CacheResolver</code> bean的名称。如果设置了这个属性，<code>cacheManager</code>属性应当忽略。示例：<code>@Cacheable(value = &quot;myCache&quot;, cacheResolver = &quot;myCacheResolver&quot;)</code></li><li><code>condition</code>：一个<code>SpEL</code>表达式，当表达式为true时，方法返回值会被缓存。这可以用来在某些条件下才缓存结果。示例：<code>@Cacheable(value = &quot;myCache&quot;, condition = &quot;#id &gt; 10&quot;)</code></li><li><code>unless</code>：一个<code>SpEL</code>表达式，当表达式为true时，即使方法被缓存拦截，返回值也不会被放入缓存。这通常用于防止将不想缓存的数据放入缓存。示例：<code>@Cacheable(value = &quot;myCache&quot;, unless = &quot;#result == null&quot;)</code></li><li><code>sync</code>：指定是否使用同步模式。如果多个线程同时访问一个计算量大的缓存方法，只有一个线程将执行方法，其他线程将等待这个结果被计算出来，避免多次执行相同的方法。示例：<code>@Cacheable(value = &quot;myCache&quot;, sync = true)</code></li><li><code>allEntries</code>：指定是否需要从缓存中移除所有条目。设置为<code>true</code>时，不考虑<code>key</code>属性的设置，将清空整个缓存。示例：<code>@CacheEvict(value = &quot;myCache&quot;, allEntries = true)</code></li><li><code>beforeInvocation</code>：指定缓存清除操作是在方法执行之前还是之后进行，默认情况下为false，即方法执行结束前不清除缓存，常用于可能抛出异常的方法（先清除缓存再执行方法，确保无论数据操作成功与否，缓存都不会返回旧数据）。示例：<code>@CacheEvict(value = &quot;myCache&quot;, beforeInvocation = true)</code></li></ul><h2 id="缓存管理-1"><a href="#缓存管理-1" class="headerlink" title="缓存管理"></a>缓存管理</h2><h3 id="cacheManager"><a href="#cacheManager" class="headerlink" title="cacheManager"></a>cacheManager</h3><p><strong>定义</strong>：<code>cacheManager</code>属性用于指定管理缓存的<code>CacheManager</code>实例。在Spring应用中，<code>CacheManager</code>负责创建和维护缓存实例。</p><p><strong>用途</strong>：当应用配置了多个<code>CacheManager</code>时，可以通过<code>cacheManager</code>属性明确指定某个方法或类使用哪一个<code>CacheManager</code>。这是通常在有多种缓存存储（如内存、Redis、EhCache等）时需要考虑的情况。</p><p><strong>示例</strong>：使用<code>cacheManager</code>属性指定缓存管理器。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;codeCache&quot;, key = &quot;#id&quot;, cacheManager = &quot;cacheManager&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> codeMap.get(id);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="cacheResolver"><a href="#cacheResolver" class="headerlink" title="cacheResolver"></a>cacheResolver</h3><p><strong>定义</strong>：<code>cacheResolver</code>属性用于指定一个<code>CacheResolver</code>实例，<code>CacheResolver</code>负责在运行时解析使用哪个缓存。它提供了一种更灵活的方式来动态决定缓存。</p><p><strong>用途</strong>：<code>cacheResolver</code>在需要根据特定条件动态决定使用哪个缓存时非常有用，例如，基于方法的输入参数或者其他运行时数据。这使得它在复杂逻辑或动态环境中尤其有用。</p><p><strong>示例</strong>：使用<code>cacheResolver</code>动态解析缓存。</p><ol><li><p>定义一个动态解析器<code>CodeDynamicCacheResolver</code>，这个解析器重写了获取缓存的方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeDynamicCacheResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleCacheResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheResolver</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CodeDynamicCacheResolver</span><span class="hljs-params">(CacheManager cacheManager)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cacheManager);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Collection&lt;String&gt; <span class="hljs-title">getCacheNames</span><span class="hljs-params">(CacheOperationInvocationContext&lt;?&gt; context)</span> </span>&#123;<br>        <span class="hljs-comment">// 假设第一方法的第一个参数都是id</span><br>        <span class="hljs-keyword">int</span> key = (<span class="hljs-keyword">int</span>) context.getArgs()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">10000</span>) &#123;<br>            <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-string">&quot;code::big&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-string">&quot;code::small&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Spring中定义<code>codeDynamicCacheResolver</code>这个Bean</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CodeDynamicCacheResolver <span class="hljs-title">codeDynamicCacheResolver</span><span class="hljs-params">(CacheManager cacheManager)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CodeDynamicCacheResolver(cacheManager);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在<code>Spring Cache</code>注解中使用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(cacheResolver = &quot;codeDynamicCacheResolver&quot;)</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>cacheManager</code>用于静态地指定使用哪个缓存管理器，通常在应用启动时配置好，之后不会改变。而<code>cacheResolver</code>提供了一种动态决定使用哪个缓存的机制，它允许开发者在运行时基于复杂的业务逻辑来选择缓存。选择<code>cacheManager</code>还是<code>cacheResolver</code>取决于应用的具体需求和缓存策略的复杂程度。在多缓存管理器场景下，简单的配置可以使用<code>cacheManager</code>；而在需要高度动态和可定制的缓存解决方案中，<code>cacheResolver</code>提供了必要的灵活性。</p><h2 id="服务器缓存总结"><a href="#服务器缓存总结" class="headerlink" title="服务器缓存总结"></a>服务器缓存总结</h2><p>Java服务器端的缓存可以大致分为几种类型，每种类型适用于不同的场景，并具有不同的实现方式，具体的选择以及实施方案需根据应用场景和需求进行具体分析再确定。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul><li><p><strong>本地缓存</strong></p><ul><li><strong>定义</strong>：存储在单个服务实例的内存中的缓存。</li></ul><ul><li><p><strong>常用实现</strong>：<code>EHCache</code>、<code>Caffeine</code>。</p></li><li><p><strong>适用场景</strong>：适合非分布式或服务实例不需要共享缓存的场景。</p></li></ul></li><li><p><strong>分布式缓存</strong>:</p><ul><li><p><strong>定义</strong>：缓存数据在多个服务实例间共享，通常独立于服务实例运行。</p></li><li><p><strong>常用实现</strong>：<code>Redis</code>、<code>Memcached</code>。</p></li><li><p><strong>适用场景</strong>：适用于需要缓存共享、高可用性和扩展性的分布式系统。</p></li></ul></li><li><p><strong>数据库缓存</strong>:</p><ul><li><p><strong>定义</strong>：缓存直接与数据库交互，通常用于缓存查询结果。</p></li><li><p><strong>常用实现</strong>：<code>MyBatis</code>缓存、<code>Hibernate</code>二级缓存。</p></li><li><p><strong>适用场景</strong>：适用于减少数据库负载、提高查询效率。</p></li></ul></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p><strong>EHCache</strong></p><ul><li><p><strong>特点</strong>：支持内存和磁盘存储，可配置为本地缓存。</p></li><li><p><strong>优势</strong>：易于集成，适用于单体应用或服务的本地缓存，支持复杂的缓存策略。</p></li><li><p><strong>劣势</strong>：在分布式环境中没有内建的数据一致性支持。</p></li></ul></li><li><p><strong>Redis</strong></p><ul><li><p><strong>特点</strong>：高性能键值存储数据库，支持数据结构的多样性。</p></li><li><p><strong>优势</strong>：支持持久化，数据可以在多个节点间复制，支持事务和高级数据结构，适合做分布式缓存。</p></li><li><p><strong>劣势</strong>：如果未正确配置，持久化和数据复制可能会影响性能。</p></li></ul></li><li><p><strong>Memcached</strong></p><ul><li><p><strong>特点</strong>：高性能的分布式内存对象缓存系统。</p></li><li><p><strong>优势</strong>：简单易用，适用于减轻数据库负载，提高读取速度。</p></li><li><p><strong>劣势</strong>：不支持持久化，缓存数据在重启后丢失，不支持复杂的数据类型。</p></li></ul></li><li><p><strong>MyBatis/Hibernate 缓存</strong></p><ul><li><p><strong>特点</strong>：集成在<code>ORM</code>框架中，自动处理<code>SQL</code>级别的缓存。</p></li><li><p><strong>优势</strong>：无需手动处理缓存逻辑，适合缓存数据库查询结果。</p></li><li><p><strong>劣势</strong>：控制较少，依赖于<code>ORM</code>框架的实现和配置。</p></li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了<code>Spring Cache</code>的工作原理和实践应用，展示了其如何帮助开发者优化应用性能和扩展性。随着技术的不断进步，<code>Spring Cache</code>也在不断地进化，为开发者提供更多的功能和更好的集成。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>缓存</tag>
      
      <tag>性能</tag>
      
      <tag>Spring Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="/2024/05/25/javase-threadlocal/"/>
    <url>/2024/05/25/javase-threadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程编程中，确保线程安全是至关重要的。Java提供了多种机制来处理线程间的数据隔离，其中<code>ThreadLocal</code>是一个非常强大的工具，它可以为每个使用该变量的线程提供一个独立的变量副本。这意味着每个线程都可以在不影响其他线程的情况下，修改自己的副本。这种方式特别适用于管理会话信息、用户ID、事务ID等线程敏感的数据。                                                                                                                                                                      </p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><code>public ThreadLocal()</code>：创建<code>ThreadLocal</code>对象</li><li><code>public void set(T value)</code>：设置当前线程绑定的局部变量</li><li><code>public T get()</code>：获取当前线程绑定的局部变量</li><li><code>public void remove()</code>：移除当前线程绑定的局部变量</li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>现有<code>Demo01</code>类，该类中有一个普通的<code>String</code>类型的变量<code>content</code>，创建一个实例对象，开启多个线程去调用该对象的<code>set</code>和<code>get</code>方法，观察输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String content;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Demo01 demo01 = <span class="hljs-keyword">new</span> Demo01();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                demo01.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">200</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; --&gt; &quot;</span> + demo01.getContent());<br>                demo01.remove();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：<br><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240523210951427.png"></p><p>观察到有线程错误地使用了非本线程设置的<code>content</code>。</p><h3 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h3><p>通过<code>synchronized</code>锁定代码块来实现线程之间数据不相互影响</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Demo02 demo01 = <span class="hljs-keyword">new</span> Demo02();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Demo02.class) &#123;<br>                demo01.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">200</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; --&gt; &quot;</span> + demo01.getContent());<br>                demo01.remove();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h3><p>将变量替换为<code>ThreadLocal &lt;String&gt;</code>类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br><br>    ThreadLocal&lt;String&gt; content = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> content.get();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content.set(content);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content.remove();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Demo01 demo01 = <span class="hljs-keyword">new</span> Demo01();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                demo01.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; --&gt; &quot;</span> + demo01.getContent());<br>                demo01.remove();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上两个方法运行多次，未出现线程之间相互影响的情况</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240523211207775.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th><strong>synchronized</strong></th><th><strong>ThreadLocal</strong></th></tr></thead><tbody><tr><td><strong>原理</strong></td><td>以“时间”换“空间”，多个线程排队访问同一个变量</td><td>以“空间”换“时间”，每个线程访问各自的变量</td></tr><tr><td><strong>侧重点</strong></td><td>多个线程之间访问资源的同步</td><td>多个线程中每个线程的数据隔离</td></tr></tbody></table><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 的核心是 <code>ThreadLocalMap</code>，这是一个定制的<strong>哈希表</strong>，用于存储每个线程的局部变量。<code>ThreadLocalMap</code> 不是全局的，而是作为 <code>Thread</code> 类的一个字段存在，每个线程都有自己的 <code>ThreadLocalMap</code> 实例。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是一个定制的哈希表，其中包含了 <code>ThreadLocalMap.Entry</code> 类型的元素，具体结构包括：</p><ul><li><strong>Entry</strong>：这是 <code>ThreadLocalMap</code> 中的存储单元，每个 <code>Entry</code> 是一个 <code>WeakReference</code>（弱引用）对 <code>ThreadLocal</code> 对象的引用，并直接持有一个对值（用户存储的对象）的引用。这种设计允许在没有外部强引用时，<code>ThreadLocal</code> 对象本身可以被垃圾回收，以避免内存泄漏。</li><li><strong>键（Key）</strong>：<code>ThreadLocal</code> 对象，作为弱引用存储。</li><li><strong>值（Value）</strong>：与 <code>ThreadLocal</code> 相关联的用户数据。</li></ul><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20240525014127027.png"></p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="计算哈希值"><a href="#计算哈希值" class="headerlink" title="计算哈希值"></a>计算哈希值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();<br><span class="hljs-comment">// 原子递增计数器，为了线程安全</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode = <span class="hljs-keyword">new</span> AtomicInteger();<br><span class="hljs-comment">// 黄金分割比的一个近似表达</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-comment">// 当前值加上增量并更新，然后返回旧值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>获取线程的局部变量值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 当前线程</span><br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 从线程中获取ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 自身为key获取entry</span><br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            T result = (T)e.value;<span class="hljs-comment">// 获取entry的值</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<span class="hljs-comment">// 值为空则设置默认值（null）并返回</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>设置线程的局部变量值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 从线程中获取ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// ThreadLocalMap不为空则设置值</span><br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// ThreadLocalMap为空则创建并设置值</span><br>        createMap(t, value);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>移除<code>ThreadLocalMap</code>的<code>entry</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 将ThreadLocalMap中的entry清除</span><br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ThreadLocalMap-1"><a href="#ThreadLocalMap-1" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><h4 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a>Entry类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 继承弱引用</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>    <span class="hljs-comment">// ThreadLocalMap get set的值或对象</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-keyword">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">// 初始化一个entry数组，大小为INITIAL_CAPACITY=16</span><br>    table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];<br>    <span class="hljs-comment">// &amp;运算计算出数组下标</span><br>    <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 设置key和value，其中key为ThreadLocal对象本身</span><br>    table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);<br>    <span class="hljs-comment">// 更新数组大小</span><br>    size = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 设置阈值，保持负载为 2/3 size</span><br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>下标计算方法</strong>：<code>ThreadLocal</code>的哈希值对数组大小进行<code>%运算</code>，但这里为<code>&amp;运算</code>。假设<code>INITIAL_CAPACITY</code>是一个  **2<sup>n</sup>**，如16（二进制表示为10000），这个数-1=15（二进制为1111），不难发现这种数的二进制的结果是一个全为<code>1</code>的数，这个数跟别的数进行<code>&amp;运算</code>能轻易的算出值，并且这个值就是对 <strong>2<sup>n</sup></strong> 进行模运算的值，这也是为什么<code>ThreadLocalMap</code>中<code>Entry[] table</code>的<code>size</code>为 **2<sup>n</sup>**。</p><h4 id="nextIndex-prevIndex"><a href="#nextIndex-prevIndex" class="headerlink" title="nextIndex / prevIndex"></a>nextIndex / prevIndex</h4><p>获取下一个 / 前一个<code>entry</code>，处理数组的环绕行为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prevIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><p>获取<code>entry</code>，获取为空时会顺便清理无效（不被强引用）的<code>entry</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 计算Entry数组下标</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    Entry e = table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 为空时调用的方法</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-keyword">int</span> i, Entry e)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-comment">// Entry对应的ThreadLocal为符合，则返回Entry</span><br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// Entry对应的ThreadLocal为空，说明这个entry已经过时了，调用删除方法</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a>expungeStaleEntry</h4><p>清除无效（即已经不再被引用）的<code>entry</code>，并可能重新哈希其他<code>entry</code>以保持哈希表的整洁和效率</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br><br>    <span class="hljs-comment">// 清除槽位中的value和entry，帮助垃圾收集器清理这些对象</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// 从下一索引开始遍历直至遇到一个空槽位</span><br>    Entry e;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">// 如果entry的key已被回收，则清除该entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            e.value = <span class="hljs-keyword">null</span>;<br>            tab[i] = <span class="hljs-keyword">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 重新进行哈希获取理想的下标值</span><br>            <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 若当前下标不等于理想下标，则清除entry并将entry设置到理想下标处（槽位被占则往后顺位）</span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><p>设置<code>entry</code>的值，可能会进行清理操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 从计算出的下标值开始循环直至空entry</span><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>        e != <span class="hljs-keyword">null</span>;<br>        e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>    <span class="hljs-comment">// 找到了对应的ThreadLocal，则进行更新，方法结束</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>         &#125;<br><span class="hljs-comment">// 槽位对应的key为空，则进行替换</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 没有找到匹配的entry且没有空引用，则新建entry</span><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-comment">// 添加新entry后，重新执行清理操作，如果达到阈值则重新进行哈希</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>处理已经变为无效<code>entry</code>，并尝试优化哈希表的结构</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value, <span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    Entry e;<br>    <span class="hljs-comment">// 开始清理的位置</span><br>    <span class="hljs-keyword">int</span> slotToExpunge = staleSlot;<br>    <span class="hljs-comment">// 向前遍历寻找，查找更早的无效entry，确定开始清理的位置，遇到空槽位则停下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = prevIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>         i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-keyword">null</span>)<br>            slotToExpunge = i;<br>    <span class="hljs-comment">// 开始往后遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>    <span class="hljs-comment">// 找到相同key的entry，将staleSlot处的entry设置为该处的entry</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br>            <span class="hljs-comment">// 如果需要清理的位置为staleSlot，则将其置为i，因为i是一个明确的被新entry占用的插槽处</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 清理位置更新</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有找到entry则设置一个新的entry到staleSlot处</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> Entry(key, value);<br><br>    <span class="hljs-comment">// 已发现的有其它的清理位置，则从那开始清理</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="cleanSomeSlots"><a href="#cleanSomeSlots" class="headerlink" title="cleanSomeSlots"></a>cleanSomeSlots</h4><p>从<code>i+1</code>处开始清理一些无效条目，范围减半清除（避免一次清理过多数据）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 减半清除无效entry</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        Entry e = tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>) &#123;<br>            n = len;<br>            <span class="hljs-comment">// 清除了就返回true</span><br>            removed = <span class="hljs-keyword">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>重新进行哈希，遍历清除所有无效<code>entry</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;<br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">// 达到阈值的3/4，进行扩容</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-comment">// 遍历清除所有无效entry</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleEntries</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>扩容条目数组table，期间也会对无效<code>entry</code>进行清除</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldLen = oldTab.length;<br>    <span class="hljs-comment">// 新entry数组大小为原来的两倍</span><br>    <span class="hljs-keyword">int</span> newLen = oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> Entry[newLen];<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        Entry e = oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>                e.value = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 重新计算哈希值并设置到对应插槽处</span><br>                <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 阈值、大小、条目数组更新</span><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>在数据库连接管理中，每个线程可能需要独立的数据库连接，或者至少需要确保自己的数据库操作不会受到其他线程的干扰。使用 <code>ThreadLocal</code> 来存储每个线程的数据库连接可以确保，如果能结合连接池，则会是一个更加稳妥且高效的方案，主要体现在以下方面：</p><ul><li><strong>线程安全</strong>：通过 <code>ThreadLocal</code> 确保每个线程拥有独立的数据库连接。这样，每个线程的数据库操作都是隔离的，避免了多线程间的干扰和数据一致性问题。</li><li><strong>连接复用</strong>：使用连接池可以有效管理多个数据库连接，提供连接复用的功能。每个线程通过 <code>ThreadLocal</code> 获取连接时，实际上是从连接池中获取，用完后再归还到连接池。这不仅减少了频繁创建和销毁连接的开销，而且增加了连接的利用率。</li><li><strong>性能提升</strong>：连接池可以预先创建一定数量的数据库连接，并且根据需求动态调整，这可以大大减少因为连接创建所需时间而造成的延迟。同时，由于每个线程都能及时获取到数据库连接，也减少了等待时间，从而提高了整体应用的响应速度和吞吐量。</li><li><strong>资源管理</strong>：连接池配合 <code>ThreadLocal</code> 使用，还可以更好地进行连接的生命周期管理。例如，在一个应用请求的开始创建连接，在结束时关闭连接。这样的管理确保了连接资源的有效分配，并防止了内存泄漏等问题。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource = setupDataSource();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">setupDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 设置连接池</span><br>        HikariConfig config = <span class="hljs-keyword">new</span> HikariConfig();<br>        config.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://url&quot;</span>);<br>        config.setUsername(<span class="hljs-string">&quot;user&quot;</span>);<br>        config.setPassword(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HikariDataSource(config);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        Connection conn = connectionThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span> || conn.isClosed()) &#123;<br>            <span class="hljs-comment">// 从连接池获取连接</span><br>            conn = dataSource.getConnection();<br>            connectionThreadLocal.set(conn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        Connection conn = connectionThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 关闭连接，将连接归还到连接池</span><br>            conn.close();<br>            <span class="hljs-comment">// 重要：确保清除ThreadLocal存储，避免内存泄漏</span><br>            connectionThreadLocal.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="线性探测设计"><a href="#线性探测设计" class="headerlink" title="线性探测设计"></a>线性探测设计</h2><p><code>nextIndex</code> 方法用于计算环绕数组的下一个索引位置。由于 <code>ThreadLocalMap</code> 的底层是一个循环数组，当到达数组的末尾时，需要从数组的开始处继续查找空槽位或处理冲突。<strong>这种循环处理是典型的哈希表的开放地址法中的线性探测策略的一部分</strong>。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>使用场景</strong></p><ul><li><strong>插入操作</strong>：在向 <code>ThreadLocalMap</code> 添加新的 <code>ThreadLocal</code> 时，如果计算得出的槽位已经被占用，<code>nextIndex</code> 用于找到下一个空闲槽位。</li><li><strong>删除操作</strong>：在从 <code>ThreadLocalMap</code> 删除条目时，<code>nextIndex</code> 用于帮助重新定位和填补可能留下的空洞，确保哈希表的连续性和减少碰撞。</li><li><strong>清理操作</strong>：在执行如 <code>expungeStaleEntry</code> 和 <code>cleanSomeSlots</code> 等清理无效条目的操作时，<code>nextIndex</code> 被用来逐个检查条目，直到整个数组被适当地处理。</li></ul><p>通过这种方式，<code>nextIndex</code> 方法支持 <code>ThreadLocalMap</code> 的有效运行，确保其性能和稳定性，特别是在处理数组环绕行为时。这是<strong>哈希表实现中处理开放寻址冲突解决策略的一个关键工具</strong>。</p><h2 id="弱引用设计"><a href="#弱引用设计" class="headerlink" title="弱引用设计"></a>弱引用设计</h2><p> <code>ThreadLocal</code> 设计为弱引用主要是为了确保 <code>ThreadLocal</code> 对象的生命周期不会因为它被 <code>ThreadLocalMap</code> 引用而不合理地延长，从而避免潜在的内存泄漏问题。具体作用可以从以下几个方面来理解：</p><h3 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h3><p>如果 <code>ThreadLocal</code> 对象被设计为强引用，那么只要线程仍然活着，<code>ThreadLocal</code> 对象以及它所持有的任何资源都不会被垃圾回收，即使这些 <code>ThreadLocal</code> 对象已经不再需要了。这在长时间运行的线程或线程池中尤其成问题，因为这些线程可能不会很快结束，导致长时间占用不必要的内存。</p><h3 id="解绑生命周期"><a href="#解绑生命周期" class="headerlink" title="解绑生命周期"></a>解绑生命周期</h3><p>通过使用弱引用，<code>ThreadLocal</code> 对象的生命周期就不再依赖于其存储在 <code>ThreadLocalMap</code> 中的状态。也就是说，一旦外部没有其他强引用指向 <code>ThreadLocal</code> 对象，这个对象就可以被垃圾收集器回收，无论其对应的线程是否仍然存在。这样做有效地解决了 <code>ThreadLocal</code> 可能导致的内存泄漏问题，因为 <code>ThreadLocal</code> 本身不会阻止其被回收。</p><h3 id="自动清理"><a href="#自动清理" class="headerlink" title="自动清理"></a>自动清理</h3><p>在 <code>ThreadLocalMap</code> 的实现中，每次访问 <code>ThreadLocalMap</code>（例如通过 <code>get()</code>、<code>set()</code> 或 <code>remove()</code> 方法）时，都有一个清理过程，用于检查并清除那些已经被垃圾回收的 <code>ThreadLocal</code> 对象的条目。这种自动清理机制有助于保持内存的健康状态，尤其是在长时间运行的线程中。所以代码编写者在使用<code>ThreadLocal</code>时一定要手动调用<code>remove()</code>方法，清理<code>Entry</code>数组中没有被强引用的<code>ThreadLocal</code>。</p><h2 id="强引用设计"><a href="#强引用设计" class="headerlink" title="强引用设计"></a>强引用设计</h2><p>如果 <code>ThreadLocal</code> 以强引用形式存在，那么只要线程存活，<code>ThreadLocal</code> 对象和其关联的值都不会被垃圾回收器回收。这会导致更严重的内存泄漏，因为它不仅保持了值，同时也保持了 <code>ThreadLocal</code> 对象本身。</p><h2 id="静态与非静态权衡"><a href="#静态与非静态权衡" class="headerlink" title="静态与非静态权衡"></a>静态与非静态权衡</h2><p><code>ThreadLocal</code>可以定义为<strong>静态</strong>与<strong>非静态</strong></p><p><strong>静态 ThreadLocal：</strong></p><ul><li><strong>用途</strong>：通常用于那些需要跨多个线程但每个线程需要保持独立状态的应用场景。</li><li><strong>生命周期</strong>：随着类的加载而加载，随着类的卸载而卸载，因此在应用运行期间，静态 <code>ThreadLocal</code> 不会被垃圾回收。</li><li><strong>例子</strong>：上述实际应用中，将 <code>ThreadLocal</code> 设置为静态属性，用于存储数据库连接；用户会话信息存储等。</li></ul><p><strong>非静态 ThreadLocal：</strong></p><ul><li><strong>用途</strong>：适合那些仅在类的实例生命周期内需要保持线程局部状态的情况。</li><li><strong>生命周期</strong>：与它所属的对象实例的生命周期相关，对象被回收时，非静态 <code>ThreadLocal</code> 也可能随之被回收（如果没有其他强引用）。</li><li><strong>例子</strong>：在一个对象处理特定任务时，可能需要跟踪任务执行的某些状态，但这些状态只在对象生命周期内有效。</li></ul><p>代码编写者确实需要在使用 <code>ThreadLocal</code> 时做出权衡，选择静态或非静态形式应根据<strong>具体应用的需求</strong>和<strong>资源管理策略</strong>来决定。这种<strong>灵活性</strong>让 <code>ThreadLocal</code> 成为处理线程局部存储的强大工具，但也要求开发者必须谨慎地设计和实现以<strong>防止资源泄漏</strong>和其他潜在问题。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocal</code>提供了一种优雅的方式来维护线程间的数据隔离，同时它也帮助我们避免了使用同步方法或同步块，这些同步机制可能会导致性能下降。通过使用<code>ThreadLocal</code>，我们可以提高应用程序在多线程环境下的性能，因为每个线程访问的是自己独立的变量。然而，<code>ThreadLocal</code>也应谨慎使用，不当的使用可能会导致内存泄露。例如，如果<code>ThreadLocal</code>没有被及时清除，那么由于其内部是通过弱引用实现的，可能会在某些情况下造成旧的线程上下文的长时间存留。因此，务必确保在不需要它时，适当地清理每个线程本地内存，以维护系统的健康状态和性能。</p>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL窗口函数</title>
    <link href="/2024/04/26/mysql-window-function/"/>
    <url>/2024/04/26/mysql-window-function/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着业务的不断发展，数据分析需求愈发复杂，传统聚合查询往往不能同时保留明细数据与聚合结果。MySQL 8.0 所提供的窗口函数（<code>Window Functions</code>），为此类分析型查询提供了全新的解决方案。通过定义 “窗口” 对数据分组、排序并限制帧范围，能在一条查询中同时实现聚合、排名、偏移访问等操作，而不会像传统聚合函数那样缩减结果集。本文将系统介绍窗口函数的原理、语法、常见用法与注意事项，并结合实际示例进行说明。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL 从 8.0 版本开始支持窗口函数，它允许对查询结果集中的每一行执行基于一组相关行（窗口）的计算。例如，可以计算累计和、排名、前后行数据的比较等。与普通聚合函数不同，窗口函数不会减少返回行数，而是为每一行附加一个计算结果。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>需要在保留原始行数据的同时计算统计信息（如累计求和、移动平均）。</li><li>进行数据排名、分位数划分等操作。</li><li>访问当前行之前或之后的某行数据（例如前后行的差值计算）。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="窗口（Window）"><a href="#窗口（Window）" class="headerlink" title="窗口（Window）"></a>窗口（Window）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个 “窗口” 是由 <code>OVER()</code> 子句定义的一组行。窗口函数将在这个窗口范围内对数据进行计算。每一行都会根据其所在窗口返回一个计算结果。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li>窗口并不改变结果集的行数。</li><li>允许在同一查询中同时返回原始数据和计算结果。</li></ul><h3 id="分区（Partition）"><a href="#分区（Partition）" class="headerlink" title="分区（Partition）"></a>分区（Partition）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>使用 <code>PARTITION BY</code> 子句将数据分割成多个分区，相当于对数据进行分组，每个分区内的行将独立参与窗口函数的计算。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SUM(salary) OVER(PARTITION BY department)<br></code></pre></div></td></tr></table></figure><p>这表示对每个部门（<code>department</code>）分别计算薪资总和。</p><h3 id="排序（Order）"><a href="#排序（Order）" class="headerlink" title="排序（Order）"></a>排序（Order）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>在窗口函数的 <code>OVER()</code> 子句中，可以使用 <code>ORDER BY</code> 对每个分区内的行进行排序，这会影响某些窗口函数的计算结果，对于排名、偏移及帧计算非常关键。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC)<br></code></pre></div></td></tr></table></figure><p>在每个部门中，按照薪资从高到低排序，并为每一行分配一个行号。</p><h3 id="帧规范（Frame-Specification）"><a href="#帧规范（Frame-Specification）" class="headerlink" title="帧规范（Frame Specification）"></a>帧规范（Frame Specification）</h3><p><code>ROWS/RANGE BETWEEN</code>，进一步定义在当前行的上下文中，窗口包含哪些行。</p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>窗口帧限定了在排序后的分区内，参与窗口函数计算的行的范围，即窗口包含了哪些行。MySQL 支持两种帧模式：</p><ul><li><p><strong>ROWS</strong>：基于物理行数进行界定。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ROWS BETWEEN 1 PRECEDING AND CURRENT ROW<br></code></pre></div></td></tr></table></figure><p>表示以当前行及其前一行为计算范围。</p></li><li><p><strong>RANGE</strong>：基于排序列的值范围。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW<br></code></pre></div></td></tr></table></figure><p>表示从分区开始到当前行所有符合排序条件的行。</p></li></ul><h4 id="边界说明"><a href="#边界说明" class="headerlink" title="边界说明"></a>边界说明</h4><p>可以使用以下关键字来定义帧的边界：</p><ul><li><strong>UNBOUNDED PRECEDING</strong>：从分区的第一行开始。</li><li><strong>N PRECEDING</strong>：前 N 行。</li><li><strong>CURRENT ROW</strong>：当前行。</li><li><strong>N FOLLOWING</strong>：后 N 行。</li><li><strong>UNBOUNDED FOLLOWING</strong>：到分区的最后一行。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">window_function (expression) <span class="hljs-keyword">OVER</span> (<br>    [<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>partition_column<span class="hljs-operator">&gt;</span>]<br>    [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_column<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]]<br>    [<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AND</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AND</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span>]<br>)<br></code></pre></div></td></tr></table></figure><ul><li><strong>window_function</strong>：可以是聚合函数（如 <code>SUM</code>、<code>AVG</code>、<code>COUNT</code>、<code>MIN</code>、<code>MAX</code>）或其他专用窗口函数（如 <code>ROW_NUMBER()</code>、<code>RANK()</code>、<code>LAG()</code> 等）。</li><li><strong>expression</strong>：要计算的表达式或列。</li><li><strong>OVER 子句</strong>：<ul><li>**PARTITION BY <partition_column>**：定义分区。</li><li>**ORDER BY <order_column> [ASC|DESC]**：定义分区内的排序规则。</li><li>**[ROWS BETWEEN &lt;start&gt; AND &lt;end&gt; | RANGE BETWEEN &lt;start&gt; AND &lt;end&gt;]**：定义窗口帧的范围。</li></ul></li></ul><h2 id="常见的窗口函数"><a href="#常见的窗口函数" class="headerlink" title="常见的窗口函数"></a>常见的窗口函数</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>这些函数在窗口内计算聚合值，与普通聚合函数类似，但不会压缩行数。</p><h4 id="SUM-column-name"><a href="#SUM-column-name" class="headerlink" title="SUM(column_name)"></a>SUM(column_name)</h4><ul><li>计算指定窗口内所有行指定列的总和。</li><li>在需要对数据集中的特定窗口（如某个时间段内、某个部门内）计算总和时使用。</li></ul><h4 id="AVG-column-name"><a href="#AVG-column-name" class="headerlink" title="AVG(column_name)"></a>AVG(column_name)</h4><ul><li>计算指定窗口内所有行指定列的平均值。</li><li>在需要对数据集中的特定窗口（如某个时间段内、某个部门内）计算平均值时使用。</li></ul><h4 id="MIN-column-name"><a href="#MIN-column-name" class="headerlink" title="MIN(column_name)"></a>MIN(column_name)</h4><ul><li>计算指定窗口内所有行指定列的最小值。</li><li>在需要找出数据集中特定窗口（如某个时间段内、某个部门内）的最小值时使用。</li></ul><h4 id="MAX-column-name"><a href="#MAX-column-name" class="headerlink" title="MAX(column_name)"></a>MAX(column_name)</h4><ul><li>计算指定窗口内所有行指定列的最大值。</li><li>在需要找出数据集中特定窗口（如某个时间段内、某个部门内）的最大值时使用。</li></ul><h4 id="COUNT-column-name"><a href="#COUNT-column-name" class="headerlink" title="COUNT(column_name)"></a>COUNT(column_name)</h4><ul><li>计算指定窗口内所有行指定列的行数。</li><li>在需要计算数据集中特定窗口（如某个时间段内、某个部门内）的行数时使用。</li></ul><h4 id="VAR-POP-column-name"><a href="#VAR-POP-column-name" class="headerlink" title="VAR_POP(column_name)"></a>VAR_POP(column_name)</h4><ul><li>计算指定窗口内所有行指定列的总体方差。</li><li>在需要分析数据集中特定窗口（如某个时间段内、某个部门内）数据的变异性时使用。</li></ul><h4 id="STDDEV-POP"><a href="#STDDEV-POP" class="headerlink" title="STDDEV_POP()"></a>STDDEV_POP()</h4><ul><li>计算指定窗口内所有行指定列的总体标准差。</li><li>在需要分析数据集中特定窗口（如某个时间段内、某个部门内）数据的标准差，即变异性度量时使用。</li></ul><h3 id="排名函数"><a href="#排名函数" class="headerlink" title="排名函数"></a>排名函数</h3><h4 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h4><ul><li>为每个窗口分组内的行提供一个唯一的序列号，从 1 开始，如1、2、3、…</li><li>在需要对数据集中特定窗口（如某个时间段内、某个部门内）的行进行唯一编号时使用，常用于排序并提取排名。</li></ul><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK()"></a>RANK()</h4><ul><li>为指定窗口内的每一行分配一个排名。如果存在相同的值，它们会获得相同的排名，而下一个排名将跳过之前的重复排名数。</li><li>在需要对数据集中特定窗口（如某个时间段内、某个部门内）的行进行排名时使用，特别是当存在并列排名的情况时。</li></ul><h4 id="DENSE-RANK"><a href="#DENSE-RANK" class="headerlink" title="DENSE_RANK()"></a>DENSE_RANK()</h4><ul><li>与 <code>RANK()</code> 类似，但排名不会跳过任何排名数。</li><li>在需要对数据集中特定窗口（如某个时间段内、某个部门内）的行进行连续排名时使用，特别是当排名不应因并列而跳号时。</li></ul><h4 id="PERCENT-RANK"><a href="#PERCENT-RANK" class="headerlink" title="PERCENT_RANK()"></a>PERCENT_RANK()</h4><ul><li>计算当前行的百分比排名。这个排名是基于当前行在分组中的位置，公式为：(排名 - 1) / (总行数 - 1)。如果只有一行，结果是 0。</li><li>在需要确定某个值在整个数据集中的相对位置时使用，常用于数据分析，特别是当需要评估数据相对于其它数据的表现时。</li></ul><h4 id="CUME-DIST"><a href="#CUME-DIST" class="headerlink" title="CUME_DIST()"></a>CUME_DIST()</h4><ul><li>计算当前行的累积分布，这意味着计算有多少比例的值小于等于当前行的值。公式为：当前行之前的行数（包括当前行） / 总行数。</li><li>在需要确定某个值在整个数据集中的累积分布位置时使用，常用于统计分析，尤其是当需要评估一个值相对于集合的位置时。</li></ul><h4 id="NTILE"><a href="#NTILE" class="headerlink" title="NTILE()"></a>NTILE()</h4><ul><li>将窗口内的行分成  n  个大致相等的组，并为每一行分配一个组号，从 1 到 n。如果窗口中的行数不能被 n 整除，那么前面的几个组将包含一个额外的行。</li><li>在需要将数据集分组进行分析时使用，如分位数分析、性能评级或将数据分成多个性能层次。</li></ul><h3 id="值获取函数"><a href="#值获取函数" class="headerlink" title="值获取函数"></a>值获取函数</h3><h4 id="FIRST-VALUE-column-name"><a href="#FIRST-VALUE-column-name" class="headerlink" title="FIRST_VALUE(column_name)"></a>FIRST_VALUE(column_name)</h4><ul><li>返回窗口内第一行的指定列值。</li><li>在需要获取数据集中特定窗口（如某个时间段内、某个部门内）第一个记录的值时使用，常用于时间序列分析，或当需要参考某个范围内的起始值进行比较时。</li></ul><h4 id="LAST-VALUE-column-name"><a href="#LAST-VALUE-column-name" class="headerlink" title="LAST_VALUE(column_name)"></a>LAST_VALUE(column_name)</h4><ul><li>返回窗口内最后一行的指定列值，使用时要注意定义正确的窗口帧（ROWS/RANGE BETWEEN），否则可能不会得到预期的结果。</li><li>在需要获取数据集中特定窗口（如某个时间段内、某个部门内）最后一个记录的值时使用，常用于时间序列分析，或当需要参考某个范围内的结束值进行比较时。</li></ul><h4 id="NTH-VALUE-column-name-n"><a href="#NTH-VALUE-column-name-n" class="headerlink" title="NTH_VALUE(column_name, n)"></a>NTH_VALUE(column_name, n)</h4><ul><li>返回窗口内第 n 行的指定列值。</li><li>在需要获取数据集中特定窗口（如某个时间段内、某个部门内）特定位置的记录值时使用，常用于需要定位序列中特定点的数据分析。</li></ul><h3 id="位移类（偏移）函数"><a href="#位移类（偏移）函数" class="headerlink" title="位移类（偏移）函数"></a>位移类（偏移）函数</h3><h4 id="LAG-column-name-offset-default-value"><a href="#LAG-column-name-offset-default-value" class="headerlink" title="LAG(column_name [, offset, default_value])"></a>LAG(column_name [, offset, default_value])</h4><ul><li>返回当前行的指定列在窗口中前一行的值，可指定前 <code>offset</code> 行的值并指定一个默认值作为返回。</li><li>在需要访问当前行之前的数据时使用，常用于时间序列数据分析、比较连续记录之间的变化，或计算增长率等。</li></ul><h4 id="LEAD-column-name-offset-default-value"><a href="#LEAD-column-name-offset-default-value" class="headerlink" title="LEAD(column_name [, offset, default_value])"></a>LEAD(column_name [, offset, default_value])</h4><ul><li>返回当前行的指定列在窗口中后一行的值，可指定前后 <code>offset</code> 行的值并指定一个默认值作为返回。</li><li>在需要访问当前行之后的数据时使用，常用于预测未来的数据点、比较连续记录之间的变化，或者在数据序列中提前反应趋势和模式。</li></ul><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><h3 id="前置数据"><a href="#前置数据" class="headerlink" title="前置数据"></a>前置数据</h3><p>创建城市 GDP 信息表，模拟插入若干数据。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 城市GDP信息表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `city_gdp`<br>(<br>    `id`       <span class="hljs-type">int</span>            <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>    `<span class="hljs-keyword">year</span>`     <span class="hljs-keyword">year</span>           <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年份&#x27;</span>,<br>    `province` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;省份&#x27;</span>,<br>    `city`     <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;城市&#x27;</span>,<br>    `gdp`      <span class="hljs-type">decimal</span>(<span class="hljs-number">12</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;人民币（亿）&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4<br>  <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_0900_ai_ci COMMENT <span class="hljs-operator">=</span><span class="hljs-string">&#x27;城市GDP&#x27;</span>;<br><br><span class="hljs-comment">-- 数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> city_gdp(<span class="hljs-keyword">year</span>, province, city, gdp)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;广州市&#x27;</span>, <span class="hljs-number">28839</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;深圳市&#x27;</span>, <span class="hljs-number">32387.68</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;佛山市&#x27;</span>, <span class="hljs-number">12698.39</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;东莞市&#x27;</span>, <span class="hljs-number">11200.32</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;惠州市&#x27;</span>, <span class="hljs-number">5401.24</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;珠海市&#x27;</span>, <span class="hljs-number">4045.45</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;福州市&#x27;</span>, <span class="hljs-number">12308.23</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;泉州市&#x27;</span>, <span class="hljs-number">12102.97</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;厦门市&#x27;</span>, <span class="hljs-number">7802.7</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;杭州市&#x27;</span>, <span class="hljs-number">18753</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;宁波市&#x27;</span>, <span class="hljs-number">15704.3</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;温州市&#x27;</span>, <span class="hljs-number">8029.8</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;绍兴市&#x27;</span>, <span class="hljs-number">7351</span>),<br>       (<span class="hljs-number">2022</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;嘉兴市&#x27;</span>, <span class="hljs-number">6739.45</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;广州市&#x27;</span>, <span class="hljs-number">30355.73</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;深圳市&#x27;</span>, <span class="hljs-number">34606.4</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;佛山市&#x27;</span>, <span class="hljs-number">13276.14</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;东莞市&#x27;</span>, <span class="hljs-number">11438.13</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;惠州市&#x27;</span>, <span class="hljs-number">5639.68</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;广东省&#x27;</span>, <span class="hljs-string">&#x27;珠海市&#x27;</span>, <span class="hljs-number">4233.2</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;福州市&#x27;</span>, <span class="hljs-number">12928.47</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;泉州市&#x27;</span>, <span class="hljs-number">12172.33</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;福建省&#x27;</span>, <span class="hljs-string">&#x27;厦门市&#x27;</span>, <span class="hljs-number">8066.49</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;杭州市&#x27;</span>, <span class="hljs-number">20058.98</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;宁波市&#x27;</span>, <span class="hljs-number">16452.83</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;温州市&#x27;</span>, <span class="hljs-number">8730.63</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;绍兴市&#x27;</span>, <span class="hljs-number">7791.14</span>),<br>       (<span class="hljs-number">2023</span>, <span class="hljs-string">&#x27;浙江省&#x27;</span>, <span class="hljs-string">&#x27;嘉兴市&#x27;</span>, <span class="hljs-number">7062.45</span>);<br></code></pre></div></td></tr></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li><p>查询 2022 年广东省各城市 GDP 与第一名城市 GDP 的差值。</p><p><strong>SQL 示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT cg.year,<br>       cg.province,<br>       cg.city,<br>       cg.gdp,<br>       MAX(cg.gdp) OVER (PARTITION BY cg.province)          AS max_gdp,<br>       MAX(cg.gdp) OVER (PARTITION BY cg.province) - cg.gdp AS diff<br>FROM city_gdp cg<br>WHERE cg.province = &#x27;广东省&#x27;<br>  AND cg.year = 2022;<br></code></pre></div></td></tr></table></figure><p><strong>查询结果</strong>：</p><table><thead><tr><th align="left">year</th><th align="left">province</th><th align="left">city</th><th align="left">gdp</th><th align="left">max_gdp</th><th align="left">diff</th></tr></thead><tbody><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">广州市</td><td align="left">28839.00</td><td align="left">32387.68</td><td align="left">3548.68</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">深圳市</td><td align="left">32387.68</td><td align="left">32387.68</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">佛山市</td><td align="left">12698.39</td><td align="left">32387.68</td><td align="left">19689.29</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">东莞市</td><td align="left">11200.32</td><td align="left">32387.68</td><td align="left">21187.36</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">惠州市</td><td align="left">5401.24</td><td align="left">32387.68</td><td align="left">26986.44</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">珠海市</td><td align="left">4045.45</td><td align="left">32387.68</td><td align="left">28342.23</td></tr></tbody></table></li><li><p>查询 2022 年各城市 GDP 在省份内的排名。</p><p><strong>SQL 示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT cg.year,<br>       cg.province,<br>       cg.city,<br>       cg.gdp,<br>       RANK() OVER (PARTITION BY cg.province ORDER BY cg.gdp DESC) AS rk<br>FROM city_gdp cg<br>WHERE cg.year = 2022;<br></code></pre></div></td></tr></table></figure><p><strong>查询结果</strong>：</p><table><thead><tr><th align="left">year</th><th align="left">province</th><th align="left">city</th><th align="left">gdp</th><th align="left">rk</th></tr></thead><tbody><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">深圳市</td><td align="left">32387.68</td><td align="left">1</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">广州市</td><td align="left">28839.00</td><td align="left">2</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">佛山市</td><td align="left">12698.39</td><td align="left">3</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">东莞市</td><td align="left">11200.32</td><td align="left">4</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">惠州市</td><td align="left">5401.24</td><td align="left">5</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">珠海市</td><td align="left">4045.45</td><td align="left">6</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">杭州市</td><td align="left">18753.00</td><td align="left">1</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">宁波市</td><td align="left">15704.30</td><td align="left">2</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">温州市</td><td align="left">8029.80</td><td align="left">3</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">绍兴市</td><td align="left">7351.00</td><td align="left">4</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">嘉兴市</td><td align="left">6739.45</td><td align="left">5</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">福州市</td><td align="left">12308.23</td><td align="left">1</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">泉州市</td><td align="left">12102.97</td><td align="left">2</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">厦门市</td><td align="left">7802.70</td><td align="left">3</td></tr></tbody></table></li><li><p>查询 2022 年各城市 GDP 与第二名 GDP 的差值。</p><p><strong>SQL 示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cg.year,<br>       cg.province,<br>       cg.gdp,<br>       cg.city,<br>       <span class="hljs-built_in">NTH_VALUE</span>(cg.gdp, <span class="hljs-number">2</span>)<br>                 <span class="hljs-keyword">OVER</span> (<br>                     <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.province<br>                     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span><br>                     )          <span class="hljs-keyword">AS</span> sec_gdp,<br>       cg.gdp <span class="hljs-operator">-</span> <span class="hljs-built_in">NTH_VALUE</span>(cg.gdp, <span class="hljs-number">2</span>)<br>                          <span class="hljs-keyword">OVER</span> (<br>                              <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.province<br>                              <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span><br>                              ) <span class="hljs-keyword">AS</span> diff<br><span class="hljs-keyword">FROM</span> city_gdp cg<br><span class="hljs-keyword">WHERE</span> cg.year <span class="hljs-operator">=</span> <span class="hljs-number">2022</span>;<br></code></pre></div></td></tr></table></figure><p><strong>查询结果</strong>：</p><table><thead><tr><th align="left">year</th><th align="left">province</th><th align="left">gdp</th><th align="left">city</th><th align="left">sec_gdp</th><th align="left">diff</th></tr></thead><tbody><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">32387.68</td><td align="left">深圳市</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">28839.00</td><td align="left">广州市</td><td align="left">28839.00</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">12698.39</td><td align="left">佛山市</td><td align="left">28839.00</td><td align="left">-16140.61</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">11200.32</td><td align="left">东莞市</td><td align="left">28839.00</td><td align="left">-17638.68</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">5401.24</td><td align="left">惠州市</td><td align="left">28839.00</td><td align="left">-23437.76</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">4045.45</td><td align="left">珠海市</td><td align="left">28839.00</td><td align="left">-24793.55</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">18753.00</td><td align="left">杭州市</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">15704.30</td><td align="left">宁波市</td><td align="left">15704.30</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">8029.80</td><td align="left">温州市</td><td align="left">15704.30</td><td align="left">-7674.50</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">7351.00</td><td align="left">绍兴市</td><td align="left">15704.30</td><td align="left">-8353.30</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">6739.45</td><td align="left">嘉兴市</td><td align="left">15704.30</td><td align="left">-8964.85</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">12308.23</td><td align="left">福州市</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">12102.97</td><td align="left">泉州市</td><td align="left">12102.97</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">7802.70</td><td align="left">厦门市</td><td align="left">12102.97</td><td align="left">-4300.27</td></tr></tbody></table><p>可以看到查询结果中第一名所在行的 <code>sec_gdp</code> 为 <code>null</code>，这是因为 <code>NTH_VALUE()</code> 函数的默认行为只考虑从当前行往前到窗口开始的行，此时就需要调整 <code>OVER()</code> 子句中的窗口帧了，这里我们需要将其调整为从分区的第一行到最后一行，调整后 SQL 为</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cg.year,<br>       cg.province,<br>       cg.gdp,<br>       cg.city,<br>       <span class="hljs-built_in">NTH_VALUE</span>(cg.gdp, <span class="hljs-number">2</span>)<br>                 <span class="hljs-keyword">OVER</span> (<br>                     <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.province<br>                     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span><br>                     <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="hljs-keyword">AND</span> UNBOUNDED FOLLOWING<br>                     )          <span class="hljs-keyword">AS</span> sec_gdp,<br>       cg.gdp <span class="hljs-operator">-</span> <span class="hljs-built_in">NTH_VALUE</span>(cg.gdp, <span class="hljs-number">2</span>)<br>                          <span class="hljs-keyword">OVER</span> (<br>                              <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.province<br>                              <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span><br>                              <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="hljs-keyword">AND</span> UNBOUNDED FOLLOWING<br>                              ) <span class="hljs-keyword">AS</span> diff<br><span class="hljs-keyword">FROM</span> city_gdp cg<br><span class="hljs-keyword">WHERE</span> cg.year <span class="hljs-operator">=</span> <span class="hljs-number">2022</span>;<br></code></pre></div></td></tr></table></figure><p><strong>查询结果</strong>：</p><table><thead><tr><th align="left">year</th><th align="left">province</th><th align="left">gdp</th><th align="left">city</th><th align="left">sec_gdp</th><th align="left">diff</th></tr></thead><tbody><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">32387.68</td><td align="left">深圳市</td><td align="left">28839.00</td><td align="left">3548.68</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">28839.00</td><td align="left">广州市</td><td align="left">28839.00</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">12698.39</td><td align="left">佛山市</td><td align="left">28839.00</td><td align="left">-16140.61</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">11200.32</td><td align="left">东莞市</td><td align="left">28839.00</td><td align="left">-17638.68</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">5401.24</td><td align="left">惠州市</td><td align="left">28839.00</td><td align="left">-23437.76</td></tr><tr><td align="left">2022</td><td align="left">广东省</td><td align="left">4045.45</td><td align="left">珠海市</td><td align="left">28839.00</td><td align="left">-24793.55</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">18753.00</td><td align="left">杭州市</td><td align="left">15704.30</td><td align="left">3048.70</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">15704.30</td><td align="left">宁波市</td><td align="left">15704.30</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">8029.80</td><td align="left">温州市</td><td align="left">15704.30</td><td align="left">-7674.50</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">7351.00</td><td align="left">绍兴市</td><td align="left">15704.30</td><td align="left">-8353.30</td></tr><tr><td align="left">2022</td><td align="left">浙江省</td><td align="left">6739.45</td><td align="left">嘉兴市</td><td align="left">15704.30</td><td align="left">-8964.85</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">12308.23</td><td align="left">福州市</td><td align="left">12102.97</td><td align="left">205.26</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">12102.97</td><td align="left">泉州市</td><td align="left">12102.97</td><td align="left">0.00</td></tr><tr><td align="left">2022</td><td align="left">福建省</td><td align="left">7802.70</td><td align="left">厦门市</td><td align="left">12102.97</td><td align="left">-4300.27</td></tr></tbody></table></li><li><p>获取每个年度每个城市的GDP与前一名的GDP差距。</p><p><strong>SQL 示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cg.year,<br>       cg.city,<br>       cg.province,<br>       cg.gdp,<br>       <span class="hljs-built_in">LAG</span>(cg.gdp) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.year, cg.province <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span>)          <span class="hljs-keyword">AS</span> pre_gdp,<br>       cg.gdp <span class="hljs-operator">-</span> <span class="hljs-built_in">LAG</span>(cg.gdp) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cg.year, cg.province <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cg.gdp <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> diff<br><span class="hljs-keyword">FROM</span> city_gdp cg;<br></code></pre></div></td></tr></table></figure><p><strong>查询结果</strong>：</p><table><thead><tr><th align="left">year</th><th align="left">city</th><th align="left">province</th><th align="left">gdp</th><th align="left">pre_gdp</th><th align="left">diff</th></tr></thead><tbody><tr><td align="left">2022</td><td align="left">深圳市</td><td align="left">广东省</td><td align="left">32387.68</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">广州市</td><td align="left">广东省</td><td align="left">28839.00</td><td align="left">32387.68</td><td align="left">-3548.68</td></tr><tr><td align="left">2022</td><td align="left">佛山市</td><td align="left">广东省</td><td align="left">12698.39</td><td align="left">28839.00</td><td align="left">-16140.61</td></tr><tr><td align="left">2022</td><td align="left">东莞市</td><td align="left">广东省</td><td align="left">11200.32</td><td align="left">12698.39</td><td align="left">-1498.07</td></tr><tr><td align="left">2022</td><td align="left">惠州市</td><td align="left">广东省</td><td align="left">5401.24</td><td align="left">11200.32</td><td align="left">-5799.08</td></tr><tr><td align="left">2022</td><td align="left">珠海市</td><td align="left">广东省</td><td align="left">4045.45</td><td align="left">5401.24</td><td align="left">-1355.79</td></tr><tr><td align="left">2022</td><td align="left">杭州市</td><td align="left">浙江省</td><td align="left">18753.00</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">宁波市</td><td align="left">浙江省</td><td align="left">15704.30</td><td align="left">18753.00</td><td align="left">-3048.70</td></tr><tr><td align="left">2022</td><td align="left">温州市</td><td align="left">浙江省</td><td align="left">8029.80</td><td align="left">15704.30</td><td align="left">-7674.50</td></tr><tr><td align="left">2022</td><td align="left">绍兴市</td><td align="left">浙江省</td><td align="left">7351.00</td><td align="left">8029.80</td><td align="left">-678.80</td></tr><tr><td align="left">2022</td><td align="left">嘉兴市</td><td align="left">浙江省</td><td align="left">6739.45</td><td align="left">7351.00</td><td align="left">-611.55</td></tr><tr><td align="left">2022</td><td align="left">福州市</td><td align="left">福建省</td><td align="left">12308.23</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2022</td><td align="left">泉州市</td><td align="left">福建省</td><td align="left">12102.97</td><td align="left">12308.23</td><td align="left">-205.26</td></tr><tr><td align="left">2022</td><td align="left">厦门市</td><td align="left">福建省</td><td align="left">7802.70</td><td align="left">12102.97</td><td align="left">-4300.27</td></tr><tr><td align="left">2023</td><td align="left">深圳市</td><td align="left">广东省</td><td align="left">34606.40</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2023</td><td align="left">广州市</td><td align="left">广东省</td><td align="left">30355.73</td><td align="left">34606.40</td><td align="left">-4250.67</td></tr><tr><td align="left">2023</td><td align="left">佛山市</td><td align="left">广东省</td><td align="left">13276.14</td><td align="left">30355.73</td><td align="left">-17079.59</td></tr><tr><td align="left">2023</td><td align="left">东莞市</td><td align="left">广东省</td><td align="left">11438.13</td><td align="left">13276.14</td><td align="left">-1838.01</td></tr><tr><td align="left">2023</td><td align="left">惠州市</td><td align="left">广东省</td><td align="left">5639.68</td><td align="left">11438.13</td><td align="left">-5798.45</td></tr><tr><td align="left">2023</td><td align="left">珠海市</td><td align="left">广东省</td><td align="left">4233.20</td><td align="left">5639.68</td><td align="left">-1406.48</td></tr><tr><td align="left">2023</td><td align="left">杭州市</td><td align="left">浙江省</td><td align="left">20058.98</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2023</td><td align="left">宁波市</td><td align="left">浙江省</td><td align="left">16452.83</td><td align="left">20058.98</td><td align="left">-3606.15</td></tr><tr><td align="left">2023</td><td align="left">温州市</td><td align="left">浙江省</td><td align="left">8730.63</td><td align="left">16452.83</td><td align="left">-7722.20</td></tr><tr><td align="left">2023</td><td align="left">绍兴市</td><td align="left">浙江省</td><td align="left">7791.14</td><td align="left">8730.63</td><td align="left">-939.49</td></tr><tr><td align="left">2023</td><td align="left">嘉兴市</td><td align="left">浙江省</td><td align="left">7062.45</td><td align="left">7791.14</td><td align="left">-728.69</td></tr><tr><td align="left">2023</td><td align="left">福州市</td><td align="left">福建省</td><td align="left">12928.47</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">2023</td><td align="left">泉州市</td><td align="left">福建省</td><td align="left">12172.33</td><td align="left">12928.47</td><td align="left">-756.14</td></tr><tr><td align="left">2023</td><td align="left">厦门市</td><td align="left">福建省</td><td align="left">8066.49</td><td align="left">12172.33</td><td align="left">-4105.84</td></tr></tbody></table></li></ol><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="性能开销"><a href="#性能开销" class="headerlink" title="性能开销"></a>性能开销</h3><ul><li><strong>数据排序</strong>：窗口函数经常需要对数据进行排序，这可以是一个资源密集型的操作，尤其是当数据集非常大时。排序操作通常涉及内存和可能的磁盘 I/O，这会影响查询的执行时间。</li><li><strong>分区处理</strong>：如果使用 <code>PARTITION BY</code> 子句，数据库需要为每个分区执行函数，这可能导致处理时间增加，尤其是当有大量小分区时。</li><li><strong>计算开销</strong>：某些窗口函数本身（如计算排名或计算移动平均）就需要额外的计算开销。特别是当每个窗口大小较大或窗口函数涉及复杂操作（例如标准差或线性回归）时，这些计算可能变得相当昂贵。</li></ul><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li><strong>合理的索引</strong>：对用于 <code>ORDER BY</code> 和 <code>PARTITION BY</code> 的列建立索引可以显著提高窗口函数的性能，因为这可以加速排序和分区的数据检索过程。</li><li><strong>减少数据量</strong>：在使用窗口函数之前通过过滤条件减少处理的数据量可以提高性能。</li><li><strong>精简窗口规格</strong>：尽量使用精简的 <code>ROWS</code> 或 <code>RANGE</code> 规格。例如，如果只需要访问前一行或后一行数据，使用 <code>LAG()</code> 或 <code>LEAD()</code> 而不是更广泛的窗口可能更有效。</li><li><strong>避免冗余计算</strong>：如果可能，尝试重用已经计算过的结果，或者在应用层而不是数据库层面进行某些计算，尤其是在结果集较小的情况下。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>窗口函数虽然在处理复杂的分析查询时非常强大，但它们可能不适合实时查询或需要高度优化的系统，除非能够很好地控制查询条件和数据量。</li><li>在处理大规模数据、需要高性能和高可用性的场景下，处理数据分析应优先考虑交给应用层实现，应用层往往有并行处理、缓存优化、资源分配、负载均衡等更多优势，虽然可能会涉及更多的开发工作，但通常能为系统提供更好的总体性能和更高的灵活性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 MySQL 8.0 中，窗口函数解决了 “既要聚合数据，又要保留明细” 的棘手问题。它通过 <code>OVER()</code> 子句使同一分组或排序下的多种计算（如排名、求和、移动平均、前后行比较等）在单条 SQL 中得以实现，大大减少了复杂分析场景下的开发成本。开发者需要充分理解窗口函数的机制并结合自身业务场景加以运用，以在数据库层面实现更灵活、高效的分析与统计处理，为数据驱动的决策和应用开发提供重要支撑。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MySQL窗口函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL常用函数</title>
    <link href="/2022/12/03/mysql-functions/"/>
    <url>/2022/12/03/mysql-functions/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在数据库应用中，恰当利用内置函数能极大提升数据查询与处理的灵活度与效率。MySQL 作为广泛使用的关系型数据库，提供了丰富的函数库以支持各种操作需求——从聚合统计、流程控制，到字符串操作、日期时间处理乃至加解密。本文根据功能类别逐一介绍了 MySQL 中常见的内置函数，并针对每个函数提供了简要说明，以帮助开发者和运维人员快速理解和使用这些函数，进而提升数据库开发与管理的效率。</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ul><li><code>AVG([DISTINCT] expr)</code>：（分组）对列的数据求平均值。</li><li><code> SUM([DISTINCT] expr)</code>：（分组）对列的数据求总和。</li><li><code>MIN([DISTINCT] expr)</code>：（分组）求列数据的最小值。</li><li><code>MAX([DISTINCT] expr)</code>：（分组）求列数据的最大值。</li><li><code>COUNT([DISTINCT] expr)</code>：（分组）求数据行数。</li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul><li><code>IF(expr1,expr2,expr3)</code>：如果 <code>expr1</code> 的值为 <code>TRUE</code>，返回 <code>expr2</code>， 否则返回 <code>expr3</code>。</li><li><code>IFNULL(expr1,expr2)</code>：如果 <code>expr1</code> 不为 <code>NULL</code>，返回 <code>expr1</code>，否则返回 <code>expr2</code>。</li><li><code>CASE WHEN ... THEN ... [ELSE ...] END</code>：相当于 Java 语言的 <code>if...else if...else...</code>。</li><li><code>CASE case_value WHEN when_value THEN statement_list ELSE statement_list END CASE;</code>：相当于 Java 语言的 <code>switch...case...</code>。</li><li><code>BENCHMARK(count,expr)</code>：将表达式 <code>expr</code> 重复执行 <code>count</code> 次。</li></ul><h2 id="数据库信息"><a href="#数据库信息" class="headerlink" title="数据库信息"></a>数据库信息</h2><ul><li><code>VERSION()</code>：返回当前 MySQL 的版本号。</li><li><code>CONNECTION_ID()</code>：返回当前会话的连接 ID（线程 ID）。</li><li><code>DATABASE()</code>，<code>SCHEMA()</code>：返回 MySQL 命令行当前所在的数据库。</li><li><code>USER()</code>、<code>CURRENT_USER()</code>、<code>SYSTEM_USER()</code>、<code>SESSION_USER()</code>：返回当前连接 MySQL 的用户名，返回结果格式为 “用户名@主机名”。</li><li><code>CHARSET(str)</code>：返回字符串 <code>str</code> 自变量的字符集。</li><li><code>COLLATION(str)</code>：返回字符串 <code>str</code> 的比较规则。</li><li><code>CONVERT(expr USING transcoding_name)</code>：将 <code>expr</code> 所使用的字符编码修改为 <code>transcoding_name</code>。</li><li><code>ROW_COUNT()</code>：返回上一句 SQL 增删改影响的记录数，查询返回-1。</li><li><code>FOUND_ROWS()</code>：上一句 <code>SELECT</code> 或 <code>SHOW</code> 语句的结果集的记录数。</li></ul><h2 id="计算-比较"><a href="#计算-比较" class="headerlink" title="计算/比较"></a>计算/比较</h2><ul><li><p><code>ABS(X)</code>：返回 <code>x</code> 的绝对值。</p></li><li><p><code>SIGN(X)</code>：返回 <code>x</code> 的符号，正数为 <code>1</code>，负数为 <code>-1</code>，<code>0</code> 返回 <code>0</code>。</p></li><li><p><code>PI()</code>：返回圆周率。</p></li><li><p><code>CEIL(X)</code> / <code>CEILING(X)</code>：返回大于或等于某个值的最小整数。</p></li><li><p><code>FLOOR(X)</code>：返回小于或等于某个值的最大整数。</p></li><li><p><code>LEAST(value1,value2,...)</code>：返回列表中的最小值，列表含 <code>NULL</code> 则返回 <code>NULL</code>。</p></li><li><p><code>GREATEST(value1,value2,...)</code>：返回列表中的最大值，列表含 <code>NULL</code> 则返回 <code>NULL</code>。</p></li><li><p><code>MOD(N,M)</code>：返回 <code>X</code> 除以 <code>Y</code> 后的余数。</p></li><li><p><code>RAND()</code>：返回 0 ~ 1 的随机值。</p></li><li><p><code>RAND(X)</code>：返回 0 ~ 1 的随机值，其中 <code>X</code> 的值用作种子值，相同的 <code>X</code> 值会产生相同的随机数。</p></li><li><p><code>ROUND(X)</code>：返回一个对 <code>X</code> 的值进行四舍五入后，最接近于 <code>X</code> 的整数。</p></li><li><p><code>ROUND(X,Y)</code>：返回一个对 <code>X</code> 的值进行四舍五入后最接近 <code>X</code> 的值，并保留到小数点后面 <code>Y</code> 位。</p></li><li><p><code>TRUNCATE(X,Y)</code>：返回数字 <code>X</code> 截断为 <code>Y</code> 位小数的结果。</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><code>ASCII(str)</code>：返回字符串 <code>str</code> 中的第一个字符的 <code>ASCII</code> 码值。</li><li><code>CHAR_LENGTH(str)</code>：返回字符串 <code>str</code> 的字符数。作用与 <code>CHARACTER_LENGTH(str)</code> 相同。</li><li><code>LENGTH(str)</code>：返回字符串 <code>str</code> 的字节数，和字符集有关。</li><li><code>CONCAT(str1,str2,..)</code>：拼接 <code>str1</code>、<code>str2</code> 等字符串为一个新的字符串。</li><li><code>CONCAT_WS(separator,str1,str2,...)</code>：同 <code>CONCAT(str1,str2,..)</code> 函数，但是每个字符串之间拼接时要加上 <code>separator</code>。</li><li><code>INSERT(str,pos,len,newstr)</code>：将字符串 <code>str</code> 从第 <code>pos</code> 位置开始，<code>len</code> 个字符长的子串替换为字符串 <code>newstr</code>。</li><li><code>REPLACE(str,from_str,to_str)</code>：用字符串 <code>to_str</code> 替换字符串 <code>str</code> 中所有出现的字符串 <code>from_str</code>。</li><li><code>UPPER(str)</code> / <code>UCASE(str)</code>：将字符串 <code>str</code> 的所有字母转成大写字母。</li><li><code>LOWER(str)</code> / <code>LCASE(str)</code>：将字符串 <code>str</code> 的所有字母转成小写字母。</li><li><code>LEFT(str,len)</code>：返回字符串 <code>str</code> 最左边的 <code>len</code> 个字符。</li><li><code>RIGHT(str,len)</code>：返回字符串 <code>str</code> 最右边的 <code>len</code> 个字符。</li><li><code>LPAD(str,len,padstr)</code>：用字符串 <code>padstr</code> 对 <code>str</code> 最左边进行填充，直到 <code>str</code> 的长度为 <code>len</code> 个字符。</li><li><code>RPAD(str,len,padstr)</code>：用字符串 <code>padstr</code> 对 <code>str</code> 最右边进行填充，直到 <code>str</code> 的长度为 <code>len</code> 个字符。</li><li><code>TRIM(str)</code>：去掉字符串 <code>str</code>开始与结尾的空格。</li><li><code>LTRIM(str)</code>：去掉字符串 <code>str</code> 左侧的空格。</li><li><code>RTRIM(str)</code>：去掉字符串 <code>str</code> 右侧的空格。</li><li><code>TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str)</code>：去掉 <code>str</code> 两边/开始/结尾处的 <code>remstr</code>。</li><li><code>REPEAT(str,count)</code>：返回 <code>str</code> 重复 <code>count</code> 次的结果。</li><li><code>SPACE(N)</code>：返回 <code>N</code> 个空格。</li><li><code>STRCMP(expr1,expr2)</code>：比较字符串 <code>expr1</code> 和 <code>expr2</code> 的 <code>ASCII</code> 码值的大小。</li><li><code>SUBSTR(str,pos,len)</code>：返回从字符串 <code>str</code> 的 <code>pos</code> 位置其 <code>len</code> 个字符，作用与 <code>SUBSTRING(str,pos,len)</code>、<code>MID(str,pos,len)</code> 相同。</li><li><code>LOCATE(substr,str)</code>：返回字符串 <code>substr</code> 在字符串 <code>str</code> 中首次出现的位置，作用于 <code>POSITION(substr IN str)</code>、<code>INSTR(str,substr)</code> 相同。未找到，返回0。</li><li><code>ELT(N,str1,str2,str3,...)</code>：返回指定位置的字符串，如果 N 等于 1，则返回 <code>str1</code>，如果 N 等于 2，则返回 <code>str2</code>，以此类推，与 <code>MAKE_SET(bits,str1,str2,...)</code> 作用相同。</li><li><code>FIELD(str,str1,str2,str3,...)</code>：返回字符串str在字符串列表中第一次出现的位置。</li><li><code>FIND_IN_SET(str,strlist)</code>：返回字符串 <code>str</code> 在字符串 <code>strlist</code> 中出现的位置。其中，字符串 <code>strlist</code> 是一个以逗号分隔的字符串。</li><li><code>REVERSE(str)</code>：返回 <code>str</code> 反转后的字符串。</li><li><code>NULLIF(expr1,expr2)</code>：比较两个字符串，如果 <code>expr1</code> 与 <code>expr2</code> 相等，则返回 <code>NULL</code>，否则返回 <code>expr1</code>。</li></ul><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><ul><li><code>CURDATE()</code> / <code>CURRENT_DATE()</code>：返回当前日期，只包含年、 月、日。</li><li><code>CURTIME()</code> / <code>CURRENT_TIME()</code>：返回当前时间，只包含时、 分、秒。</li><li><code>NOW()</code> / <code>SYSDATE()</code> / <code>CURRENT_TIMESTAMP()</code> / <code>LOCALTIME()</code> / <code>LOCALTIMESTAMP()</code>：返回当前系统日期和时间。</li><li><code>UTC_DATE()</code>：返回 UTC（世界标准时间）日期。</li><li><code>UTC_TIME()</code>：返回 UTC（世界标准时间）时间。</li><li><code>UNIX_TIMESTAMP()</code>：以 <code>UNIX</code> 时间戳的形式返回当前时间。</li><li><code>UNIX_TIMESTAMP(date)</code>：将时间 <code>date</code> 以 <code>UNIX</code> 时间戳的形式返回。</li><li><code>FROM_UNIXTIME(unix_timestamp)</code>：将 <code>UNIX</code> 时间戳转换为普通格式的时间。</li><li><code>FROM_UNIXTIME(unix_timestamp,format)</code>：将 <code>UNIX</code> 时间戳转换为指定格式的时间。</li><li><code>YEAR(date)</code> / <code>MONTH(date)</code> / <code>DAY(date)</code>：返回具体的日期值。</li><li><code>HOUR(time)</code> / <code>MINUTE(time)</code> / <code>SECOND(time)</code>：返回具体的时间值。</li><li><code>MONTHNAME(date)</code>：返回月份：<code>January</code>、…。</li><li><code>DAYNAME(date)</code>：返回星期几：<code>MONDAY</code>、<code>TUESDAY</code>、…、<code>SUNDAY</code>。</li><li><code>WEEKDAY(date)</code>：返回周几，注意，周一是 <code>0</code>、周二是 <code>1</code>、…、周日是 <code>6</code>。</li><li><code>QUARTER(date)</code>：返回日期对应的季度，范围为 1～4。</li><li><code>WEEK(date)</code> / <code>WEEKOFYEAR(date)</code>：返回一年中的第几周。</li><li><code>DAYOFYEAR(date)</code>：返回日期是一年中的第几天。</li><li><code>DAYOFMONTH(date)</code>：返回日期位于所在月份的第几天。</li><li><code>DAYOFWEEK(date)</code>：返回周几，注意，周一是 <code>0</code>、周二是 <code>1</code>、…、周日是 <code>6</code>。</li><li><code>EXTRACT(unit FROM date)</code>：返回指定日期中的特定部分或组合，如 <code>SECOND</code>、<code>HOUR</code>、<code>YEAR</code>、…、<code>DAY_HOUR</code>。</li><li><code>TIME_TO_SEC(time)</code>：将 <code>time</code> 转化为秒并返回结果值，转化的公式为：“小时 * 3600 + 分钟 * 60 + 秒”。</li><li><code>SEC_TO_TIME(seconds)</code>：将 <code>seconds</code> 描述转化为包含小时、分钟和秒的时间。</li><li><code>DATE_ADD(date,INTERVAL expr unit)</code> / <code>ADDDATE(date,INTERVAL expr unit)</code>：返回与给定日期时间 <code>date</code> 之后 <code>INTERVAL</code> 时间段的日期时间（单位为 <code>unit</code>）。</li><li><code>DATE_SUB(date,INTERVAL expr unit)</code> / <code>SUBDATE(date,INTERVAL expr unit)</code>：返回与给定日期时间 <code>date</code> 之前 <code>INTERVAL</code> 时间段的日期时间（单位为 <code>unit</code>）。</li><li><code>ADDTIME(expr1,expr2)</code>：返回 <code>expr1</code> 加上 <code>expr2</code> 的时间。当 <code>expr2</code> 为一个数字时，代表的是秒，可以为负数。</li><li><code>SUBTIME(expr1,expr2)</code>：返回 <code>expr1</code> 减去 <code>expr2</code> 后的时间。当 <code>expr2</code> 为一个数字时，代表的是秒 ，可以为负数。</li><li><code>DATEDIFF(expr1,expr2)</code>：返回两个日期的间隔天数（<code>expr1 - expr2</code>）。</li><li><code>TIMEDIFF(expr1,expr2)</code>：返回两个时间的间隔（<code>expr1 - expr2</code>，格式为 “时:分:秒”）。</li><li><code>FROM_DAYS(N)</code>：返回从 0000 年 1 月 1 日起，N 天以后的日期。</li><li><code>TO_DAYS(date)</code>：返回日期 <code>date</code> 距离 0000 年 1 月 1 日的天数。</li><li><code>LAST_DAY(date)</code>：返回日期 <code>date</code> 所在月份的最后一天的日期。</li><li><code>MAKEDATE(year,dayofyear)</code>：返回给定年份 <code>year</code> 的第 <code>dayofyear</code> 天的日期。</li><li><code>MAKETIME(hour,minute,second)</code>：将给定的小时、分钟和秒组合成时间并返回。</li><li><code>PERIOD_ADD(P,N)</code>：返回 <code>P</code> 加上 <code>N</code> 后的时间，如 <code>20221203+3=20221206</code>、<code>202212+3=202303</code>。</li><li><code>PERIOD_DIFF(P1,P2)</code>：计算两个日期的差值（<code>P1 - P2</code>），参数格式为 <code>%YY%m%s</code> 或 <code>%YY%m</code>，结果单位为 <code>%s</code> 或 <code>%m</code>。</li></ul><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ul><li><code>FORMAT(X,D)</code>：返回对数字 <code>X</code> 进行格式化后的结果数据，保留小数 <code>D</code> 位（四舍五入）。</li><li><code>DATE_FORMAT(date,format)</code>：按照字符串 <code>format</code> 格式化日期 <code>date</code> 值。</li><li><code>TIME_FORMAT(time,format)</code>：按照字符串 <code>format</code> 格式化时间 <code>time</code> 值。</li><li><code>GET_FORMAT(&#123;DATE|TIME|DATETIME&#125;, &#123;&#39;EUR&#39;|&#39;USA&#39;|&#39;JIS&#39;|&#39;ISO&#39;|&#39;INTERNAL&#39;&#125;)</code>：返回日期字符串的显示格式。</li><li><code>STR_TO_DATE(str, format)</code>：按照字符串 <code>format</code> 对 <code>str</code> 进行解析，返回一个格式为 <code>format</code> 的日期。</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><code>CAST(any AS datatype)</code>：将任何类型的值转换为指定类型的值，目标类型可能是 <code>BINARY</code>、<code>CHAR</code>、<code>DATE</code>、<code>DATETIME</code>、<code>TIME</code>、<code>DECIMAL</code>、<code>SIGNED</code>、<code>UNSIGNED</code>，如不能进行转换则只为 <code>NULL</code>。</li><li><code>CONVERT(str, cast_datatype)</code>：将字符串 <code>str</code> 转换为指定类型 <code>cast_datatype</code> 的值，大多数情况下与 <code>CAST</code> 函数功能重叠。</li><li><code>CONVERT(str USING charset)</code>：将字符串 <code>str</code> 转换为指定的字符集 <code>charset</code>。</li></ul><h2 id="指数-对数"><a href="#指数-对数" class="headerlink" title="指数/对数"></a>指数/对数</h2><ul><li><code>SQRT(X)</code>：返回 <code>X</code> 的平方根。结果不合法时返回 <code>NULL</code>。</li><li><code>POW(X,Y)</code> / <code>POWER(X,Y)</code>：返回 <code>X</code> 的 <code>Y</code> 次方。</li><li><code>EXP(X)</code>：返回 <code>e</code> 的 <code>X</code> 次方，其中 <code>e</code> 是一个常数（<code>2.718281828459045...</code>）。</li><li><code>LN(X)</code> / <code>LOG(X)</code>：返回以 <code>e</code> 为底的 <code>X</code> 的对数，当 <code>X</code> 小于等于 <code>0</code> 时，返回的结果为 <code>NULL</code>。</li><li><code>LOG10(X)</code>：返回以 <code>10</code> 为底的 <code>X</code> 的对数，当 <code>X</code> 小于等于 <code>0</code> 时，返回的结果为 <code>NULL</code>。</li><li><code>LOG2(X)</code>：返回以 <code>2</code> 为底的 <code>X</code> 的对数，结果不合法时返回 <code>NULL</code>。</li><li><code>LOG(B,X)</code>：以 <code>B</code> 为底 <code>X</code> 的对数，结果不合法时返回 <code>NULL</code>。</li></ul><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul><li><code>BIN(X)</code>：返回 <code>X</code> 的二进制编码。</li><li><code>HEX(X)</code>：返回 <code>X</code> 的十六进制编码。</li><li><code>OCT(X)</code>：返回 <code>X</code> 的八进制编码。</li><li><code>CONV(N,from_base,to_base)</code>：将 <code>N</code> 从 <code>from_base</code> 进制转为 <code>to_base</code> 进制。</li></ul><h2 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h2><ul><li><code>RADIANS(X)</code>：将角度转化为弧度，其中，参数 <code>X</code> 为角度值。</li><li><code>DEGREES(X)</code>：将弧度转化为角度，其中，参数 <code>X</code> 为弧度值。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul><li><code>INET_ATON(expr)</code>：将以点分隔的 IP 地址 <code>expr</code> 转化为一个数字，值为字符串类型。</li><li><code>INET_NTOA(expr)</code>：将数字形式的 IP 地址 <code>expr</code> 转化为以点分隔的 IP 地址，值为字符串类型。</li></ul><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul><li><code>SIN(X)</code>：返回 <code>X</code> 的正弦值，其中，参数 <code>X</code> 为弧度值。</li><li><code>ASIN(X)</code>：返回 <code>X</code> 的反正弦值，即获取正弦为 <code>X</code> 的值，结果不合法时返回 <code>NULL</code>。</li><li><code>COS(X)</code>：返回 <code>X</code> 的余弦值，其中，参数 <code>X</code> 为弧度值。</li><li><code>ACOS(X)</code>：返回 <code>X</code> 的反余弦值，即获取余弦为 <code>X</code> 的值，结果不合法时返回 <code>NULL</code>。</li><li><code>TAN(X)</code>：返回 <code>X</code> 的正切值，其中，参数 <code>X</code> 为弧度值。</li><li><code>ATAN(X)</code>：返回 <code>X</code> 的反正切值，即返回正切值为 <code>X</code> 的值。</li><li><code>ATAN2(Y,X)</code>：返回两个参数的反正切值。</li><li><code>COT(X)</code>：返回 <code>X</code> 的余切值，其中，<code>X</code>为弧度值。</li></ul><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><ul><li><code>PASSWORD(str)</code>：返回字符串 <code>str</code> 的加密版本，41 位长的字符串。加密结果不可逆，常用于用户的密码加密。</li><li><code>MD5(str)</code>：返回字符串 <code>str</code> 的 <code>MD5</code>编码值，也是一种加密方式。若参数为 <code>NULL</code>，则会返回 <code>NULL</code>。</li><li><code>SHA(str)</code>：从原明文密码 <code>str</code> 计算并返回加密后的密码字符串，当参数为 <code>NULL</code>时，返回 <code>NULL</code>。<code>SHA</code> 加密算法比 <code>MD5</code> 更加安全。</li><li><code>ENCODE(str,pass_str)</code>：返回使用 <code>pass_str</code> 作为加密密码加密 <code>str</code> 后的值。</li><li><code>DECODE(str,pass_str)</code>：返回使用 <code>pass_str</code> 作为加密密码解密 <code>str</code> 后的值。</li></ul><h2 id="日期格式化附录"><a href="#日期格式化附录" class="headerlink" title="日期格式化附录"></a>日期格式化附录</h2><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>缩写星期名</td></tr><tr><td>%b</td><td>缩写月名</td></tr><tr><td>%c</td><td>月，数值</td></tr><tr><td>%D</td><td>带有英文前缀的月中的天</td></tr><tr><td>%d</td><td>月的天，数值(00-31)</td></tr><tr><td>%e</td><td>月的天，数值(0-31)</td></tr><tr><td>%f</td><td>微秒</td></tr><tr><td>%H</td><td>小时 (00-23)</td></tr><tr><td>%h</td><td>小时 (01-12)</td></tr><tr><td>%I</td><td>小时 (01-12)</td></tr><tr><td>%i</td><td>分钟，数值(00-59)</td></tr><tr><td>%j</td><td>年的天 (001-366)</td></tr><tr><td>%k</td><td>小时 (0-23)</td></tr><tr><td>%l</td><td>小时 (1-12)</td></tr><tr><td>%M</td><td>月名</td></tr><tr><td>%m</td><td>月，数值(00-12)</td></tr><tr><td>%p</td><td>AM 或 PM</td></tr><tr><td>%r</td><td>时间，12-小时（hh:mm:ss AM 或 PM）</td></tr><tr><td>%S</td><td>秒(00-59)</td></tr><tr><td>%s</td><td>秒(00-59)</td></tr><tr><td>%T</td><td>时间, 24-小时 (hh:mm:ss)</td></tr><tr><td>%U</td><td>周 (00-53) 星期日是一周的第一天</td></tr><tr><td>%u</td><td>周 (00-53) 星期一是一周的第一天</td></tr><tr><td>%V</td><td>周 (01-53) 星期日是一周的第一天，与 %X 使用</td></tr><tr><td>%v</td><td>周 (01-53) 星期一是一周的第一天，与 %x 使用</td></tr><tr><td>%W</td><td>星期名</td></tr><tr><td>%w</td><td>周的天 （0=星期日, 6=星期六）</td></tr><tr><td>%X</td><td>年，其中的星期日是周的第一天，4 位，与 %V 使用</td></tr><tr><td>%x</td><td>年，其中的星期一是周的第一天，4 位，与 %v 使用</td></tr><tr><td>%Y</td><td>年，4 位</td></tr><tr><td>%y</td><td>年，2 位</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 MySQL 中各类函数的系统梳理，可以发现 MySQL 内置的各类函数在日常的数据处理和运维场景下都能发挥重要作用，熟悉并灵活运用这些函数，不仅能够简化 SQL 语句的编写，还能减少网络传输与数据处理的额外开销，为数据库层面的性能优化和业务逻辑实现带来更大的便利。正如文章所示，MySQL 丰富多样的函数提供了高度的灵活性和可扩展能力，帮助开发者和运维人员快速、高效地完成多种复杂数据操作。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot整合MyBatis</title>
    <link href="/2022/08/25/mybatis-spring-boot/"/>
    <url>/2022/08/25/mybatis-spring-boot/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着微服务和容器化技术的普及，Spring Boot成为Java开发者首选的微服务框架之一，而MyBatis作为一个灵活且功能强大的持久层框架，其与Spring Boot的集成可以极大地提高数据库操作的效率和灵活性。本文将详细介绍如何在Spring Boot项目中集成MyBatis，从依赖管理到配置细节，每一步都旨在帮助开发者构建一个高效、可维护的应用。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在Spring Boot项目中引入MySQL连接、MyBatis、pagehelper的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><p>这里我们采用“配置文件+Java配置类”的形式来配置数据源</p><p>在项目配置文件中指定数据库连接信息</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 数据源连接url</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-comment"># 数据库连接用户名</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-comment"># 数据库连接密码</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><br><span class="hljs-comment"># 数据库连接驱动</span><br><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></div></td></tr></table></figure><p>这里我们采用连接池方案，配置连接池的相关参数</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 连接池最小空闲连接数</span><br><span class="hljs-meta">spring.datasource.minimum-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"># 连接池最大连接数</span><br><span class="hljs-meta">spring.datasource.maximum-pool-size</span>=<span class="hljs-string">20</span><br><span class="hljs-comment"># 连接池空闲连接存活时间</span><br><span class="hljs-meta">spring.datasource.idle-timeout</span>=<span class="hljs-string">30000</span><br><span class="hljs-comment"># 连接池连接最大存活时间</span><br><span class="hljs-meta">spring.datasource.max-lifetime</span>=<span class="hljs-string">2000000</span><br><span class="hljs-comment"># 连接池等待连接超时时间</span><br><span class="hljs-meta">spring.datasource.connection-timeout</span>=<span class="hljs-string">30000</span><br><span class="hljs-comment"># 连接池名称</span><br><span class="hljs-meta">spring.datasource.pool-name</span>=<span class="hljs-string">MyHikariCP</span><br><span class="hljs-comment"># 连接池是否自动提交</span><br><span class="hljs-meta">spring.datasource.auto-commit</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 连接池验证SQL</span><br><span class="hljs-meta">spring.datasource.connection-test-query</span>=<span class="hljs-string">SELECT 1</span><br><span class="hljs-comment"># 连接池验证SQl超时时间</span><br><span class="hljs-meta">spring.datasource.validation-timeout</span>=<span class="hljs-string">3000</span><br></code></pre></div></td></tr></table></figure><p>对应的Java Properties类为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String url;<br><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">private</span> String driverClassName;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minimumIdle;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maximumPoolSize;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> idleTimeout;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxLifetime;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> connectionTimeout;<br><br>    <span class="hljs-keyword">private</span> String poolName;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> autoCommit;<br><br>    <span class="hljs-keyword">private</span> String connectionTestQuery;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> validationTimeout;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对应的数据源实现配置为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSourceProperties dataSourceProperties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        HikariDataSource dataSource = <span class="hljs-keyword">new</span> HikariDataSource();<br>        dataSource.setJdbcUrl(dataSourceProperties.getUrl());<br>        dataSource.setUsername(dataSourceProperties.getUsername());<br>        dataSource.setPassword(dataSourceProperties.getPassword());<br>        dataSource.setDriverClassName(dataSourceProperties.getDriverClassName());<br>        dataSource.setMinimumIdle(dataSourceProperties.getMinimumIdle());<br>        dataSource.setMaximumPoolSize(dataSourceProperties.getMaximumPoolSize());<br>        dataSource.setIdleTimeout(dataSourceProperties.getIdleTimeout());<br>        dataSource.setMaxLifetime(dataSourceProperties.getMaxLifetime());<br>        dataSource.setConnectionTimeout(dataSourceProperties.getConnectionTimeout());<br>        dataSource.setPoolName(dataSourceProperties.getPoolName());<br>        dataSource.setAutoCommit(dataSourceProperties.isAutoCommit());<br>        dataSource.setConnectionTestQuery(dataSourceProperties.getConnectionTestQuery());<br>        dataSource.setValidationTimeout(dataSource.getValidationTimeout());<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="MyBatis自身配置"><a href="#MyBatis自身配置" class="headerlink" title="MyBatis自身配置"></a>MyBatis自身配置</h2><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># mapper文件位置</span><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br><span class="hljs-comment"># 数据库字段下划线转驼峰</span><br><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 启用懒加载</span><br><span class="hljs-meta">mybatis.configuration.lazy-loading-enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 允许单个语句返回多结果集</span><br><span class="hljs-meta">mybatis.configuration.multiple-result-sets-enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 使用列标签代替列名</span><br><span class="hljs-meta">mybatis.configuration.use-column-label</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 驱动程序提示每次批量返回的结果行数</span><br><span class="hljs-meta">mybatis.configuration.default-fetch-size</span>=<span class="hljs-string">100</span><br><span class="hljs-comment"># SQL语句的默认超时时间</span><br><span class="hljs-meta">mybatis.configuration.default-statement-timeout</span>=<span class="hljs-string">30</span><br><span class="hljs-comment"># 允许JDBC支持自动生成主键</span><br><span class="hljs-meta">mybatis.configuration.use-generated-keys</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 执行器类型</span><br><span class="hljs-meta">mybatis.configuration.default-executor-type</span>=<span class="hljs-string">batch</span><br><span class="hljs-comment"># 开启二级缓存</span><br><span class="hljs-meta">mybatis.configuration.cache-enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 二级缓存的缓存区域</span><br><span class="hljs-meta">mybatis.configuration.local-cache-scope</span>=<span class="hljs-string">SESSION</span><br><span class="hljs-comment"># 自动映射所有结果集</span><br><span class="hljs-meta">mybatis.configuration.auto-mapping-behavior</span>=<span class="hljs-string">FULL</span><br><span class="hljs-comment"># 参数为null时的JDBC类型</span><br><span class="hljs-meta">mybatis.configuration.jdbc-type-for-null</span>=<span class="hljs-string">null</span><br></code></pre></div></td></tr></table></figure><h2 id="分页插件配置"><a href="#分页插件配置" class="headerlink" title="分页插件配置"></a>分页插件配置</h2><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 分页插件数据库方言</span><br><span class="hljs-meta">pagehelper.helper-dialect</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment"># 自动判断数据库方言</span><br><span class="hljs-comment"># pagehelper.auto-dialect=true</span><br><span class="hljs-comment"># 分页参数合理化</span><br><span class="hljs-meta">pagehelper.reasonable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 支持通过Mapper接口参数来传递分页参数</span><br><span class="hljs-meta">pagehelper.support-methods-arguments</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 分页参数别名</span><br><span class="hljs-meta">pagehelper.params</span>=<span class="hljs-string">pageNum=page;pageSize=size</span><br><span class="hljs-comment"># 通过offest方式进行分页</span><br><span class="hljs-comment"># pagehelper.offset-as-page-num=true</span><br><span class="hljs-comment"># 查询后关闭数据库连接（一般交给web容器管理）</span><br><span class="hljs-comment"># pagehelper.close-conn=false</span><br></code></pre></div></td></tr></table></figure><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>在系统日志配置文件中指定相关类的日志级别</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.apache.ibatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Connection&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Statement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.PreparedStatement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>以Student表为例，编写数据库Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;space.yangtao.mapper.StudentMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>        SELECT * FROM tt_student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>对应的Mapper接口为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;<br><br>    <span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>定义服务层接口及对应的实现类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentService</span> </span>&#123;<br><br>    <span class="hljs-function">PageInfo&lt;StudentPO&gt; <span class="hljs-title">page</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class, readOnly = true)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PageInfo&lt;StudentPO&gt; <span class="hljs-title">page</span><span class="hljs-params">()</span> </span>&#123;<br>        PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(studentMapper.list());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>编写视图层接口，用于测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PageInfo&lt;StudentPO&gt; <span class="hljs-title">page</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> studentService.page();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>启动项目，通过HTTP请求进行测试</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl -XGET http://localhost:8080/student/page<br></code></pre></div></td></tr></table></figure><p>请求结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;total&quot;</span>:3,<span class="hljs-string">&quot;list&quot;</span>:[&#123;<span class="hljs-string">&quot;id&quot;</span>:3,<span class="hljs-string">&quot;classId&quot;</span>:2,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;zhangsan2&quot;</span>,<span class="hljs-string">&quot;height&quot;</span>:180.0,<span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;birthday&quot;</span>:<span class="hljs-string">&quot;1989-12-31T16:00:00.000+00:00&quot;</span>,<span class="hljs-string">&quot;createTime&quot;</span>:<span class="hljs-string">&quot;2022-07-01T14:10:22.000+00:00&quot;</span>&#125;],<span class="hljs-string">&quot;pageNum&quot;</span>:2,<span class="hljs-string">&quot;pageSize&quot;</span>:2,<span class="hljs-string">&quot;size&quot;</span>:1,<span class="hljs-string">&quot;startRow&quot;</span>:3,<span class="hljs-string">&quot;endRow&quot;</span>:3,<span class="hljs-string">&quot;pages&quot;</span>:2,<span class="hljs-string">&quot;prePage&quot;</span>:1,<span class="hljs-string">&quot;nextPage&quot;</span>:0,<span class="hljs-string">&quot;isFirstPage&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;isLastPage&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;hasPreviousPage&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;hasNextPage&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;navigatePages&quot;</span>:8,<span class="hljs-string">&quot;navigatepageNums&quot;</span>:[1,2],<span class="hljs-string">&quot;navigateFirstPage&quot;</span>:1,<span class="hljs-string">&quot;navigateLastPage&quot;</span>:2&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">18:00:56.756 [http-nio-8080-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - GET <span class="hljs-string">&quot;/student/page&quot;</span>, parameters=&#123;&#125;<br>18:00:56.756 [http-nio-8080-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to space.yangtao.domain.controller.StudentController<span class="hljs-comment">#page()</span><br>18:00:56.757 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Creating new transaction with name [space.yangtao.service.StudentServiceImpl.page]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception<br>18:00:56.757 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Acquired Connection [HikariProxyConnection@493797028 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ac4f26f] <span class="hljs-keyword">for</span> JDBC transaction<br>18:00:56.757 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Switching JDBC Connection [HikariProxyConnection@493797028 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ac4f26f] to manual commit<br>18:00:56.757 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Creating a new SqlSession<br>18:00:56.758 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Registering transaction synchronization <span class="hljs-keyword">for</span> SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@195129d1]<br>18:00:56.758 [http-nio-8080-exec-3] DEBUG SQL_CACHE - Cache Hit Ratio [SQL_CACHE]: 0.6666666666666666<br>18:00:56.758 [http-nio-8080-exec-3] DEBUG o.m.spring.transaction.SpringManagedTransaction - JDBC Connection [HikariProxyConnection@493797028 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ac4f26f] will be managed by Spring<br>18:00:56.758 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list_COUNT - ==&gt;  Preparing: SELECT count(0) FROM tt_student<br>18:00:56.758 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list_COUNT - ==&gt; Parameters: <br>18:00:56.759 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list_COUNT - &lt;==      Total: 1<br>18:00:56.760 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list - ==&gt;  Preparing: SELECT * FROM tt_student LIMIT ?, ?<br>18:00:56.760 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list - ==&gt; Parameters: 2(Long), 2(Integer)<br>18:00:56.760 [http-nio-8080-exec-3] DEBUG space.yangtao.mapper.StudentMapper.list - &lt;==      Total: 1<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@195129d1]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@195129d1]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@195129d1]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@195129d1]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Initiating transaction commit<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Committing JDBC transaction on Connection [HikariProxyConnection@493797028 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ac4f26f]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG o.s.jdbc.support.JdbcTransactionManager - Releasing JDBC Connection [HikariProxyConnection@493797028 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ac4f26f] after transaction<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using <span class="hljs-string">&#x27;application/json&#x27;</span>, given [*/*] and supported [application/json, application/*+json, application/json, application/*+json]<br>18:00:56.761 [http-nio-8080-exec-3] DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [PageInfo&#123;pageNum=2, pageSize=2, size=1, startRow=3, endRow=3, total=3, pages=2, list=Page&#123;count=<span class="hljs-literal">true</span> (truncated)...]<br>18:00:56.762 [http-nio-8080-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK<br></code></pre></div></td></tr></table></figure><p>由请求结果和控制台日志可知，Web环境下MyBatis的各项基本配置已经配置成功。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，开发者可以详细了解如何在Spring Boot环境下配置和使用MyBatis，包括如何设置数据源、如何配置MyBatis以优化执行和管理SQL会话，以及如何利用MyBatis的高级功能如分页插件来增强应用的性能。此外，文章还探讨了如何通过适当的日志配置来监控和调试数据库交互，确保应用的稳定运行。整合MyBatis后，开发者将能够更有效地管理数据库操作，同时保持代码的清晰和组织性。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis注解开发</title>
    <link href="/2022/08/22/mybatis-annotation-dev/"/>
    <url>/2022/08/22/mybatis-annotation-dev/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代应用开发中，快速开发和代码的易维护性至关重要。MyBatis作为一个广泛使用的持久层框架，提供了通过注解集成SQL语句和Java代码的能力，极大地简化了数据库操作的配置。注解开发模式允许开发者在单个Java文件中定义SQL映射和接口，减少了配置的复杂性，提高了开发效率。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis注解开发是指在MyBatis中使用Java 注解（Annotations）来代替XML映射文件进行SQL映射配置的方法。这种方式提供了一种更直接、更简洁的方式来绑定SQL语句与Java方法，使得开发者可以在单个Java文件中即定义接口及配置SQL映射，提高了开发效率并降低了项目的复杂性。</p><p>常用的注解主要集中于映射SQL语句到接口方法。这些注解包括但不限于：</p><ul><li><strong>@Select</strong>：用于标注查询语句。</li><li><strong>@Insert</strong>：用于标注插入语句。</li><li><strong>@Update</strong>：用于标注更新语句。</li><li><strong>@Delete</strong>：用于标注删除语句。</li><li><strong>@Param</strong>：用于指定SQL参数的名称。</li><li><strong>@Result</strong>、**@Results**：用于配置结果映射，对应XML配置中的<code>&lt;resultMap&gt;</code>。</li><li><strong>@ResultMap</strong>：用于引用已定义的<code>XML resultMap</code>。</li><li><strong>@Options</strong>：提供了执行语句时的控制，例如是否使用缓存，是否自动生成主键等。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>简洁</strong>：减少了配置的冗余，所有配置都在Java代码中完成，不需要额外的XML文件。</li><li><strong>直观</strong>：SQL语句紧邻其对应的Java方法，提高了代码的可读性和维护性。</li><li><strong>易于维护</strong>：代码和SQL语句的修改在同一个地方完成，不需要在项目中搜索对应的XML文件。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>灵活性有限</strong>：对于非常复杂的SQL语句或动态SQL，使用注解可能不如XML方式灵活。</li><li><strong>功能受限</strong>：一些高级的映射和配置选项在注解中不可用或表达不便。</li></ul><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p><code>tt_student</code>表结构定义</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `tt_student`<br>(<br>    `id`          bigint      NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br>    `class_id`    bigint      NOT NULL COMMENT &#x27;班级ID&#x27;,<br>    `name`        varchar(50) NOT NULL COMMENT &#x27;姓名&#x27;,<br>    `height`      double      NOT NULL COMMENT &#x27;身高（cm）&#x27;,<br>    `gender`      char        NOT NULL COMMENT &#x27;性别&#x27;,<br>    `birthday`    date        NOT NULL COMMENT &#x27;出生日期&#x27;,<br>    `create_time` datetime    NOT NULL default current_timestamp COMMENT &#x27;创建时间&#x27;,<br>    PRIMARY KEY (`id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;学生表&#x27;;<br></code></pre></div></td></tr></table></figure><p>Mapper接口定义对应的增删改查方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Insert(&quot;INSERT INTO tt_student (class_id, name, height, gender, birthday, create_time) VALUES (#&#123;classId&#125;, #&#123;name&#125;, #&#123;height&#125;, #&#123;gender&#125;, #&#123;birthday&#125;, #&#123;createTime&#125;)&quot;)</span><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertStudent</span><span class="hljs-params">(StudentPO student)</span></span>;<br><br>    <span class="hljs-meta">@Delete(&quot;DELETE FROM tt_student WHERE id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;<br><br>    <span class="hljs-meta">@Update(&quot;UPDATE tt_student SET class_id = #&#123;classId&#125;, name = #&#123;name&#125;, height = #&#123;height&#125;, gender = #&#123;gender&#125;, birthday = #&#123;birthday&#125;, create_time = #&#123;createTime&#125; WHERE id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStudent</span><span class="hljs-params">(StudentPO student)</span></span>;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT id, class_id, name, height, gender, birthday, create_time FROM tt_student WHERE id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">            @Result(property = &quot;id&quot;, column = &quot;id&quot;, id = true),</span><br><span class="hljs-meta">            @Result(property = &quot;classId&quot;, column = &quot;class_id&quot;),</span><br><span class="hljs-meta">            @Result(property = &quot;name&quot;, column = &quot;name&quot;),</span><br><span class="hljs-meta">            @Result(property = &quot;height&quot;, column = &quot;height&quot;),</span><br><span class="hljs-meta">            @Result(property = &quot;gender&quot;, column = &quot;gender&quot;),</span><br><span class="hljs-meta">            @Result(property = &quot;birthday&quot;, column = &quot;birthday&quot;),</span><br><span class="hljs-meta">            @Result(property = &quot;createTime&quot;, column = &quot;create_time&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function">StudentPO <span class="hljs-title">selectStudentById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>StudentPO studentPO = <span class="hljs-keyword">new</span> StudentPO().setName(<span class="hljs-string">&quot;zl&quot;</span>)<br>        .setClassId(<span class="hljs-number">1L</span>)<br>        .setHeight(<span class="hljs-number">176.1</span>)<br>        .setGender(<span class="hljs-string">&#x27;男&#x27;</span>)<br>        .setBirthday(dateSdf.parse(<span class="hljs-string">&quot;1990-01-01&quot;</span>))<br>        .setCreateTime(dateTimeSdf.parse(<span class="hljs-string">&quot;2022-07-04 21:08:34&quot;</span>));<br>log.info(<span class="hljs-string">&quot;注解新增：&#123;&#125;&quot;</span>, studentMapper.insertStudent(studentPO));<br>log.info(<span class="hljs-string">&quot;注解更新：&#123;&#125;&quot;</span>, studentMapper.updateStudent(studentPO.setId(studentPO.getId()).setName(<span class="hljs-string">&quot;zhaoliu&quot;</span>)));<br>log.info(<span class="hljs-string">&quot;注解查询：&#123;&#125;&quot;</span>, studentMapper.selectStudentById(studentPO.getId()));<br>log.info(<span class="hljs-string">&quot;注解删除：&#123;&#125;&quot;</span>, studentMapper.deleteStudent(studentPO.getId()));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>08:55:25.932 [main] DEBUG space.yangtao.mapper.StudentMapper.insertStudent - ==&gt;  Preparing: INSERT INTO tt_student (class_id, name, height, gender, birthday, create_time) VALUES (?, ?, ?, ?, ?, ?)<br>08:55:25.957 [main] DEBUG space.yangtao.mapper.StudentMapper.insertStudent - ==&gt; Parameters: 1(Long), zl(String), 176.1(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-04 21:08:34.0(Timestamp)<br>08:55:25.959 [main] DEBUG space.yangtao.mapper.StudentMapper.insertStudent - &lt;==    Updates: 1<br>08:55:25.965 [main] INFO  space.yangtao.client.StudentMapperTest - 注解新增：1<br>08:55:25.965 [main] DEBUG space.yangtao.mapper.StudentMapper.updateStudent - ==&gt;  Preparing: UPDATE tt_student SET class_id = ?, name = ?, height = ?, gender = ?, birthday = ?, create_time = ? WHERE id = ?<br>08:55:25.966 [main] DEBUG space.yangtao.mapper.StudentMapper.updateStudent - ==&gt; Parameters: 1(Long), zhaoliu(String), 176.1(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-04 21:08:34.0(Timestamp), 4(Long)<br>08:55:25.968 [main] DEBUG space.yangtao.mapper.StudentMapper.updateStudent - &lt;==    Updates: 1<br>08:55:25.968 [main] INFO  space.yangtao.client.StudentMapperTest - 注解更新：1<br>08:55:25.969 [main] DEBUG s.yangtao.mapper.StudentMapper.selectStudentById - ==&gt;  Preparing: SELECT id, class_id, name, height, gender, birthday, create_time FROM tt_student WHERE id = ?<br>08:55:25.969 [main] DEBUG s.yangtao.mapper.StudentMapper.selectStudentById - ==&gt; Parameters: 4(Long)<br>08:55:25.974 [main] TRACE s.yangtao.mapper.StudentMapper.selectStudentById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>08:55:25.975 [main] TRACE s.yangtao.mapper.StudentMapper.selectStudentById - &lt;==        Row: 4, 1, zhaoliu, 176.1, 男, 1990-01-01, 2022-07-04 21:08:34<br>08:55:25.976 [main] DEBUG s.yangtao.mapper.StudentMapper.selectStudentById - &lt;==      Total: 1<br>08:55:25.977 [main] INFO  space.yangtao.client.StudentMapperTest - 注解查询：StudentPO(id=4, classId=1, name=zhaoliu, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Mon Jul 04 21:08:34 CST 2022)<br>08:55:25.978 [main] DEBUG space.yangtao.mapper.StudentMapper.deleteStudent - ==&gt;  Preparing: DELETE FROM tt_student WHERE id = ?<br>08:55:25.978 [main] DEBUG space.yangtao.mapper.StudentMapper.deleteStudent - ==&gt; Parameters: 4(Long)<br>08:55:25.979 [main] DEBUG space.yangtao.mapper.StudentMapper.deleteStudent - &lt;==    Updates: 1<br>08:55:25.979 [main] INFO  space.yangtao.client.StudentMapperTest - 注解删除：1<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，MyBatis已通过<code>@Insert</code>、<code>@Delete</code>、<code>@Update</code>、<code>@Select</code>实现了对数据库的增删改查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，开发者可以明白如何在MyBatis中使用注解来简化数据库操作的配置。尽管注解方式在处理非常复杂的SQL或需要高度灵活性的场景中可能存在局限，但对于大多数应用场景而言，它提供了一种更为直接和清晰的配置方式。对于那些追求快速开发和代码整洁的项目，注解开发无疑是一个优秀的选择。然而，选择使用注解还是传统的XML配置，应根据项目的具体需求和团队的偏好来决定。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis缓存</title>
    <link href="/2022/08/15/mybatis-cache/"/>
    <url>/2022/08/15/mybatis-cache/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在高并发和大数据量的应用场景中，缓存机制对于提升性能和降低数据库负担至关重要。MyBatis作为一个流行的持久层框架，提供了灵活的缓存配置选项，允许开发者根据具体需求实施一级缓存和二级缓存策略。此外，MyBatis还支持与第三方缓存框架如EhCache的集成，进一步扩展了缓存的功能和效率。本文将详细介绍这些缓存机制的工作原理和配置方法。</p><h2 id="一级缓存（Session-Cache）"><a href="#一级缓存（Session-Cache）" class="headerlink" title="一级缓存（Session Cache）"></a>一级缓存（Session Cache）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一级缓存是MyBatis中默认启用的缓存。它的作用范围限定于同一个<code>SqlSession</code>内。当在同一个<code>SqlSession</code>内执行相同的 SQL 查询时，结果会被缓存起来，并在下次查询相同SQL时直接从缓存返回结果，避免了对数据库的重复查询。</p><ul><li><strong>作用域</strong>：仅限于同一<code>SqlSession</code>。</li><li><strong>生命周期</strong>：与<code>SqlSession</code>的生命周期相同。当<code>SqlSession</code>关闭或执行非查询类SQL时，其一级缓存也会被清空。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>一级缓存是自动启用的，无需特别配置。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>在多次查询中观察控制台日志输出（数据库隔离级别为<strong>可重复读</strong>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>SqlSession session = sqlSessionFactory.openSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>StudentPO studentPO;<br>log.info(<span class="hljs-string">&quot;第1次SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第2次相同SqlSession查询：&#123;&#125;&quot;</span>, studentPO = studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>log.info(<span class="hljs-string">&quot;相同SqlSession更新相同行操作&quot;</span>);<br>studentMapper.updateById(studentPO.setName(<span class="hljs-string">&quot;zhangsan1&quot;</span>));<br>log.info(<span class="hljs-string">&quot;第3次更新相同行后SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第4次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>log.info(<span class="hljs-string">&quot;相同SqlSession更新不同行操作&quot;</span>);<br>studentMapper.updateById(studentPO.setId(<span class="hljs-number">2L</span>).setName(<span class="hljs-string">&quot;zhangsan1&quot;</span>));<br>log.info(<span class="hljs-string">&quot;第5次更新不同行后SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第6次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>log.info(<span class="hljs-string">&quot;相同SqlSession更新其它表操作&quot;</span>);<br>VehicleMapper vehicleMapper = session.getMapper(VehicleMapper.class);<br>vehicleMapper.deleteVehicle(<span class="hljs-number">1L</span>);<br><br>log.info(<span class="hljs-string">&quot;第7次更新其它表后SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第8次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>log.info(<span class="hljs-string">&quot;相同SqlSession手动清理缓存&quot;</span>);<br>session.clearCache();<br><br>log.info(<span class="hljs-string">&quot;第9次手动清理缓存后SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第10次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>session.commit();<br>log.info(<span class="hljs-string">&quot;session提交事务&quot;</span>);<br>log.info(<span class="hljs-string">&quot;第11次相同SqlSession提交事务后查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第12次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>log.info(<span class="hljs-string">&quot;不同SqlSession发生更新不同行操作&quot;</span>);<br>SqlSession session2 = sqlSessionFactory.openSession();<br>StudentMapper studentMapper2 = session2.getMapper(StudentMapper.class);<br>studentMapper2.updateById(studentPO.setId(<span class="hljs-number">3L</span>).setName(<span class="hljs-string">&quot;zhangsan2&quot;</span>));<br><br>session2.commit();<br>session2.close();<br><br>log.info(<span class="hljs-string">&quot;第13次不同SqlSession更新后查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;第14次相同SqlSession查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>session.rollback();<br>log.info(<span class="hljs-string">&quot;session回滚事务&quot;</span>);<br>log.info(<span class="hljs-string">&quot;第15次回滚后查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>session2.rollback();<br>log.info(<span class="hljs-string">&quot;session2回滚事务&quot;</span>);<br>log.info(<span class="hljs-string">&quot;第16次不同SqlSession回滚后查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br><br>session.close();<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:30:02.311 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.324 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.334 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.335 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.336 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.337 [main] INFO  space.yangtao.client.StudentMapperTest - 第1次SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.338 [main] INFO  space.yangtao.client.StudentMapperTest - 第2次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.338 [main] INFO  space.yangtao.client.StudentMapperTest - 相同SqlSession更新相同行操作<br>21:30:02.338 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt;  Preparing: update tt_student <span class="hljs-built_in">set</span> name = ?, height = ?, gender = ?, birthday = ?, create_time = ? <span class="hljs-built_in">where</span> id = ?<br>21:30:02.344 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt; Parameters: zhangsan1(String), 180.0(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-01 22:10:22.0(Timestamp), 1(Long)<br>21:30:02.345 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - &lt;==    Updates: 1<br>21:30:02.345 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.345 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.346 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.346 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.346 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.346 [main] INFO  space.yangtao.client.StudentMapperTest - 第3次更新相同行后SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.347 [main] INFO  space.yangtao.client.StudentMapperTest - 第4次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.347 [main] INFO  space.yangtao.client.StudentMapperTest - 相同SqlSession更新不同行操作<br>21:30:02.347 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt;  Preparing: update tt_student <span class="hljs-built_in">set</span> name = ?, height = ?, gender = ?, birthday = ?, create_time = ? <span class="hljs-built_in">where</span> id = ?<br>21:30:02.347 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt; Parameters: zhangsan1(String), 180.0(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-01 22:10:22.0(Timestamp), 2(Long)<br>21:30:02.348 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - &lt;==    Updates: 1<br>21:30:02.348 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.348 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.349 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.349 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.350 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.350 [main] INFO  space.yangtao.client.StudentMapperTest - 第5次更新不同行后SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.350 [main] INFO  space.yangtao.client.StudentMapperTest - 第6次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.350 [main] INFO  space.yangtao.client.StudentMapperTest - 相同SqlSession更新其它表操作<br>21:30:02.351 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt;  Preparing: delete from tt_vehicle <span class="hljs-built_in">where</span> id = ?<br>21:30:02.351 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt; Parameters: 1(Long)<br>21:30:02.351 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - &lt;==    Updates: 0<br>21:30:02.352 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.352 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.352 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.353 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.353 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.353 [main] INFO  space.yangtao.client.StudentMapperTest - 第7次更新其它表后SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.353 [main] INFO  space.yangtao.client.StudentMapperTest - 第8次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.354 [main] INFO  space.yangtao.client.StudentMapperTest - 相同SqlSession手动清理缓存<br>21:30:02.354 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.354 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.355 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.355 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.355 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.356 [main] INFO  space.yangtao.client.StudentMapperTest - 第9次手动清理缓存后SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.356 [main] INFO  space.yangtao.client.StudentMapperTest - 第10次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.356 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@a22cb6a]<br>21:30:02.357 [main] INFO  space.yangtao.client.StudentMapperTest - session提交事务<br>21:30:02.357 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.357 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.358 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.358 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.358 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.358 [main] INFO  space.yangtao.client.StudentMapperTest - 第11次相同SqlSession提交事务后查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.358 [main] INFO  space.yangtao.client.StudentMapperTest - 第12次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.358 [main] INFO  space.yangtao.client.StudentMapperTest - 不同SqlSession发生更新不同行操作<br>21:30:02.359 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:30:02.369 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1976401987.<br>21:30:02.369 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@75cd8043]<br>21:30:02.370 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt;  Preparing: update tt_student <span class="hljs-built_in">set</span> name = ?, height = ?, gender = ?, birthday = ?, create_time = ? <span class="hljs-built_in">where</span> id = ?<br>21:30:02.370 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt; Parameters: zhangsan2(String), 180.0(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-01 22:10:22.0(Timestamp), 3(Long)<br>21:30:02.371 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - &lt;==    Updates: 1<br>21:30:02.371 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@75cd8043]<br>21:30:02.371 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@75cd8043]<br>21:30:02.372 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@75cd8043]<br>21:30:02.372 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1976401987 to pool.<br>21:30:02.372 [main] INFO  space.yangtao.client.StudentMapperTest - 第13次不同SqlSession更新后查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.372 [main] INFO  space.yangtao.client.StudentMapperTest - 第14次相同SqlSession查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.372 [main] INFO  space.yangtao.client.StudentMapperTest - session回滚事务<br>21:30:02.372 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:30:02.372 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:30:02.373 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:30:02.373 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:30:02.373 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:30:02.373 [main] INFO  space.yangtao.client.StudentMapperTest - 第15次回滚后查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>21:30:02.373 [main] INFO  space.yangtao.client.StudentMapperTest - session2回滚事务<br>21:30:02.373 [main] INFO  space.yangtao.client.StudentMapperTest - 第16次不同SqlSession回滚后查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>...<br></code></pre></div></td></tr></table></figure><p><strong>日志分析</strong>：</p><ol><li>第1次和第2次使用相同的SqlSession，因此第2次查询直接从缓存中取数据。</li><li>第3次查询前发生了SqlSession更新相同行操作，因此查询没使用缓存，而第4次查询使用了缓存。</li><li>第5次查询前发生了SqlSession更新不同行操作，因此查询没使用缓存，而第6次查询使用了缓存。</li><li>第7次查询前发生了SqlSession更新其他表操作，因此查询没使用缓存，而第8次查询使用了缓存。</li><li>第9次查询前手动清除了SqlSession的缓存，因此查询没有使用缓存，而第10次查询使用了缓存。</li><li>第11次查询前SqlSession提交了一次事务，因此查询没有使用缓存，而第12次查询使用了缓存。</li><li>第13次查询前其他SqlSession发生了更新不同行的操作，但不影响本SqlSession，因此第13次和第14次查询都使用了缓存。</li><li>第15次查询前SqlSession回滚了事务，因此查询没使用缓存，而后不同SqlSession回滚了事务，但不影响本SqlSession，因此第16次查询使用了缓存。</li><li>注意这里隐藏了一个场景，其他SqlSession更新了相同行，因为更新相同行的条件是本SqlSession提交事务，否则MySQL的行锁会导致其他SqlSession更新相同行失败，因此结果跟本次SqlSession提交事务后的结果是一致的，即提交了事务后本次SqlSession的查询不使用缓存。</li></ol><p><strong>总结</strong>：在默认的一级缓存中，相同的事务中SqlSession只要执行了非查询类的操作（更新、删除、事务提交或回滚），就会导致本次事务中的所有缓存都失效，在可重复度的隔离级别下，其他事务不会影响本次事务，因此不会影响本次事务的缓存。</p><h2 id="二级缓存（Mapper-Cache）"><a href="#二级缓存（Mapper-Cache）" class="headerlink" title="二级缓存（Mapper Cache）"></a>二级缓存（Mapper Cache）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>二级缓存的作用范围更广，可以跨多个<code>SqlSession</code>和<code>SqlMapper</code>。二级缓存需要显式地在MyBatis配置文件中或通过注解启用。启用后，多个会话可以重用缓存的数据，大大减少数据库的查询次数，提高了应用性能。</p><ul><li><strong>作用域</strong>：跨<code>SqlSession</code>，通常绑定到一个Mapper接口。</li><li><strong>生命周期</strong>：通常跟应用的生命周期一致，或者是缓存提供者（如Ehcache、Redis）管理的。</li><li><strong>配置</strong>：需要在MyBatis的配置文件中启用，并且可以对其细粒度控制，例如配置缓存的大小、清除策略、读写策略等。</li></ul><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><ol><li><p>全局配置文件中开启（默认开启）</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>Mapper文件中加上<code>&lt;cache/&gt;</code>标签表示局部开启</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p><strong>eviction</strong>：缓存的回收策略。默认为LRU策略。</p><ul><li><p><strong>LRU</strong>：Least Recently Used，最近最少使用。</p></li><li><p><strong>FIFO</strong>：First In First Out，先进先出。</p></li><li><p><strong>SOFT</strong>：软引用指向对象优先淘汰。</p></li><li><p><strong>WEAK</strong>：弱引用指向对象优先淘汰。</p></li></ul></li><li><p><strong>flushInterval</strong>：二级缓存的刷新时间间隔，单位为毫秒，没有则代表不刷新缓存。</p></li><li><p><strong>readOnly</strong></p><ul><li><p><strong>true</strong>：多条相同语句执行返回的对象是共享的一个，性能高，可能有并发问题。</p></li><li><p><strong>false</strong>：多条相同语句执行返回的对象是克隆出来的副本，性能一般，多线程安全。</p></li></ul></li><li><p><strong>size</strong>：引用数目，一个数值，表示缓存中可以存储的引用数量，默认1024。</p></li></ul></li></ol><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>在多次查询中观察控制台日志输出（数据库隔离级别为<strong>可重复读</strong>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>SqlSession session1 = sqlSessionFactory.openSession();<br>SqlSession session2 = sqlSessionFactory.openSession();<br><br>StudentMapper mapper1 = session1.getMapper(StudentMapper.class);<br>StudentMapper mapper2 = session2.getMapper(StudentMapper.class);<br><br>log.info(<span class="hljs-string">&quot;session1 第1次查询：&#123;&#125;&quot;</span>, mapper1.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;session2 第1次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br><br>session1.commit();<br>session2.clearCache();<br><br>log.info(<span class="hljs-string">&quot;session2 第2次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br>session2.clearCache();<br><br>log.info(<span class="hljs-string">&quot;session2 第3次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br>VehicleMapper vehicleMapper = session1.getMapper(VehicleMapper.class);<br>vehicleMapper.deleteVehicle(<span class="hljs-number">1L</span>);<br>session1.commit();<br>session2.commit();<br>log.info(<span class="hljs-string">&quot;session2 第4次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br>session2.clearCache();<br><br>mapper1.updateById(mapper1.getById(<span class="hljs-number">3L</span>).setId(<span class="hljs-number">2L</span>).setName(<span class="hljs-string">&quot;zhangsan1&quot;</span>));<br>log.info(<span class="hljs-string">&quot;session2 第5次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br>session1.commit();<br><br>log.info(<span class="hljs-string">&quot;session2 第6次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br>session2.close();<br>session1.clearCache();<br><br>log.info(<span class="hljs-string">&quot;session1 第2次查询：&#123;&#125;&quot;</span>, mapper1.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;session1 第3次查询：&#123;&#125;&quot;</span>, mapper1.getById(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>22:22:04.491 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:22:04.505 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:22:04.516 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:22:04.516 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:22:04.518 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:22:04.519 [main] INFO  space.yangtao.client.StudentMapperTest - session1 第1次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.520 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>22:22:04.520 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>22:22:04.530 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1653361344.<br>22:22:04.530 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@628c4ac0]<br>22:22:04.530 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:22:04.530 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:22:04.531 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:22:04.531 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:22:04.531 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:22:04.532 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第1次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.534 [main] WARN  org.apache.ibatis.io.SerialFilterChecker - As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66<br>22:22:04.536 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.3333333333333333<br>22:22:04.536 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第2次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.536 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5<br>22:22:04.536 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第3次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.537 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt;  Preparing: delete from tt_vehicle <span class="hljs-built_in">where</span> id = ?<br>22:22:04.537 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt; Parameters: 1(Long)<br>22:22:04.538 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - &lt;==    Updates: 0<br>22:22:04.538 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79c7532f]<br>22:22:04.538 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.6<br>22:22:04.538 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第4次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.539 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5<br>22:22:04.539 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:22:04.539 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 3(Long)<br>22:22:04.539 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:22:04.540 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:22:04.540 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:22:04.540 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt;  Preparing: update tt_student <span class="hljs-built_in">set</span> name = ?, height = ?, gender = ?, birthday = ?, create_time = ? <span class="hljs-built_in">where</span> id = ?<br>22:22:04.546 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - ==&gt; Parameters: zhangsan1(String), 180.0(Double), 男(String), 1990-01-01 00:00:00.0(Timestamp), 2022-07-01 22:10:22.0(Timestamp), 2(Long)<br>22:22:04.547 [main] DEBUG space.yangtao.mapper.StudentMapper.updateById - &lt;==    Updates: 1<br>22:22:04.548 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5714285714285714<br>22:22:04.548 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第5次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.548 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79c7532f]<br>22:22:04.548 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5<br>22:22:04.548 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:22:04.548 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:22:04.549 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:22:04.549 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:22:04.550 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:22:04.551 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第6次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.551 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@628c4ac0]<br>22:22:04.552 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@628c4ac0]<br>22:22:04.552 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1653361344 to pool.<br>22:22:04.552 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5555555555555556<br>22:22:04.552 [main] INFO  space.yangtao.client.StudentMapperTest - session1 第2次查询：StudentPO(id=1, classId=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:22:04.552 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.5<br>22:22:04.552 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:22:04.553 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 2(Long)<br>22:22:04.553 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:22:04.553 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:22:04.554 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:22:04.554 [main] INFO  space.yangtao.client.StudentMapperTest - session1 第3次查询：StudentPO(id=2, classId=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>...<br></code></pre></div></td></tr></table></figure><p><strong>日志分析</strong>：</p><ol><li>由于session1第1次查询后未提交或关闭session，因此session2的查询不是从二级缓存中取数据，而是从磁盘中取数据。</li><li>session1提交、同时清除session2的一级缓存，因此session2的第2次查询从二级缓存中取数据。</li><li>session2在第2次查询后就清除了一级缓存，第3次查询仍然是从缓存中取数据，因此可以判定缓存为二级缓存。</li><li>session1更新其它的数据表并提交事务、session2重新开启事务，第4次查询仍然从二级缓存中取数据。</li><li>session1更新相同表的其他行数据，未提交事务前，session2的第5次查询从二级缓存中取数据。</li><li>session1提交事务后，二级缓存失效，session2的第6次查询重新从磁盘中读取数据。</li><li>session2关闭，此时将session1的一级缓存清除，查询仍然从二级缓存中取数据，而对于刚才更新并提交事务的相同行，则会重新从磁盘中取数据。</li></ol><p><strong>总结</strong>：在原有一级缓存的规则下，其他session的事务提交或会话关闭会将其一级缓存写入到二级缓存中，且未有session提交此表相同行的事务的前提下，此表中该行的二级缓存会一直存在于SqlSessionFactory中。</p><h2 id="集成EhCache"><a href="#集成EhCache" class="headerlink" title="集成EhCache"></a>集成EhCache</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>EhCache是一个广泛使用的开源Java分布式缓存框架，提供了内存和磁盘存储的缓存功能，非常适合用作MyBatis的二级缓存。通过集成<code>EhCache</code>，MyBatis可以提升应用性能，减少数据库访问次数，以及提供更复杂的缓存管理功能。</p><p>集成<code>EcCache</code>可以替换MyBatis自带的二级缓存（一级缓存无法替代）。</p><h3 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="DEMO"></a>DEMO</h3><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>类的根路径下创建配置文件ehcache.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">updateCheck</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--磁盘存储：将缓存中暂时不使用的对象，转移到硬盘，类似于Windows系统的虚拟内存。--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;e:/ehcache&quot;</span>/&gt;</span><br>  <br>    <span class="hljs-comment">&lt;!--defaultCache：默认的管理策略--&gt;</span><br>    <span class="hljs-comment">&lt;!--eternal：设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断--&gt;</span><br>    <span class="hljs-comment">&lt;!--maxElementsInMemory：在内存中缓存的element的最大数目--&gt;</span><br>    <span class="hljs-comment">&lt;!--overflowToDisk：如果内存中数据超过内存限制，是否要缓存到磁盘上--&gt;</span><br>    <span class="hljs-comment">&lt;!--diskPersistent：是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false--&gt;</span><br>    <span class="hljs-comment">&lt;!--timeToIdleSeconds：对象空闲时间(单位：秒)，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问--&gt;</span><br>    <span class="hljs-comment">&lt;!--timeToLiveSeconds：对象存活时间(单位：秒)，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问--&gt;</span><br>    <span class="hljs-comment">&lt;!--memoryStoreEvictionPolicy：缓存的3 种清空策略--&gt;</span><br>    <span class="hljs-comment">&lt;!--FIFO：first in first out (先进先出)--&gt;</span><br>    <span class="hljs-comment">&lt;!--LFU：Less Frequently Used (最少使用).意思是一直以来最少被使用的。缓存的元素有一个hit 属性，hit 值最小的将会被清出缓存--&gt;</span><br>    <span class="hljs-comment">&lt;!--LRU：Least Recently Used(最近最少使用). (ehcache 默认值).缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;600&quot;</span> <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在Mapper文件中指定使用<code>EhCache</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>SqlSession session1 = sqlSessionFactory.openSession();<br>SqlSession session2 = sqlSessionFactory.openSession();<br><br>StudentMapper mapper1 = session1.getMapper(StudentMapper.class);<br>StudentMapper mapper2 = session2.getMapper(StudentMapper.class);<br><br>log.info(<span class="hljs-string">&quot;session1 第1次查询：&#123;&#125;&quot;</span>, mapper1.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;session2 第1次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br><br>session1.close();<br>session2.clearCache();<br><br>log.info(<span class="hljs-string">&quot;session2 第2次查询：&#123;&#125;&quot;</span>, mapper2.getById(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure></li><li><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">22:40:41.562 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>22:40:42.323 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1205559205.<br>22:40:42.323 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@47db5fa5]<br>22:40:42.325 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:40:42.350 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:40:42.362 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:40:42.363 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:40:42.365 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:40:42.367 [main] INFO  space.yangtao.client.StudentMapperTest - session1 第1次查询：StudentPO(id=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:40:42.367 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>22:40:42.367 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>22:40:42.381 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 367967231.<br>22:40:42.382 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@15eebbff]<br>22:40:42.382 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:40:42.382 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:40:42.383 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:40:42.383 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:40:42.384 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:40:42.384 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第1次查询：StudentPO(id=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>22:40:42.385 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@47db5fa5]<br>22:40:42.385 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@47db5fa5]<br>22:40:42.385 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1205559205 to pool.<br>22:40:42.385 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.3333333333333333<br>22:40:42.385 [main] INFO  space.yangtao.client.StudentMapperTest - session2 第2次查询：StudentPO(id=1, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br></code></pre></div></td></tr></table></figure><p>由日志可知，MyBatis已集成并使用<code>EhCache</code>。</p></li></ol><p><strong>注意</strong>：建议提醒读者在实际应用中，需要根据应用的并发量和数据量，合理配置缓存大小，以防止内存溢出或缓存失效等问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的学习，开发者可以充分理解并运用MyBatis提供的缓存机制，有效地管理SqlSession的生命周期和跨会话的数据共享。一级缓存带来了会话内的数据访问优化，而二级缓存则扩展了数据共享的范围，提高了应用的响应速度和数据处理能力。此外，通过EhCache的集成，开发者能够实现更复杂的缓存策略，如数据的持久化和过期策略管理。掌握这些技能将显著提升数据库操作的效率和应用的性能。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis分页</title>
    <link href="/2022/08/13/mybatis-pagination/"/>
    <url>/2022/08/13/mybatis-pagination/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代Web开发中，有效的数据管理和呈现是至关重要的，尤其是当涉及到大量数据时。分页是一种常用的技术，用于提高数据处理的效率和用户界面的响应性。MyBatis作为一个强大的持久层框架，提供了多种分页实现方法，本文将探讨MyBatis中常见的分页技术，旨在帮助开发者根据应用需求选择最合适的分页解决方案。</p><h2 id="手动实现分页"><a href="#手动实现分页" class="headerlink" title="手动实现分页"></a>手动实现分页</h2><p>最基本的方法是在SQL查询中手动实现分页逻辑。这通常涉及到修改SQL语句以包含数据库特定的分页语法。</p><ul><li><p><strong>MySQL/PostgreSQL</strong>：使用<code>LIMIT</code>和<code>OFFSET</code>关键字。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">10</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>Oracle</strong>：使用<code>ROWNUM</code>或在Oracle 12c及以上使用<code>FETCH NEXT</code></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> a.<span class="hljs-operator">*</span>, ROWNUM rnum <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id) a <span class="hljs-keyword">WHERE</span> ROWNUM <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span> ) <span class="hljs-keyword">WHERE</span> rnum <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>SQL Server</strong>：使用<code>OFFSET-FETCH</code>子句。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">20</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">FETCH</span> NEXT <span class="hljs-number">10</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span><br></code></pre></div></td></tr></table></figure></li></ul><p>这种方法虽然直接且容易理解，但它要求开发者对不同数据库的分页机制有足够的了解，并且在数据库切换时需要修改SQL代码。</p><h2 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h2><p><code>PageHelper</code>是MyBatis社区提供的一个分页插件，这是一个非常流行的MyBatis分页插件，通过拦截器自动修改SQL实现分页，可以让开发者忽略手动编写分页SQL。</p><p><code>PageHelper</code>支持多种数据库，无需担心不同数据库分页语法的差异。</p><p><strong>DEMO</strong>：</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在MyBatis核心配置文件中添加拦截器</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在Mapper文件中定义查询方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student order by id desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>调用<code>PageHelper</code>的<code>startPage</code>方法，设置分页信息，同时将查询结果封装到一个<code>PageInfo</code>对象中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br><span class="hljs-keyword">int</span> pageNum = <span class="hljs-number">1</span>;<span class="hljs-comment">// 页码</span><br><span class="hljs-keyword">int</span> pageSize = <span class="hljs-number">2</span>;<span class="hljs-comment">// 每页记录数</span><br>PageHelper.startPage(pageNum, pageSize);<br>PageInfo&lt;StudentPO&gt; studentPOPageInfo = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(studentMapper.getAll(), <span class="hljs-number">10</span>);<br>log.info(<span class="hljs-string">&quot;PageHelper分页查询：&#123;&#125;&quot;</span>, studentPOPageInfo);<br></code></pre></div></td></tr></table></figure></li><li><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>22:38:11.834 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll_COUNT - ==&gt;  Preparing: SELECT count(0) FROM tt_student<br>22:38:11.849 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll_COUNT - ==&gt; Parameters: <br>22:38:11.861 [main] TRACE space.yangtao.mapper.StudentMapper.getAll_COUNT - &lt;==    Columns: count(0)<br>22:38:11.861 [main] TRACE space.yangtao.mapper.StudentMapper.getAll_COUNT - &lt;==        Row: 3<br>22:38:11.861 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll_COUNT - &lt;==      Total: 1<br>22:38:11.862 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>22:38:11.863 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll - ==&gt;  Preparing: select * from tt_student order by id desc LIMIT ?, ?<br>22:38:11.863 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll - ==&gt; Parameters: 2(Long), 2(Integer)<br>22:38:11.864 [main] TRACE space.yangtao.mapper.StudentMapper.getAll - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:38:11.865 [main] TRACE space.yangtao.mapper.StudentMapper.getAll - &lt;==        Row: 1, 1, zhangsan, 180.0, 男, 1990-01-01, 2024-07-01 22:10:22<br>22:38:11.866 [main] DEBUG space.yangtao.mapper.StudentMapper.getAll - &lt;==      Total: 1<br>22:38:11.866 [main] INFO  space.yangtao.client.StudentMapperTest - PageHelper分页查询：PageInfo&#123;pageNum=2, pageSize=2, size=1, startRow=3, endRow=3, total=3, pages=2, list=Page&#123;count=<span class="hljs-literal">true</span>, pageNum=2, pageSize=2, startRow=2, endRow=4, total=3, pages=2, reasonable=<span class="hljs-literal">false</span>, pageSizeZero=<span class="hljs-literal">false</span>&#125;[StudentPO(id=1, name=zhangsan, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Mon Jul 01 22:10:22 CST 2024)], prePage=1, nextPage=0, isFirstPage=<span class="hljs-literal">false</span>, isLastPage=<span class="hljs-literal">true</span>, hasPreviousPage=<span class="hljs-literal">true</span>, hasNextPage=<span class="hljs-literal">false</span>, navigatePages=8, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;<br>...<br></code></pre></div></td></tr></table></figure></li></ol><p>由日志可知，<code>PageHelper</code>已经帮我们自动设置了<code>limit</code>参数，同时看到返回的分页对象中除了需要的列表外，还含有其他一些可能用到的属性，如当前页、页大小、页码、总数、前一页、后一页、是否最后一页等。</p><h2 id="RowBounds"><a href="#RowBounds" class="headerlink" title="RowBounds"></a>RowBounds</h2><p>MyBatis也提供了一个<code>RowBounds</code>类用于支持分页，通过在Mapper方法中使用<code>RowBounds</code>参数，可以进行物理分页。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;StudentPO&gt; studentPOPageInfo = studentMapper.getAll(<span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 跳过前20条，然后取10条数据 </span><br></code></pre></div></td></tr></table></figure><p><code>RowBounds</code>的一个缺点是它是通过在内存中过滤记录实现的，即首先拉取所有记录然后在内存中进行分页，这在数据量较大时会影响性能。</p><h2 id="Web环境下的选择"><a href="#Web环境下的选择" class="headerlink" title="Web环境下的选择"></a>Web环境下的选择</h2><p>简单总结下以上各个分页方案：</p><ol><li><strong>手动实现</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>控制性强</strong>：完全控制SQL查询，可以针对性地优化查询。</li><li><strong>灵活性高</strong>：可以根据具体需求调整SQL，满足复杂的分页需求。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>代码复杂</strong>：需要手动编写用于计算总数的查询以及分页的查询，增加了开发的复杂性。</li><li><strong>维护成本高</strong>：每次分页逻辑调整或数据库迁移都需要手动修改SQL。</li><li><strong>性能问题</strong>：如果处理不当，可能会因为两次查询（一次获取总数，一次获取分页数据）而导致性能下降。</li></ul></li></ul></li><li><strong>PageHelper</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>简单易用</strong>：通过简单的 API 调用实现分页，无需修改原有 SQL。</li><li><strong>自动化</strong>：自动处理总页数、总记录数的计算，对开发者透明。</li><li><strong>高效</strong>：通常只需要进行一次额外的查询来获取总记录数，且插件内部可以有优化措施。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>依赖第三方</strong>：增加了对外部库的依赖，可能需要关注其兼容性和更新。</li><li><strong>适应性问题</strong>：虽然支持多种数据库，但在一些特殊的分页需求下可能需要调整默认行为。</li></ul></li></ul></li><li><strong>RowBounds</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>内置支持</strong>：无需额外引入库或工具，MyBatis内置支持。</li><li><strong>简单使用</strong>：通过传递RowBounds对象为查询方法提供偏移量和限制即可实现分页。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>效率低</strong>：RowBounds 是通过在数据库查询全部数据后，在内存中进行分页，这在数据量大时效率极低。</li><li><strong>不返回额外信息</strong>：不提供如总记录数等额外的分页信息，需要额外的查询和逻辑来实现。</li></ul></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合考虑<code>Web</code>环境下分页的需求，使用分页插件（如<code>PageHelper</code>）通常是最合适的选择，因为它既提供了开箱即用的分页功能，又能有效地返回必需的分页信息，同时保持了代码的简洁性和易维护性。如果对性能有极致要求，建议采用数据库自带的物理分页功能，并优化SQL查询。对于简单应用，<code>RowBounds</code>提供了快速实现分页的方法，尽管它在大数据量处理上效率不高。除此之外，使用分页时还需要限制每页的最大记录数、优化查询相关索引、同时充分利用缓存，以保证应用的稳定和高效。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis配置</title>
    <link href="/2022/08/08/mybatis-config/"/>
    <url>/2022/08/08/mybatis-config/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代应用开发中，数据库操作和管理的效率至关重要。MyBatis作为一个半ORM（对象关系映射）框架，提供了灵活的配置选项，以支持不同的日志实现、连接池管理以及事务处理。本文将详细探讨MyBatis的关键配置项，包括如何配置日志来监控SQL执行，数据源的不同配置选项以及事务管理的策略，以帮助开发者最大化地利用MyBatis来构建高效、可维护的数据库应用。                                                                                                                                                                                                                                                                                                                                                                         </p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>MyBatis提供了灵活的日志管理功能，允许开发者在应用中监控和记录SQL语句的执行情况，这对于调试和优化数据库操作是非常有帮助的。通过配置MyBatis使用特定的日志实现，开发者可以获得执行的SQL语句、参数以及与数据库交互的详细信息。</p><h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><p>常见的日志组件包括</p><ul><li>**SLF4J (Simple Logging Facade for Java)**：作为一个日志门面，SLF4J允许开发者在后端使用不同的日志框架（如<code>Logback</code>、<code>log4j</code>），而不需要修改源代码。</li><li><strong>Log4j</strong>：这是一个非常流行的日志框架，提供了强大的日志管理和配置功能。</li><li><strong>Log4j2</strong>：<code>Log4j</code>的升级版，提供了更好的性能和更多的功能。</li><li><strong>JUL</strong> (Java Util Logging)：Java平台的内置日志工具，无需额外依赖。</li><li><strong>JCL</strong> (Jakarta Commons Logging)：Apache的日志门面，类似于<code>SLF4J</code>。</li><li><strong>Apache Commons Logging</strong>：提供日志功能的另一个门面。</li><li><strong>STDOUT</strong> 和 <strong>NO_LOGGING</strong>：分别代表标准输出和不记录任何日志。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><strong>调试</strong>：在开发过程中，可以通过查看日志快速定位问题，了解SQL语句的执行情况和潜在的错误。</li><li><strong>性能优化</strong>：通过分析日志中的SQL执行时间和频率，可以识别性能瓶颈，优化查询语句或数据库结构。</li><li><strong>审计和监控</strong>：日志可以帮助跟踪系统的活动和数据访问，对于维护数据安全和合规性非常重要。</li><li><strong>透明性</strong>：日志提供了数据库操作的透明记录，使得系统的数据库交互更加清晰可追踪。</li></ol><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ol><li><p>在全局配置文件<code>mybatis-config.xml</code>的<code>settings</code>标签中加入<code>logImpl</code>的配置项</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <br>    &lt;.../&gt;<br>    &lt;.../&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>设置为以后，运行测试程序，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Logging initialized using <span class="hljs-string">&#x27;class org.apache.ibatis.logging.stdout.StdOutImpl&#x27;</span> adapter.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>Opening JDBC Connection<br>Created connection 2020152163.<br>Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@78691363]<br>==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (<span class="hljs-string">&quot;Audi A6L&quot;</span>, <span class="hljs-string">&quot;LVIN1&quot;</span>, <span class="hljs-string">&quot;2024-06-22&quot;</span>, <span class="hljs-string">&quot;400000.12&quot;</span>)<br>==&gt; Parameters: <br>&lt;==    Updates: 1<br>Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@78691363]<br></code></pre></div></td></tr></table></figure><p>在日志信息中可以看到开启JDBC链接、执行SQL、更新SQL条数、提交以及关闭JDBC连接等信息。</p></li></ol><h3 id="集成logback"><a href="#集成logback" class="headerlink" title="集成logback"></a>集成logback</h3><p><code>logback</code>作为经常使用的日志框架，也能集成到MyBatis中，步骤如下：</p><ol><li><p>引入<code>logback</code>相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>修改全局配置文件<code>mybatis-config.xml</code>，将日志的实现类修改为<code>SLF4J</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在类路径中创建<code>logback</code>的配置文件<code>logback.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 按照每天生成日志文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件输出的文件名，其中LOG_HOME需要配置为相对或绝对路径--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志文件最大的大小--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mybatis日志配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.apache.ibatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Connection&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Statement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.PreparedStatement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 日志输出级别,logback日志级别包括五个：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>再次运行程序，控制台输出日志信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">00:11:34.969 [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using <span class="hljs-string">&#x27;class org.apache.ibatis.logging.slf4j.Slf4jImpl&#x27;</span> adapter.<br>00:11:34.972 [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using <span class="hljs-string">&#x27;class org.apache.ibatis.logging.slf4j.Slf4jImpl&#x27;</span> adapter.<br>00:11:34.988 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>00:11:34.988 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>00:11:34.989 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>00:11:34.989 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>00:11:35.033 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>00:11:36.175 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 501705927.<br>00:11:36.176 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1de76cc7]<br>00:11:36.178 [main] DEBUG xxx.insertTest - ==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (<span class="hljs-string">&quot;Audi A6L&quot;</span>, <span class="hljs-string">&quot;LVIN1&quot;</span>, <span class="hljs-string">&quot;2024-06-22&quot;</span>, <span class="hljs-string">&quot;400000.12&quot;</span>)<br>00:11:36.199 [main] DEBUG xxx.insertTest - ==&gt; Parameters: <br>00:11:36.215 [main] DEBUG xxx.insertTest - &lt;==    Updates: 1<br>00:11:36.216 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1de76cc7]<br></code></pre></div></td></tr></table></figure><p>可以看出控制台打印的日志信息按照日志配置文件进行了格式化后才输出</p></li></ol><p><strong>拓展</strong>：<code>SLF4J</code>（<code>Simple Logging Facade for Java</code>）本质上不是一个日志框架，而是一个<strong>日志抽象层（facade）</strong>，提供了一个简单的日志API，它允许最终用户在部署时插入所需的日志框架。这使得SLF4J成为一种标准的日志API，开发者可以通过这个API编写日志语句，而不需要直接依赖于具体的日志实现库，如<code>Log4j</code>、<code>Logback</code>或<code>java.util.logging</code>等。</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p><code>dataSource</code>标签是用于配置数据库连接的来源，它是配置数据库连接细节的关键部分。这个标签定义了数据库的连接信息，包括驱动程序、连接字符串、用户名、密码等。</p><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>dataSource</code>标签含有属性<code>type</code>，可以指定数据源的类型，常见的类型有：</p><ul><li><strong>UNPOOLED</strong>：每次请求都会打开和关闭连接。</li><li><strong>POOLED</strong>：使用连接池，复用连接，提高效率。</li><li><strong>JNDI</strong>：用于在如<code>Java EE</code>或应用服务器这样的容器中查找<code>JNDI</code>数据源。</li></ul><h3 id="UNPOOLED"><a href="#UNPOOLED" class="headerlink" title="UNPOOLED"></a>UNPOOLED</h3><p>这个数据源的实现会每次请求时打开和关闭连接。性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。<code>UNPOOLED</code>类型的数据源仅仅需要配置以下 5 种属性：</p><ul><li><strong>driver</strong>：JDBC驱动的Java类全限定名（如<code>com.mysql.cj.jdbc.Driver</code>）。</li><li><strong>url</strong>：数据库的<code>JDBC URL</code>地址。</li><li><strong>username</strong>：登录数据库的用户名。</li><li><strong>password</strong>：登录数据库的密码。</li><li><strong>defaultTransactionIsolationLevel</strong>：默认的连接事务隔离级别，仅适用于mybatis管理的<code>SqlSession</code>。</li><li><strong>defaultNetworkTimeout</strong>：等待数据库操作完成的默认网络超时时间（单位：毫秒）。</li></ul><h3 id="POOLED"><a href="#POOLED" class="headerlink" title="POOLED"></a>POOLED</h3><p>这种数据源的实现利用<strong>“池”</strong>的概念将<code>JDBC</code>连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。</p><p>除了<code>UNPOOLED</code>中提到的属性，<code>POOLED</code>还有如下属性：</p><ul><li><strong>poolMaximumActiveConnections</strong>：在任意时间可存在的活动（正在使用）连接数量，默认值：<code>10</code>。</li><li><strong>poolMaximumIdleConnections</strong>：任意时间可存在的空闲连接数。</li><li><strong>poolMaximumCheckoutTime</strong>：连接从池中被借出的最大时间，默认值：<code>20000</code>毫秒。</li><li><strong>poolTimeToWait</strong>：超过时间未获取到连接，则连接池会打印状态日志并重新尝试获取一个连接，默认值：<code>20000</code>毫秒。</li><li><strong>poolMaximumLocalBadConnectionTolerance</strong>：这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过<code>poolMaximumIdleConnections</code>与<code>poolMaximumLocalBadConnectionTolerance</code>之和。 默认值：<code>3</code>（新增于 3.4.5）</li><li><strong>poolPingQuery</strong>：发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“<code>NO PING QUERY SET</code>”，这会导致多数数据库驱动出错时返回恰当的错误消息。</li><li><strong>poolPingEnabled</strong>：是否启用侦测查询。若开启，需要设置 <code>poolPingQuery</code> 属性为一个可执行的SQL语句（最好是一个速度非常快的SQL语句），默认值：<code>false</code>。</li><li><strong>poolPingConnectionsNotUsedFor</strong>：配置<code>poolPingQuery</code>的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：<code>0</code>（即所有连接每一时刻都被侦测 — 当然仅当<code>poolPingEnabled</code>为<code>true</code>时适用）。</li></ul><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><p>这个数据源实现是为了能在如<code>EJB</code>或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个<code>JNDI</code>上下文的数据源引用</p><ul><li><strong>initial_context</strong>：这个属性用来在<code>InitialContext</code>中寻找上下文（即<code>initialContext.lookup(initial_context)</code>）。这是个可选属性，如果忽略，那么将会直接从 <code>InitialContext</code>中寻找<code>data_source</code>属性。</li><li><strong>data_source</strong>：这是引用数据源实例位置的上下文路径。提供了<code>initial_context</code>配置时会在其返回的上下文中进行查找，没有提供时则直接在<code>InitialContext</code>中查找。</li></ul><p><strong>拓展</strong>：通常，在应用启动时通过数据源设置连接的<code>autoCommit</code>模式，而当连接关闭并返回到连接池时，MyBatis默认会尝试将<code>autoCommit</code>设置回借用前的状态。这样做的目的是保证连接的状态清晰一致，避免对后续使用该连接的操作产生意外影响。出于对性能优化或特定数据源兼容性的需要，可以设置属性值<code>skipSetAutoCommitOnClose</code>，这个属性允许控制在连接关闭时是否跳过这种自动恢复<code>autoCommit</code>状态的行为。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>将配置文件中<code>dataSource</code>的<code>type</code>属性设置为<code>UNPOOLED</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;UNPOOLED&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>SqlSession dbSession = sqlSessionFactory.openSession();<br>Object o1 = dbSession.selectOne(<span class="hljs-string">&quot;ownerMapper.selectMapTest&quot;</span>, <span class="hljs-number">1</span>);<br>Object o2 = dbSession.selectOne(<span class="hljs-string">&quot;ownerMapper.selectMapTest&quot;</span>, <span class="hljs-number">2</span>);<br>dbSession.close();<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">01:37:36.586 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:37:37.344 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@531c311e]<br>01:37:37.349 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:37:37.369 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 1(Integer)<br>01:37:37.383 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:37:37.385 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:37:37.385 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 2(Integer)<br>01:37:37.386 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:37:37.386 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@531c311e]<br>01:37:37.386 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@531c311e]<br></code></pre></div></td></tr></table></figure><p>根据日志内容可看到，程序运行首先是打开了<code>JDBC</code>连接，在执行完<code>SQL</code>语句以后，关闭了<code>JDBC</code>连接。</p></li><li><p>将<code>dataSource</code>的<code>type</code>设置为<code>POOLED</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>再次运行测试类，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.036 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.037 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.037 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.<br>01:39:05.774 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:39:06.528 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 246003654.<br>01:39:06.529 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@ea9b7c6]<br>01:39:06.531 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:39:06.552 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 1(Integer)<br>01:39:06.564 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:39:06.565 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:39:06.566 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 2(Integer)<br>01:39:06.567 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:39:06.567 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@ea9b7c6]<br>01:39:06.567 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@ea9b7c6]<br>01:39:06.567 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 246003654 to pool.<br></code></pre></div></td></tr></table></figure><p>与上一次不同的是，在连接池初始化时<code>PooledDataSource</code>创建了连接，但在操作了执行完SQL语句以后将连接对象返还到连接池中。</p></li><li><p>配置数据库连接池如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 最大连接数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolMaximumActiveConnections&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 最大空闲数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolMaximumIdleConnections&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 连接被借出的最长时间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolMaximumCheckoutTime&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 超时打印时间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolTimeToWait&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 开启数据库侦测 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 数据库侦测sql --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPingQuery&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SELECT 1&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 未使用数据库连接的时间阈值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPingConnectionsNotUsedFor&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3600000&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>测试代码：在一个循环中，每次循环都开启一个新的SqlSession并执行查询，但不关闭这些SqlSession，模拟遇到了资源耗尽的情况</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    SqlSession sqlSession = SqlSessionUtil.openSession();<br>    sqlSession.selectOne(<span class="hljs-string">&quot;ownerMapper.selectMapTest&quot;</span>, i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行后，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">01:44:54.468 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:44:55.227 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 246003654.<br>01:44:55.228 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@ea9b7c6]<br>01:44:55.232 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:44:55.253 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 0(Integer)<br>01:44:55.266 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:44:55.268 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:44:55.281 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 737104370.<br>01:44:55.282 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2bef51f2]<br>01:44:55.282 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:44:55.282 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 1(Integer)<br>01:44:55.283 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:44:55.283 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:44:55.283 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Waiting as long as 2000 milliseconds <span class="hljs-keyword">for</span> connection.<br>01:44:57.287 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Waiting as long as 2000 milliseconds <span class="hljs-keyword">for</span> connection.<br>01:44:59.300 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Waiting as long as 2000 milliseconds <span class="hljs-keyword">for</span> connection.<br>01:45:01.311 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Waiting as long as 2000 milliseconds <span class="hljs-keyword">for</span> connection.<br>01:45:03.312 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Waiting as long as 2000 milliseconds <span class="hljs-keyword">for</span> connection.<br>01:45:05.321 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Claimed overdue connection 246003654.<br>01:45:05.322 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:45:05.322 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 2(Integer)<br>01:45:05.323 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br></code></pre></div></td></tr></table></figure><p>分析：在前两次循环中，都拿到了连接，此时达到了连接池的最大连接数，因此第三个连接请求会等待，且每经过<code>2000ms</code>都会打印等待信息，等待时间超过<code>10000ms</code>（连接被借出的最长时间）以后，第一个连接被声明为超时并回收，之后重新分配给了第三次连接请求。</p></li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>MyBatis支持配置多个数据库环境，在<code>mybatis-config.xml</code>中的<code>environments</code>标签下，通过<code>environment</code>配置多个数据库环境</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;dev_mybatis_db&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一个数据库环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev_mybatis_db&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 另一个数据库环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev_mybatis_db2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_db2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>其中一个<code>environment</code>对应一个数据库环境，也对应一个<code>SqlSessionFactory</code>对象，这些<code>environment</code>也有一个专属的<code>id</code>，在创建<code>SqlSessionFactory</code>对象时，这个<code>id</code>可作为构造参数，用于指定对应的数据库环境。</p><p>创建用于测试的另一个数据库表<code>mybatis_db2.tt_test</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">use mybatis_db2;<br>CREATE TABLE `tt_test`<br>(<br>    `id`   int          NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br>    PRIMARY KEY (`id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;测试表&#x27;;<br><br>insert into tt_test(id) value (1);<br></code></pre></div></td></tr></table></figure><p>对应的配置Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;testMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectMapTest&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br>        select id   as id<br>        from tt_test<br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行测试程序：查询不同的数据库表</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>SqlSessionFactory dbFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>), <span class="hljs-string">&quot;mybatis_db&quot;</span>);<br>SqlSessionFactory db2Factory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>), <span class="hljs-string">&quot;mybatis_db2&quot;</span>);<br>SqlSession dbSession = dbFactory.openSession();<br>SqlSession db2Session = db2Factory.openSession();<br><br>Object o1 = dbSession.selectOne(<span class="hljs-string">&quot;ownerMapper.selectMapTest&quot;</span>, <span class="hljs-number">1</span>);<br>Object o2 = db2Session.selectOne(<span class="hljs-string">&quot;testMapper.selectMapTest&quot;</span>, <span class="hljs-number">1</span>);<br><br>log.info(<span class="hljs-string">&quot;o1：&#123;&#125;&quot;</span>, o1);<br>log.info(<span class="hljs-string">&quot;o2：&#123;&#125;&quot;</span>, o2);<br><br>dbSession.close();<br>db2Session.close();<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">01:29:42.671 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:29:43.470 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1337829755.<br>01:29:43.470 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@4fbda97b]<br>01:29:43.472 [main] DEBUG ownerMapper.selectMapTest - ==&gt;  Preparing: select id as id, name as name from tt_owner <span class="hljs-built_in">where</span> id = ?<br>01:29:43.492 [main] DEBUG ownerMapper.selectMapTest - ==&gt; Parameters: 1(Integer)<br>01:29:43.509 [main] DEBUG ownerMapper.selectMapTest - &lt;==      Total: 0<br>01:29:43.511 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>01:29:43.527 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1398260359.<br>01:29:43.527 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@5357c287]<br>01:29:43.527 [main] DEBUG testMapper.selectMapTest - ==&gt;  Preparing: select id as id from tt_test <span class="hljs-built_in">where</span> id = ?<br>01:29:43.527 [main] DEBUG testMapper.selectMapTest - ==&gt; Parameters: 1(Integer)<br>01:29:43.529 [main] TRACE testMapper.selectMapTest - &lt;==    Columns: id<br>01:29:43.529 [main] TRACE testMapper.selectMapTest - &lt;==        Row: 1<br>01:29:43.531 [main] DEBUG testMapper.selectMapTest - &lt;==      Total: 1<br>01:29:43.531 [main] INFO  space.yangtao.client.TestClient001 - o1：null<br>01:29:43.531 [main] INFO  space.yangtao.client.TestClient001 - o2：&#123;id=1&#125;<br>01:29:43.531 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@4fbda97b]<br>01:29:43.531 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@4fbda97b]<br>01:29:43.531 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1337829755 to pool.<br>01:29:43.531 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@5357c287]<br>01:29:43.532 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@5357c287]<br>01:29:43.532 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1398260359 to pool.<br></code></pre></div></td></tr></table></figure><p>由日志可知已正确查询出了数据，即通过不同的<code>environment</code>创建了不同的<code>SqlSessionFactory</code>，获取不同环境的<code>SqlSession</code>，从而实现了不同环境的库表查询操作。</p><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>MyBatis提供了一个事务管理器接口<code>org.apache.ibatis.transaction.Transaction</code>，通过配置<code>mybatis-config.xml</code>中<code>transactionManager</code>的标签属性<code>type</code>，可指定接口<code>Transaction</code>的实现类，进而完成MyBatis管理事务的配置。</p><p>在MyBatis中有两种类型的事务管理器，分别是<code>JDBC</code>和<code>MANAGED</code>，设置方式为</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC|MANAGED&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><ul><li><code>Transaction</code>接口的实现类为<code>JdbcTransaction</code>。</li><li>直接使用 JDBC 的事务控制机制，需要手动控制事务的提交（<code>commit</code>）和回滚（<code>rollback</code>）。</li><li>适合多数场景，特别是在没有复杂的 JEE 容器管理事务的环境中。</li></ul><h3 id="MANAGED"><a href="#MANAGED" class="headerlink" title="MANAGED"></a>MANAGED</h3><ul><li><code>Transaction</code>接口的实现类为<code>ManagedTransaction</code>。</li><li>MyBatis不再负责事务的管理，而是将事务管理交给其他的<code>JavaEE</code>容器管理。</li><li>通常用在Spring或JEE容器中，这些容器支持声明式事务管理。</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ul><li>在选择事务管理器时，考虑应用运行的环境和需要的事务控制级别。</li><li>在使用<code>JDBC</code>事务管理时，需要确保正确处理事务的提交和回滚。</li><li>在使用<code>MANAGED</code>事务管理时，确保应用服务器或Spring容器正确配置了事务管理。</li></ul><h2 id="Mapper配置"><a href="#Mapper配置" class="headerlink" title="Mapper配置"></a>Mapper配置</h2><p><code>mybatis-config.xml</code>中<code>mappers</code>标签用于配置<code>Mapper</code>映射文件，允许MyBatis知道如何找到并加载这些<code>Mapper</code>，从而可以将<code>SQL</code>语句映射到接口方法。</p><h3 id="通过XML文件"><a href="#通过XML文件" class="headerlink" title="通过XML文件"></a>通过XML文件</h3><ol><li><p>指定<code>mapper</code>标签的<code>resource</code>属性为<code>XML</code>文件的相对路径（注意<code>resources</code>目录为项目的根路径）</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/VehicleMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>指定<code>mapper</code>标签的<code>url</code>属性（不推荐，不同的操作系统中可能不通用）</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///C:/CodeSpaces/IDEASpace/mybatis-learn/mybatis-demo/target/classes/mapper/VehicleMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="通过类名"><a href="#通过类名" class="headerlink" title="通过类名"></a>通过类名</h3><p>直接指定<code>Mapper</code>对应接口的类名，注意要保证<code>Mapper XML</code>文件与接口<code>class</code>文件在同一个命名空间下</p><p>如在<code>space.yangtao.mapper</code>目录下定义了接口<code>VehicleMapper.java</code>，且<code>Mapper XML</code>文件所在目录为<code>space/yangtao/mapper</code>，则可以通过<code>mapper</code>标签的<code>class</code>属性配置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;space.yangtao.mapper.VehicleMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="包扫描"><a href="#包扫描" class="headerlink" title="包扫描"></a>包扫描</h3><p>如果有多个<code>Mapper</code>，并且希望<code>MyBatis</code>自动扫描一个报下的所有<code>Mapper</code>，可以通过<code>package</code>标签实现。注意跟通过类名配置一样，要保证<code>Mapper XML</code>文件与接口<code>class</code>文件在同一个命名空间下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;space.yangtao.mapper&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，开发者应能够掌握MyBatis的高级配置技巧，这包括如何通过日志配置来优化SQL调试过程，选择适合项目需求的数据源类型，以及正确地管理事务以确保应用的稳定性和一致性。此外，文章还讨论了如何通过Mapper配置来简化SQL管理和提高开发效率。掌握这些配置策略将有助于开发者更好地利用MyBatis框架，以应对复杂的数据库操作和事务管理需求。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis核心功能二</title>
    <link href="/2022/08/05/mybatis-core-features-2/"/>
    <url>/2022/08/05/mybatis-core-features-2/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>MyBatis作为一个强大的持久层框架，提供了丰富的动态SQL功能，可以极大地提升SQL语句的灵活性和代码的可维护性。本文详细介绍了如何使用MyBatis提供的动态SQL标签来构建条件丰富且灵活的SQL查询，以及如何通过高级映射技术处理复杂的数据结构关系，使开发者能够更有效地管理和操作数据库。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>MyBatis允许在运行时根据一系列<code>XML</code>标签以及传入的参数值构建灵活的 SQL 语句，使得 SQL 语句的编写更加灵活和强大。</p><p>定义获取参数方法如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getParams</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1L</span>);<br>        put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>    &#125;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><code>&lt;if&gt;</code>标签允许根据提供的表达式的结果（true or false）来决定是否包含一段特定的SQL。这样可以在执行SQL之前根据业务逻辑的需要动态构建SQL语句。</p><p>标签中<code>test</code>属性接受一个返回布尔值的表达式。MyBatis会评估这个表达式，并根据其返回结果决定是否包含 <code>&lt;if&gt;</code> 标签内的SQL片段。</p><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;param.id != null and param.id != &#x27;&#x27;&quot;</span>&gt;</span><br>        and id = #&#123;param.id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testIf2&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>        and id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentPO <span class="hljs-title">testIf</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;param&quot;)</span> Map&lt;String, Object&gt; params)</span></span>;<br><br><span class="hljs-function">StudentPO <span class="hljs-title">testIf2</span><span class="hljs-params">(StudentPO studentPO)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;if标签测试：&#123;&#125;&quot;</span>, studentMapper.testIf(getParams()));<br>log.info(<span class="hljs-string">&quot;if标签测试2：&#123;&#125;&quot;</span>, studentMapper.testIf2(<span class="hljs-keyword">new</span> StudentPO().setId(<span class="hljs-number">1L</span>)));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:04:42.881 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>23:04:42.898 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf - ==&gt; Parameters: 1(Long)<br>23:04:42.933 [main] TRACE space.yangtao.mapper.StudentMapper.testIf - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:04:42.934 [main] TRACE space.yangtao.mapper.StudentMapper.testIf - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:04:42.937 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf - &lt;==      Total: 1<br>23:04:42.938 [main] INFO  space.yangtao.client.StudentMapperTest - <span class="hljs-keyword">if</span>标签测试：StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>23:04:42.939 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>23:04:42.940 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf2 - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>23:04:42.940 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf2 - ==&gt; Parameters: 1(Long)<br>23:04:42.941 [main] TRACE space.yangtao.mapper.StudentMapper.testIf2 - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:04:42.941 [main] TRACE space.yangtao.mapper.StudentMapper.testIf2 - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:04:42.942 [main] DEBUG space.yangtao.mapper.StudentMapper.testIf2 - &lt;==      Total: 1<br>23:04:42.942 [main] INFO  space.yangtao.client.StudentMapperTest - <span class="hljs-keyword">if</span>标签测试2：StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，当<code>&lt;if&gt;</code>标签中<code>test</code>表达式判断为true时，会自动拼接标签内的SQL语句。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>在上述<code>&lt;if&gt;</code>标签的例子中，如果<code>test</code>表达式判断为<code>false</code>，则不会拼接SQl语句<code>and ...</code>，但SQL语句中又以<code>where</code>结尾、存在语法错误，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;if标签测试：&#123;&#125;&quot;</span>, studentMapper.testIf(<span class="hljs-keyword">new</span> HashMap&lt;&gt;()));<br></code></pre></div></td></tr></table></figure><p>参数为空，运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">org.apache.ibatis.exceptions.PersistenceException: <br><span class="hljs-comment">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27; at line 1</span><br><span class="hljs-comment">### The error may exist in space/yangtao/mapper/StudentMapper.xml</span><br><span class="hljs-comment">### The error may involve defaultParameterMap</span><br><span class="hljs-comment">### The error occurred while setting parameters</span><br><span class="hljs-comment">### SQL: select * from tt_student where</span><br><span class="hljs-comment">### Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27; at line 1</span><br></code></pre></div></td></tr></table></figure><p>MyBatis中提供了一个<code>&lt;where&gt;</code>标签，用于拼接<code>where</code>关键字，同时，这个标签会智能地处理<code>&lt;if&gt;</code>标签语句中的<code>and</code>关键字，当<code>where</code>标签中所有<code>if</code>标签判断都为<code>false</code>时，则不会拼接<code>where</code>，反之则会拼接。</p><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testWhere&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>            and id = #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">testWhere</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;where标签测试1：&#123;&#125;&quot;</span>, studentMapper.testWhere(<span class="hljs-keyword">new</span> HashMap&lt;&gt;()));<br>log.info(<span class="hljs-string">&quot;where标签测试2：&#123;&#125;&quot;</span>, studentMapper.testWhere(<span class="hljs-keyword">null</span>));<br>log.info(<span class="hljs-string">&quot;where标签测试3：&#123;&#125;&quot;</span>, studentMapper.testWhere(getParams()));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:12:37.735 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - ==&gt;  Preparing: select * from tt_student<br>23:12:37.753 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - ==&gt; Parameters: <br>23:12:37.769 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:12:37.770 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:12:37.772 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:12:37.773 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:12:37.773 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - &lt;==      Total: 3<br>23:12:37.774 [main] INFO  space.yangtao.client.StudentMapperTest - <span class="hljs-built_in">where</span>标签测试1：[StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022)]<br>23:12:37.775 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>23:12:37.775 [main] INFO  space.yangtao.client.StudentMapperTest - <span class="hljs-built_in">where</span>标签测试2：[StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022)]<br>23:12:37.776 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>23:12:37.776 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - ==&gt;  Preparing: select * from tt_student WHERE id = ?<br>23:12:37.776 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - ==&gt; Parameters: 1(Long)<br>23:12:37.777 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:12:37.777 [main] TRACE space.yangtao.mapper.StudentMapper.testWhere - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:12:37.778 [main] DEBUG space.yangtao.mapper.StudentMapper.testWhere - &lt;==      Total: 1<br>23:12:37.778 [main] INFO  space.yangtao.client.StudentMapperTest - <span class="hljs-built_in">where</span>标签测试3：[StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>&lt;where&gt;</code>标签会智能地处理标签内的SQL语句。</p><p>补充：<code>&lt;where&gt;</code>标签还能智能处理<code>&lt;if&gt;</code>标签中的条件连接符<code>and</code>、<code>or</code>。</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p><code>&lt;trim&gt;</code>标签用于对生成的SQL片段进行更细致的控制。它可以添加或删除特定的前缀、后缀以及前缀或后缀中的某些字符，特别适用于自定义和优化SQL语句的输出。</p><p>这个标签含有4个属性：</p><ul><li><strong>prefix</strong>：在生成的SQL片段前添加指定的前缀。</li><li><strong>prefixOverrides</strong>：移除生成的SQL片段前多余的指定前缀（如<code>AND</code>、<code>OR</code>）。</li><li><strong>suffix</strong>：在生成的SQL片段后添加指定的后缀。</li><li><strong>suffixOverrides</strong>：移除生成的SQL片段后多余的指定后缀。</li></ul><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student<br>    <span class="hljs-comment">&lt;!-- |表示或 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>            id = #&#123;id&#125; and<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;other != null and other != &#x27;&#x27;&quot;</span>&gt;</span><br>            name = #&#123;other&#125; and<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">testTrim</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;trim标签测试：&#123;&#125;&quot;</span>, studentMapper.testTrim(getParams()));<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:16:21.582 [main] DEBUG space.yangtao.mapper.StudentMapper.testTrim - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>23:16:21.601 [main] DEBUG space.yangtao.mapper.StudentMapper.testTrim - ==&gt; Parameters: 1(Long)<br>23:16:21.615 [main] TRACE space.yangtao.mapper.StudentMapper.testTrim - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:16:21.617 [main] TRACE space.yangtao.mapper.StudentMapper.testTrim - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:16:21.618 [main] DEBUG space.yangtao.mapper.StudentMapper.testTrim - &lt;==      Total: 1<br>23:16:21.620 [main] INFO  space.yangtao.client.StudentMapperTest - trim标签测试：[StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>&lt;trim&gt;</code>标签已正确拼接以及删除前缀后缀<code>&lt;or&gt;</code>。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>&lt;set&gt;</code> 标签是一个专门用于动态生成<code>update</code>语句中的<code>set</code>部分的动态SQL标签。使用<code>&lt;set&gt;</code>标签可以便捷地构建含有条件性更新字段的SQL语句，同时自动处理列表前后的逗号，确保语法正确。</p><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testSet&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    update tt_student<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>            id = #&#123;id&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>            name = #&#123;name&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;height != null&quot;</span>&gt;</span><br>            height = #&#123;height&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">(StudentPO studentPO)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>studentMapper.testSet(<span class="hljs-keyword">new</span> StudentPO().setId(<span class="hljs-number">1L</span>).setHeight(<span class="hljs-number">180.0</span>));<br>session.commit();<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:18:12.706 [main] DEBUG space.yangtao.mapper.StudentMapper.testSet - ==&gt;  Preparing: update tt_student SET id = ?, height = ? <span class="hljs-built_in">where</span> id = ?<br>23:18:12.723 [main] DEBUG space.yangtao.mapper.StudentMapper.testSet - ==&gt; Parameters: 1(Long), 180.0(Double), 1(Long)<br>23:18:12.730 [main] DEBUG space.yangtao.mapper.StudentMapper.testSet - &lt;==    Updates: 1<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>&lt;set&gt;</code>标签对不为空的参数进行了智能拼接，并且智能地处理了逗号。</p><h3 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h3><p><code>&lt;choose&gt;</code>标签提供了类似于Java中的<code>switch</code>关键字的功能，它用于在SQL映射文件中执行条件逻辑选择。这个标签允许在多个条件中选择一个执行。</p><p><code>choose</code>标签包括三个部分：</p><ul><li><code>when</code>：这相当于<code>switch</code>语句中的<code>case</code>，用于指定一个条件。</li><li><code>otherwise</code>：这相当于<code>switch</code>语句中的<code>default</code>，用于指定当没有任何<code>when</code>条件匹配时执行的操作。</li><li><code>choose</code>：这是包裹<code>when</code>和<code>otherwise</code>的容器标签。</li></ul><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br>            where id = #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>            where name = #&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>            where 1 = 1<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">testChoose</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;choose标签测试1：&#123;&#125;&quot;</span>, studentMapper.testChoose(getParams()));<br>log.info(<span class="hljs-string">&quot;choose标签测试2：&#123;&#125;&quot;</span>, studentMapper.testChoose(<span class="hljs-keyword">null</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:20:50.736 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>23:20:50.755 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - ==&gt; Parameters: 1(Long)<br>23:20:50.768 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:20:50.769 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==        Row: 1, 1, zhangsan, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:20:50.771 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - &lt;==      Total: 1<br>23:20:50.772 [main] INFO  space.yangtao.client.StudentMapperTest - choose标签测试1：[StudentPO(id=1, name=zhangsan, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)]<br>23:20:50.773 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>23:20:50.773 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> 1 = 1<br>23:20:50.773 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - ==&gt; Parameters: <br>23:20:50.774 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:20:50.774 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==        Row: 1, 1, zhangsan, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:20:50.774 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:20:50.774 [main] TRACE space.yangtao.mapper.StudentMapper.testChoose - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:20:50.775 [main] DEBUG space.yangtao.mapper.StudentMapper.testChoose - &lt;==      Total: 3<br>23:20:50.775 [main] INFO  space.yangtao.client.StudentMapperTest - choose标签测试2：[StudentPO(id=1, name=zhangsan, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>&lt;choose&gt;</code>标签会根据条件正确选择<code>where</code>条件。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p><code>&lt;foreach&gt;</code>标签用于在SQL语句中处理集合和数组。这个标签允许你迭代一个集合，并为每个元素生成相应的SQL片段，如列表、IN查询条件或批量插入语句等。</p><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testForeach&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">testForeach</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;foreach标签测试1：&#123;&#125;&quot;</span>, studentMapper.testForeach(Arrays.asList(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>)));<br>log.info(<span class="hljs-string">&quot;foreach标签测试2：&#123;&#125;&quot;</span>, studentMapper.testForeach(<span class="hljs-keyword">null</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:25:44.657 [main] DEBUG space.yangtao.mapper.StudentMapper.testForeach - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id <span class="hljs-keyword">in</span> ( ? , ? )<br>23:25:44.675 [main] DEBUG space.yangtao.mapper.StudentMapper.testForeach - ==&gt; Parameters: 1(Long), 2(Long)<br>23:25:44.690 [main] TRACE space.yangtao.mapper.StudentMapper.testForeach - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>23:25:44.691 [main] TRACE space.yangtao.mapper.StudentMapper.testForeach - &lt;==        Row: 1, 1, zhangsan, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:25:44.693 [main] TRACE space.yangtao.mapper.StudentMapper.testForeach - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:25:44.694 [main] DEBUG space.yangtao.mapper.StudentMapper.testForeach - &lt;==      Total: 2<br>23:25:44.695 [main] INFO  space.yangtao.client.StudentMapperTest - foreach标签测试1：[StudentPO(id=1, name=zhangsan, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022)]<br><br>org.apache.ibatis.exceptions.PersistenceException: <br><span class="hljs-comment">### Error querying database.  Cause: org.apache.ibatis.builder.BuilderException: The expression &#x27;ids&#x27; evaluated to a null value.</span><br><span class="hljs-comment">### Cause: org.apache.ibatis.builder.BuilderException: The expression &#x27;ids&#x27; evaluated to a null value.</span><br></code></pre></div></td></tr></table></figure><p>由日志可知，当传入集合不为空时，<code>&lt;foreach&gt;</code>标签会正确地为SQL拼接参数，当传入参数为null时，SQL处理则会出现异常，可以结合<code>&lt;if&gt;</code>标签处理集合为空的情况，如</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ids != null and ids.size() &gt; 0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- foreach 标签 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="sql和include"><a href="#sql和include" class="headerlink" title="sql和include"></a>sql和include</h3><p><code>&lt;sql&gt;</code>和<code>&lt;include&gt;</code>标签是用于复用SQL代码片段的强大工具。它们可以显著提高SQL语句的可维护性和可读性，尤其是在处理大量重复或结构相似的语句时。</p><p>在Mapper中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;columnsSql&quot;</span>&gt;</span><br>    id,<br>    name,<br>    height,<br>    gender,<br>    birthday,<br>    create_time<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testSqlInclude&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;columnsSql&quot;</span>/&gt;</span><br>    from tt_student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">testSqlInclude</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;sqlInclude标签测试：&#123;&#125;&quot;</span>, studentMapper.testSqlInclude());<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>23:28:35.159 [main] DEBUG space.yangtao.mapper.StudentMapper.testSqlInclude - ==&gt;  Preparing: select id, name, height, gender, birthday, create_time from tt_student<br>23:28:35.178 [main] DEBUG space.yangtao.mapper.StudentMapper.testSqlInclude - ==&gt; Parameters: <br>23:28:35.192 [main] TRACE space.yangtao.mapper.StudentMapper.testSqlInclude - &lt;==    Columns: id, name, height, gender, birthday, create_time<br>23:28:35.194 [main] TRACE space.yangtao.mapper.StudentMapper.testSqlInclude - &lt;==        Row: 1, zhangsan, 180.0, 男, 1990-01-01, 2022-07-01 22:10:22<br>23:28:35.196 [main] TRACE space.yangtao.mapper.StudentMapper.testSqlInclude - &lt;==        Row: 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:28:35.197 [main] TRACE space.yangtao.mapper.StudentMapper.testSqlInclude - &lt;==        Row: 3, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>23:28:35.197 [main] DEBUG space.yangtao.mapper.StudentMapper.testSqlInclude - &lt;==      Total: 3<br>23:28:35.198 [main] INFO  space.yangtao.client.StudentMapperTest - sqlInclude标签测试：[StudentPO(id=1, name=zhangsan, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 21:10:22 CST 2022)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>&lt;include&gt;</code>标签已正确地将指定<code>&lt;sql&gt;</code>标签中的语句拼接到原SQL语句中。</p><h2 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h2><p>MyBatis提供了强大的映射功能，允许开发者在数据库操作中实现复杂的对象关系映射，包括一对多、多对一的关系。这些高级映射主要通过<code>&lt;resultMap&gt;</code>标签来配置，能够处理复杂的 SQL 查询结果并将它们正确地映射到Java对象和对象集合中。</p><p>创建一个班级表<code>tt_class</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `tt_class`<br>(<br>    `id`          bigint      NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br>    `grade`       varchar(20) NOT NULL COMMENT &#x27;年级&#x27;,<br>    `no`          int         NOT NULL COMMENT &#x27;班级号&#x27;,<br>    PRIMARY KEY (`id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;班级信息表&#x27;;<br></code></pre></div></td></tr></table></figure><p>为学生表添加字段<code>class_id</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">alter table tt_student add column class_id bigint not null comment &#x27;班级ID&#x27; after id;<br></code></pre></div></td></tr></table></figure><p>新增数据</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT INTO mybatis_db.tt_class (id, grade, no) VALUES (1, &#x27;一年级&#x27;, 1);<br>INSERT INTO mybatis_db.tt_class (id, grade, no) VALUES (2, &#x27;二年级&#x27;, 1);<br><br>INSERT INTO mybatis_db.tt_student (id, class_id, name, height, gender, birthday, create_time) VALUES (1, 1, &#x27;zhangsan&#x27;, 180, &#x27;男&#x27;, &#x27;1990-01-01&#x27;, &#x27;2024-07-01 22:10:22&#x27;);<br>INSERT INTO mybatis_db.tt_student (id, class_id, name, height, gender, birthday, create_time) VALUES (2, 2, &#x27;lisi&#x27;, 178.1, &#x27;男&#x27;, &#x27;1991-02-12&#x27;, &#x27;2024-07-02 22:33:24&#x27;);<br>INSERT INTO mybatis_db.tt_student (id, class_id, name, height, gender, birthday, create_time) VALUES (3, 2, &#x27;wangwu&#x27;, 172, &#x27;女&#x27;, &#x27;1991-04-21&#x27;, &#x27;2024-07-03 22:40:43&#x27;);<br></code></pre></div></td></tr></table></figure><p>整体数据如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">+----+--------+----+<br>| id | grade  | no |<br>+----+--------+----+<br>|  1 | 一年级 |  1 |<br>|  2 | 二年级 |  1 |<br>+----+--------+----+<br><br>+----+----------+----------+--------+--------+------------+---------------------+<br>| id | class_id | name     | height | gender | birthday   | create_time         |<br>+----+----------+----------+--------+--------+------------+---------------------+<br>|  1 |        1 | zhangsan |    180 | 男     | 1990-01-01 | 2024-07-01 22:10:22 |<br>|  2 |        2 | lisi     |  178.1 | 男     | 1991-02-12 | 2024-07-02 22:33:24 |<br>|  3 |        2 | wangwu   |    172 | 女     | 1991-04-21 | 2024-07-03 22:40:43 |<br>+----+----------+----------+--------+--------+------------+---------------------+<br></code></pre></div></td></tr></table></figure><h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>多对一映射用于处理一个对象属于另一个对象的情况，例如每个学生属于一个班级。</p><h4 id="实体类结构"><a href="#实体类结构" class="headerlink" title="实体类结构"></a>实体类结构</h4><p>现在要构造<code>StudentVO</code>，其中包含属性<code>ClassVO</code>，两个实体类结构如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassVO</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String grade;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> no;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentVO</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> ClassVO classVO;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> height;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="级联属性映射"><a href="#级联属性映射" class="headerlink" title="级联属性映射"></a>级联属性映射</h4><p>在Mapper中定义查询方法，同时定义一个<code>resultMap</code>，标签中含有对应的<code>classVO</code>的属性名与数据库字段名的映射</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scMap1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.StudentVO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classVO.grade&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;grade&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classVO.no&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;no&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;height&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;height&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getScVO1&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;scMap1&quot;</span>&gt;</span><br>    select s.id,<br>           s.name,<br>           c.grade,<br>           c.no,<br>           s.height<br>    from tt_student s<br>    left join tt_class c on s.class_id = c.id<br>    where s.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentVO <span class="hljs-title">getScVO1</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;getScVO1：&#123;&#125;&quot;</span>, studentMapper.getScVO1(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台打印日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>08:57:49.636 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO1 - ==&gt;  Preparing: select s.id, s.name, c.grade, c.no, s.height from tt_student s left join tt_class c on s.class_id = c.id <span class="hljs-built_in">where</span> s.id = ?<br>08:57:49.654 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO1 - ==&gt; Parameters: 1(Long)<br>08:57:49.685 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO1 - &lt;==    Columns: id, name, grade, no, height<br>08:57:49.686 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO1 - &lt;==        Row: 1, zhangsan, 一年级, 1, 180.0<br>08:57:49.687 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO1 - &lt;==      Total: 1<br>08:57:49.688 [main] INFO  space.yangtao.client.StudentMapperTest - getScVO1：StudentVO(id=1, name=zhangsan, classVO=ClassVO(grade=一年级, no=1), height=180.0)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>StudentVO</code>对象中已包含<code>ClassVO</code>对象，<code>resultMap</code>已完成多对一属性映射。</p><h4 id="association"><a href="#association" class="headerlink" title="association"></a>association</h4><p><code>&lt;association&gt;</code>标签用于处理一对一的关系。它相当于Java中对象的嵌套，允许将查询结果的一部分映射到另一个对象的属性中。</p><ul><li><strong>property</strong>：Java对象中关联对象的属性名。</li><li><strong>javaType</strong>：关联对象的类型（全限定类名或别名）。</li><li><strong>column</strong>：用于关联查询的列名。</li><li><strong>select</strong>：指定分步查询的方法，全限定名。</li><li><strong>fetchType</strong>：加载方式，<code>lazy</code>（延迟加载）或<code>eager</code>（立即加载）。</li></ul><p>在Mapper文件中，同样定义<code>resultMap</code>，同时使用<code>association</code>标签，将学生对象中的<code>classVO</code>与数据库字段进行关联</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scMap2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.StudentVO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;height&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;height&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classVO&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.ClassVO&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;grade&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;no&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getScVO2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;scMap2&quot;</span>&gt;</span><br>    select s.id,<br>           s.name,<br>           c.grade,<br>           c.no,<br>           s.height<br>    from tt_student s<br>    left join tt_class c on s.class_id = c.id<br>    where s.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentVO <span class="hljs-title">getScVO2</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;getScVO2：&#123;&#125;&quot;</span>, studentMapper.getScVO2(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台打印日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>08:58:56.713 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO2 - ==&gt;  Preparing: select s.id, s.name, c.grade, c.no, s.height from tt_student s left join tt_class c on s.class_id = c.id <span class="hljs-built_in">where</span> s.id = ?<br>08:58:56.730 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO2 - ==&gt; Parameters: 1(Long)<br>08:58:56.744 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO2 - &lt;==    Columns: id, name, grade, no, height<br>08:58:56.744 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO2 - &lt;==        Row: 1, zhangsan, 一年级, 1, 180.0<br>08:58:56.745 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO2 - &lt;==      Total: 1<br>08:58:56.747 [main] INFO  space.yangtao.client.StudentMapperTest - getScVO2：StudentVO(id=1, name=zhangsan, classVO=ClassVO(grade=一年级, no=1), height=180.0)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>StudentVO</code>对象中已包含<code>ClassVO</code>对象，<code>resultMap</code>已完成多对一属性映射。</p><h4 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h4><p>与前面两种方法不同，分布查询需要书写两条SQL语句，这种方法的优点是可复用、支持懒加载。</p><p>在<code>StudentMapper</code>中定义查询语句</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getVoById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;scMap3&quot;</span>&gt;</span><br>    select s.id,<br>    s.class_id,<br>    s.name,<br>    s.height<br>    from tt_student s<br>    where s.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的<code>resultMap</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scMap3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.StudentVO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;height&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;height&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    association：关联，一个学生对应一个班级（需放在所有result之后）</span><br><span class="hljs-comment">    property：关联的属性</span><br><span class="hljs-comment">    javaType：关联的实体类</span><br><span class="hljs-comment">    column：主表与子表的关联字段</span><br><span class="hljs-comment">    select：子查询对应的接口方法（全类名）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classVO&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.ClassVO&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_id&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;space.yangtao.mapper.ClassMapper.getVoById&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在<code>ClassMapper</code>中定义刚才声明的<code>getVoById</code>方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getVoById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.ClassVO&quot;</span>&gt;</span><br>    select * from tt_class where id = $&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>两个查询对应的接口方法分别为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentVO <span class="hljs-title">getScVO3</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">ClassVO <span class="hljs-title">getVoById</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;getScVO3：&#123;&#125;&quot;</span>, studentMapper.getScVO3(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>09:01:34.577 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - ==&gt;  Preparing: select s.id, s.class_id, s.name, s.height from tt_student s <span class="hljs-built_in">where</span> s.id = 1<br>09:01:34.593 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - ==&gt; Parameters: <br>09:01:34.605 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==    Columns: id, class_id, name, height<br>09:01:34.606 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==        Row: 1, 1, zhangsan, 180.0<br>09:01:34.607 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById - ====&gt;  Preparing: select * from tt_class <span class="hljs-built_in">where</span> id = ?<br>09:01:34.607 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById - ====&gt; Parameters: 1(Integer)<br>09:01:34.608 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById - &lt;====    Columns: id, grade, no<br>09:01:34.608 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById - &lt;====        Row: 1, 一年级, 1<br>09:01:34.609 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById - &lt;====      Total: 1<br>09:01:34.610 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==      Total: 1<br>09:01:34.610 [main] INFO  space.yangtao.client.StudentMapperTest - getScVO3：StudentVO(id=1, name=zhangsan, classVO=ClassVO(grade=一年级, no=1), height=180.0)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>StudentVO</code>对象中已包含<code>ClassVO</code>对象，<code>resultMap</code>已完成多对一属性映射，同时可以看到进行了两次SQL查询。</p><p>拓展：单个Mapper方法开启延迟加载，修改<code>resultMap</code>中的<code>association</code>标签，添加属性<code>fetchType=&quot;lazy&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classVO&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo.ClassVO&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_id&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;space.yangtao.mapper.ClassMapper.getVoById&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>或开启全局延迟加载（注意单个Mapper配置会覆盖全局延迟加载配置，推荐项目开启全局延迟加载，特别的不需要延迟加载则单独设置<code>fetchType=&quot;eager&quot;</code>即可）</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行测试程序：获取到学生对象后，只获取其名称，对于班级对象<code>classVO</code>不做操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;getScVO3：&#123;&#125;&quot;</span>, studentMapper.getScVO3(<span class="hljs-number">1L</span>).getName());<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>09:03:01.035 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - ==&gt;  Preparing: select s.id, s.class_id, s.name, s.height from tt_student s <span class="hljs-built_in">where</span> s.id = 1<br>09:03:01.055 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - ==&gt; Parameters: <br>09:03:01.070 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==    Columns: id, class_id, name, height<br>09:03:01.070 [main] TRACE space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==        Row: 1, 1, zhangsan, 180.0<br>09:03:01.103 [main] DEBUG space.yangtao.mapper.StudentMapper.getScVO3 - &lt;==      Total: 1<br>09:03:01.104 [main] INFO  space.yangtao.client.StudentMapperTest - getScVO3：zhangsan<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，MyBatis只对<code>tt_student</code>表进行了查询，而不再对<code>tt_class</code>进行查询，即只进行了一次查询，这是分布查询的一个优化点。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一对多映射用于处理一个对象关联多个其他对象的情况，例如一个班级有多个学生。</p><h4 id="实体类结构-1"><a href="#实体类结构-1" class="headerlink" title="实体类结构"></a>实体类结构</h4><p>重新设计学生和班级的实体类：<code>ClassVO</code>中含有一个<code>StudentVO</code>的集合</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentVO</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassVO</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String grade;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> no;<br><br>    <span class="hljs-keyword">private</span> List&lt;StudentVO&gt; students;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p><code>&lt;collection&gt;</code>标签用于处理一对多的关系。这种标签允许你将查询结果的一部分映射到Java集合属性中。</p><ul><li><strong>property</strong>：Java对象中集合属性的名称。</li><li><strong>ofType</strong>：集合中元素的类型。</li><li><strong>select</strong>：指定分步查询的方法。</li><li><strong>column</strong>：用于关联查询的列名。</li></ul><p>在Mapper文件中定义SQL如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getVoById2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;csMap1&quot;</span>&gt;</span><br>    select c.grade,<br>           c.no,<br>           s.id,<br>           s.name<br>    from tt_class c<br>    left join tt_student s on s.class_id = c.id<br>    where c.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">space.yangtao.domain.vo2.<span class="hljs-function">ClassVO <span class="hljs-title">getVoById2</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>定义对应的<code>resultMap</code>，使用<code>collection</code>标签指定集合</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;csMap1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo2.ClassVO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;grade&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;no&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定集合，property为属性名，ofType为属性的类型 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo2.StudentVO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>ClassMapper classMapper = session.getMapper(ClassMapper.class);<br>log.info(<span class="hljs-string">&quot;getCsVO1：&#123;&#125;&quot;</span>, classMapper.getVoById2(<span class="hljs-number">2L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>09:04:52.321 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById2 - ==&gt;  Preparing: select c.grade, c.no, s.id, s.name from tt_class c left join tt_student s on s.class_id = c.id <span class="hljs-built_in">where</span> c.id = ?<br>09:04:52.339 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById2 - ==&gt; Parameters: 2(Long)<br>09:04:52.353 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById2 - &lt;==    Columns: grade, no, id, name<br>09:04:52.353 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById2 - &lt;==        Row: 二年级, 1, 2, zhangsan1<br>09:04:52.354 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById2 - &lt;==        Row: 二年级, 1, 3, zhangsan2<br>09:04:52.354 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById2 - &lt;==      Total: 2<br>09:04:52.355 [main] INFO  space.yangtao.client.StudentMapperTest - getCsVO1：ClassVO(grade=二年级, no=1, students=[StudentVO(id=2, name=zhangsan1), StudentVO(id=3, name=zhangsan2)])<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>ClassVO</code>对象中已包含多个<code>StudentVO</code>对象，<code>resultMap</code>已完成一对多属性映射。</p><h4 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h4><p>在Mapper文件中定义SQL如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getVoById3&quot;</span> resultMap=<span class="hljs-string">&quot;csMap2&quot;</span>&gt;<br>    select c.grade,<br>    c.no,<br>    c.id as class_id<br>    from tt_class c<br>    where c.id = #&#123;id&#125;<br>&lt;/select&gt;<br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">space.yangtao.domain.vo2.<span class="hljs-function">ClassVO <span class="hljs-title">getVoById3</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>定义<code>resultMap</code>，使用<code>collection</code>标签指定集合</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;csMap2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo2.ClassVO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;grade&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;no&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;space.yangtao.domain.vo2.StudentVO&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;space.yangtao.mapper.StudentMapper.getVoByClassId&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在<code>StudentMapper</code>中定义刚才在<code>collection</code>中声明的<code>getVoByClassId</code>方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getVoByClassId&quot;</span> resultType=<span class="hljs-string">&quot;space.yangtao.domain.vo2.StudentVO&quot;</span>&gt;<br>    select id, name from tt_student where class_id = #&#123;class_id&#125;<br>&lt;/select&gt;<br></code></pre></div></td></tr></table></figure><p>运行测试程序如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>ClassMapper classMapper = session.getMapper(ClassMapper.class);<br>log.info(<span class="hljs-string">&quot;getCsVO2：&#123;&#125;&quot;</span>, classMapper.getVoById3(<span class="hljs-number">2L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>09:06:14.124 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById3 - ==&gt;  Preparing: select c.grade, c.no, c.id as class_id from tt_class c <span class="hljs-built_in">where</span> c.id = ?<br>09:06:14.142 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById3 - ==&gt; Parameters: 2(Long)<br>09:06:14.153 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById3 - &lt;==    Columns: grade, no, class_id<br>09:06:14.154 [main] TRACE space.yangtao.mapper.ClassMapper.getVoById3 - &lt;==        Row: 二年级, 1, 2<br>09:06:14.156 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>09:06:14.156 [main] DEBUG space.yangtao.mapper.StudentMapper.getVoByClassId - ====&gt;  Preparing: select id, name from tt_student <span class="hljs-built_in">where</span> class_id = ?<br>09:06:14.156 [main] DEBUG space.yangtao.mapper.StudentMapper.getVoByClassId - ====&gt; Parameters: 2(Long)<br>09:06:14.157 [main] TRACE space.yangtao.mapper.StudentMapper.getVoByClassId - &lt;====    Columns: id, name<br>09:06:14.158 [main] TRACE space.yangtao.mapper.StudentMapper.getVoByClassId - &lt;====        Row: 2, zhangsan1<br>09:06:14.158 [main] TRACE space.yangtao.mapper.StudentMapper.getVoByClassId - &lt;====        Row: 3, zhangsan2<br>09:06:14.158 [main] DEBUG space.yangtao.mapper.StudentMapper.getVoByClassId - &lt;====      Total: 2<br>09:06:14.159 [main] DEBUG space.yangtao.mapper.ClassMapper.getVoById3 - &lt;==      Total: 1<br>09:06:14.160 [main] INFO  space.yangtao.client.StudentMapperTest - getCsVO2：ClassVO(grade=二年级, no=1, students=[StudentVO(id=2, name=zhangsan1), StudentVO(id=3, name=zhangsan2)])<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>ClassVO</code>对象中已包含多个<code>StudentVO</code>对象，<code>resultMap</code>已完成一对多属性映射。</p><p><strong>补充</strong>：跟多对一一样，一对多的分步查询页也支持延迟加载，且开启方式一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习本文，开发者不仅能够掌握MyBatis的动态SQL构建技巧，还能了解到如何通过高级映射技术实现一对多和多对一的关系映射。这些技术不仅优化了代码结构，也提高了开发效率和数据操作的灵活性。随着对MyBatis功能的深入理解，开发者将能更加自信地应用这些高级功能来设计和实现更复杂的数据库交互操作。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis核心功能一</title>
    <link href="/2022/08/03/mybatis-core-features-1/"/>
    <url>/2022/08/03/mybatis-core-features-1/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>MyBatis作为一个强大的持久层框架，提供了面向接口编程的方法，通过动态代理技术，自动地生成接口实现，本文将对这一特点进行详细介绍。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>面向接口编程是一种常用的设计模式，在MyBatis中，可以定义一个Java接口，其中的每个方法对应于SQL映射文件中的一个SQL语句。MyBatis利用<strong>动态代理技术</strong>在运行时自动生成这些接口的实现类。开发者只需调用接口方法，即可执行对应的SQL操作。这种方法将接口定义与具体的SQL操作分离，使得代码更加整洁、易于管理和扩展。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><strong>接口定义</strong>：首先定义一个接口，声明所需的数据库操作，如插入、查询、更新和删除。</li><li><strong>映射文件</strong>：为接口中的每个方法提供相应的SQL语句映射。这些映射定义在Mapper文件中，或通过注解直接在接口方法上指定。</li><li><strong>SqlSessionFactory</strong>：通过配置信息，MyBatis构建一个<code>SqlSessionFactory</code>实例，这是创建SQL会话的工厂。</li><li><strong>SqlSession</strong>：从<code>SqlSessionFactory</code>获取<code>SqlSession</code>，它是执行SQL命令的实际对象。</li><li><strong>动态代理</strong>：当调用接口方法时，MyBatis会通过动态代理拦截这些调用，并根据方法名称匹配Mapper文件或注解中定义的 SQL 语句，执行数据库操作。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>解耦合</strong>：接口和SQL映射的分离使得业务逻辑和数据库操作代码解耦，提高了代码的可维护性。</li><li><strong>简洁性</strong>：开发者只需通过调用接口方法来执行数据库操作，无需关心底层的SQL详情，代码更简洁。</li><li><strong>易于维护</strong>：SQL语句集中管理，在Mapper文件或接口注解中修改SQL语句即可，无需修改业务代码。</li><li><strong>灵活性</strong>：易于实现和切换不同的数据库操作逻辑，只需更改SQL映射即可，不影响业务逻辑层。</li><li><strong>类型安全</strong>：由于使用Java接口，所有的操作都是类型安全的，减少了运行时错误。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p>以<code>tt_vehicle</code>为示例表，定义<code>DAO</code>接口<code>VehicleMapper.class</code>，这个接口包含了的各种操作如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VehicleMapper</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addVehicle</span><span class="hljs-params">(VehiclePO vehiclePO)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteVehicle</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;<br><br>    <span class="hljs-function">VehiclePO <span class="hljs-title">getVehicleById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;<br><br>    <span class="hljs-function">List&lt;VehiclePO&gt; <span class="hljs-title">getAllVehicles</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateVehicle</span><span class="hljs-params">(VehiclePO vehiclePO)</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>定义对应的Mapper文件<code>VehicleMapper.xml</code>，接口与Mapper文件之间通过<code>namespace</code>进行关联（<code>Mapper</code>文件的<code>namespace</code>=接口的全限定类名），SQL语句标签的<code>id</code>=接口方法名</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;space.yangtao.mapper.VehicleMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addVehicle&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>        insert into tt_vehicle (product_name, vin, production_date, guide_price)<br>        values (#&#123;productName&#125;, #&#123;vin&#125;, #&#123;productionDate&#125;, #&#123;guidePrice&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteVehicle&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        delete from tt_vehicle where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getVehicleById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>        select id              as id,<br>               product_name    as productName,<br>               vin             as vin,<br>               production_date as productionDate,<br>               guide_price     as guidePrice<br>        from tt_vehicle<br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllVehicles&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>        select id              as id,<br>               product_name    as productName,<br>               vin             as vin,<br>               production_date as productionDate,<br>               guide_price     as guidePrice<br>        from tt_vehicle<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateVehicle&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>        update tt_vehicle<br>        set product_name = #&#123;productName&#125;,<br>            vin = #&#123;vin&#125;,<br>            production_date = #&#123;productionDate&#125;,<br>            guide_price = #&#123;guidePrice&#125;<br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>使用时，不再通过<code>SqlSession</code>对象调用Mapper文件中的方法，而是通过<code>SqlSession</code>获取到对应的<strong>接口的代理对象</strong>，通过调用代理对象的方法，实现对Mapper文件中对应SQL的调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleMapperTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(VehicleMapperTest.class);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddVehicle</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;--- testAddVehicle start ---&quot;</span>);<br>        VehiclePO audiA6L = <span class="hljs-keyword">new</span> VehiclePO()<br>                .setProductName(<span class="hljs-string">&quot;Audi A6L&quot;</span>)<br>                .setVin(<span class="hljs-string">&quot;LVIN1&quot;</span>)<br>                .setProductionDate(LocalDate.now())<br>                .setGuidePrice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;450000&quot;</span>));<br>        VehiclePO bwm530Li = <span class="hljs-keyword">new</span> VehiclePO()<br>                .setProductName(<span class="hljs-string">&quot;BMW 530Li&quot;</span>)<br>                .setVin(<span class="hljs-string">&quot;LVIN2&quot;</span>)<br>                .setProductionDate(LocalDate.now())<br>                .setGuidePrice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;600000&quot;</span>));<br>        VehiclePO benzE300L = <span class="hljs-keyword">new</span> VehiclePO()<br>                .setProductName(<span class="hljs-string">&quot;Benz E300L&quot;</span>)<br>                .setVin(<span class="hljs-string">&quot;LVIN3&quot;</span>)<br>                .setProductionDate(LocalDate.now())<br>                .setGuidePrice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;500000&quot;</span>));<br>        SqlSession session = SqlSessionUtil.getSession();<br>        session.getMapper(VehicleMapper.class).addVehicle(audiA6L);<br>        session.getMapper(VehicleMapper.class).addVehicle(bwm530Li);<br>        session.getMapper(VehicleMapper.class).addVehicle(benzE300L);<br>        session.commit();<br>        log.info(<span class="hljs-string">&quot;--- testAddVehicle end ---&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetVehicleById</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;--- testGetVehicleById start ---&quot;</span>);<br>        SqlSession session = SqlSessionUtil.getSession();<br>        VehiclePO vehiclePO = session.getMapper(VehicleMapper.class).getVehicleById(<span class="hljs-number">1L</span>);<br>        System.out.println(vehiclePO);<br>        log.info(<span class="hljs-string">&quot;--- testGetVehicleById end ---&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@Order(3)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateVehicle</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;--- testUpdateVehicle start ---&quot;</span>);<br>        VehiclePO vehiclePO = <span class="hljs-keyword">new</span> VehiclePO()<br>                .setId(<span class="hljs-number">1L</span>)<br>                .setProductName(<span class="hljs-string">&quot;Audi A6L&quot;</span>)<br>                .setVin(<span class="hljs-string">&quot;LVIN1&quot;</span>)<br>                .setProductionDate(LocalDate.now())<br>                .setGuidePrice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;450000&quot;</span>));<br>        SqlSession session = SqlSessionUtil.getSession();<br>        session.getMapper(VehicleMapper.class).updateVehicle(vehiclePO);<br>        session.commit();<br>        log.info(<span class="hljs-string">&quot;--- testUpdateVehicle end ---&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@Order(4)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteVehicle</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;--- testDeleteVehicle start ---&quot;</span>);<br>        SqlSession session = SqlSessionUtil.getSession();<br>        session.getMapper(VehicleMapper.class).deleteVehicle(<span class="hljs-number">1L</span>);<br>        session.commit();<br>        log.info(<span class="hljs-string">&quot;--- testDeleteVehicle end ---&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@Order(5)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetAllVehicles</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;--- testGetAllVehicles start ---&quot;</span>);<br>        SqlSession session = SqlSessionUtil.getSession();<br>        session.getMapper(VehicleMapper.class).getAllVehicles().forEach(System.out::println);<br>        log.info(<span class="hljs-string">&quot;--- testGetAllVehicles end ---&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>运行程序，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">21:01:57.345 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:01:58.177 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 34073107.<br>21:01:58.177 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.179 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (?, ?, ?, ?)<br>21:01:58.197 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt; Parameters: Audi A6L(String), LVIN1(String), 2024-07-18(LocalDate), 450000(BigDecimal)<br>21:01:58.204 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - &lt;==    Updates: 1<br>21:01:58.213 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (?, ?, ?, ?)<br>21:01:58.214 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt; Parameters: BMW 530Li(String), LVIN2(String), 2024-07-18(LocalDate), 600000(BigDecimal)<br>21:01:58.215 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - &lt;==    Updates: 1<br>21:01:58.215 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (?, ?, ?, ?)<br>21:01:58.215 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt; Parameters: Benz E300L(String), LVIN3(String), 2024-07-18(LocalDate), 500000(BigDecimal)<br>21:01:58.216 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - &lt;==    Updates: 1<br>21:01:58.216 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.218 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.218 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.219 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 34073107 to pool.<br>21:01:58.219 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testAddVehicle end ---<br>21:01:58.223 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testGetVehicleById start ---<br>21:01:58.224 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:01:58.224 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection 34073107 from pool.<br>21:01:58.224 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.225 [main] DEBUG space.yangtao.mapper.VehicleMapper.getVehicleById - ==&gt;  Preparing: select id as id, product_name as productName, vin as vin, production_date as productionDate, guide_price as guidePrice from tt_vehicle <span class="hljs-built_in">where</span> id = ?<br>21:01:58.226 [main] DEBUG space.yangtao.mapper.VehicleMapper.getVehicleById - ==&gt; Parameters: 1(Long)<br>21:01:58.235 [main] TRACE space.yangtao.mapper.VehicleMapper.getVehicleById - &lt;==    Columns: id, productName, vin, productionDate, guidePrice<br>21:01:58.236 [main] TRACE space.yangtao.mapper.VehicleMapper.getVehicleById - &lt;==        Row: 1, Audi A6L, LVIN1, 2024-07-18, 450000.00<br>21:01:58.238 [main] DEBUG space.yangtao.mapper.VehicleMapper.getVehicleById - &lt;==      Total: 1<br>VehiclePO(id=1, productName=Audi A6L, vin=LVIN1, productionDate=2024-07-18, guidePrice=450000.00)<br>21:01:58.240 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.240 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.240 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 34073107 to pool.<br>21:01:58.240 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testGetVehicleById end ---<br>21:01:58.241 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testUpdateVehicle start ---<br>21:01:58.242 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:01:58.242 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection 34073107 from pool.<br>21:01:58.242 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.242 [main] DEBUG space.yangtao.mapper.VehicleMapper.updateVehicle - ==&gt;  Preparing: update tt_vehicle <span class="hljs-built_in">set</span> product_name = ?, vin = ?, production_date = ?, guide_price = ? <span class="hljs-built_in">where</span> id = ?<br>21:01:58.242 [main] DEBUG space.yangtao.mapper.VehicleMapper.updateVehicle - ==&gt; Parameters: Audi A6L(String), LVIN1(String), 2024-07-18(LocalDate), 450000(BigDecimal), 1(Long)<br>21:01:58.243 [main] DEBUG space.yangtao.mapper.VehicleMapper.updateVehicle - &lt;==    Updates: 1<br>21:01:58.243 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.244 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.244 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.244 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 34073107 to pool.<br>21:01:58.244 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testUpdateVehicle end ---<br>21:01:58.245 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testDeleteVehicle start ---<br>21:01:58.245 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:01:58.245 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection 34073107 from pool.<br>21:01:58.245 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.246 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt;  Preparing: delete from tt_vehicle <span class="hljs-built_in">where</span> id = ?<br>21:01:58.246 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - ==&gt; Parameters: 1(Long)<br>21:01:58.247 [main] DEBUG space.yangtao.mapper.VehicleMapper.deleteVehicle - &lt;==    Updates: 1<br>21:01:58.247 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.249 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.250 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.250 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 34073107 to pool.<br>21:01:58.250 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testDeleteVehicle end ---<br>21:01:58.251 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testGetAllVehicles start ---<br>21:01:58.251 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection<br>21:01:58.251 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection 34073107 from pool.<br>21:01:58.252 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to <span class="hljs-literal">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.252 [main] DEBUG space.yangtao.mapper.VehicleMapper.getAllVehicles - ==&gt;  Preparing: select id as id, product_name as productName, vin as vin, production_date as productionDate, guide_price as guidePrice from tt_vehicle<br>21:01:58.253 [main] DEBUG space.yangtao.mapper.VehicleMapper.getAllVehicles - ==&gt; Parameters: <br>21:01:58.253 [main] TRACE space.yangtao.mapper.VehicleMapper.getAllVehicles - &lt;==    Columns: id, productName, vin, productionDate, guidePrice<br>21:01:58.253 [main] TRACE space.yangtao.mapper.VehicleMapper.getAllVehicles - &lt;==        Row: 2, BMW 530Li, LVIN2, 2024-07-18, 600000.00<br>21:01:58.253 [main] TRACE space.yangtao.mapper.VehicleMapper.getAllVehicles - &lt;==        Row: 3, Benz E300L, LVIN3, 2024-07-18, 500000.00<br>21:01:58.253 [main] DEBUG space.yangtao.mapper.VehicleMapper.getAllVehicles - &lt;==      Total: 2<br>VehiclePO(id=2, productName=BMW 530Li, vin=LVIN2, productionDate=2024-07-18, guidePrice=600000.00)<br>VehiclePO(id=3, productName=Benz E300L, vin=LVIN3, productionDate=2024-07-18, guidePrice=500000.00)<br>21:01:58.255 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to <span class="hljs-literal">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.255 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@207ea13]<br>21:01:58.255 [main] DEBUG o.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 34073107 to pool.<br>21:01:58.255 [main] INFO  space.yangtao.client.VehicleMapperTest - --- testGetAllVehicles end ---<br></code></pre></div></td></tr></table></figure><p>由日志可以看出，SqlSession通过接口的动态代理对象已经实现了对Mapper文件中的SQL执行，并且在编码时分层清晰且可维护性高。</p></li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p><code>VehicleMapper.xml</code>中定义两个测试方法，都是以<code>VIN</code>为条件，分别用<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>传递参数</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testD&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>    select id from tt_vehicle where vin = #&#123;vin&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testE&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>    select id from tt_vehicle where vin = $&#123;vin&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>VehicleMapper.class</code>中定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;VehiclePO&gt; <span class="hljs-title">testD</span><span class="hljs-params">(String vin)</span></span>;<br><br><span class="hljs-function">List&lt;VehiclePO&gt; <span class="hljs-title">testE</span><span class="hljs-params">(String vin)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>VehicleMapper vehicleMapper = session.getMapper(VehicleMapper.class);<br>vehicleMapper.testD(<span class="hljs-string">&quot;LVIN1&quot;</span>);<br>vehicleMapper.testE(<span class="hljs-string">&quot;LVIN1&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:03:22.737 [main] DEBUG space.yangtao.mapper.VehicleMapper.testD - ==&gt;  Preparing: select id from tt_vehicle <span class="hljs-built_in">where</span> vin = ?<br>21:03:22.760 [main] DEBUG space.yangtao.mapper.VehicleMapper.testD - ==&gt; Parameters: LVIN1(String)<br>21:03:22.775 [main] DEBUG space.yangtao.mapper.VehicleMapper.testD - &lt;==      Total: 0<br>21:03:22.790 [main] DEBUG space.yangtao.mapper.VehicleMapper.testE - ==&gt;  Preparing: select id from tt_vehicle <span class="hljs-built_in">where</span> vin = LVIN1<br>21:03:22.790 [main] DEBUG space.yangtao.mapper.VehicleMapper.testE - ==&gt; Parameters: <br><br>org.apache.ibatis.exceptions.PersistenceException: <br><span class="hljs-comment">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;LVIN1&#x27; in &#x27;where clause&#x27;</span><br><span class="hljs-comment">### The error may exist in space/yangtao/mapper/VehicleMapper.xml</span><br><span class="hljs-comment">### The error may involve defaultParameterMap</span><br><span class="hljs-comment">### The error occurred while setting parameters</span><br><span class="hljs-comment">### SQL: select id from tt_vehicle where vin = LVIN1</span><br><span class="hljs-comment">### Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;LVIN1&#x27; in &#x27;where clause&#x27;</span><br></code></pre></div></td></tr></table></figure><p>由日志可知，方法执行<code>testD</code>方法时报错了，从日志的<code>SQL</code>条件看，两条语句中，使用<code>#&#123;&#125;</code>语句将<code>#&#123;&#125;</code>替换为了<code>?</code>，并通过预处理语句设置参数值，而<code>$&#123;&#125;</code>语句不使用预处理语句，而是直接将<code>$&#123;&#125;</code>替换为了参数值，SQL语句中对于字符串参数没有加引号<code>&#39;&#39;</code>，因此报错。</p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p><code>VehicleMapper.xml</code>中定义两个测试方法，查询参数为排序方式</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testF&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>    select id from tt_vehicle order by production_date $&#123;order&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testG&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span>&gt;</span><br>    select id from tt_vehicle order by production_date #&#123;order&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>VehicleMapper.class</code>中定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;VehiclePO&gt; <span class="hljs-title">testF</span><span class="hljs-params">(String vin)</span></span>;<br><br><span class="hljs-function">List&lt;VehiclePO&gt; <span class="hljs-title">testG</span><span class="hljs-params">(String vin)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>VehicleMapper vehicleMapper = session.getMapper(VehicleMapper.class);<br>vehicleMapper.testF(<span class="hljs-string">&quot;asc&quot;</span>);<br>vehicleMapper.testG(<span class="hljs-string">&quot;asc&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:06:25.044 [main] DEBUG space.yangtao.mapper.VehicleMapper.testF - ==&gt;  Preparing: select id from tt_vehicle order by production_date asc<br>21:06:25.063 [main] DEBUG space.yangtao.mapper.VehicleMapper.testF - ==&gt; Parameters: <br>21:06:25.080 [main] TRACE space.yangtao.mapper.VehicleMapper.testF - &lt;==    Columns: id<br>21:06:25.081 [main] TRACE space.yangtao.mapper.VehicleMapper.testF - &lt;==        Row: 2<br>21:06:25.082 [main] TRACE space.yangtao.mapper.VehicleMapper.testF - &lt;==        Row: 3<br>21:06:25.082 [main] DEBUG space.yangtao.mapper.VehicleMapper.testF - &lt;==      Total: 2<br>21:06:25.083 [main] DEBUG space.yangtao.mapper.VehicleMapper.testG - ==&gt;  Preparing: select id from tt_vehicle order by production_date ?<br>21:06:25.083 [main] DEBUG space.yangtao.mapper.VehicleMapper.testG - ==&gt; Parameters: asc(String)<br><br>org.apache.ibatis.exceptions.PersistenceException: <br><span class="hljs-comment">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27;asc&#x27;&#x27; at line 1</span><br><span class="hljs-comment">### The error may exist in space/yangtao/mapper/VehicleMapper.xml</span><br><span class="hljs-comment">### The error may involve defaultParameterMap</span><br><span class="hljs-comment">### The error occurred while setting parameters</span><br><span class="hljs-comment">### SQL: select id from tt_vehicle order by production_date ?</span><br><span class="hljs-comment">### Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27;asc&#x27;&#x27; at line 1</span><br></code></pre></div></td></tr></table></figure><p>由日志可知，方法在执行<code>testG</code>方法时报错了，从日志的<code>SQL</code>看，使用<code>$&#123;&#125;</code>传参的语句正确的实现了预想的功能，而<code>#&#123;&#125;</code>传参的语句使用了预处理，将MySQL关键字<code>asc</code>当成了参数，导致执行报错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><strong>预处理与直接替换</strong></p><ul><li><p><code>#&#123;&#125;</code>：使用预处理，安全地绑定变量。</p></li><li><p><code>$&#123;&#125;</code>：直接进行字符串替换，存在<code>SQL</code>注入的风险。</p></li></ul></li></ol><ol start="2"><li><p><strong>应用场景</strong></p><ul><li><p><code>#&#123;&#125;</code>：对于大多数需要动态数据绑定的场景。</p></li><li><p><code>$&#123;&#125;</code>：可用于那些动态构建<code>SQL</code>语句的场景，如动态表名或动态列名或排序方式，但必须非常小心处理变量值，确保安全性。</p></li></ul></li></ol><ol start="3"><li><p><strong>SQL 注入防御</strong></p><ul><li><p><code>#&#123;&#125;</code>：因为使用了预处理和参数绑定，能有效防止<code>SQL</code>注入。</p></li><li><p><code>$&#123;&#125;</code>：由于缺乏预处理，用户输入如果不被适当清理和限制，可能会引起<code>SQL</code>注入问题。</p></li></ul></li></ol><h2 id="取别名"><a href="#取别名" class="headerlink" title="取别名"></a>取别名</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在 MyBatis 中，<code>&lt;typeAliases&gt;</code>标签用于定义Java类型的别名，以便在配置文件和映射文件中简化对Java类的引用。通过使用别名，可以避免在XML配置中反复写出长的类名，从而使配置文件更加简洁易读。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>简化类名</strong>：为长的完全限定类名（FQCN）提供一个简短的名称，使得配置文件中的引用更加简洁。</li><li><strong>提高可读性</strong>：通过使用别名，配置文件的可读性得到提高，配置更加直观。</li><li><strong>配置灵活性</strong>：允许开发者自定义别名，根据项目的需要，映射任意的类名。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在<code>mybatis-config.xml</code>中，在<code>&lt;typeAliases&gt;</code>标签下取别名，别名可以在<code>Mapper</code>文件中使用</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 单个自定义别名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;VehiclePO&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 默认的别名机制，类的简名ownerPO，不区分大小写 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.OwnerPO&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 包下所有类批量起别名，规则为默认别名机制 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;space.yangtao.domain&quot;</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>别名默认不区分大小写，但可以在设置中，通过<code>caseSensitiveAliases</code>开启别名大小写敏感。</li><li>如果不同的类使用相同的简单名称，自动扫描可能会引发冲突，此时需要为冲突的类指定具体的别名。</li><li>使用别名时，确保别名的唯一性和一致性，避免在项目中引起混淆。</li><li><code>namespace</code>不能取别名。</li></ul><h2 id="获取主键"><a href="#获取主键" class="headerlink" title="获取主键"></a>获取主键</h2><p>在许多开发场景中，插入一条数据库后，通常会希望的到新插入行自动生成的主键值，MyBatis中通过设置<code>Mapper</code>文件中对应的<code>insert</code>标签即可实现，如</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addVehicle&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.VehiclePO&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tt_vehicle (product_name, vin, production_date, guide_price)<br>    values (#&#123;productName&#125;, #&#123;vin&#125;, #&#123;productionDate&#125;, #&#123;guidePrice&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><code>useGeneratedKeys</code>：是否使用自动生成的主键</li><li><code>keyProperty</code>：生成的主键值赋值给对象的哪个属性</li></ul><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>VehicleMapper vehicleMapper = session.getMapper(VehicleMapper.class);<br>VehiclePO vehiclePO = <span class="hljs-keyword">new</span> VehiclePO()<br>        .setProductName(<span class="hljs-string">&quot;Audi A6L&quot;</span>)<br>        .setVin(<span class="hljs-string">&quot;LVIN1&quot;</span>)<br>        .setProductionDate(LocalDate.now())<br>        .setGuidePrice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;450000&quot;</span>));<br>vehicleMapper.addVehicle(vehiclePO);<br>log.info(<span class="hljs-string">&quot;Generated key: &#123;&#125;&quot;</span>, vehiclePO.getId());<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:13:16.484 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt;  Preparing: insert into tt_vehicle (product_name, vin, production_date, guide_price) values (?, ?, ?, ?)<br>21:13:16.504 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - ==&gt; Parameters: Audi A6L(String), LVIN1(String), 2024-07-18(LocalDate), 450000(BigDecimal)<br>21:13:16.507 [main] DEBUG space.yangtao.mapper.VehicleMapper.addVehicle - &lt;==    Updates: 1<br>21:13:16.515 [main] INFO  space.yangtao.client.VehicleMapperTest - Generated key: 4<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知新插入数据的主键<code>ID</code>为4，经核查也与数据库中对应的主键<code>ID</code>一致。</p><p><strong>拓展</strong>：本方式适用于支持自动生成主键的数据库（如MySQL的<code>AUTO_INCREMENT</code>）。对于不支持自动生成主键的数据库，需要使用<code>selectKey</code>标签来获取主键。</p><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><p>创建测试表<code>tt_student</code>，同时插入3条测试数据</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `tt_student`<br>(<br>    `id`          bigint      NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br>    `name`        varchar(50) NOT NULL COMMENT &#x27;姓名&#x27;,<br>    `height`      double      NOT NULL COMMENT &#x27;身高（cm）&#x27;,<br>    `gender`      char        NOT NULL COMMENT &#x27;性别&#x27;,<br>    `birthday`    date        NOT NULL COMMENT &#x27;出生日期&#x27;,<br>    `create_time` datetime    NOT NULL default current_timestamp COMMENT &#x27;创建时间&#x27;,<br>    PRIMARY KEY (`id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;学生表&#x27;;<br><br>INSERT INTO mybatis_db.tt_student (id, name, height, gender, birthday, create_time) VALUES (1, &#x27;zhangsan&#x27;, 176.1, &#x27;男&#x27;, &#x27;1990-01-01&#x27;, &#x27;2022-07-01 22:10:22&#x27;);<br>INSERT INTO mybatis_db.tt_student (id, name, height, gender, birthday, create_time) VALUES (2, &#x27;zhangsan1&#x27;, 180, &#x27;男&#x27;, &#x27;1990-01-01&#x27;, &#x27;2022-07-01 21:10:22&#x27;);<br>INSERT INTO mybatis_db.tt_student (id, name, height, gender, birthday, create_time) VALUES (3, &#x27;zhangsan2&#x27;, 180, &#x27;男&#x27;, &#x27;1990-01-01&#x27;, &#x27;2022-07-01 21:10:22&#x27;);<br></code></pre></div></td></tr></table></figure><h3 id="简单类型自动转换"><a href="#简单类型自动转换" class="headerlink" title="简单类型自动转换"></a>简单类型自动转换</h3><ul><li>基本数据类型：byte、short、int、long、float、double、char</li><li>基本数据类型包装类：Byte、Short、Integer、Long、Float、Double、Character</li><li>字符串类型：String</li><li>日期：java.util.Date、java.sql.Date、java.time.LocalDate、java.time.LocalDateTime</li></ul><p>在Mapper文件<code>StudentMapper.xml</code>中定义表<code>tt_student</code>对应的方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByHeight&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where height = #&#123;height&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByGender&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where gender = #&#123;gender&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByBirthday&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where birthday = #&#123;birthday&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByCreateTime&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where create_Time = #&#123;createTime&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>编写对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentPO <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByName</span><span class="hljs-params">(String name)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByHeight</span><span class="hljs-params">(<span class="hljs-keyword">double</span> height)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByGender</span><span class="hljs-params">(<span class="hljs-keyword">char</span> gender)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByBirthday</span><span class="hljs-params">(Date birthday)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByCreateTime</span><span class="hljs-params">(Date createTime)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByBirthday2</span><span class="hljs-params">(LocalDate birthday)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByCreateTime2</span><span class="hljs-params">(LocalDateTime createTime2)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;Long查询          students -&gt; &#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;String查询        students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByName(<span class="hljs-string">&quot;zhangsan&quot;</span>));<br>log.info(<span class="hljs-string">&quot;double查询        students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByHeight(<span class="hljs-number">176.1</span>));<br>log.info(<span class="hljs-string">&quot;char查询          students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByGender(<span class="hljs-string">&#x27;男&#x27;</span>));<br>log.info(<span class="hljs-string">&quot;Date查询          students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByBirthday(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="hljs-string">&quot;1990-01-01&quot;</span>)));<br>log.info(<span class="hljs-string">&quot;Date查询          students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByCreateTime(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="hljs-string">&quot;2022-07-01 22:10:22&quot;</span>)));<br>log.info(<span class="hljs-string">&quot;LocalDate查询     students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByBirthday2(LocalDate.of(<span class="hljs-number">1990</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)));<br>log.info(<span class="hljs-string">&quot;LocalDateTime查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByCreateTime2(LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>).atTime(<span class="hljs-number">21</span>, <span class="hljs-number">10</span>, <span class="hljs-number">22</span>)));<br>session.close();<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:23:33.807 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:23:33.825 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:23:33.837 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.838 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.839 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:23:33.840 [main] INFO  space.yangtao.client.StudentMapperTest - Long查询          students -&gt; StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)<br>21:23:33.841 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.841 [main] DEBUG space.yangtao.mapper.StudentMapper.getByName - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> name = ?<br>21:23:33.841 [main] DEBUG space.yangtao.mapper.StudentMapper.getByName - ==&gt; Parameters: zhangsan(String)<br>21:23:33.842 [main] TRACE space.yangtao.mapper.StudentMapper.getByName - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.842 [main] TRACE space.yangtao.mapper.StudentMapper.getByName - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.842 [main] DEBUG space.yangtao.mapper.StudentMapper.getByName - &lt;==      Total: 1<br>21:23:33.843 [main] INFO  space.yangtao.client.StudentMapperTest - String查询        students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.843 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.843 [main] DEBUG space.yangtao.mapper.StudentMapper.getByHeight - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> height = ?<br>21:23:33.843 [main] DEBUG space.yangtao.mapper.StudentMapper.getByHeight - ==&gt; Parameters: 176.1(Double)<br>21:23:33.844 [main] TRACE space.yangtao.mapper.StudentMapper.getByHeight - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.844 [main] TRACE space.yangtao.mapper.StudentMapper.getByHeight - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.846 [main] DEBUG space.yangtao.mapper.StudentMapper.getByHeight - &lt;==      Total: 1<br>21:23:33.846 [main] INFO  space.yangtao.client.StudentMapperTest - double查询        students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.846 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.846 [main] DEBUG space.yangtao.mapper.StudentMapper.getByGender - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> gender = ?<br>21:23:33.846 [main] DEBUG space.yangtao.mapper.StudentMapper.getByGender - ==&gt; Parameters: 男(String)<br>21:23:33.847 [main] TRACE space.yangtao.mapper.StudentMapper.getByGender - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.847 [main] TRACE space.yangtao.mapper.StudentMapper.getByGender - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.847 [main] TRACE space.yangtao.mapper.StudentMapper.getByGender - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.848 [main] TRACE space.yangtao.mapper.StudentMapper.getByGender - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.848 [main] DEBUG space.yangtao.mapper.StudentMapper.getByGender - &lt;==      Total: 3<br>21:23:33.848 [main] INFO  space.yangtao.client.StudentMapperTest - char查询          students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.848 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.849 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> birthday = ?<br>21:23:33.855 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday - ==&gt; Parameters: 1990-01-01 00:00:00.0(Timestamp)<br>21:23:33.856 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.856 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.857 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.857 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.858 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday - &lt;==      Total: 3<br>21:23:33.858 [main] INFO  space.yangtao.client.StudentMapperTest - Date查询          students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.858 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.858 [main] DEBUG space.yangtao.mapper.StudentMapper.getByCreateTime - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> create_Time = ?<br>21:23:33.858 [main] DEBUG space.yangtao.mapper.StudentMapper.getByCreateTime - ==&gt; Parameters: 2022-07-01 22:10:22.0(Timestamp)<br>21:23:33.859 [main] TRACE space.yangtao.mapper.StudentMapper.getByCreateTime - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.860 [main] TRACE space.yangtao.mapper.StudentMapper.getByCreateTime - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.861 [main] DEBUG space.yangtao.mapper.StudentMapper.getByCreateTime - &lt;==      Total: 1<br>21:23:33.861 [main] INFO  space.yangtao.client.StudentMapperTest - Date查询          students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.861 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.861 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday2 - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> birthday = ?<br>21:23:33.862 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday2 - ==&gt; Parameters: 1990-01-01(LocalDate)<br>21:23:33.863 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday2 - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.863 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday2 - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:23:33.863 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday2 - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.863 [main] TRACE space.yangtao.mapper.StudentMapper.getByBirthday2 - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.863 [main] DEBUG space.yangtao.mapper.StudentMapper.getByBirthday2 - &lt;==      Total: 3<br>21:23:33.863 [main] INFO  space.yangtao.client.StudentMapperTest - LocalDate查询     students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:23:33.864 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:23:33.864 [main] DEBUG s.yangtao.mapper.StudentMapper.getByCreateTime2 - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> create_Time = ?<br>21:23:33.865 [main] DEBUG s.yangtao.mapper.StudentMapper.getByCreateTime2 - ==&gt; Parameters: 2022-07-01T21:10:22(LocalDateTime)<br>21:23:33.866 [main] TRACE s.yangtao.mapper.StudentMapper.getByCreateTime2 - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:23:33.866 [main] TRACE s.yangtao.mapper.StudentMapper.getByCreateTime2 - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.866 [main] TRACE s.yangtao.mapper.StudentMapper.getByCreateTime2 - &lt;==        Row: 3, 2, zhangsan2, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:23:33.866 [main] DEBUG s.yangtao.mapper.StudentMapper.getByCreateTime2 - &lt;==      Total: 2<br>21:23:33.866 [main] INFO  space.yangtao.client.StudentMapperTest - LocalDateTime查询 students -&gt; [StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=3, name=zhangsan2, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>...<br></code></pre></div></td></tr></table></figure><p>根据日志可知，MyBatis自身有类型推断机制，对于简单数据类型和常用的时间日期类型可自动转换映射。</p><p>除了类型推断，还可以在Mapper中通过<code>parameterType</code>指定参数类型，如</p><ol><li><p>通过全限定类名指定类型</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>通过MyBatis的默认别名转换</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- java.lang.String类型的默认别名为string --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><br>    select * from tt_student where name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Java基本数据类型double的默认别名为_double --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByHeight&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;_double&quot;</span>&gt;</span><br>    select * from tt_student where height = #&#123;height&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在<code>#&#123;&#125;</code>中通过属性<code>javaType</code>指定Java的参数类型，通过属性<code>jdbcType</code>指定MySQL表字段的参数类型</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByGender&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where gender = #&#123;gender, javaType=Character, jdbcType=C23 AR&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>123456789 -<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="对象或Map类型参数"><a href="#对象或Map类型参数" class="headerlink" title="对象或Map类型参数"></a>对象或Map类型参数</h3><p>在MyBatis Mapper中还支持将所有的参数都封装到一个实体对象或Map数据结构中，其中对象属性名或Map的key必须与<code>#&#123;param&#125;</code>中的参数名一致。</p><p>在Mapper中定义查询语句</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByObj&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125; and name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125; and name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByObj</span><span class="hljs-params">(StudentPO studentPO)</span></span>;<br><br><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>StudentPO zhangsan = <span class="hljs-keyword">new</span> StudentPO().setId(<span class="hljs-number">1L</span>).setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>log.info(<span class="hljs-string">&quot;Obj查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByObj(zhangsan));<br>HashMap&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>    put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1L</span>);<br>    put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>&#125;&#125;;<br>log.info(<span class="hljs-string">&quot;Map查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByMap(params));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:42:00.498 [main] DEBUG space.yangtao.mapper.StudentMapper.getByObj - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ? and name = ?<br>21:42:00.515 [main] DEBUG space.yangtao.mapper.StudentMapper.getByObj - ==&gt; Parameters: 1(Long), zhangsan(String)<br>21:42:00.527 [main] TRACE space.yangtao.mapper.StudentMapper.getByObj - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:42:00.528 [main] TRACE space.yangtao.mapper.StudentMapper.getByObj - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:42:00.530 [main] DEBUG space.yangtao.mapper.StudentMapper.getByObj - &lt;==      Total: 1<br>21:42:00.531 [main] INFO  space.yangtao.client.StudentMapperTest - Obj查询 students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:42:00.533 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:42:00.533 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMap - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ? and name = ?<br>21:42:00.533 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMap - ==&gt; Parameters: 1(Long), zhangsan(String)<br>21:42:00.534 [main] TRACE space.yangtao.mapper.StudentMapper.getByMap - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:42:00.534 [main] TRACE space.yangtao.mapper.StudentMapper.getByMap - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:42:00.535 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMap - &lt;==      Total: 1<br>21:42:00.535 [main] INFO  space.yangtao.client.StudentMapperTest - Map查询 students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，Mapper已正确接收接口传递的参数。</p><h3 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h3><p>在mapper中定义查询方法如下，其中参数占位符为<code>#&#123;id&#125;</code>和<code>#&#123;name&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByMultipleParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125; and name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByMultipleParams</span><span class="hljs-params">(Long id, String name)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;多个参数查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByMultipleParams(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">org.apache.ibatis.exceptions.PersistenceException: <br><span class="hljs-comment">### Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br><span class="hljs-comment">### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br></code></pre></div></td></tr></table></figure><p>程序运行出现异常，由日志可知异常原因是没有找到名为<code>id</code>的参数，支持的参数有<code>arg1</code>、<code>arg0</code>、<code>param1</code>、<code>param2</code>，因此修改Mapper文件如下</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByMultipleParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;arg0&#125; and name = #&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>再次运行，控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:46:20.044 [main] DEBUG s.yangtao.mapper.StudentMapper.getByMultipleParams - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ? and name = ?<br>21:46:20.062 [main] DEBUG s.yangtao.mapper.StudentMapper.getByMultipleParams - ==&gt; Parameters: 1(Long), zhangsan(String)<br>21:46:20.074 [main] TRACE s.yangtao.mapper.StudentMapper.getByMultipleParams - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:46:20.075 [main] TRACE s.yangtao.mapper.StudentMapper.getByMultipleParams - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:46:20.076 [main] DEBUG s.yangtao.mapper.StudentMapper.getByMultipleParams - &lt;==      Total: 1<br>21:46:20.077 [main] INFO  space.yangtao.client.StudentMapperTest - 多个参数查询 students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，方法执行成功，查找到了需要的数据，此外<code>arg0</code>和<code>arg1</code>还可以分别替换为<code>param1</code>和<code>param2</code>，如</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByMultipleParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;param1&#125; and name = #&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>之所以要通过指定的参数，是因为MyBatis底层会自动将多个简单参数封装到一个Map型数据结构中，逻辑类似于</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>    put(<span class="hljs-string">&quot;arg0&quot;</span>, 第一个参数值);<br>    put(<span class="hljs-string">&quot;param1&quot;</span>, 第一个参数值);<br>    put(<span class="hljs-string">&quot;arg1&quot;</span>, 第二个参数值);<br>    put(<span class="hljs-string">&quot;param2&quot;</span>, 第二个参数值);<br>&#125;&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="Param命名参数"><a href="#Param命名参数" class="headerlink" title="@Param命名参数"></a>@Param命名参数</h3><p>上面提到的多参数，MyBatis默认创建key为<code>arg0... param1...</code>的Map型数据结构，MyBatis提供了<code>@Param</code>注解，用于指定Mapper接口参数的名称，方便在SQl语句中引用这些参数。</p><p>定义SQL如下，其中参数占位符为<code>#&#123;id&#125;</code>和<code>#&#123;name&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByParamAnno&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125; and name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByParamAnno</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id, <span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;Param注解查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByParamAnno(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:50:05.710 [main] DEBUG space.yangtao.mapper.StudentMapper.getByParamAnno - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ? and name = ?<br>21:50:05.728 [main] DEBUG space.yangtao.mapper.StudentMapper.getByParamAnno - ==&gt; Parameters: 1(Long), zhangsan(String)<br>21:50:05.743 [main] TRACE space.yangtao.mapper.StudentMapper.getByParamAnno - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:50:05.744 [main] TRACE space.yangtao.mapper.StudentMapper.getByParamAnno - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:50:05.745 [main] DEBUG space.yangtao.mapper.StudentMapper.getByParamAnno - &lt;==      Total: 1<br>21:50:05.747 [main] INFO  space.yangtao.client.StudentMapperTest - Param注解查询 students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>@Param</code>已经将MyBatis默认的参数命名替换成了<code>id</code>和<code>name</code>。</p><p>除此之外，<code>@Param</code>还可以应用于实体对象以及Map类型参数，甚至还可以使接口同时支持多个这种复杂参数。</p><p>在Mapper中指定了id对应参数为<code>#&#123;map1.id&#125;</code>，name对应参数为<code>#&#123;map2.name&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByMapAndObj&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;map.id&#125; and name = #&#123;obj.name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法中也指定参数的<code>@Param</code>值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByMapAndObj</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;map&quot;)</span> Map&lt;String, Object&gt; map1, <span class="hljs-meta">@Param(&quot;obj&quot;)</span> StudentPO studentPO)</span></span>;<br></code></pre></div></td></tr></table></figure><p>测试测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;<br>    put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1L</span>);<br>&#125;&#125;;<br>StudentPO studentPO = <span class="hljs-keyword">new</span> StudentPO().setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>log.info(<span class="hljs-string">&quot;多个复杂参数查询 students -&gt; &#123;&#125;&quot;</span>, studentMapper.getByMapAndObj(map, studentPO));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:52:37.851 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMapAndObj - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ? and name = ?<br>21:52:37.871 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMapAndObj - ==&gt; Parameters: 1(Long), zhangsan(String)<br>21:52:37.885 [main] TRACE space.yangtao.mapper.StudentMapper.getByMapAndObj - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:52:37.886 [main] TRACE space.yangtao.mapper.StudentMapper.getByMapAndObj - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:52:37.888 [main] DEBUG space.yangtao.mapper.StudentMapper.getByMapAndObj - &lt;==      Total: 1<br>21:52:37.889 [main] INFO  space.yangtao.client.StudentMapperTest - 多个复杂参数查询 students -&gt; [StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>@Param</code>注解支持为多个参数进行不同的命名。</p><p>在实际开发中，对于复杂参数，应明确使用<code>@Param</code>参数注解，特别是在团队协作和代码审查时，有助于避免参数混淆。</p><h2 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h2><h3 id="单个对象"><a href="#单个对象" class="headerlink" title="单个对象"></a>单个对象</h3><p>单个对象可以通过实体对象或Map接收Mapper SQL的返回值。</p><p>在mapper中定义查询方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById2&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentPO <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;<br><br><span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getById2</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;单个实体对象接收返回值：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br>log.info(<span class="hljs-string">&quot;单个Map对象接收返回值：&#123;&#125;&quot;</span>, studentMapper.getById2(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:55:37.437 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:55:37.454 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>21:55:37.469 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:55:37.471 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:55:37.472 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>21:55:37.474 [main] INFO  space.yangtao.client.StudentMapperTest - 单个实体对象接收返回值：StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)<br>21:55:37.474 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:55:37.474 [main] DEBUG space.yangtao.mapper.StudentMapper.getById2 - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>21:55:37.474 [main] DEBUG space.yangtao.mapper.StudentMapper.getById2 - ==&gt; Parameters: 1(Long)<br>21:55:37.475 [main] TRACE space.yangtao.mapper.StudentMapper.getById2 - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:55:37.476 [main] TRACE space.yangtao.mapper.StudentMapper.getById2 - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:55:37.478 [main] DEBUG space.yangtao.mapper.StudentMapper.getById2 - &lt;==      Total: 1<br>21:55:37.478 [main] INFO  space.yangtao.client.StudentMapperTest - 单个Map对象接收返回值：&#123;birthday=1990-01-01, gender=男, create_time=2022-07-01T22:10:22, class_id=1, name=zhangsan, id=1, height=176.1&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，实体类和Map结构都能接收单行数据。</p><h3 id="多个对象"><a href="#多个对象" class="headerlink" title="多个对象"></a>多个对象</h3><p>如果SQL查询可能存在多行，则在接口中需要通过集合来接收，如List数据结构</p><p>在mapper定义查询方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    select * from tt_student where id in ($&#123;id&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByIds2&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select * from tt_student where id in ($&#123;id&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;StudentPO&gt; <span class="hljs-title">getByIds</span><span class="hljs-params">(String ids)</span></span>;<br><br>List&lt;Map&lt;String, Object&gt;&gt; getByIds2(String ids);<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>String ids = <span class="hljs-string">&quot;1, 2&quot;</span>;<br>log.info(<span class="hljs-string">&quot;多个实体对象接收返回值：&#123;&#125;&quot;</span>, studentMapper.getByIds(ids));<br>log.info(<span class="hljs-string">&quot;多个Map对象接收返回值：&#123;&#125;&quot;</span>, studentMapper.getByIds2(ids));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>21:58:05.240 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id <span class="hljs-keyword">in</span> (1, 2)<br>21:58:05.256 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds - ==&gt; Parameters: <br>21:58:05.269 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:58:05.270 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:58:05.272 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:58:05.272 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds - &lt;==      Total: 2<br>21:58:05.273 [main] INFO  space.yangtao.client.StudentMapperTest - 多个实体对象接收返回值：[StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null), StudentPO(id=2, name=zhangsan1, height=180.0, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=null)]<br>21:58:05.274 [main] DEBUG space.yangtao.mapper.StudentMapper - Cache Hit Ratio [space.yangtao.mapper.StudentMapper]: 0.0<br>21:58:05.274 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds2 - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id <span class="hljs-keyword">in</span> (1, 2)<br>21:58:05.274 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds2 - ==&gt; Parameters: <br>21:58:05.275 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds2 - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>21:58:05.276 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds2 - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>21:58:05.277 [main] TRACE space.yangtao.mapper.StudentMapper.getByIds2 - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>21:58:05.277 [main] DEBUG space.yangtao.mapper.StudentMapper.getByIds2 - &lt;==      Total: 2<br>21:58:05.277 [main] INFO  space.yangtao.client.StudentMapperTest - 多个Map对象接收返回值：[&#123;birthday=1990-01-01, gender=男, create_time=2022-07-01T22:10:22, class_id=1, name=zhangsan, id=1, height=176.1&#125;, &#123;birthday=1990-01-01, gender=男, create_time=2022-07-01T21:10:22, class_id=2, name=zhangsan1, id=2, height=180.0&#125;]<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，对于多行数据，Java的接口方法可以使用集合类数据结构接收，如List，List的泛型可为实体类或Map。</p><h3 id="Map-lt-Object-Map-lt-String-Object-gt-gt"><a href="#Map-lt-Object-Map-lt-String-Object-gt-gt" class="headerlink" title="Map&lt;Object, Map&lt;String, Object&gt;&gt;"></a>Map&lt;Object, Map&lt;String, Object&gt;&gt;</h3><p>在日常中可能会遇到需要将SQL查询的结果封装成Map&lt;Object, Map&lt;String, Object&gt;&gt;这种结构，其中Map的key为指定列的值，value为行。</p><p>例如将列id作为查询结果的key，行封装为Map作为value</p><p>mapper中定义方法</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getIdMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select * from tt_student where id in ($&#123;id&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法，此时需要使用<code>@MapKey</code>注解定义返回结果的key值取的列名称（此处为<code>id</code>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br>Map&lt;Integer, Map&lt;String, Object&gt;&gt; getIdMap(String ids);<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>String ids = <span class="hljs-string">&quot;1, 2&quot;</span>;<br>log.info(<span class="hljs-string">&quot;getIdMap：&#123;&#125;&quot;</span>, studentMapper.getIdMap(ids));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>22:02:38.523 [main] DEBUG space.yangtao.mapper.StudentMapper.getIdMap - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id <span class="hljs-keyword">in</span> (1, 2)<br>22:02:38.544 [main] DEBUG space.yangtao.mapper.StudentMapper.getIdMap - ==&gt; Parameters: <br>22:02:38.565 [main] TRACE space.yangtao.mapper.StudentMapper.getIdMap - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:02:38.566 [main] TRACE space.yangtao.mapper.StudentMapper.getIdMap - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:02:38.569 [main] TRACE space.yangtao.mapper.StudentMapper.getIdMap - &lt;==        Row: 2, 2, zhangsan1, 180.0, 男, 1990-01-01, 2022-07-01 21:10:22<br>22:02:38.569 [main] DEBUG space.yangtao.mapper.StudentMapper.getIdMap - &lt;==      Total: 2<br>22:02:38.571 [main] INFO  space.yangtao.client.StudentMapperTest - getIdMap：&#123;1=&#123;birthday=1990-01-01, gender=男, create_time=2022-07-01T22:10:22, class_id=1, name=zhangsan, id=1, height=176.1&#125;, 2=&#123;birthday=1990-01-01, gender=男, create_time=2022-07-01T21:10:22, class_id=2, name=zhangsan1, id=2, height=180.0&#125;&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，<code>@MapKey</code>注解可以将查询的结果封装成Map&lt;Object, Map&lt;String, Object&gt;&gt;结构对象。</p><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>前面提到过，如果数据库中的列名与实体对象中的字段名对应不上，可以在Mapper文件中为SQL字段取别名。除此之外，还可以通过<code>resultMap</code>进行结果映射</p><p>在Mapper中定义<code>resultMap</code>以及对应的查询方法，并在标签<code>resultMap</code>中将数据库字段<code>create_time</code>映射到了实体类的<code>createTime</code>属性</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentRm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 主键id配置，可以提高效率 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- result配置，column为数据库字段名，property为实体类属性名，两者如果一致则可以省略 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;height&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;height&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;create_time&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTime&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByResultMap&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentRm&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>定义对应的接口方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentPO <span class="hljs-title">getByResultMap</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;resultMap查询：&#123;&#125;&quot;</span>, studentMapper.getByResultMap(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>22:19:35.024 [main] DEBUG space.yangtao.mapper.StudentMapper.getByResultMap - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:19:35.046 [main] DEBUG space.yangtao.mapper.StudentMapper.getByResultMap - ==&gt; Parameters: 1(Long)<br>22:19:35.059 [main] TRACE space.yangtao.mapper.StudentMapper.getByResultMap - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:19:35.062 [main] TRACE space.yangtao.mapper.StudentMapper.getByResultMap - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:19:35.063 [main] DEBUG space.yangtao.mapper.StudentMapper.getByResultMap - &lt;==      Total: 1<br>22:19:35.064 [main] INFO  space.yangtao.client.StudentMapperTest - resultMap查询：StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，方法的返回结果createTime字段正确取值为SQL中create_time字段的值，resultMap已成功为两个字段进行映射。</p><h3 id="驼峰命名自动映射"><a href="#驼峰命名自动映射" class="headerlink" title="驼峰命名自动映射"></a>驼峰命名自动映射</h3><p>如果MyBatis开启了驼峰命名自动自动映射、且实体类属性符合驼峰命名规范、SQL字段符合单词小写、单词之间采用下划线分割，那么Java实体类中的属性能与SQL的字段进行映射。</p><p>全局配置文件<code>mybatis-config.xml</code>的<code>setting</code>标签中开启命名自动映射</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    &lt;.../&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Mapper中对应的SQL为</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;space.yangtao.domain.po.StudentPO&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span><br>    select * from tt_student where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>对应的接口方法为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">StudentPO <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>此时实体类属性createTime与SQL字段create_time符合驼峰命名自动映射条件</p><p>运行测试程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">SqlSession session = SqlSessionUtil.getSession();<br>StudentMapper studentMapper = session.getMapper(StudentMapper.class);<br>log.info(<span class="hljs-string">&quot;自动映射查询：&#123;&#125;&quot;</span>, studentMapper.getById(<span class="hljs-number">1L</span>));<br></code></pre></div></td></tr></table></figure><p>控制台输出日志如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">...<br>22:27:43.693 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt;  Preparing: select * from tt_student <span class="hljs-built_in">where</span> id = ?<br>22:27:43.710 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - ==&gt; Parameters: 1(Long)<br>22:27:43.722 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==    Columns: id, class_id, name, height, gender, birthday, create_time<br>22:27:43.723 [main] TRACE space.yangtao.mapper.StudentMapper.getById - &lt;==        Row: 1, 1, zhangsan, 176.1, 男, 1990-01-01, 2022-07-01 22:10:22<br>22:27:43.725 [main] DEBUG space.yangtao.mapper.StudentMapper.getById - &lt;==      Total: 1<br>22:27:43.726 [main] INFO  space.yangtao.client.StudentMapperTest - 自动映射查询：StudentPO(id=1, name=zhangsan, height=176.1, gender=男, birthday=Mon Jan 01 00:00:00 CST 1990, createTime=Fri Jul 01 22:10:22 CST 2022)<br>...<br></code></pre></div></td></tr></table></figure><p>由日志可知，驼峰命名自动映射已为实体属性createTime与数据库字段create_time进行了映射。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>MyBatis面向接口编程不仅提高了开发效率，也提升了代码的可维护性和可扩展性。通过将SQL操作封装在接口中，MyBatis使得SQL语句的管理变得更加集中和系统化，极大地降低了数据库操作的复杂性。本文详细说明了如何有效地利用MyBatis提供的这一功能，是理解和应用MyBatis核心功能的重要资源。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis简介</title>
    <link href="/2022/08/01/mybatis-base/"/>
    <url>/2022/08/01/mybatis-base/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文是MyBatis系列的第一篇文章，将详细介绍MyBatis的基本用法和配置，使开发者能够快速上手并有效地使用MyBatis进行数据库开发。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><p><code>MyBatis</code>是一个流行的持久层框架，它帮助开发者在Java程序中更方便地管理数据库操作。</p><p>具备特点：</p><ol><li><strong>数据映射</strong>：MyBatis主要提供了SQL映射功能，允许将数据库中的记录直接映射到Java对象上。这意味着可以将数据库表映射为Java类，表的行映射为类的实例，而表的列映射为类的属性。</li><li><strong>XML配置</strong>：MyBatis允许开发者通过<code>XML</code>配置文件详细定义SQL语句和映射规则，而不需要在Java代码中硬编码SQL。这样做的好处是可以更清晰地组织SQL语句，便于管理和优化。</li><li><strong>灵活性</strong>：与其他ORM框架相比，MyBatis提供了更多的灵活性。它不会完全取代手写的SQL，而是允许开发者在必要时直接使用原始SQL语句，这对于复杂的数据库操作特别有用。</li><li><strong>动态SQL</strong>：MyBatis支持动态SQL，允许在<code>XML</code>映射文件中根据不同的条件构建不同的SQL语句。这种灵活性使得开发者可以根据不同的业务需求动态地生成合适的SQL语句，而不是依赖于框架生成。</li><li><strong>插件和拦截器</strong>：MyBatis支持自定义插件，这些插件可以插入到MyBatis核心处理的任何点，例如SQL语句构建、查询执行等环节。这提供了很大的灵活性来扩展MyBatis的功能。</li><li><strong>会话管理</strong>：MyBatis 的<code>SqlSession</code>提供了执行命令、获取映射器和管理事务的方法。SqlSession是非线程安全的，通常是方法范围内使用，即在一个数据库会话中使用后关闭。</li></ol><h3 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h3><p><code>ORM</code>，<code>Object-Relational Mapping</code>，即<strong>对象关系映射</strong>，是一种程序设计技术，用于实现对象与数据库之间的映射，程序中的对象可以直接对应数据库中的表，对象的属性与表的列相对应，而对象的实例对应表中的一行。这使得开发者可以用更直观的面向对象的方式来操作数据库，而无需直接处理SQL语句。</p><p>MyBatis并不是一个全自动的ORM框架，更准确地说，MyBatis是一个半ORM框架，它不会像Hibernate那样自动生成SQL语句，而是提供SQL映射功能。相反，它需要开发者手动编写SQL语句，并通过MyBatis提供的映射机制将SQL查询结果映射到Java对象上。这种方式提供了更多的控制权和灵活性，允许开发者优化SQL语句，适应更复杂的查询需求。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><ol><li><p>数据库实例创建库表<code>mybatis_db.tt_vehicle</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">USE mybatis_db;<br>CREATE TABLE `tt_vehicle`<br>(<br>    `id`              int            NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,<br>    `product_name`    varchar(100)   NOT NULL COMMENT &#x27;产品&#x27;,<br>    `vin`             varchar(50)    NOT NULL COMMENT &#x27;VIN码&#x27;,<br>    `production_date` date           NOT NULL COMMENT &#x27;生产日期&#x27;,<br>    `guide_price`     decimal(10, 2) NOT NULL COMMENT &#x27;销售价格&#x27;,<br>    PRIMARY KEY (`id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;车辆信息表&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>创建Maven项目，引入MySQL连接以及Mybatis依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建Mybatis核心配置文件<code>mybatis-config.xml</code>，配置数据库实例的数据源</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建单个表的<code>Mapper</code>文件<code>VehicleMapper.xml</code>，并写入一条<code>insert</code>语句</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertTest&quot;</span>&gt;</span><br>        insert into tt_vehicle (product_name, vin, production_date, guide_price)<br>        values (&quot;Audi A6L&quot;, &quot;LVIN1&quot;, &quot;2024-06-22&quot;, &quot;400000.12&quot;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>将表Mapper文件<code>VehicleMapper.xml</code>注册到核心配置文件<code>mybatis-config.xml</code>中</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/VehicleMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>编写测试程序如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 创建SqlSessionFactoryBuilder对象</span><br>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        <span class="hljs-comment">// 获取mybatis配置文件的输入流</span><br>        InputStream is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-comment">// 通过配置文件的输入流构建SqlSessionFactory对象</span><br>        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);<br>        <span class="hljs-comment">// 从SqlSessionFactory中获取一个SqlSession对象</span><br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        <span class="hljs-comment">// 使用sqlSession调用mapper文件中的方法</span><br>        <span class="hljs-keyword">int</span> insertTest = sqlSession.insert(<span class="hljs-string">&quot;insertTest&quot;</span>);<br>        <span class="hljs-comment">// 提交事务</span><br>        sqlSession.commit();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>运行后，查看数据库</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mysql&gt; use mybatis_db;<br>Database changed<br>mysql&gt; select * from tt_vehicle;<br>+----+--------------+-------+-----------------+-------------+<br>| id | product_name | vin   | production_date | guide_price |<br>+----+--------------+-------+-----------------+-------------+<br>|  1 | Audi A6L     | LVIN1 | 2024-06-22      |   400000.12 |<br>+----+--------------+-------+-----------------+-------------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></div></td></tr></table></figure><p>根据数据库查询结果可知，测试程序的代码运行后，执行了Mapper文件中的insert SQL语句，往数据库中插入了一行数据。</p></li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><p>MyBatis的全局配置文件（通常命名为 <code>mybatis-config.xml</code>）是一个中心配置文件，通过它可以配置MyBatis运行时的行为和环境设置。下面简要介绍该配置文件中的各种标签及其作用：</p><h4 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h4><p>这是最顶层的标签，包含了所有的MyBatis配置信息。</p><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><p>此标签用于引入外部的配置文件，通常包含数据库连接信息等环境变量。可以通过<code>resource</code>或<code>url</code>属性指定外部文件的位置。</p><h4 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h4><p>定义了MyBatis的运行时行为，比如是否开启延迟加载、生成SQL语句的形式等。每个设置都有其默认值，但可以通过此标签进行自定义配置。</p><h4 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h4><p>定义别名，使配置文件中的类引用更简洁。可以为单个类指定别名，或指定一个包名自动为所有类生成别名。</p><h4 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h4><p>自定义类型处理器的配置。用于定义Java类型与数据库类型之间的映射关系，特别是当遇到MyBatis未提供默认处理器的类型时。</p><h4 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h4><p>用于创建结果对象的实例，允许自定义结果对象的创建过程，例如通过依赖注入。</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>配置插件，MyBatis允许使用插件来拦截和修改其核心执行流程的某些部分，如SQL执行、参数设置等。</p><h4 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h4><p>定义多个数据库环境，可支持不同的数据库配置。每个环境包括一个<code>transactionManager</code>和一个<code>dataSource</code>：</p><ul><li><strong>transactionManager</strong>：配置事务管理类型，通常是<code>JDBC</code>或<code>MANAGED</code>。</li><li><strong>dataSource</strong>：配置数据源，包括连接池的各种属性，如驱动器、URL、用户名和密码等。</li></ul><h4 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h4><p>支持基于数据库厂商标识来选择不同的SQL映射。这允许编写只有在特定数据库品牌和版本上才会被使用的SQL语句。</p><h4 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h4><p>指定Mapper映射文件的位置。可以通过单个文件的方式引用，也可以指定整个包名自动扫描所有的Mapper文件。</p><p>这些标签共同构成了MyBatis的全局配置，允许开发者精细地控制MyBatis的行为和数据库的交互方式。正确配置这些标签对于确保应用程序的正确运行和性能优化至关重要。</p><h3 id="Mapper配置文件"><a href="#Mapper配置文件" class="headerlink" title="Mapper配置文件"></a>Mapper配置文件</h3><p>MyBatis的XML Mapper文件是用于定义SQL映射规则的关键配置文件，允许开发者指定如何将SQL语句映射到Java接口方法。以下是XML Mapper文件中常见标签的简要说明：</p><h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><p>这是XML Mapper文件的根标签，所有的SQL映射定义都包含在这个标签内，通常会指定一个命名空间<code>namespace</code>。</p><ul><li><strong>namespace</strong>：命名空间，关联一个具体的Java接口</li></ul><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>该标签用于配置该Mapper对应的缓存策略。通过启用缓存，可以提高查询效率并减少数据库访问次数。</p><h4 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h4><p>允许当前Mapper引用另一个Mapper定义的缓存配置，实现缓存配置的复用。</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>定义插入数据的SQL语句。可包含动态SQL元素，如标签<code>&lt;if&gt;</code>。通常还可以通过<code>useGeneratedKeys</code>和<code>keyProperty</code>属性获取数据库生成的主键。</p><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>定义更新操作的SQL语句。同样支持动态SQL元素，以适应不同的更新条件和要求。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>定义删除操作的SQL语句。可以包含条件判断，允许基于复杂逻辑执行删除操作。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>定义查询操作的SQL语句。可以配置返回类型，支持返回单个对象或对象集合。通过<code>resultMap</code>或<code>resultType</code>指定如何映射查询结果。</p><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>定义如何将数据库的结果集映射到Java对象。这包括字段到属性的映射、复杂类型的处理（如集合和关联对象）等。<code>resultMap</code>是处理复杂查询结果的强大工具。</p><h4 id="association和collection"><a href="#association和collection" class="headerlink" title="association和collection"></a>association和collection</h4><p>这两个标签用于在<code>resultMap</code>中定义复杂的对象关系，如一对一和一对多关系。<code>association</code>用于一对一关系，而<code>collection</code>用于一对多关系。</p><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><p>定义可重用的SQL代码片段。可以在同一个Mapper文件中的其他SQL映射中通过<code>&lt;include&gt;</code>标签引用这些片段，减少SQL代码的重复。</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>用于在 SQL 语句中包含<code>&lt;sql&gt;</code>标签定义的SQL片段。通过<code>refid</code>属性指向要包含的片段。</p><h4 id="parameterMap（已废弃）"><a href="#parameterMap（已废弃）" class="headerlink" title="parameterMap（已废弃）"></a>parameterMap（已废弃）</h4><p>在早期版本的MyBatis中使用，用于定义参数映射。现已被推荐直接在SQL语句中使用<code>#&#123;&#125;</code>或<code>$&#123;&#125;</code>代替。</p><h2 id="三大对象及其作用域"><a href="#三大对象及其作用域" class="headerlink" title="三大对象及其作用域"></a>三大对象及其作用域</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p><code>SqlSessionFactoryBuilder</code>是用于构建<code>SqlSessionFactory</code>的一个构建器类。它的主要任务是在应用程序启动时解析MyBatis配置文件（如XML配置文件或注解），并基于这些配置信息创建<code>SqlSessionFactory</code>。<code>SqlSessionFactoryBuilder</code>实例的使用通常是一次性的，即一旦创建了<code>SqlSessionFactory</code>后，就没有再继续使用的需要，即创建后即可丢弃。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p><code>SqlSessionFactory</code>是MyBatis中的一个核心接口，它负责创建 <code>SqlSession</code> 实例，每个数据库会话或请求都通过<code>SqlSessionFactory</code>来获取<code>SqlSession</code>实例 。<code>SqlSessionFactory</code>一旦被创建，就应该在应用执行期间一直存在，这个对象是线程安全地，可以在应用程序中共享，通常以单例模式被管理。它确保所有的数据库操作都是通过有效的<code>SqlSession</code>实例进行的。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p><code>SqlSession</code>是MyBatis中用于执行实际数据库操作的接口。它提供了访问数据库所需的所有方法，包括执行SQL语句、管理事务等。一个 <code>SqlSession</code> 通常代表一个数据库会话，<code>SqlSession</code>的实例不是线程安全的，通常每个线程或请求都应该获取自己的<code>SqlSession</code>实例，不能在多个线程间共享，且用完之后需要关闭。</p><h3 id="作用域总结"><a href="#作用域总结" class="headerlink" title="作用域总结"></a>作用域总结</h3><p>通过以上对<code>SqlSessionFactoryBuilder</code>、<code>SqlSessionFactory</code>、<code>SqlSession</code>的了解，可以总结它们各自的作用域为：</p><ul><li><strong>SqlSessionFactoryBuilder</strong>：方法作用域（局部方法变量）</li><li><strong>SqlSessionFactory</strong>：应用作用域</li><li><strong>SqlSession</strong>：请求或方法作用域</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对MyBatis概念、配置文件以及三大对象做了一个简要介绍，通过本文，读者应该能够对MyBatis的概念有一个清晰的理解，后面文章将对MyBatis的各个模块进行更加深入的介绍。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="/2022/07/24/mysql-lock/"/>
    <url>/2022/07/24/mysql-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在数据库高并发应用中，对数据进行安全并行读写的关键技术之一便是锁。MySQL 在不同存储引擎与不同层面（全局、表、行、元数据等）都提供了多种锁机制来保障数据一致性与并发性能。其中，<code>InnoDB</code> 通过行级锁与多版本并发控制（<code>MVCC</code>）实现了高并发与事务隔离的平衡，而 <code>MyISAM</code> 则依赖简单的表级锁适用于读多写少场景。本文将从全局锁、表级锁、行级锁等多方面系统介绍 MySQL 的锁体系，探讨从锁的分类、适用场景到死锁处理、锁优化等关键话题，帮助开发者在设计与运维中能更好地掌控数据库的并发行为。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="全局锁（Global-Lock）"><a href="#全局锁（Global-Lock）" class="headerlink" title="全局锁（Global Lock）"></a>全局锁（Global Lock）</h3><h4 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h4><p>全局锁是作用于整个 MySQL 实例的锁，通常用于对所有数据库或整个实例进行操作时，防止数据发生变化。最典型的使用场景包括数据备份和主从复制的一致性维护。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>锁定范围大，覆盖整个实例所有的数据库和表。</li><li>使用时需要特别注意锁的释放，否则会导致数据库不可写，影响正常业务。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>数据备份</strong>：在进行物理备份或冷备份时，通过全局锁保证数据一致性。</li><li><strong>主从复制配置</strong>：在配置复制时，确保主库数据在复制过程中不会发生写入操作，便于建立稳定的复制关系。</li></ul><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">FLUSH TABLES WITH READ LOCK;<br></code></pre></div></td></tr></table></figure><p>该命令会锁住所有打开的表，期间所有写操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）都会被阻塞，直至锁释放。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>锁定范围广</strong>：全局锁会影响整个实例，因此在生产环境中使用时必须非常谨慎，避免长时间持锁导致业务不可写。</li><li><strong>释放锁</strong>：全局锁一般在当前连接断开或显式执行解锁操作时释放。开发者应确保在备份或配置工作完成后及时释放锁，否则可能影响系统性能。</li><li><strong>业务中断风险</strong>：由于全局锁会阻塞所有写请求，建议在业务低峰期或维护窗口内使用。</li></ul><h3 id="表级锁（Table-Lock）"><a href="#表级锁（Table-Lock）" class="headerlink" title="表级锁（Table Lock）"></a>表级锁（Table Lock）</h3><h4 id="定义与作用-1"><a href="#定义与作用-1" class="headerlink" title="定义与作用"></a>定义与作用</h4><p>表级锁是对整个数据表进行加锁，常见于 <code>MyISAM</code> 和 <code>Memory</code> 存储引擎，也可能出现在 <code>InnoDB</code> 的某些场景中。</p><p>表级锁可以明确分为两种模式：读锁、写锁。</p><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>批量操作</strong>：当需要对表进行一系列操作并保证数据在整个操作期间不被其他连接修改时，可以使用表级锁。</li><li><strong>MyISAM 存储引擎</strong>：由于 <code>MyISAM</code> 只支持表级锁，因此在该引擎下所有的并发控制都依赖于这种锁机制。</li></ul><h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><ol><li><p>使用 <code>LOCK TABLES</code> 语句进行锁定，注意需要指明锁的种类</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 对指定表加读锁，允许其他会话读取，但禁止写入。<br>LOCK TABLES table_name READ;<br><br># 对指定表加写锁，其他会话既不能读取也不能写入。<br>LOCK TABLES table_name WRITE;<br></code></pre></div></td></tr></table></figure></li><li><p>使用完毕释放锁</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UNLOCK TABLES;<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>锁的粒度</strong>：由于表级锁锁定的是整张表，可能会导致不必要的阻塞，特别是在高并发场景下。使用时应权衡并发性与一致性要求。</li><li><strong>事务与锁无关</strong>：表级锁通常不在事务中自动释放（除非使用事务性引擎），开发者需要手动调用 <code>UNLOCK TABLES</code> 进行释放。</li><li><strong>避免死锁</strong>：如果多个连接需要锁定多个表，必须严格按照相同的顺序加锁，以避免死锁风险。</li></ul><h3 id="元数据锁（Metadata-Lock-MDL）"><a href="#元数据锁（Metadata-Lock-MDL）" class="headerlink" title="元数据锁（Metadata Lock, MDL）"></a>元数据锁（Metadata Lock, MDL）</h3><h4 id="定义与作用-2"><a href="#定义与作用-2" class="headerlink" title="定义与作用"></a>定义与作用</h4><p>元数据锁并非由用户直接控制，而是由 MySQL 内部在执行 <code>DDL</code>（如 <code>ALTER</code>、<code>DROP</code>、<code>RENAME</code> 等）时自动加上的锁。其主要目的是保护表的结构和定义，防止在执行 <code>DDL</code> 操作时，<code>DML</code> 操作对表结构造成冲突或不一致。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><code>MDL</code> 是在每次访问表时都会隐式加上的锁，既存在于读操作，也存在于写操作中。</li><li>与显式的表级锁不同，<code>MDL</code> 的管理更透明，通常不需要开发人员手动干预。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在高并发环境下执行 <code>DDL</code> 可能产生长时间阻塞，或使读写操作被阻塞，就是 <code>MDL</code> 的影响，所以在业务繁忙时期一律禁止执行 <code>DDL</code> 操作。</p><h3 id="行级锁（Row-Lock）"><a href="#行级锁（Row-Lock）" class="headerlink" title="行级锁（Row Lock）"></a>行级锁（Row Lock）</h3><p>行级锁主要由 <code>InnoDB</code> 存储引擎实现，其粒度较细，能够提高并发处理能力。行级锁可以进一步细分为多种类型，根据不同的场景选择合适的锁定方式。</p><h4 id="共享锁（Shared-Lock）"><a href="#共享锁（Shared-Lock）" class="headerlink" title="共享锁（Shared Lock）"></a>共享锁（Shared Lock）</h4><p><strong>定义与作用</strong></p><ul><li>允许其他事务同时加共享锁读取相同的数据行，但不允许其他事务对这些数据行加排他锁进行修改。</li><li>保证在当前事务期间，数据不会被其他事务修改，从而保持读取数据的一致性。</li></ul><p><strong>适用场景</strong></p><ul><li><p>当需要读取数据并确保在当前事务内数据不被更新时使用共享锁。</p></li><li><p>适用于需要多事务并发读取但不希望数据发生变动的场景，例如统计、报表等只读操作。</p></li></ul><p><strong>使用示例</strong></p><p>使用 <code>LOCK IN SHARE MODE</code> 表示对查询结果集中的每一行加共享锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>SELECT * FROM your_table WHERE condition LOCK IN SHARE MODE;<br>-- 后续可以进行其他操作<br>COMMIT;<br></code></pre></div></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>锁持有时间</strong>：共享锁会一直持有到事务结束（提交或回滚），因此应尽快完成相关操作，避免长时间持锁导致并发性能下降。</li><li><strong>并发影响</strong>：多个事务可以同时获取共享锁，但如果有事务试图对相同数据加排他锁，则会被阻塞，直到所有共享锁释放。</li><li><strong>与事务隔离级别的关系</strong>：在 <code>REPEATABLE READ</code> 或 <code>SERIALIZABLE</code> 隔离级别下，MySQL 可能会自动加锁来防止幻读，显式加共享锁时应注意与自动加锁行为的交互。</li><li><strong>使用索引</strong>：建议在查询条件中使用索引，以避免锁定过多无关数据行，减少锁竞争和可能的性能问题。</li></ul><h4 id="排他锁（Exclusive-Lock）"><a href="#排他锁（Exclusive-Lock）" class="headerlink" title="排他锁（Exclusive Lock）"></a>排他锁（Exclusive Lock）</h4><p><strong>定义与作用</strong></p><ul><li>排他锁允许事务对数据进行修改，同时禁止其他事务对同一数据进行读取或修改。</li></ul><p><strong>适用场景</strong></p><ul><li><strong>数据修改操作</strong>：排他锁主要用于更新、删除或插入操作前，确保当前事务对数据拥有完全的控制权，防止其他事务并发修改相同数据，造成数据不一致。</li><li><strong>预防并发问题</strong>：在某些需要强制序列化操作的业务场景下，显式加排他锁可以避免因并发修改引起的竞争和死锁问题（前提是锁粒度和锁顺序设计合理）。</li></ul><p><strong>使用示例</strong></p><p>使用 <code>FOR UPDATE</code> 表示对查询结果中的每一行加排他锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>SELECT * FROM your_table WHERE condition FOR UPDATE;<br>-- 进行更新或其他修改操作<br>COMMIT;<br></code></pre></div></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>锁的范围与精确性</strong>：使用 <code>FOR UPDATE</code> 时，尽可能通过精确的查询条件或利用索引，避免锁定不必要的数据行，减少潜在的锁冲突和死锁风险。如果查询条件不够精准，可能会锁定超出预期范围的数据，从而影响其他事务的执行。</li><li><strong>锁持有时间</strong>：同共享锁一样，排他锁会一直持有到事务结束。因此，建议在获取锁后尽快完成修改操作，并及时提交或回滚事务，避免长时间持锁阻塞其他事务。</li><li><strong>死锁风险</strong>：排他锁的使用不当容易导致死锁。设计事务时应确保所有事务遵循相同的加锁顺序，减少交叉锁定的情况。在开发过程中，可通过 <code>SHOW ENGINE INNODB STATUS</code> 来监控和诊断死锁问题，并根据日志信息进行相应优化。</li><li><strong>与自动加锁机制的关系</strong>：在某些情况下，<code>InnoDB</code> 会自动为数据修改操作加排他锁。开发者在显式使用 <code>FOR UPDATE</code> 时，应了解数据库自动加锁的行为，避免重复锁定或逻辑混淆。</li></ul><h4 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h4><p><strong>定义</strong></p><ul><li>意向锁是 <code>InnoDB</code> 为了兼顾表级锁和行级锁之间的协调而引入的锁机制。</li><li>它并不直接锁定数据行，而是表示事务打算在这些行上加何种类型的锁。</li></ul><p><strong>作用</strong></p><ul><li>通过意向锁，<code>InnoDB</code> 可以在对表进行锁定时快速判断是否存在行级锁，从而避免不必要的锁冲突。</li><li>意向锁和表级锁兼容，帮助实现锁粒度的逐级检查。</li></ul><p><strong>分类</strong></p><ul><li><strong>意向共享锁（IS）：</strong> 表示事务准备在行级上加共享锁。</li><li><strong>意向排他锁（IX）：</strong> 表示事务准备在行级上加排他锁。</li></ul><h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p><strong>定义与作用</strong></p><ul><li>间隙锁锁定的是索引值之间的 “间隙” 区域，而不是具体的记录。</li><li>主要用于防止其他事务在已锁定的范围内插入新的数据，从而避免幻读现象。</li></ul><p><strong>使用场景</strong></p><ul><li>在 <code>REPEATABLE READ</code> 隔离级别下，<code>InnoDB</code> 会自动使用间隙锁来防止幻读。</li><li>常见于范围查询操作，例如 <code>SELECT ... FOR UPDATE WHERE id BETWEEN ...</code>。</li></ul><h4 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h4><p><strong>定义与作用</strong></p><ul><li>临键锁是行锁与间隙锁的组合，既锁定了索引记录本身，也锁定了该记录前面的间隙。</li><li>这种锁机制主要用于防止幻读，在范围查询中非常常见。</li></ul><p><strong>使用场景</strong></p><ul><li>当查询条件涉及索引的连续范围时，<code>InnoDB</code> 会采用临键锁来确保整个范围内的数据状态稳定。</li></ul><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><strong>定义与作用</strong></p><ul><li>记录锁是对数据行本身的锁定，不包括记录间的间隙。</li><li>在某些场景下（如精确索引查找），<code>InnoDB</code> 只对命中的行加记录锁，而不必对间隙加锁，从而提高并发性能。</li></ul><p><strong>使用场景</strong></p><ul><li>对于基于主键或唯一索引的精确查找，<code>InnoDB</code> 通常只加记录锁，而避免额外的间隙锁。</li></ul><h4 id="自增锁（AUTO-INC-Lock）"><a href="#自增锁（AUTO-INC-Lock）" class="headerlink" title="自增锁（AUTO-INC Lock）"></a>自增锁（AUTO-INC Lock）</h4><p><strong>定义与作用</strong></p><ul><li>自增锁是 <code>InnoDB</code> 针对 <code>AUTO_INCREMENT</code> 列设计的特殊锁。</li><li>它保证在并发插入数据时，生成的自增值不会冲突，并且保持有序性。</li></ul><p><strong>使用场景</strong></p><ul><li>当一个表中存在 <code>AUTO_INCREMENT</code> 字段时，在执行插入操作时，<code>InnoDB</code> 会临时获取一个轻量级的自增锁，确保当前事务生成的自增值不会被其他事务干扰。</li></ul><h2 id="存储引擎与锁"><a href="#存储引擎与锁" class="headerlink" title="存储引擎与锁"></a>存储引擎与锁</h2><p>MySQL 支持多种存储引擎，不同引擎的锁机制有较大差异，主要体现在锁粒度、锁类型和并发控制方式上。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><p><code>InnoDB</code> 是 MySQL 默认的事务型存储引擎，支持 <code>ACID</code> 事务，采用行级锁和多版本并发控制（<code>MVCC</code>）来提高并发性能和数据一致性。</p><h4 id="锁粒度与锁类型"><a href="#锁粒度与锁类型" class="headerlink" title="锁粒度与锁类型"></a>锁粒度与锁类型</h4><ul><li><p><strong>行级锁</strong>：</p><ul><li><strong>共享锁（S Lock） 和 排他锁（X Lock）</strong>：用于控制单行数据的读取和修改。</li><li><strong>记录锁</strong>：锁定实际存在的数据行。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定索引记录之间的间隙，防止幻读。</li><li><strong>临键锁（Next-Key Lock）</strong>：行锁与间隙锁的组合，既锁定记录也锁定其前的间隙。</li></ul></li><li><p><strong>意向锁（Intention Lock）</strong>：</p><p>用于表级的标记，表明事务打算在行级上加共享锁或排他锁，便于存储引擎在处理表级操作时迅速判断行锁情况。</p></li><li><p><strong>自增锁</strong>：</p><p>针对 <code>AUTO_INCREMENT</code> 列设计的轻量级锁，保证并发插入时生成的自增值顺序性和唯一性。</p></li></ul><h4 id="并发控制机制"><a href="#并发控制机制" class="headerlink" title="并发控制机制"></a>并发控制机制</h4><ul><li>采用 <code>MVCC</code>，允许非锁定读取，通过保存数据的历史版本（<code>Undo Log</code>）来实现一致性读。</li><li>依靠锁与版本控制共同维护事务隔离，同时在高并发场景下降低锁竞争。</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><p><code>MyISAM</code> 为非事务型存储引擎，主要特点是查询速度较快，但不支持事务和行级锁。</p><h4 id="锁粒度与锁类型-1"><a href="#锁粒度与锁类型-1" class="headerlink" title="锁粒度与锁类型"></a>锁粒度与锁类型</h4><ul><li><strong>表级锁</strong>：<ul><li>对整个表加锁，所有的读写操作都必须等待当前操作释放锁。</li><li>表级锁简单且开销小，但在并发写入场景下容易形成瓶颈。</li></ul></li></ul><h4 id="并发控制机制-1"><a href="#并发控制机制-1" class="headerlink" title="并发控制机制"></a>并发控制机制</h4><ul><li><code>MyISAM</code> 采用简单的表级锁机制来实现并发控制，在高并发写操作时容易导致阻塞或锁等待，因此适合读多写少的场景。</li></ul><h3 id="Memory（HEAP）"><a href="#Memory（HEAP）" class="headerlink" title="Memory（HEAP）"></a>Memory（HEAP）</h3><h4 id="主要特点-2"><a href="#主要特点-2" class="headerlink" title="主要特点"></a>主要特点</h4><p><code>Memory</code> 存储引擎的数据全部保存在内存中，访问速度极快，但数据在服务器重启后会丢失。</p><h4 id="锁粒度与锁类型-2"><a href="#锁粒度与锁类型-2" class="headerlink" title="锁粒度与锁类型"></a>锁粒度与锁类型</h4><ul><li><strong>表级锁</strong>：<ul><li>和 <code>MyISAM</code> 类似，<code>Memory</code> 引擎也采用表级锁机制，因此在并发操作时同样可能出现锁竞争问题。</li></ul></li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>主要适用于临时表、缓存或对数据一致性要求不高但需要极快响应的场景。</li></ul><h3 id="NDB-Cluster"><a href="#NDB-Cluster" class="headerlink" title="NDB Cluster"></a>NDB Cluster</h3><h4 id="主要特点-3"><a href="#主要特点-3" class="headerlink" title="主要特点"></a>主要特点</h4><p><code>NDB Cluster</code> 是 MySQL 的分布式存储引擎，适用于高可用和大规模数据的分布式环境。</p><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><ul><li><code>NDB Cluster</code> 实现了一套分布式锁机制，在数据节点上采用行级锁来保证数据一致性。</li><li>由于数据分布在多个节点上，锁的协调涉及网络通信和全局一致性协议，因此在高并发和分布式环境中会有特殊的延迟和同步考虑。</li></ul><h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p><code>Archive</code>、<code>CSV</code> 等引擎：这些引擎通常不支持事务，锁机制较简单，或者依赖于操作系统层面的文件锁，不适合高并发场景。</p><h2 id="事务与锁"><a href="#事务与锁" class="headerlink" title="事务与锁"></a>事务与锁</h2><h3 id="隐式加锁"><a href="#隐式加锁" class="headerlink" title="隐式加锁"></a>隐式加锁</h3><ul><li>在 <code>InnoDB</code> 中，<code>DML</code> 操作（如 <code>SELECT ... FOR UPDATE</code>、<code>UPDATE</code>、<code>DELETE</code> 等）会根据操作类型和事务隔离级别自动加锁，通常加行级锁（共享锁或排他锁），以确保数据在事务期间的一致性。</li><li>在 <code>REPEATABLE READ</code> 隔离级别下，<code>InnoDB</code> 会对符合条件的数据行加上临键锁（<code>next-key lock</code>），既锁定了数据记录也锁定了相邻间隙，从而防止幻读现象。</li></ul><h3 id="锁的持有与事务边界"><a href="#锁的持有与事务边界" class="headerlink" title="锁的持有与事务边界"></a>锁的持有与事务边界</h3><ul><li>在事务内加的锁会一直保持到事务提交或回滚时释放。因此，长事务可能导致锁长时间持有，从而影响其他事务的并发性能。</li><li><strong>自动释放</strong>：事务结束后，<code>InnoDB</code> 会自动释放事务持有的所有行锁、意向锁和自增锁，而全局锁和显式的表锁（如 <code>LOCK TABLES</code>）则需要开发者主动释放。</li></ul><h3 id="隔离级别对锁行为的影响"><a href="#隔离级别对锁行为的影响" class="headerlink" title="隔离级别对锁行为的影响"></a>隔离级别对锁行为的影响</h3><ul><li><strong>READ UNCOMMITTED</strong>：不加锁读取，但容易产生脏读，不常用于生产。</li><li><strong>READ COMMITTED</strong>：不加锁读取，因此可能出现不可重复读。</li><li><strong>REPEATABLE READ</strong>：默认隔离级别，保证同一事务内多次读取同一数据时结果一致，为此会加临键锁和间隙锁，防止幻读，但也容易引发死锁。</li><li><strong>SERIALIZABLE</strong>：最严格的隔离级别，所有读取操作都被当作 <code>SELECT ... FOR UPDATE</code> 执行，会加全表锁或行级锁，性能开销较大。</li></ul><h3 id="事务并发与锁竞争"><a href="#事务并发与锁竞争" class="headerlink" title="事务并发与锁竞争"></a>事务并发与锁竞争</h3><ul><li>在多事务并发执行过程中，不同事务对相同数据记录加锁会产生竞争。如果锁粒度较小（如行级锁），并发性能更高，但也更容易出现死锁；如果使用表级锁，则锁范围大，简单但可能造成大量阻塞。</li><li>开发者需要设计好事务的执行顺序和 SQL 语句的查询条件，确保锁尽可能精细，从而减少锁冲突和死锁的风险。</li></ul><h3 id="MVCC-与锁的协同"><a href="#MVCC-与锁的协同" class="headerlink" title="MVCC 与锁的协同"></a>MVCC 与锁的协同</h3><ul><li><code>InnoDB</code> 的多版本并发控制（<code>MVCC</code>）允许在避免加锁读取，通过读取历史版本实现一致性视图，从而在大部分查询中不需要等待锁释放。</li><li>但在执行涉及数据修改或显式锁定的操作时，仍需依赖行锁、意向锁等机制来确保数据的并发安全。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li><strong>锁竞争与加锁顺序不一致</strong>：当两个或多个事务以不同的顺序获取锁时，可能出现循环等待的情况。例如，事务 <code>A</code> 锁定了数据行 <code>1</code> 后请求数据行 <code>2</code>，而事务 <code>B</code> 锁定了数据行 <code>2</code> 后请求数据行 <code>1</code>，就会形成循环等待。</li><li><strong>锁类型与范围</strong>：使用行级锁时，如果查询条件不够精确，可能导致锁定更多的数据行（例如使用了间隙锁或临键锁），从而增加死锁概率。</li><li><strong>长事务或锁持有时间过长</strong>：如果事务执行时间过长，锁长期占用也容易与其他事务产生冲突。</li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><h4 id="SHOW-ENGINE-INNODB-STATUS"><a href="#SHOW-ENGINE-INNODB-STATUS" class="headerlink" title="SHOW ENGINE INNODB STATUS"></a>SHOW ENGINE INNODB STATUS</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW ENGINE INNODB STATUS\G<br></code></pre></div></td></tr></table></figure><ul><li><strong>用途</strong>：返回 <code>InnoDB</code> 引擎的详细状态信息，其中包含了最近一次死锁的详细信息，如参与死锁的事务、锁等待情况、锁资源等。</li><li><strong>使用场景</strong>：当应用中出现异常或事务超时时，可以用此命令查看死锁日志，帮助定位问题所在。</li></ul><h4 id="INFORMATION-SCHEMA"><a href="#INFORMATION-SCHEMA" class="headerlink" title="INFORMATION_SCHEMA"></a>INFORMATION_SCHEMA</h4><p>MySQL 提供了一些 <code>INFORMATION_SCHEMA</code> 中的表来监控锁的状态：</p><ul><li><strong>INNODB_LOCKS</strong>：显示当前被持有的锁信息。</li><li><strong>INNODB_LOCK_WAITS</strong>：显示锁等待情况，指出哪些事务正在等待其他事务释放锁。</li><li><strong>INNODB_TRX</strong>：显示当前正在执行的事务信息。</li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;<br>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;<br>SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;<br></code></pre></div></td></tr></table></figure><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li><code>InnoDB</code> 内置死锁检测机制，当检测到死锁时，会自动选择一个事务作为牺牲者回滚，以打破循环等待。</li><li>应用程序在捕获到死锁错误（错误码 <code>1213</code>，通常提示 <code>Deadlock found when trying to get lock; try restarting transaction</code>）后，应实现重试逻辑，即回滚当前事务后重新执行。</li></ul><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ul><li><p><strong>统一加锁顺序</strong>：确保在多个事务中访问相同的资源时，以相同的顺序加锁，降低循环等待的概率。</p></li><li><p><strong>尽量减少锁持有时间</strong>：尽快完成事务操作，避免在事务中执行不必要的操作或等待用户交互，从而缩短锁的持有时间。</p></li><li><p><strong>优化 SQL 语句和索引</strong>：使用精确的 <code>WHERE</code> 条件和适当的索引，减少扫描和锁定的行数，降低锁冲突。</p></li><li><p><strong>减少范围锁（如间隙锁）的影响</strong>：在设计查询时注意尽可能精确地定位数据，避免因范围过大而锁定不必要的记录或间隙。</p></li><li><p><strong>调整锁等待超时参数</strong>：可以通过设置系统变量 <code>innodb_lock_wait_timeout</code> 来控制事务等待锁的最长时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET innodb_lock_wait_timeout = 50;<br></code></pre></div></td></tr></table></figure><p>虽然这不能完全避免死锁，但可以让死锁发生时及时释放等待，避免长时间阻塞。</p></li><li><p><strong>使用最新版本的 MySQL 特性</strong>：部分新版本 MySQL 支持诸如 <code>NOWAIT</code> 和 <code>SKIP LOCKED</code> 等语法（主要在 PostgreSQL 中较为常见），MySQL 在未来版本中也可能会进一步优化并发控制和锁机制。</p></li></ul><h2 id="索引失效导致锁表"><a href="#索引失效导致锁表" class="headerlink" title="索引失效导致锁表"></a>索引失效导致锁表</h2><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>在 <code>InnoDB</code> 中，行锁是基于索引实现的，而如果查询条件无法正确利用索引，则会导致 <code>InnoDB</code> 进行全表扫描，从而锁住所有符合查询条件的行，这可能会导致：</p><ul><li>所有符合查询条件的行都被加锁</li><li>新插入或更新的行可能受影响</li><li>多个事务因等待锁释放而阻塞，类似表锁的效果</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>在 <code>users</code> 表中 <code>phone_number</code> 字段是没有索引的，因此以下 SQL 会导致 <code>InnoDB</code> 执行全表扫描，从而对所有扫描到的行加锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">BEGIN;<br>SELECT * FROM users WHERE phone_number = &#x27;123456789&#x27; FOR UPDATE;<br></code></pre></div></td></tr></table></figure><ul><li><code>phone_number</code> 没有索引，MySQL 只能执行全表扫描。</li><li><code>FOR UPDATE</code> 要求对所有符合条件的行加 排他锁，而由于是全表扫描，所有行都被锁住。</li><li>这会导致其他事务对 <code>users</code> 表的任何写入（<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>）都可能被阻塞，行锁表现得像一个表锁。</li></ul><h3 id="避免-1"><a href="#避免-1" class="headerlink" title="避免"></a>避免</h3><ul><li><p><strong>确保查询使用索引</strong>：必要时使用 <code>FORCE INDEX</code> 强制使用特定索引，让 <code>InnoDB</code> 仅对匹配的行加锁，而不会锁住整个表，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM users FORCE INDEX(idx_phone_number) WHERE phone_number = &#x27;123456789&#x27; FOR UPDATE;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>限制锁的范围</strong>：如果无法避免全表扫描，考虑减少锁定范围，如在 <code>FOR UPDATE</code> 后面加上 <code>LIMIT</code> 关键字只锁定特定行数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM users WHERE phone_number = &#x27;123456789&#x27; FOR UPDATE LIMIT 1;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>修改锁竞争策略</strong>：在 <code>FOR UPDATE</code> 后面使用 <code>NOWAIT</code> 立即返回、不等待锁释放，或使用 <code>SKIP LOCKED</code> 跳过已锁定的行，如</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM users WHERE phone_number = &#x27;123456789&#x27; FOR UPDATE NOWAIT;<br><br>SELECT * FROM users WHERE phone_number = &#x27;123456789&#x27; FOR UPDATE SKIP LOCKED;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL 锁机制为数据库在并发环境下提供了多层次的保护，从全局锁到表级锁、行级锁及元数据锁，兼顾了数据安全与性能需求。在应用中，开发者应只有深入了解各种锁类型的特性与兼容关系、合理掌控锁粒度、理解 MySQL 事务与锁的联系、再配合完善的监控及调优方案，才能充分发挥 MySQL 在并发处理方面的高效与安全性，为业务的持续增长打下稳固的数据库基础。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MySQL锁机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2022/07/18/mysql-transaction/"/>
    <url>/2022/07/18/mysql-transaction/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代应用中，数据一致性与安全性常常由数据库事务来保障——只有当一系列操作（插入、更新、删除等）被当作一个不可分割的逻辑单元时，我们才能确保系统在面对并发和故障时依然保持可靠。MySQL 中，特别是 <code>InnoDB</code> 存储引擎，通过 <code>Undo/Redo</code> 日志、<code>MVCC</code>、间隙锁与下一键锁（<code>Next-Key Lock</code>）、以及两阶段提交等机制实现了高效而灵活的事务管理。本文将从事务的定义及四大特性出发，深入介绍 MySQL 事务的隔离级别与内部机制，并探讨在高并发场景下如何对事务进行调优，以保障数据库的正确性与性能。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>事务（<code>Transaction</code>）是数据库管理系统中一组被视为一个逻辑单元的操作序列，这些操作要么全部执行成功，要么在出现错误时全部撤销，确保数据库状态的一致性。事务主要用于确保数据库在面对并发访问和故障时能够保持数据的正确性和完整性。</p><ul><li><strong>逻辑单位</strong>：事务通常包含多个 SQL 语句，这些语句共同完成一个业务逻辑，例如转账操作需要同时扣款和存款，这两个操作必须同时成功才能保证数据正确。</li><li><strong>原子性</strong>：事务中的操作不可分割，要么全部执行成功，要么全部失败（即回滚）。</li><li><strong>应用场景</strong>：在银行、订单处理、库存管理等需要确保多步骤操作完整性的场景中，事务起到了关键作用。</li></ul><h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><p>事务的四大特性通常被称为 <code>ACID</code>，这四个字母分别代表：</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><ul><li><strong>定义</strong>：原子性指的是事务中的所有操作被视为一个原子操作单元。若其中某个操作失败，整个事务中的所有操作都必须回滚，使数据库返回到事务开始前的状态。</li><li><strong>实现机制</strong>：数据库通过日志（如 <code>Undo Log</code>）记录事务中每一步操作的反向操作，以便在事务失败时进行回滚。</li></ul><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><ul><li><strong>定义</strong>：一致性确保事务在执行前和执行后，数据库都处于一个合法的状态，即满足所有的完整性约束、业务规则和触发器规定。</li><li><strong>实现机制</strong>：数据库设计时定义的数据完整性约束（如主键、外键、唯一性约束等）以及业务逻辑能够保证一致性。当事务完成时，所有数据变更必须保持这些规则不被破坏。</li></ul><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><ul><li><strong>定义</strong>：隔离性指多个并发事务在执行过程中彼此独立，互不干扰。每个事务都应该感觉自己是数据库中唯一在运行的事务，不会受到其他并发事务的中间状态影响。</li><li><strong>具体问题</strong>：<ul><li><strong>脏读（Dirty Read）</strong>：一个事务读取了另一个未提交事务的数据。</li><li><strong>不可重复读（Non-Repeatable Read）</strong>：同一事务中，两次读取同一数据得到不同结果，因为其他事务修改并提交了该数据。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，两次查询返回的记录集不同，通常是由于其他事务插入或删除了满足查询条件的记录。</li></ul></li></ul><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><ul><li><strong>定义</strong>：持久性保证一旦事务提交，对数据库的修改将永久保存下来，即使系统发生崩溃也不会丢失。</li><li><strong>实现机制</strong>：通过日志（如 <code>Redo Log</code>）和物理存储设备（磁盘）的数据同步（如刷盘策略），确保提交后的数据能够被恢复。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>隔离级别决定了并发事务之间的相互影响程度。SQL 标准定义了四种隔离级别，MySQL（尤其是 <code>InnoDB</code> 存储引擎）也实现了这些隔离级别，同时做了一些细节优化。</p><h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><ul><li><strong>特点</strong>：最低的隔离级别，一个事务可以读取另一个事务未提交的数据。</li><li><strong>问题</strong>：会产生脏读问题，即读取到的数据可能最终回滚，导致不一致。</li><li><strong>适用场景</strong>：对数据一致性要求不高，但需要高性能和高并发场景。</li></ul><h3 id="READ-COMMITTED（读已提交）"><a href="#READ-COMMITTED（读已提交）" class="headerlink" title="READ COMMITTED（读已提交）"></a>READ COMMITTED（读已提交）</h3><ul><li><strong>特点</strong>：一个事务只能读取到其他事务已经提交的数据。每次查询时都会获取最新的已提交数据。</li><li><strong>问题</strong>：避免了脏读，但可能会出现不可重复读。例如，在同一事务中多次读取同一数据可能会看到不同的值。</li><li><strong>应用场景</strong>：大多数应用系统中使用较多，既保证了一定的数据正确性，又允许较高的并发性。</li></ul><h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><ul><li><strong>特点</strong>：保证在同一事务中多次读取同一数据时结果一致。<code>InnoDB</code> 存储引擎默认采用这种隔离级别。</li><li><strong>问题</strong>：在经典的定义中，可能会存在幻读问题。但 <code>InnoDB</code> 通过 <code>MVCC</code> 和 <code>Next-Key Locking</code>（间隙锁）机制有效防止幻读现象。</li><li><strong>应用场景</strong>：适合对数据读取一致性要求较高的场景，同时在一定程度上也允许高并发。</li></ul><h3 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h3><ul><li><strong>特点</strong>：最高的隔离级别，事务按照严格的顺序执行，仿佛它们是串行执行的一样。所有并发事务都被强制排序，完全避免了脏读、不可重复读和幻读。</li><li><strong>问题</strong>：这种隔离级别需要更多的锁机制，可能大幅降低并发性能，增加锁竞争和等待时间。</li><li><strong>应用场景</strong>：主要用于对数据一致性要求极高、并发量较低的场景，或者某些关键操作。</li></ul><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="START-TRANSACTION-开启事务"><a href="#START-TRANSACTION-开启事务" class="headerlink" title="START TRANSACTION - 开启事务"></a>START TRANSACTION - 开启事务</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>与 <code>BEGIN</code> 作用相同，用于标识事务的开始。</li><li>可与 <code>SET TRANSACTION</code> 结合使用，指定事务的隔离级别及读写属性（须在事务开始后立即设置）。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>事务一旦启动，后续的修改操作不会立即生效，只有提交（<code>COMMIT</code>）后才会永久保存，若出现错误可使用 <code>ROLLBACK</code> 进行回滚。</li><li>请确保使用的存储引擎（如 <code>InnoDB</code>）支持事务操作。</li><li>长事务可能占用资源和锁定数据，建议尽快提交或回滚。</li></ul><h3 id="COMMIT-提交事务"><a href="#COMMIT-提交事务" class="headerlink" title="COMMIT - 提交事务"></a>COMMIT - 提交事务</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>无额外参数，直接提交当前事务中所有已执行的修改操作。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>COMMIT</code> 会使当前事务中的所有修改永久生效，无法回退，在执行前请确保数据正确性。</li><li>对于长事务，建议及时提交以减少锁等待和资源占用。</li><li>某些存储引擎（如 <code>InnoDB</code>）支持事务，而其他（如 <code>MyISAM</code>）则不支持，使用前请确认存储引擎类型。</li></ul><h3 id="ROLLBACK-回滚事务"><a href="#ROLLBACK-回滚事务" class="headerlink" title="ROLLBACK - 回滚事务"></a>ROLLBACK - 回滚事务</h3><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ROLLBACK;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-2"><a href="#常见参数-2" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>无额外参数，用于撤销当前事务中自上次 <code>COMMIT</code> 或事务开始以来的所有修改。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>-- 发现错误或业务逻辑有问题，执行回滚<br>ROLLBACK;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>ROLLBACK</code> 只能撤销当前事务内尚未提交的操作，一旦 <code>COMMIT</code> 后，无法使用 <code>ROLLBACK</code> 恢复。</li><li>在使用事务时，应结合应用逻辑判断错误场景，及时执行 <code>ROLLBACK</code> 以保持数据一致性。</li><li>某些复杂操作（例如涉及外部系统的数据同步）可能无法简单回滚，需谨慎设计事务边界。</li></ul><h3 id="SAVEPOINT-设置事务保存点"><a href="#SAVEPOINT-设置事务保存点" class="headerlink" title="SAVEPOINT - 设置事务保存点"></a>SAVEPOINT - 设置事务保存点</h3><h4 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-3"><a href="#常见参数-3" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>savepoint_name</strong>：自定义的保存点名称，用于标识当前事务中一个中间状态。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>SAVEPOINT sp1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>-- 若后续操作出错，只回滚到保存点 sp1<br>ROLLBACK TO SAVEPOINT sp1;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SAVEPOINT</code> 允许在事务中设置多个回滚点，便于部分撤销操作而非整个事务回滚。</li><li>保存点只在当前事务有效，事务结束后自动失效。</li><li><code>SAVEPOINT</code> 操作会增加事务管理的复杂度，使用时应明确各保存点对应的业务逻辑阶段。</li></ul><h3 id="RELEASE-SAVEPOINT-删除指定的保存点"><a href="#RELEASE-SAVEPOINT-删除指定的保存点" class="headerlink" title="RELEASE SAVEPOINT - 删除指定的保存点"></a>RELEASE SAVEPOINT - 删除指定的保存点</h3><h4 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">RELEASE SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-4"><a href="#常见参数-4" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>savepoint_name</strong>：指定需要删除的保存点名称。</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE orders SET status = &#x27;processing&#x27; WHERE order_id = 123;<br>SAVEPOINT sp_order;<br>-- 执行部分操作后，确认不需要再回滚到该保存点时，释放它<br>RELEASE SAVEPOINT sp_order;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>RELEASE SAVEPOINT</code> 会删除指定保存点，释放与该保存点相关的资源，一旦释放，不能再回滚到该保存点。</li><li>删除保存点对事务后续操作没有影响，但应在确定不需要部分回滚后再执行。</li><li>释放保存点后，事务依然处于原来的状态，不会自动提交或回滚。</li></ul><h3 id="SET-TRANSACTION-设置事务隔离级别"><a href="#SET-TRANSACTION-设置事务隔离级别" class="headerlink" title="SET TRANSACTION - 设置事务隔离级别"></a>SET TRANSACTION - 设置事务隔离级别</h3><h4 id="语法格式-5"><a href="#语法格式-5" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION [transaction_option [, transaction_option] ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-5"><a href="#常见参数-5" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>transaction_option 主要包括</strong>：<ul><li><strong>ISOLATION LEVEL level</strong>：设置事务的隔离级别（如 <code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>、<code>SERIALIZABLE</code>）。</li><li><strong>READ WRITE 或 READ ONLY</strong>：指定事务是否允许写操作。</li></ul></li><li><code>SET TRANSACTION</code> 必须在事务开始之前（即在 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 之后立即执行，否则不会生效）。</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE;<br>START TRANSACTION;<br>-- 执行事务操作...<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SET TRANSACTION</code> 的设置仅影响当前事务，事务结束后恢复默认设置。</li><li>不同隔离级别对并发控制、锁策略及性能有较大影响，选择时应根据业务需求权衡一致性和性能。</li><li>一般建议在事务开始后立即设置事务属性，以确保整个事务按照预期运行，否则可能需要重启事务。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>回滚支持</strong>：<code>Undo Log</code> 用于记录数据修改前的 “旧值”，当事务需要回滚时，可以根据 <code>Undo Log</code> 将数据恢复到修改之前的状态。</li><li><strong>MVCC 实现</strong>：为了实现多版本并发控制（<code>MVCC</code>），<code>Undo Log</code> 存储了数据的历史版本。查询操作可以根据事务的快照信息，从 <code>Undo Log</code> 中找出符合当前可见性的记录版本，从而避免读到未提交的数据。</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>在执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作时，<code>InnoDB</code> 会将原始数据写入 <code>Undo Log</code>。</li><li>每条数据记录内都有隐藏的字段（如 <code>DB_TRX_ID</code> 与 <code>DB_ROLL_PTR</code>），利用这些字段可以链接到对应的 <code>Undo Log</code> 条目。</li></ul><h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>Undo Log</code> 占用额外的存储空间，长事务或频繁修改会导致 <code>Undo Log</code> 累积较多，因而需要定期的清理（<code>Purging</code>）以释放空间。</li><li>如果事务长时间未提交，可能会使旧版本数据长期存在，进而影响 <code>MVCC</code> 效率。</li></ul><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>持久性保障</strong>：<code>Redo Log</code> 用于保证事务的持久性。通过写前日志（<code>WAL</code>，<code>Write-Ahead Logging</code>）机制，在事务提交前，所有数据变更会先记录到 <code>Redo Log</code> 中，这样即使发生系统崩溃，也能利用 <code>Redo Log</code> 对数据进行恢复。</li><li><strong>性能优化</strong>：将变更先写入内存中的 <code>Redo Log</code> 缓冲区，然后异步刷盘，可以减少每次写操作的磁盘 I/O 开销。</li></ul><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当事务执行更新操作时，数据修改先写入内存中的 Redo Log 缓冲区，并按照一定策略（由参数如 <code>innodb_flush_log_at_trx_commit</code> 决定）将日志刷入磁盘。</li><li>系统崩溃时，通过 <code>Redo Log</code> 可以重放事务操作，确保已提交的事务修改不会丢失。</li></ul><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>Redo Log</code> 的刷盘策略对事务性能和数据安全有较大影响，合理设置参数（例如 <code>innodb_flush_log_at_trx_commit</code> 和 <code>sync_binlog</code>）非常重要。</li><li><code>Redo Log</code> 与 <code>Undo Log</code> 分工明确：前者侧重于故障恢复和持久性，后者则主要用于事务回滚和实现 MVCC。</li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>MVCC</code>（<code>Multi-Version Concurrency Control</code>，多版本并发控制）是一种并发控制技术，它通过为数据库中的每条记录维护多个版本，允许不同事务在同一时间访问数据而不产生冲突，从而实现非阻塞的读取操作。</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>读一致性</strong>：当事务启动时，系统为其创建一个数据快照，使得该事务在整个执行过程中看到的数据保持一致，即使其他事务对数据做了修改。</li><li><strong>提高并发性</strong>：读操作无需加锁（或只需轻量级锁定），降低了读写之间的冲突，提高了系统的吞吐量。</li></ul><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h5 id="隐藏列和事务标识"><a href="#隐藏列和事务标识" class="headerlink" title="隐藏列和事务标识"></a>隐藏列和事务标识</h5><p><code>InnoDB</code> 在每个数据行中维护了两个隐藏列（除了用户定义的列之外）：</p><ul><li><strong>DB_TRX_ID</strong>：记录最后一次修改该行的事务 ID。</li><li><strong>DB_ROLL_PTR</strong>：指向 <code>Undo Log</code> 中该行之前版本的指针，用于回滚或查找旧版本数据。</li></ul><p>这些隐藏列为 <code>MVCC</code> 提供了版本管理的基本依据。</p><h5 id="Undo-Log-作用"><a href="#Undo-Log-作用" class="headerlink" title="Undo Log 作用"></a>Undo Log 作用</h5><ul><li><p><strong>记录旧版本</strong></p><p>当一条记录被更新或删除时，<code>InnoDB</code> 不会立即覆盖或删除原数据，而是将原有版本写入 <code>Undo Log</code>。这样，正在执行的事务就可以根据自己的 “快照” 来访问数据的历史版本。</p></li><li><p><strong>实现读一致性</strong></p><p>每个事务启动时会记录当前活动事务的快照信息，当执行查询操作时，<code>InnoDB</code> 会根据记录的 <code>DB_TRX_ID</code> 与 <code>Undo Log</code> 中保存的历史版本判断哪一版本对当前事务可见。</p><ul><li><p>如果行记录的修改事务在当前事务开始后提交，则当前事务不会看到这些新修改，依然读取 <code>Undo Log</code> 中保存的版本。</p></li><li><p>反之，如果该修改事务在当前事务启动前就已经提交，则新数据对当前事务可见。</p></li></ul></li></ul><h5 id="事务-ID-与版本控制"><a href="#事务-ID-与版本控制" class="headerlink" title="事务 ID 与版本控制"></a>事务 ID 与版本控制</h5><ul><li><p><strong>事务标识</strong>：每个事务在启动时都会分配一个全局唯一的事务 ID。通过比较事务 ID 与行记录中的 <code>DB_TRX_ID</code>，以及判断这些事务是否已提交，<code>InnoDB</code> 能决定当前事务应看到哪个版本的数据。</p></li><li><p><strong>版本判断规则</strong>：当前事务在执行查询时，会利用其事务快照信息，判断每一行记录的修改是否在它的可见范围内，从而选择合适的版本返回给用户。这样就实现了即使在并发修改情况下，每个事务依然能看到一个逻辑上一致的数据库状态。</p></li></ul><h5 id="旧版本清理"><a href="#旧版本清理" class="headerlink" title="旧版本清理"></a>旧版本清理</h5><ul><li><p><strong>Undo Log 累积</strong>：随着大量更新和删除操作的发生，<code>Undo Log</code> 中会积累许多旧版本数据，这些数据如果长期保留会占用大量存储资源。</p></li><li><p><strong>Purging 机制</strong>：<code>InnoDB</code> 内部有一个专门的后台线程定期扫描并清理不再被任何活动事务需要的旧版本数据，回收空间并确保 <code>Undo Log</code> 不至于无限增长。</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>非阻塞读取</strong>：<code>MVCC</code> 使得读取操作不必等待写锁释放，即便数据正在被修改，也可以读取到一个一致的快照版本，显著提高并发性能。</li><li><strong>高效的并发控制</strong>：由于读操作不加锁，事务之间的并发冲突减少了，降低了锁竞争和死锁风险，适合高并发场景。</li></ul><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li><strong>Undo Log 管理</strong>：需要额外的存储空间来保存历史版本，且随着系统运行 <code>Undo Log</code> 需要定期清理，管理不当可能影响性能。</li><li><strong>数据版本累积</strong>：如果长事务持续占用快照，可能导致大量旧版本数据不能及时被清理，从而增加系统的负担。</li><li><strong>写入开销</strong>：每次更新或删除操作不仅需要写入新数据，还需要保存旧数据到 <code>Undo Log</code>，增加了写操作的成本。</li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>两阶段提交（<code>2PC</code>）是一种分布式事务协议，用于确保所有参与者（或多个数据页/日志）在提交时达成一致，保证事务的原子性和持久性。尽管 <code>InnoDB</code> 内部不是严格意义上的分布式事务，但在提交时也采用了类似 <code>2PC</code> 的流程，其内部 <code>Commit</code> 流程带有两阶段性质。</p><h4 id="阶段说明"><a href="#阶段说明" class="headerlink" title="阶段说明"></a>阶段说明</h4><h5 id="第一阶段（Prepare）"><a href="#第一阶段（Prepare）" class="headerlink" title="第一阶段（Prepare）"></a>第一阶段（Prepare）</h5><p>在这一阶段，所有参与者（例如各个数据页、日志缓冲区）会记录事务的修改并锁定必要资源，但不会正式提交。<code>InnoDB</code> 会先将 <code>Redo Log</code> 写入磁盘，并设置标记表示事务处于待提交状态。</p><h5 id="第二阶段（Commit）"><a href="#第二阶段（Commit）" class="headerlink" title="第二阶段（Commit）"></a>第二阶段（Commit）</h5><p>当所有资源确认无误后，系统会正式提交事务，将标记修改为 “已提交”，并释放锁资源。此时，事务的所有变更对外部客户端都可见。</p><h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>2PC</code> 可以确保在发生故障时不会出现部分提交的情况，但同时会增加事务提交的延时。</li><li>在 <code>InnoDB</code> 中，<code>2PC</code> 的实现主要依赖于 <code>Redo Log</code> 的先写入和事务提交标记的管理，合理调优日志参数有助于优化 <code>2PC</code> 的性能表现。</li></ul><h3 id="自增-ID-在事务中的处理"><a href="#自增-ID-在事务中的处理" class="headerlink" title="自增 ID 在事务中的处理"></a>自增 ID 在事务中的处理</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li><code>InnoDB</code> 使用自动增长机制为自增字段分配连续或半连续的数值。每当插入新记录时，<code>InnoDB</code> 会分配一个新的自增值。</li></ul><h4 id="事务内的特点"><a href="#事务内的特点" class="headerlink" title="事务内的特点"></a>事务内的特点</h4><ul><li><strong>预分配与消费</strong>：当执行插入操作时，即使后续事务回滚，分配的自增值也不会回退。这就导致了可能出现序列中 “空洞” 的情况。</li><li><strong>锁机制保护</strong>：为了避免并发插入时产生重复值，自增列操作在内部使用一种特殊的 “自增锁”，确保同一时刻只有一个事务能够分配新的自增值。</li></ul><h4 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>应用在设计时要注意自增 ID 并非严格连续，而是保证唯一性。</li><li>长事务或频繁回滚会导致自增 ID 的浪费，但不会影响数据的正确性。</li></ul><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><ul><li><strong>定义</strong>：间隙锁是锁住两个索引记录之间的空隙，而不锁定实际存在的记录。</li><li><strong>作用</strong>：防止其他事务在锁定的间隙内插入新记录，从而避免幻读现象。</li><li><strong>应用场景</strong>：通常在可重复读隔离级别下启用，用于保证同一查询在事务期间返回一致的结果集。</li></ul><h3 id="Next-Key-Lock（临键锁）"><a href="#Next-Key-Lock（临键锁）" class="headerlink" title="Next-Key Lock（临键锁）"></a>Next-Key Lock（临键锁）</h3><ul><li><strong>定义</strong>：<code>Next-Key Lock</code> 是一种组合锁，包括了对记录本身的锁定（记录锁）以及记录前空隙的锁定（间隙锁），主要应用于更新操作。</li><li><strong>作用</strong>：防止其他事务插入或修改可能影响当前事务查询结果的记录，从而完全杜绝幻读。</li><li><strong>工作方式</strong>：在查询或更新时，<code>InnoDB</code> 会自动对符合条件的记录及其前面的间隙加锁，确保在整个事务期间这些记录不会发生变化。</li><li><strong>注意事项</strong>：<ul><li><code>Next-Key Lock</code> 在提高数据一致性方面效果显著，但也可能引发较多的锁争用，特别是在高并发环境下。</li><li>对于某些特定场景，可以通过设置隔离级别或调整 SQL 语句来减轻锁竞争（例如合理使用索引、拆分查询范围等）。</li></ul></li></ul><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><code>Binlog</code> 是 MySQL 服务器层记录数据修改操作的一种逻辑日志。与存储引擎内部的物理日志（如 <code>Redo Log</code>）不同，<code>Binlog</code> 记录的是 SQL 操作或行级变化的事件，以二进制格式存储。它不仅用于故障恢复，还作为主从复制、数据审计和点时间恢复（<code>Point-in-Time Recovery</code>，<code>PITR</code>）的重要依据。</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><code>Binlog</code> 以文件形式存储在服务器上，随着数据修改不断追加。当日志文件达到一定大小后，会自动进行日志轮转。</p><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>数据复制（Replication）</strong>：在主从复制架构中，主服务器的 <code>Binlog</code> 记录所有数据修改事件，从服务器通过读取和重放 <code>Binlog</code> 事件来保持数据同步。这使得数据在分布式系统间的复制变得可靠且高效。</li><li><strong>故障恢复与数据恢复</strong>：配合定期备份，<code>Binlog</code> 可以用于点时间恢复。当系统发生故障或数据误操作时，备份数据加上后续的 <code>Binlog</code> 事件可以将数据库恢复到某个精确的时间点。</li><li><strong>数据审计</strong>：由于 <code>Binlog</code> 记录了所有变更操作，管理员可以通过解析 <code>Binlog</code> 了解数据库中发生的所有数据修改，便于问题追踪和审计。</li></ul><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><strong>记录事件</strong>：每当事务提交时，MySQL 服务器会将该事务所引发的修改操作转换为一个或多个事件，写入 <code>Binlog</code>。这些事件可能包括 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等操作，也可能包含 <code>DDL</code> 操作（注意：某些 <code>DDL</code> 操作会隐式提交事务）。</li><li><strong>日志刷新与同步</strong>：<code>Binlog</code> 的写入并不是实时刷盘的，其刷新策略由参数 <code>sync_binlog</code> 控制。<ul><li>如果 <code>sync_binlog=1</code>，每次提交都会同步刷新 <code>Binlog</code> 文件，这样可以最大程度保证数据一致性，但可能会牺牲性能。</li><li>较高的 <code>sync_binlog</code> 值可以减少磁盘 I/O 次数，但在系统崩溃时可能会丢失部分未同步的日志。</li></ul></li><li><strong>日志轮转</strong>：当当前 <code>Binlog</code> 文件达到预设大小后，MySQL 会生成新的 <code>Binlog</code> 文件。管理员可根据需要设置日志保留策略，防止日志文件占用过多磁盘空间。</li></ol><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>MySQL 提供了三种 <code>Binlog</code> 格式，以适应不同场景和需求：</p><ul><li><strong>STATEMENT 模式（基于语句的日志）</strong>：记录执行的 SQL 语句。<ul><li><strong>优点</strong>：日志体积较小。</li><li><strong>缺点</strong>：某些 SQL 语句可能在不同环境下执行结果不同，复制时可能存在不一致性问题。</li></ul></li><li><strong>ROW 模式（基于行的日志）</strong>：记录每一行数据的实际变化（前后状态）。<ul><li><strong>优点</strong>：能够精确复制数据修改，避免因语句执行差异导致的复制错误；在复杂的 SQL 操作（如多表操作）时更为安全。</li><li><strong>缺点</strong>：日志文件通常较大，可能对存储和网络带宽产生更大压力。</li></ul></li><li><strong>MIXED 模式（混合模式）</strong><ul><li>根据具体操作自动选择使用 <code>Statement</code> 或 <code>Row</code> 模式。</li><li>目的是在性能与复制安全性之间取得平衡，但也需要对应用场景和 SQL 语句特性有清晰了解，避免潜在的不一致性。</li></ul></li></ul><h3 id="与-Redo-Log-的区别"><a href="#与-Redo-Log-的区别" class="headerlink" title="与 Redo Log 的区别"></a>与 Redo Log 的区别</h3><ul><li><strong>Redo Log</strong><ul><li>属于存储引擎内部日志，是一种物理日志，记录数据页的变化，用于崩溃恢复和保证事务的持久性。</li><li>由 <code>InnoDB</code> 直接管理，刷新机制更关注 I/O 性能和数据一致性。</li></ul></li><li><strong>Binlog</strong><ul><li>是 <code>MySQL</code> 服务器层的逻辑日志，记录 SQL 级别的操作，主要用于复制和数据恢复。</li><li>相比 <code>Redo Log</code>，<code>Binlog</code> 更适合跨服务器的数据同步和审计，但写入和刷新策略则需要权衡性能与数据安全。</li></ul></li></ul><h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>日志同步策略</strong>：根据业务对数据一致性与性能的要求，合理设置 <code>sync_binlog</code> 参数。若对数据一致性要求较高，建议设置为 <code>1</code>；若对性能有更高要求，则可以适当调高该值，但需要接受一定的风险。</li><li><strong>日志格式选择</strong>：根据实际应用场景选择合适的日志格式。高并发、数据变更频繁的系统可能倾向于 <code>ROW</code> 模式以确保复制精度，但需注意日志量的增加；而对日志量敏感且操作确定性的场景，<code>STATEMENT</code> 模式也可满足需求。</li><li><strong>磁盘空间管理</strong>：由于 <code>Binlog</code> 会不断增长，需要配置日志轮转和清理策略，防止日志文件占满磁盘。可以通过 <code>expire_logs_days</code> 等参数自动清理过期日志。</li><li><strong>安全与审计</strong>：<code>Binlog</code> 中记录了所有数据变更，若泄露可能导致安全风险。应当合理设置访问权限，并对 <code>Binlog</code> 文件进行加密或保护。</li><li><strong>复制一致性</strong>：在主从复制环境下，确保 <code>Binlog</code> 的格式与相关参数在主从服务器间一致，避免因格式不匹配导致复制异常。</li></ul><h2 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h2><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><h4 id="定义与默认行为"><a href="#定义与默认行为" class="headerlink" title="定义与默认行为"></a>定义与默认行为</h4><ul><li><strong>自动提交模式</strong>：MySQL 默认处于自动提交模式，即 <code>autocommit=1</code>。在该模式下，每条单独的 SQL 语句都被视为一个完整的事务，执行后会立即自动提交，无需显式调用 <code>COMMIT</code>。</li><li><strong>优点</strong>：适合简单的操作，不需要手动管理事务边界，编程和使用相对简单。</li><li><strong>缺点</strong>：在需要将多条语句组合为一个原子操作时，自动提交模式不适用，因为每条语句都是独立提交的，无法保证整体原子性。</li></ul><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><ul><li><strong>频繁提交</strong>：每条语句执行完毕后都会立即提交，可能导致较高的 I/O 负担，尤其是在大量 <code>DML</code> 操作时。</li><li><strong>事务隔离控制</strong>：由于每个语句都是独立事务，可能无法满足某些需要跨语句的逻辑一致性要求。</li><li><strong>如何处理</strong>：如果需要组合多条语句为一个事务，可以通过设置 <code>SET autocommit=0</code> 或在事务中使用 <code>BEGIN/START TRANSACTION</code> 来关闭自动提交，然后在所有操作结束后调用 <code>COMMIT</code> 或在出错时调用 <code>ROLLBACK</code>。</li></ul><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><h3 id="定义与触发场景"><a href="#定义与触发场景" class="headerlink" title="定义与触发场景"></a>定义与触发场景</h3><p>隐式提交是指某些 SQL 语句在执行时，会自动提交当前正在进行的事务，即使没有显式调用 <code>COMMIT</code>。这种情况主要出现在以下场景：</p><ul><li><strong>DDL 语句</strong>：例如 <code>CREATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code> 等操作。在执行这些语句前，MySQL 会先隐式提交当前事务，再执行 <code>DDL</code> 操作。</li><li><strong>其他特殊语句</strong>：如 <code>TRUNCATE TABLE</code>、<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code> 等也会触发隐式提交。</li></ul><h4 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h4><ul><li><strong>事务边界不清晰</strong>：如果在一个事务中混合使用 <code>DML</code> 操作（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）和 <code>DDL</code> 操作，可能会在不经意间触发隐式提交，从而导致事务提前结束。这会使得之前未提交的修改被自动提交，无法再通过 <code>ROLLBACK</code> 撤销。</li><li><strong>不可控的提交</strong>：在一些复杂的业务逻辑中，开发者可能希望将多个操作放在一个事务中统一提交，但一旦执行了触发隐式提交的语句，整个事务会被强制提交，可能破坏原本预期的原子性和一致性。</li></ul><h2 id="调优策略"><a href="#调优策略" class="headerlink" title="调优策略"></a>调优策略</h2><h3 id="减少事务持有时间"><a href="#减少事务持有时间" class="headerlink" title="减少事务持有时间"></a>减少事务持有时间</h3><ul><li><p><strong>精简事务内的操作</strong></p><ul><li><p>将事务中必须的操作限定在一个较小的范围内，只包含那些在逻辑上必须原子提交的语句。</p></li><li><p>避免在事务内执行不必要的复杂计算或等待用户输入，使事务尽快完成。</p></li></ul></li><li><p><strong>尽早提交事务</strong></p><ul><li><p>尽快执行 <code>COMMIT</code>，防止事务长时间持有锁，降低因长事务带来的锁竞争。</p></li><li><p>对于批量处理或长时间任务，可考虑将大事务拆分为多个短事务，按业务逻辑分阶段提交。</p></li></ul></li><li><p><strong>合理设计事务边界</strong></p><ul><li><p>将只读操作与写操作分离。对于只读查询尽量利用 <code>MVCC</code> 快照机制，而不必在事务内加锁。</p></li><li><p>对于涉及多步操作的业务逻辑，确保事务范围仅限于必要操作，其他辅助操作在事务外执行。</p></li></ul></li><li><p><strong>使用异步处理</strong></p><ul><li>对于不要求实时一致性但数据量较大的操作，可以考虑使用消息队列、异步任务等方式将大事务拆分成小的、可独立处理的任务。</li></ul></li><li><p><strong>避免外部依赖阻塞</strong></p><ul><li>避免在事务中调用外部服务或执行耗时操作，防止因外部响应延迟而拖长事务时间。</li></ul></li><li><p><strong>关注事务间依赖</strong></p></li></ul><ul><li>在拆分事务时要注意数据之间的依赖关系，确保拆分后的事务不会破坏整体业务逻辑的数据一致性，必要时通过补偿机制或额外的校验保证正确性。</li></ul><h3 id="降低死锁概率"><a href="#降低死锁概率" class="headerlink" title="降低死锁概率"></a>降低死锁概率</h3><ul><li><strong>统一访问顺序</strong><ul><li>确保所有事务按照相同的顺序访问同一组资源（例如按主键或索引顺序更新记录），避免因资源竞争顺序不一致而产生死锁。</li></ul></li><li><strong>减少锁粒度和锁持有范围</strong><ul><li>尽可能缩小 SQL 的影响范围，利用精准的 <code>WHERE</code> 条件，减少锁定的记录数量。</li><li>合理使用索引，使得查询和更新操作能够定位到少量记录，从而降低锁定范围。</li></ul></li><li><strong>合理选择隔离级别</strong><ul><li>根据业务需求，选择合适的事务隔离级别。例如在允许一定程度脏读或不可重复读的场景下，可以选择 <code>READ COMMITTED</code> 而非 <code>REPEATABLE READ</code>，从而减少 <code>Next-Key Lock</code> 的范围。</li></ul></li><li><strong>短事务优先策略</strong><ul><li>如前所述，缩短事务的持有时间可以减少死锁发生的概率，因为长时间锁定数据的事务容易与其他并发事务产生冲突。</li></ul></li><li><strong>错误重试机制</strong><ul><li>在应用层面设计合理的错误处理和重试机制，一旦检测到死锁错误（错误代码 <code>1213</code>），可以捕获异常并重新执行事务逻辑，降低死锁对业务的影响。</li></ul></li></ul><h3 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h3><ul><li><p><strong>提高查询效率</strong></p><ul><li><p>索引可以大幅减少扫描的行数，使查询更快，同时也降低了需要加锁的记录数量，从而减少锁竞争和死锁发生。</p></li><li><p>设计合理的复合索引，覆盖查询条件和排序字段，避免全表扫描。</p></li></ul></li><li><p><strong>避免不必要的锁定</strong></p><ul><li><p>通过索引能精确定位目标记录，避免对大量不相关记录加锁。</p></li><li><p>在更新操作时，确保更新条件能充分利用索引，使得锁定范围只集中在目标记录，而非整个数据页或更大范围。</p></li></ul></li><li><p><strong>索引维护与优化</strong></p><ul><li><p>定期对索引使用情况进行监控，移除不必要的或冗余的索引，避免因为过多索引导致写操作变慢以及锁竞争加剧。</p></li><li><p>考虑在高并发环境下使用覆盖索引，减少回表查询，从而进一步降低锁竞争。</p></li></ul></li></ul><h3 id="Binlog-配置优化"><a href="#Binlog-配置优化" class="headerlink" title="Binlog 配置优化"></a>Binlog 配置优化</h3><ul><li><p><strong>sync_binlog 参数</strong>：</p><ul><li><p>设置 <code>sync_binlog=1</code> 可确保每次事务提交时 <code>Binlog</code> 都会同步写入磁盘，最大限度保证数据一致性，但会对性能产生一定影响。</p></li><li><p>如果业务对数据一致性的要求稍低，而追求更高的写入性能，可适当调高 <code>sync_binlog</code> 值，但需要接受在故障时可能丢失最近一部分事务的风险。</p></li></ul></li><li><p><strong>日志格式选择</strong>：</p><ul><li>根据应用场景选择合适的日志格式。<code>ROW</code> 模式记录详细变更信息，复制更精确；<code>STATEMENT</code> 模式日志体积小，性能更好，但可能存在某些场景下的复制问题。</li></ul></li><li><p><strong>日志轮转与保留策略</strong>：</p><ul><li>配置 <code>expire_logs_days</code> 或者手动清理过期 <code>Binlog</code> 文件，避免日志文件无限增长，影响磁盘空间和 I/O 性能。</li></ul></li></ul><h3 id="Redo-Log-配置优化"><a href="#Redo-Log-配置优化" class="headerlink" title="Redo Log 配置优化"></a>Redo Log 配置优化</h3><ul><li><p><strong>日志缓冲区大小</strong>：</p><ul><li>调整 <code>innodb_log_buffer_size</code> 参数，保证在高并发写入场景下能够容纳足够的日志数据，减少因日志缓冲不足而频繁刷盘的情况。</li></ul></li><li><p><strong>刷盘策略</strong>：</p><ul><li>参数 <code>innodb_flush_log_at_trx_commit</code> 控制事务提交时日志的刷盘行为。<ul><li>设置为 <code>1</code>：每次提交时都刷盘，数据安全性最高，但性能较低。</li><li>设置为 <code>2</code> 或 <code>0</code>：可以提高性能，但在系统崩溃时可能丢失部分最近提交的事务数据。</li></ul></li></ul></li><li><p><strong>Redo Log 文件大小和数量</strong>：</p><ul><li>调整 <code>redo log</code> 文件的大小（<code>innodb_log_file_size</code>）和数量，既要确保在高峰时日志能够充分缓冲，也要避免过大的日志文件导致恢复时间延长。</li></ul></li></ul><h2 id="运行事务查询"><a href="#运行事务查询" class="headerlink" title="运行事务查询"></a>运行事务查询</h2><h3 id="查看正在运行的事务"><a href="#查看正在运行的事务" class="headerlink" title="查看正在运行的事务"></a>查看正在运行的事务</h3><h4 id="Performance-Schema-和-Information-Schema"><a href="#Performance-Schema-和-Information-Schema" class="headerlink" title="Performance Schema 和 Information Schema"></a>Performance Schema 和 Information Schema</h4><ul><li><p><strong>information_schema.innodb_trx</strong></p><p>MySQL 从 5.7 版本开始提供了 <code>information_schema.innodb_trx</code> 表，它列出了当前所有活动的 <code>InnoDB</code> 事务。可以通过如下 SQL 语句查看详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM information_schema.innodb_trx\G<br></code></pre></div></td></tr></table></figure><p>其中包含事务的开始时间、状态、等待锁信息以及相关的事务 ID，这有助于判断哪些事务运行时间过长或可能导致锁竞争。</p></li><li><p><strong>相关表</strong>：还可以结合 <code>information_schema.innodb_locks</code> 和 <code>information_schema.innodb_lock_waits</code> 表，了解锁持有情况及等待关系，从而定位是否存在阻塞或死锁。</p></li></ul><h4 id="SHOW-ENGINE-INNODB-STATUS"><a href="#SHOW-ENGINE-INNODB-STATUS" class="headerlink" title="SHOW ENGINE INNODB STATUS"></a>SHOW ENGINE INNODB STATUS</h4><ul><li><p>执行以下命令可以获得当前 <code>InnoDB</code> 引擎的状态信息，其中包括当前正在运行的事务、锁情况、最近的死锁信息等：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW ENGINE INNODB STATUS\G<br></code></pre></div></td></tr></table></figure><p>输出中会显示 <code>TRANSACTIONS</code> 部分，列出当前活跃的事务、它们持有的锁以及等待的锁信息，对排查问题非常有帮助。</p></li></ul><h4 id="SHOW-FULL-PROCESSLIST"><a href="#SHOW-FULL-PROCESSLIST" class="headerlink" title="SHOW FULL PROCESSLIST"></a>SHOW FULL PROCESSLIST</h4><ul><li><p>通过命令可以查看当前所有连接和其执行的 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW FULL PROCESSLIST;<br></code></pre></div></td></tr></table></figure><p>这不仅能发现哪些连接正执行长时间事务，还可以看出是否有连接处于 <code>Sleep</code> 状态但长时间未释放事务（例如因未提交的事务）。</p></li></ul><h3 id="异常事务的处理方案"><a href="#异常事务的处理方案" class="headerlink" title="异常事务的处理方案"></a>异常事务的处理方案</h3><p>异常事务一般指运行时间过长、持有锁导致阻塞或已进入死锁状态的事务。处理方案包括以下几个方面：</p><h4 id="杀死异常事务"><a href="#杀死异常事务" class="headerlink" title="杀死异常事务"></a>杀死异常事务</h4><p><strong>手动终止</strong>：一旦确定某个事务因为长时间运行或死锁而影响系统，可以通过 <code>KILL</code> 命令终止相应连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">KILL &lt;connection_id&gt;;<br></code></pre></div></td></tr></table></figure><p>使用前可以先通过 <code>SHOW FULL PROCESSLIST</code> 或查询 <code>information_schema.innodb_trx</code> 得到对应的线程 ID。</p><p><strong>注意</strong>：杀掉事务会导致事务回滚，可能需要评估数据一致性影响。</p><h4 id="调整锁等待超时时间"><a href="#调整锁等待超时时间" class="headerlink" title="调整锁等待超时时间"></a>调整锁等待超时时间</h4><p>如果事务等待锁的时间过长，可以适当调整参数 <code>innodb_lock_wait_timeout</code>（单位为秒），以便在达到设定时间后自动回滚等待锁的事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET GLOBAL innodb_lock_wait_timeout = 50;<br></code></pre></div></td></tr></table></figure><p>这样可以防止长时间等待造成资源占用，但需要根据具体业务场景权衡超时设置，防止因短暂阻塞误杀正常事务。</p><h4 id="分析和解决死锁"><a href="#分析和解决死锁" class="headerlink" title="分析和解决死锁"></a>分析和解决死锁</h4><ul><li><strong>查看死锁日志</strong>：使用 <code>SHOW ENGINE INNODB STATUS\G</code> 可以查看最近的死锁信息。根据死锁日志可以分析哪些 SQL 语句、索引或事务访问顺序导致冲突。</li><li><strong>优化 SQL 和事务设计</strong>：<ul><li><strong>统一访问顺序</strong>：确保多个事务以相同的顺序访问资源，降低死锁发生的概率。</li><li><strong>缩短事务持有时间</strong>：尽量将事务范围控制在最小范围内，快速提交事务。</li><li><strong>合理使用索引</strong>：通过优化查询条件和索引设计，使得更新或删除操作能精确定位目标记录，减少锁定范围。</li></ul></li></ul><h4 id="自动化监控与报警"><a href="#自动化监控与报警" class="headerlink" title="自动化监控与报警"></a>自动化监控与报警</h4><p>部署监控工具（如 <code>Performance Schema</code> 监控、第三方监控系统或 MySQL 自带的日志分析工具）来实时监控事务状态和锁竞争情况。一旦发现异常事务或长事务自动报警，并根据预先设定的规则触发自动处理或通知管理员进行干预。</p><h4 id="应用层面优化"><a href="#应用层面优化" class="headerlink" title="应用层面优化"></a>应用层面优化</h4><ul><li>在应用逻辑中，对事务执行时间进行监控和记录，及时捕获异常情况。</li><li>对可能引起长事务的业务逻辑进行拆分或优化，确保事务不长时间持有锁，从而降低整体系统压力。</li></ul><h2 id="常见参数总结"><a href="#常见参数总结" class="headerlink" title="常见参数总结"></a>常见参数总结</h2><h3 id="自动提交与事务隔离相关参数"><a href="#自动提交与事务隔离相关参数" class="headerlink" title="自动提交与事务隔离相关参数"></a>自动提交与事务隔离相关参数</h3><h4 id="autocommit"><a href="#autocommit" class="headerlink" title="autocommit"></a>autocommit</h4><ul><li><strong>说明</strong>：控制 MySQL 是否在每条独立 SQL 语句后自动提交事务。</li><li><strong>配置值</strong>：<ul><li><code>autocommit=1</code>（默认）：每条语句自动提交。</li><li><code>autocommit=0</code>：关闭自动提交，需要显式使用 <code>BEGIN/COMMIT/ROLLBACK</code> 来管理事务。</li></ul></li><li><strong>影响及注意事项</strong>：<ul><li>在自动提交模式下，每条语句都是独立事务，适合简单操作，但无法保证多语句操作的原子性。</li><li>若需要将多个操作整合在一个事务中，须关闭自动提交（或使用显式事务），避免意外提交或隐式提交导致数据不一致。</li></ul></li></ul><h4 id="transaction-isolation（或-transaction-read-only）"><a href="#transaction-isolation（或-transaction-read-only）" class="headerlink" title="transaction_isolation（或 transaction_read_only）"></a>transaction_isolation（或 transaction_read_only）</h4><ul><li><p><strong>说明</strong>：指定事务的隔离级别，决定了并发事务之间数据读取的一致性。</p></li><li><p><strong>常见配置值</strong>：</p><ul><li><code>READ-UNCOMMITTED</code></li><li><code>READ-COMMITTED</code></li><li><code>REPEATABLE-READ</code>（默认 <code>InnoDB</code> 隔离级别）</li><li><code>SERIALIZABLE</code></li></ul></li><li><p><strong>影响及注意事项</strong>：</p><ul><li><p>隔离级别越高，数据一致性越好，但并发性能可能下降。</p></li><li><p>在高并发系统中，经常采用 <code>READ-COMMITTED</code> 或 <code>REPEATABLE-READ</code> 来平衡一致性与性能。</p></li><li><p>可在全局或会话级设置，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h3 id="日志同步与持久性相关参数"><a href="#日志同步与持久性相关参数" class="headerlink" title="日志同步与持久性相关参数"></a>日志同步与持久性相关参数</h3><h4 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h4><ul><li><strong>说明</strong>：控制 <code>InnoDB</code> 提交事务时 <code>Redo Log</code> 的写入和刷盘行为。</li><li><strong>配置值</strong>：<ul><li><code>1</code>（默认）：每次事务提交时将 <code>Redo Log</code> 写入日志文件并刷盘，确保数据持久性。</li><li><code>2</code>：事务提交时写入日志文件但不立即刷盘，由操作系统定时刷盘，性能较好但在崩溃时可能丢失最近事务。</li><li><code>0</code>：每秒钟刷一次日志，风险与 <code>2</code> 类似，适用于对性能要求较高且数据丢失风险可控的场景。</li></ul></li><li><strong>影响及注意事项</strong>：<ul><li>设置为 <code>1</code> 可以获得最高的数据安全性，但会增加 I/O 开销。</li><li>根据业务对数据一致性和性能的要求选择合适的值，需权衡数据丢失风险与性能。</li></ul></li></ul><h4 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h4><ul><li><strong>说明</strong>：控制二进制日志（<code>Binlog</code>）的同步刷新策略。</li><li><strong>配置值</strong>：<ul><li><code>sync_binlog=1</code>：每次事务提交后同步刷新 <code>Binlog</code> 到磁盘，保证数据复制和恢复的一致性。</li><li>大于 <code>1</code> 的值或 <code>0</code>：会降低同步频率，提高写入性能，但在系统崩溃时可能丢失部分 <code>Binlog</code> 数据。</li></ul></li><li><strong>影响及注意事项</strong>：<ul><li>对复制环境和点时间恢复要求严格时，建议设置为 <code>1</code>；</li><li>如果追求更高的写入性能，可以适当调高，但需要接受在故障时丢失部分最近提交数据的风险。</li></ul></li></ul><h4 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h4><ul><li><strong>说明</strong>：定义 <code>InnoDB</code> 日志缓冲区的大小，用于暂存事务产生的 <code>Redo Log</code> 数据。</li><li><strong>默认值</strong>：通常为 <code>16MB</code>（不同版本可能有所不同）</li><li><strong>影响及注意事项</strong>：<ul><li>较大的日志缓冲区能减少频繁刷盘的次数，适用于大事务或高并发写入。</li><li>若设置过大，会占用较多内存。</li><li>根据系统写入负载调整合适的大小。</li></ul></li></ul><h4 id="innodb-log-file-size"><a href="#innodb-log-file-size" class="headerlink" title="innodb_log_file_size"></a>innodb_log_file_size</h4><ul><li><strong>说明</strong>：控制单个 <code>InnoDB Redo Log</code> 文件的大小。</li><li><strong>默认值</strong>：版本不同可能在 <code>48MB ~ 256MB</code> 不等。</li><li><strong>影响及注意事项</strong>：<ul><li>较大的 <code>Redo Log</code> 文件可以降低日志切换频率，提升写入性能。</li><li>但同时在系统崩溃后恢复时间会变长。</li><li>调整时需综合考虑写入负载和恢复窗口的需求。</li></ul></li></ul><h3 id="锁等待与自增相关参数"><a href="#锁等待与自增相关参数" class="headerlink" title="锁等待与自增相关参数"></a>锁等待与自增相关参数</h3><h4 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h4><ul><li><strong>说明</strong>：设置 <code>InnoDB</code> 等待行锁（或其他锁）释放的超时时间（单位：秒）。</li><li><strong>默认值</strong>：一般为 <code>50</code> 秒</li><li><strong>影响及注意事项</strong>：<ul><li>过短的等待时间可能导致事务因暂时的锁竞争频繁回滚。</li><li>过长则可能使得事务等待时间过长，影响系统响应。</li><li>根据应用特点进行适当调整，防止长时间等待占用资源。</li></ul></li></ul><h4 id="innodb-autoinc-lock-mode"><a href="#innodb-autoinc-lock-mode" class="headerlink" title="innodb_autoinc_lock_mode"></a>innodb_autoinc_lock_mode</h4><ul><li><strong>说明</strong>：控制自增（<code>AUTO_INCREMENT</code>）字段在多线程并发插入时的锁策略。</li><li><strong>配置值</strong>：<ul><li><code>0</code>（传统模式）：对每个插入请求都加锁，保证严格连续，但并发性能较低。</li><li><code>1</code>（默认，连续模式）：在语句级别加锁，允许批量插入，性能和连续性之间平衡。</li><li><code>2</code>（交错模式）：允许多个并发插入无锁竞争，适用于高并发，但可能导致自增值不连续。</li></ul></li><li><strong>影响及注意事项</strong>：<ul><li>应根据实际业务对自增值连续性和并发性能的要求选择合适的模式。</li></ul></li></ul><h4 id="innodb-print-all-deadlocks"><a href="#innodb-print-all-deadlocks" class="headerlink" title="innodb_print_all_deadlocks"></a>innodb_print_all_deadlocks</h4><ul><li><strong>说明</strong>：控制是否将检测到的死锁信息输出到错误日志中。</li><li><strong>配置值</strong>：<code>ON</code> 或 <code>OFF</code>，默认通常为 <code>OFF</code>。</li><li><strong>影响及注意事项</strong>：<ul><li>开启后有助于开发和运维人员分析死锁原因，但可能会在高并发环境下产生较多日志输出。</li><li>可在调试阶段开启，生产环境根据需要选择是否保留。</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="binlog-format"><a href="#binlog-format" class="headerlink" title="binlog_format"></a>binlog_format</h4><ul><li><strong>说明</strong>：设置 <code>Binlog</code> 的记录格式，对复制和数据恢复影响较大。</li><li><strong>配置值</strong>：<ul><li><code>STATEMENT</code>：记录 SQL 语句；</li><li><code>ROW</code>：记录数据行的变化；</li><li><code>MIXED</code>：自动在 <code>STATEMENT</code> 和 <code>ROW</code> 间切换。</li></ul></li><li><strong>影响及注意事项</strong>：<ul><li><code>ROW</code> 模式数据一致性更高，但日志量大；<code>STATEMENT</code> 模式性能更好但在某些复杂操作时可能出现不一致；</li><li>复制环境下建议保持主从一致的配置。</li></ul></li></ul><h4 id="transaction-write-set-extraction"><a href="#transaction-write-set-extraction" class="headerlink" title="transaction_write_set_extraction"></a>transaction_write_set_extraction</h4><ul><li><strong>说明</strong>：用于并行复制场景中，提取写集（即事务修改的数据集合），以提高复制效率。</li><li><strong>配置值</strong>：例如 <code>XXHASH64</code>、<code>MURMUR32</code> 等。</li><li><strong>影响及注意事项</strong>：<ul><li>主要用于 <code>GTID</code> 和多线程复制的优化；</li><li>配置需与复制方案相适应，调整时注意与其他复制参数的匹配。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务是数据库保证数据一致性和完整性的重要手段，从 <code>ACID</code> 四大特性到 <code>InnoDB</code> 的多版本并发控制（<code>MVCC</code>），无一不体现了 MySQL 对高并发与安全的平衡追求。通过合适的隔离级别选择、精心的日志写入策略（<code>Redo/Undo/Binlog</code>）、间隙锁等锁机制的灵活运用，开发者既能避免常见的脏读、不可重复读、幻读等问题，又能在大多数场景下兼顾性能。在实际应用中，则需要持续关注控制事务范围、隔离级别、维护良好的索引与日志策略，再加上不断地监控、跟踪、诊断、处理异常。只有在理解事务原理与运行细节的基础上，才能在设计与运维中做出恰当决策，让数据库在严苛环境下依然保持高性能与高可靠。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MySQL事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL优化</title>
    <link href="/2022/07/11/mysql-sql-optimize/"/>
    <url>/2022/07/11/mysql-sql-optimize/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着业务复杂度和数据量的不断上升，数据库性能往往成为系统瓶颈之一。如何让常见查询在海量数据下依然保持高效？MySQL 提供了多种机制与工具帮助我们识别和调优低效的 SQL，包括慢查询日志、<code>SHOW PROFILE</code>、<code>Performance Schema</code> 以及 <code>EXPLAIN</code> 等。结合良好的索引设计和 SQL 写法，才能可以显著改善查询响应时间，合理利用硬件资源。本文将围绕 MySQL 中常见的性能分析方法与查询优化技巧展开，从日志配置到语法策略，从索引失效到查询执行计划，为数据库优化提供一份系统性的指导。</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>记录慢查询</strong>：MySQL可以通过慢查询日志记录执行时间超过设定阈值的 SQL 语句，帮助定位性能瓶颈。</li><li><strong>诊断工具</strong>：慢查询日志提供的详细信息（如执行时间、扫描行数等）可以发现未使用索引或设计不合理的查询，为后续调优提供依据。</li></ul><h3 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h3><ul><li><strong>slow_query_log</strong>：用于开启或关闭慢查询日志。设置为 <code>ON</code> 表示启用。</li><li><strong>slow_query_log_file</strong>：指定慢查询日志的存储文件路径。可以根据实际情况选择合适的位置，确保 MySQL 有写入权限。</li><li><strong>long_query_time</strong>：定义记录为慢查询的阈值（单位为秒）。例如设置为 <code>1</code> 表示记录执行时间超过 <code>1</code> 秒的查询。可以根据系统情况和业务要求调整这个值。</li><li><strong>log_queries_not_using_indexes</strong>：当设置为 <code>ON</code> 时，未使用索引的查询也会被记录，帮助发现没有走索引的查询语句，通常对于优化非常有帮助。</li><li><strong>log_output</strong>：指定日志的输出方式，可以设置为 <code>FILE</code>（默认）、<code>TABLE</code> 或者 <code>NONE</code>。如果设置为 <code>TABLE</code>，慢查询日志会写入系统表 <code>mysql.slow_log</code>，便于通过 SQL 语句查询和分析。</li></ul><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><h4 id="配置文件（my-cnf-或-my-ini）"><a href="#配置文件（my-cnf-或-my-ini）" class="headerlink" title="配置文件（my.cnf 或 my.ini）"></a>配置文件（my.cnf 或 my.ini）</h4><p>在 MySQL 的配置文件中添加或修改相关参数，示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-comment"># 开启慢查询日志</span><br><span class="hljs-attr">slow_query_log</span> = <span class="hljs-literal">ON</span><br><span class="hljs-comment"># 指定慢查询日志文件路径（根据实际环境调整路径）</span><br><span class="hljs-attr">slow_query_log_file</span> = /var/log/mysql/slow_query.log<br><span class="hljs-comment"># 设置慢查询的时间阈值（单位秒）</span><br><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 记录未使用索引的查询</span><br><span class="hljs-attr">log_queries_not_using_indexes</span> = <span class="hljs-literal">ON</span><br><span class="hljs-comment"># 设置日志输出方式，可选FILE或TABLE</span><br><span class="hljs-attr">log_output</span> = FILE<br></code></pre></div></td></tr></table></figure><p>修改配置文件后需要重启MySQL服务以使配置生效。</p><h4 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h4><p>除了配置文件外，也可以在 MySQL 客户端中通过<code>SET GLOBAL</code>命令动态设置参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">-- 开启慢查询日志<br>SET GLOBAL slow_query_log = &#x27;ON&#x27;;<br><br>-- 设置日志文件路径（注意：部分参数可能需要在配置文件中设置，具体取决于MySQL版本）<br>SET GLOBAL slow_query_log_file = &#x27;/var/log/mysql/slow_query.log&#x27;;<br><br>-- 设置慢查询时间阈值为1秒<br>SET GLOBAL long_query_time = 1;<br><br>-- 开启记录未使用索引的查询<br>SET GLOBAL log_queries_not_using_indexes = &#x27;ON&#x27;;<br><br>-- 指定日志输出方式为FILE<br>SET GLOBAL log_output = &#x27;FILE&#x27;;<br></code></pre></div></td></tr></table></figure><p>这种方式适用于临时调整，但重启后可能失效，因此建议将关键参数写入配置文件中。</p><h3 id="记录示例"><a href="#记录示例" class="headerlink" title="记录示例"></a>记录示例</h3><p>在开启慢查询日志后，当某条 SQL 语句执行时间超过设置的阈值（例如1秒）时，就会被记录到慢查询日志中。</p><p><strong>示例</strong>：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"># <span class="hljs-type">Time</span>: <span class="hljs-number">2022</span><span class="hljs-number">-07</span><span class="hljs-number">-02</span>T23:<span class="hljs-number">42</span>:<span class="hljs-number">43.123456</span>Z<br># <span class="hljs-keyword">User</span>@Host: dbuser[dbuser] @ localhost [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]  Id: <span class="hljs-number">8</span><br># Query_time: <span class="hljs-number">1.234567</span>  Lock_time: <span class="hljs-number">0.000123</span>  Rows_sent: <span class="hljs-number">50</span>  Rows_examined: <span class="hljs-number">10000</span><br><span class="hljs-keyword">SET</span> <span class="hljs-type">timestamp</span>=<span class="hljs-number">1656776563</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> status = <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> created_at <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100</span>;<br></code></pre></div></td></tr></table></figure><p><strong>解析：</strong></p><ul><li><p><strong>时间戳信息</strong>：</p><p><code># Time: 2022-07-02T23:42:43.123456Z</code> 表示该查询的开始执行时间（UTC 时间）。</p></li><li><p><strong>连接信息</strong>：</p><p><code># User@Host: dbuser[dbuser] @ localhost [127.0.0.1] Id: 8</code> 记录了执行该查询的数据库用户、主机以及连接 ID。</p></li><li><p><strong>执行详情</strong>：</p><ul><li><code># Query_time: 1.234567</code> 表示该查询耗时 1.234567 秒。</li><li><code>Lock_time: 0.000123</code> 显示锁定时间。</li><li><code>Rows_sent: 50</code> 表示返回的行数。</li><li><code>Rows_examined: 10000</code> 表示扫描的行数，通常行数越多说明可能存在优化空间。</li></ul></li><li><p><strong>SET timestamp</strong>：</p><p>表示实际执行 SQL 语句时的 Unix 时间戳，可以用来确认日志中的时间。</p></li><li><p><strong>实际查询语句</strong>：</p><p>最后一行显示了完整的 SQL 语句，方便后续重现和调试。</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p><strong>权限与磁盘空间</strong>：确保 MySQL 用户对日志文件所在目录具有写权限，并定期监控日志文件的大小，避免因日志过大而影响磁盘空间。</p></li><li><p><strong>日志轮转（Log Rotation）</strong>：可配置日志轮转策略，定期归档和清理慢查询日志文件，避免日志文件无限制增长。</p></li><li><p><strong>日志分析工具</strong>：配合 <code>Percona Toolkit</code> 中的 <code>pt-query-digest</code> 等工具，可以对慢查询日志进行统计和分析，找到最耗时的查询和潜在的性能瓶颈。</p></li></ul><h2 id="SHOW-PROFILE"><a href="#SHOW-PROFILE" class="headerlink" title="SHOW PROFILE"></a>SHOW PROFILE</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>SHOW PROFILE</code> 是 MySQL 提供的一种查询分析工具，用于展示单条 SQL 语句执行过程中的各个阶段及其耗时。通过查看这些阶段信息，可以发现查询在执行过程中哪些部分比较耗时，从而辅助性能调优。</p><h3 id="开启-Profiling"><a href="#开启-Profiling" class="headerlink" title="开启 Profiling"></a>开启 Profiling</h3><p>在使用 <code>SHOW PROFILE</code> 前，需要在当前会话中启用 <code>profiling</code> 功能。可以通过以下命令启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET profiling = 1;<br></code></pre></div></td></tr></table></figure><p>此命令会在当前会话中启用查询分析功能，后续执行的 SQL 语句都会被记录详细的执行阶段信息。</p><h3 id="查看-Profiling-信息"><a href="#查看-Profiling-信息" class="headerlink" title="查看 Profiling 信息"></a>查看 Profiling 信息</h3><h4 id="执行-SQL-查询"><a href="#执行-SQL-查询" class="headerlink" title="执行 SQL 查询"></a>执行 SQL 查询</h4><p>启用 <code>profiling</code> 后，执行需要分析的查询。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT id, name FROM tt_student WHERE class_id = 1;<br></code></pre></div></td></tr></table></figure><h4 id="查看已记录的查询"><a href="#查看已记录的查询" class="headerlink" title="查看已记录的查询"></a>查看已记录的查询</h4><p>使用 <code>SHOW PROFILES</code> 命令可以查看当前会话中所有执行过的查询及其对应的查询 ID 和执行时间。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW PROFILES;<br></code></pre></div></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">+----------+------------+----------------------------------------------------+<br>| Query_ID | Duration   | Query                                              |<br>+----------+------------+----------------------------------------------------+<br>|        1 | 0.00036925 | SELECT id, name FROM tt_student WHERE class_id = 1 |<br>+----------+------------+----------------------------------------------------+<br></code></pre></div></td></tr></table></figure><p>这里的 <code>Query_ID</code> 是查询标识，后续可以通过该 ID 查看详细的执行阶段信息。</p><h3 id="查看单条查询的详细执行阶段"><a href="#查看单条查询的详细执行阶段" class="headerlink" title="查看单条查询的详细执行阶段"></a>查看单条查询的详细执行阶段</h3><p>使用 <code>SHOW PROFILE FOR QUERY [query_id]</code> 命令可以查看指定查询的详细信息。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW PROFILE FOR QUERY 1;<br></code></pre></div></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">+--------------------------------+----------+<br>| Status                         | Duration |<br>+--------------------------------+----------+<br>| starting                       | 0.000065 |<br>| Executing hook on transaction  | 0.000002 |<br>| starting                       | 0.000005 |<br>| checking permissions           | 0.000003 |<br>| Opening tables                 | 0.000117 |<br>| init                           | 0.000003 |<br>| System lock                    | 0.000005 |<br>| optimizing                     | 0.000006 |<br>| statistics                     | 0.000038 |<br>| preparing                      | 0.000009 |<br>| executing                      | 0.000025 |<br>| end                            | 0.000001 |<br>| query end                      | 0.000002 |<br>| waiting <span class="hljs-keyword">for</span> handler commit     | 0.000006 |<br>| closing tables                 | 0.000005 |<br>| freeing items                  | 0.000043 |<br>| logging slow query             | 0.000030 |<br>| cleaning up                    | 0.000006 |<br>+--------------------------------+----------+<br></code></pre></div></td></tr></table></figure><p><strong>解析说明</strong>：</p><ul><li><strong>Status</strong>：描述查询执行过程中的各个阶段（例如 <code>starting</code>、<code>opening tables</code>、<code>executing</code>、<code>sending data</code> 等）。</li><li><strong>Duration</strong>：显示每个阶段的耗时，单位为秒，通过这些数据可以定位哪个环节消耗的时间较多。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>性能调优</strong>：通过详细的阶段耗时数据，可以找出执行时间较长的环节。例如，如果 <code>sending data</code> 阶段耗时显著，可能需要检查是否存在数据传输或排序等瓶颈。</li><li><strong>调试复杂查询</strong>：对于结构复杂或执行过程不明确的查询，<code>SHOW PROFILE</code> 能够提供直观的分解信息，帮助理解 SQL 执行过程。</li><li><strong>对比优化效果</strong>：在进行 SQL 优化前后，通过多次执行并对比 <code>SHOW PROFILE</code> 的输出，可以直观感受到性能改进情况。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>性能开销</strong>：启用 <code>profiling</code> 功能会对查询性能产生一定开销，建议在开发或测试环境中使用，生产环境中尽量只在必要时启用。</li><li><strong>会话级别</strong>：<code>profiling</code> 信息仅在当前会话内有效，断开连接后相关数据将丢失。若需要长期保存查询性能信息，可结合慢查询日志或 <code>Performance Schema</code>。</li></ul><h2 id="Performance-Schema"><a href="#Performance-Schema" class="headerlink" title="Performance Schema"></a>Performance Schema</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Performance Schema</code> 是 MySQL 提供的内置性能监控与诊断框架。它基于一系列的 <code>producer-consumer</code> 模式来捕获数据库内部的各种事件（语句事件、阶段事件、等待事件等），并将这些事件信息存储在 <code>Performance Schema</code> 下的若干表中（如 <code>events_statements_summary_by_digest</code>、<code>events_stages_history</code>、<code>events_waits_summary_global_by_event_name</code> 等），以便我们进行查询分析和系统调优。</p><p>相较于早期的 <code>SHOW PROFILE</code> 功能，<code>Performance Schema</code> 提供的数据更加全面、更细粒度，可用于多种场景下的性能分析，包括定位慢 SQL、监控高并发场景下的资源消耗、查看锁等待、分析表扫描量等。。</p><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><ol><li><p><strong>检查是否已启用</strong></p><p>在 MySQL 5.6+ 版本中，<code>Performance Schema</code> 默认是启用的。可以通过以下方式查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;performance_schema&#x27;;<br></code></pre></div></td></tr></table></figure><p>如果结果为 <code>ON</code>，则表示已启用；若为 <code>OFF</code>，可在配置文件或启动参数中设置 <code>performance_schema=ON</code> 并重启 MySQL 生效。</p></li><li><p><strong>启用生产者（Instruments）</strong></p><p><code>Performance Schema</code> 下的 <code>setup_instruments</code> 表决定了哪些事件会被记录。可以查看如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT NAME, ENABLED, TIMED<br>FROM performance_schema.setup_instruments<br>WHERE NAME LIKE &#x27;stage/%&#x27; <br>   OR NAME LIKE &#x27;statement/%&#x27;<br>   OR NAME LIKE &#x27;wait/%&#x27;;<br></code></pre></div></td></tr></table></figure><ul><li><code>ENABLED = &#39;YES&#39;</code> 表示对该事件类型已开启采集；</li><li><code>TIMED = &#39;YES&#39;</code> 表示会记录耗时信息。</li></ul><p>如需启用更多，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE performance_schema.setup_instruments<br>SET ENABLED = &#x27;YES&#x27;, TIMED = &#x27;YES&#x27;<br>WHERE NAME LIKE &#x27;stage/%&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>启用消费者（Consumers）</strong></p><p>采集到的数据是否写入相应的表，还取决于 <code>setup_consumers</code> 表的设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT NAME, ENABLED<br>FROM performance_schema.setup_consumers;<br></code></pre></div></td></tr></table></figure><p>常用的消费者包括：</p><ul><li><p><code>events_statements_history</code></p></li><li><p><code>events_statements_history_long</code></p></li><li><p><code>events_stages_history</code></p></li><li><p><code>events_stages_history_long</code></p></li><li><p><code>events_statements_summary_by_digest</code> (用来做 SQL 摘要统计) 若想启用 <code>events_stages_history</code> 存储阶段数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE performance_schema.setup_consumers<br>SET ENABLED = &#x27;YES&#x27;<br>WHERE NAME = &#x27;events_stages_history&#x27;;<br></code></pre></div></td></tr></table></figure><p>同理，也可以启用或关闭其他消费者。</p></li></ul><p><strong>注意</strong>：</p><ul><li>通过 <code>UPDATE</code> 的方式只对当前运行的 MySQL 实例生效，重启后可能会回到默认值。若需永久生效，需在 <code>my.cnf</code>（或 <code>mysqld.cnf</code>）里进行合适的配置或使用 MySQL 8.0+ 的持久化系统变量机制。</li><li>在同一会话中进行配置、执行 SQL、查看数据，效果更明确。</li></ul></li></ol><h3 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h3><h4 id="执行次数及时长最多的-SQL"><a href="#执行次数及时长最多的-SQL" class="headerlink" title="执行次数及时长最多的 SQL"></a>执行次数及时长最多的 SQL</h4><p>最简单的是查看 <code>events_statements_summary_by_digest</code> 表。它会将类似的 SQL（相似结构但绑定值不同）聚合为一个 <code>digest</code>，统计执行次数、总耗时、平均耗时、最大耗时等信息。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT <br>    DIGEST_TEXT,<br>    COUNT_STAR AS exec_count,<br>    SUM_TIMER_WAIT/1000000000000 AS total_time_sec,<br>    AVG_TIMER_WAIT/1000000000000 AS avg_time_sec<br>FROM performance_schema.events_statements_summary_by_digest<br>ORDER BY exec_count DESC<br>LIMIT 10;<br></code></pre></div></td></tr></table></figure><p>这条 SQL 能快速找到执行次数最多的前 10 条 SQL 摘要。</p><ul><li><strong>DIGEST_TEXT</strong>：一条 SQL 摘要化后的模板，如 <code>SELECT * FROM employees WHERE employee_id = ?</code>。</li><li><strong>COUNT_STAR</strong>：统计 SQL 被执行的次数。</li><li><strong>SUM_TIMER_WAIT 和 AVG_TIMER_WAIT</strong>：代表总执行时间和平均执行时间，单位通常是皮秒（可除以 <code>10^12</code> 转化为秒）。</li></ul><h4 id="扫描记录最多的-SQL"><a href="#扫描记录最多的-SQL" class="headerlink" title="扫描记录最多的 SQL"></a>扫描记录最多的 SQL</h4><p><code>Performance Schema</code> 的摘要表也会统计 “扫描的行数（<code>Rows_examined</code>）” 等信息，可以帮助定位 “谁” 在频繁地做全表扫描或高代价扫描。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT <br>    DIGEST_TEXT,<br>    SUM_ROWS_EXAMINED AS total_rows_examined,<br>    COUNT_STAR AS exec_count,<br>    ROUND(SUM_ROWS_EXAMINED / COUNT_STAR) AS avg_rows_examined<br>FROM performance_schema.events_statements_summary_by_digest<br>ORDER BY total_rows_examined DESC<br>LIMIT 10;<br></code></pre></div></td></tr></table></figure><ul><li><strong>SUM_ROWS_EXAMINED</strong>：此 <code>digest</code> 下所有 SQL 语句执行时累计检查的行数。</li><li><strong>avg_rows_examined</strong>：平均每次扫描的行数，如果某条 SQL 平均扫描行数特别高，则通常有潜在的索引或写法问题，需要优化。</li></ul><h4 id="查看单条-SQL-各阶段运行时间"><a href="#查看单条-SQL-各阶段运行时间" class="headerlink" title="查看单条 SQL 各阶段运行时间"></a>查看单条 SQL 各阶段运行时间</h4><p>当需要更细粒度地了解 SQL 执行中的具体耗时环节（例如：<code>opening tables</code>、<code>executing</code>、<code>sending data</code> 等），可以使用阶段（<code>stage</code>）事件。步骤如下：</p><ol><li><p>启用生产者 <code>stage instrument</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE performance_schema.setup_instruments<br>SET ENABLED = &#x27;YES&#x27;, TIMED = &#x27;YES&#x27;<br>WHERE NAME LIKE &#x27;stage/%&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>启用对应消费者 <code>setup_consumers</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE performance_schema.setup_consumers<br>SET ENABLED = &#x27;YES&#x27;<br>WHERE NAME = &#x27;events_stages_history&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>在当前会话中执行一个查询（尽量稍微复杂些，让它有足够阶段可记录）。</p></li><li><p>然后查看 events_stages_history 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT EVENT_ID,<br>       EVENT_NAME,<br>       TIMER_WAIT/1000000000000 AS duration_sec<br>FROM performance_schema.events_stages_history<br>ORDER BY EVENT_ID DESC<br>LIMIT 10;<br></code></pre></div></td></tr></table></figure><p>或者查看 <code>events_stages_history_long</code> 表 以获取更久远的数据。开发者将看到每一阶段名称（例如 <code>stage/sql/starting</code>、<code>stage/sql/executing</code>、<code>stage/sql/sending data</code> 等）以及对应的耗时，从而判断在哪个阶段花费了最多时间，针对性进行优化。</p></li></ol><h3 id="其他数据指标"><a href="#其他数据指标" class="headerlink" title="其他数据指标"></a>其他数据指标</h3><p><code>Performance Schema</code> 涵盖了广泛的性能信息，以下是常见的一些指标及其对应的表或视图，你可在需要时参考官方文档或进一步查询：</p><ul><li><strong>临时表使用情况</strong>：可关注 <code>events_statements_summary_by_digest</code> 中的 <code>SUM_CREATED_TMP_DISK_TABLES</code>、<code>SUM_CREATED_TMP_TABLES</code> 等字段，或在 <code>events_statements_history[_long]</code> 表中查看单次执行的具体信息。</li><li><strong>索引使用情况</strong>：可以通过 “扫描行数” 与 “返回行数” 的对比来做粗略判断，也可结合慢查询日志和 <code>EXPLAIN</code> 工具来评估索引是否生效。</li><li><strong>锁使用情况</strong>：在 <code>performance_schema.events_waits_history</code>、<code>events_waits_summary_global_by_event_name</code> 等表中查看锁等待事件（<code>wait/lock</code>）。</li><li><strong>IO 次数、IO 等待情况</strong>：查询 <code>events_waits_summary_global_by_event_name</code> 中 <code>wait/io/file</code> 或 <code>wait/io/socket</code> 类型的事件。也可通过 <code>events_waits_history</code> / <code>events_waits_history_long</code> 研究具体会话下的 IO 等待。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>性能开销</strong>：开启过多的 <code>Instruments</code> 和 <code>Consumers</code>，尤其在高并发环境下，可能带来较大性能开销。应根据实际需求 “按需启用”，避免给生产环境造成显著负担。</li><li><strong>会话与持久化</strong>：通过 <code>UPDATE performance_schema.setup_instruments</code> 或 <code>setup_consumers</code> 的方式通常只对当前实例生效，重启后会恢复为默认。若要永久生效，需在配置文件中写明或使用 MySQL 8.0+ 的 <code>SET PERSIST</code> 语句。</li><li><strong>版本差异</strong>：不同 MySQL 版本对 <code>Performance Schema</code> 的默认配置和可用字段略有差异。遇到无法查询字段或表的情况，应查阅对应版本的官方文档进行确认。</li><li><strong>安全与权限</strong>：<code>Performance Schema</code> 某些表仅有 <code>SELECT</code> 权限对 DBA 或特定用户开放，需确保当前用户具备访问 <code>performance_schema</code> 数据的权限。</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>展示执行计划</strong>：<code>EXPLAIN</code> 命令用于显示给定 SQL 语句（包括 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>、<code>UPDATE</code> 等）生成的执行计划。它揭示了查询语句中涉及的各个表的访问顺序、使用的索引以及访问数据的方式。</li><li><strong>辅助查询优化</strong>：通过分析 <code>EXPLAIN</code> 的输出，可以判断查询是否存在全表扫描、索引选择不合理或者不必要的排序、临时表等问题，从而针对性地调整 SQL 语句、创建或修改索引以及改进表结构，以提高查询性能。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>在 SQL 语句前加上 <code>EXPLAIN</code>，即可查看执行计划。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">EXPLAIN [FORMAT=JSON] SELECT * FROM employees WHERE id = 100;<br></code></pre></div></td></tr></table></figure><p>其中 <code>FORMAT=JSON</code> 为 MySQL 5.6 引入的可选项，可以适用 <code>JSON</code> 格式输出执行计划。</p><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><p><code>EXPLAIN</code> 命令返回的结果集通常包含多个列，不同版本可能略有不同，但主要列及其含义如下：</p><ul><li><p><strong>id</strong>：表示查询中每个 <code>SELECT</code> 子句的标识符。<code>id</code> 值越大，表示该子查询或联合查询的优先级越高，通常也能反映执行顺序。</p></li><li><p><strong>select_type</strong>：描述查询中各个 <code>SELECT</code> 的类型，如：</p><ul><li><strong>SIMPLE</strong>：简单查询，不包含子查询或 <code>UNION</code>。</li><li><strong>PRIMARY</strong>：主查询，即复杂查询中的最外层 <code>SELECT</code>。</li><li><strong>SUBQUERY</strong>：在 <code>SELECT</code> 或 <code>WHERE</code> 语句中嵌套的子查询。</li><li><strong>DERIVED</strong>：派生表（<code>Derived Table</code>），即 <code>FROM</code> 子查询，MySQL 会将其视为临时表。</li><li><strong>UNION</strong>：<code>UNION</code> 查询中的第二个及后续 <code>SELECT</code> 语句。</li><li><strong>UNION RESULT</strong>：<code>UNION</code> 查询的结果集，存放在一个临时表中。</li><li><strong>DEPENDENT SUBQUERY</strong>：依赖外部查询的子查询，必须逐行执行（类似于 <code>correlated subquery</code> 相关子查询）。</li><li><strong>DEPENDENT UNION</strong>：<code>UNION</code> 查询中的第二个及后续 <code>SELECT</code> 语句，且依赖于外部查询。</li><li><strong>UNCACHEABLE SUBQUERY</strong>：不能被缓存的子查询，每次执行都要重新评估。</li><li><strong>UNCACHEABLE UNION</strong>：<code>UNION</code> 语句中的一个分支，该分支不能被缓存。</li></ul></li><li><p><strong>table</strong>：显示当前行所引用的表的名称，表示查询中正在访问哪个表。</p></li><li><p><strong>partitions</strong>：如果表使用了分区，则此列会显示参与查询的分区信息。</p></li><li><p><strong>type</strong>：代表访问类型，也是衡量查询性能的关键指标。从最好到最差的类型依次为：</p><ul><li><strong>system</strong>、<strong>const</strong>：极其高效，只需要访问一行或几行数据。</li><li><strong>eq_ref</strong>、<strong>ref</strong>：较好，可以利用索引精确定位。</li><li><strong>range</strong>：通过范围条件访问索引中的连续数据。</li><li><strong>index</strong>：全索引扫描，比全表扫描略好。</li><li><strong>ALL</strong>：全表扫描，效率较低，应尽量避免。</li></ul></li><li><p><strong>possible_keys</strong>：列出查询中可能用到的所有索引，供优化器参考。</p></li><li><p><strong>key</strong>：实际上被 MySQL 选择使用的索引。如果为 <code>NULL</code>，说明没有使用索引。</p></li><li><p><strong>key_len</strong>：表示 MySQL 实际使用的索引长度。这个值可以帮助判断索引是否被充分利用。</p></li><li><p><strong>ref</strong>：显示哪个列或常量与 key 索引一起被使用，用来指示索引的匹配情况。</p></li><li><p><strong>rows</strong>：估计需要扫描的行数，行数越多，通常说明查询的代价越高。</p></li><li><p><strong>filtered</strong>：表示经过表过滤条件后，实际返回的行所占的百分比。</p></li><li><p><strong>Extra</strong>：提供额外的执行信息，比如：</p><ul><li><strong>Using where</strong>：查询中使用了 <code>WHERE</code> 过滤条件。</li><li><strong>Using index</strong>：查询仅通过索引、无需访问表数据就能获取数据，称为 “覆盖索引”。</li><li><strong>Using index condition</strong>：只利用索引条件进行部分筛选，但仍需访问表数据。</li><li><strong>Using temporary</strong>：查询中使用了临时表（通常出现在 <code>GROUP BY</code> 和 <code>ORDER BY</code> 查询中）。</li><li><strong>Using filesort</strong>：需要额外的排序操作，而不是利用索引进行排序（通常出现在 <code>ORDER BY</code> 语句中）。</li><li>**Using join buffer (Block Nested Loop)**：连接时使用了 <code>join buffer</code>，通常发生在 <code>JOIN</code> 查询未使用索引的情况下。</li><li><strong>Using MRR</strong>：MySQL 使用了 <code>Multi-Range Read</code>，优化范围查询时的一种方式。</li><li><strong>Using index for group-by</strong>：<code>GROUP BY</code> 操作直接使用索引，无需额外排序或临时表。</li><li><strong>Using where with pushed condition</strong>：<code>WHERE</code> 条件被 “推送” 到索引扫描阶段，提高查询效率（主要适用于 <code>InnoDB</code>）。</li><li><strong>Start temporary; End temporary</strong>：表示查询涉及临时表，数据可能在临时表中被重新排序或处理。</li><li><strong>No matching rows in const table</strong>：查询的 <code>const</code> 类型表没有匹配的行，通常意味着索引查找失败。</li></ul></li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>关注访问类型（type）</strong>：访问类型是衡量查询效率的重要指标，尽量避免出现全表扫描这种类型。如果发现查询使用了全表扫描，应考虑是否能通过增加索引或修改查询条件来改进。</li><li><strong>索引使用情况</strong>：比较 <code>possible_keys</code> 与 <code>key</code> 列，看看是否 MySQL 在可选的索引中选用了最优的索引。如果 <code>key</code> 为 <code>NULL</code> 而 <code>possible_keys</code> 不为空，可能说明查询条件未能充分利用索引。</li><li><strong>额外信息（Extra）</strong>：注意 <code>Extra</code> 列中出现的提示信息，如 <code>Using temporary</code> 或 <code>Using filesort</code>。这通常表示查询中存在需要额外优化的部分，如排序或分组操作，这时可以考虑改写查询或调整索引。</li><li><strong>扫描行数（rows）</strong>：如果扫描的行数较多，查询可能会变慢。可以尝试进一步缩小查询范围或优化查询条件，以减少扫描的行数。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>查看以下 SQL 的执行计划</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">EXPLAIN SELECT id, name FROM tt_student WHERE class_id = 1;<br></code></pre></div></td></tr></table></figure><p>执行计划如下：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">+----+-------------+------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+<br>| id | select_type | table      | partitions | <span class="hljs-built_in">type</span> | possible_keys | key          | key_len | ref   | rows | filtered | Extra |<br>+----+-------------+------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+<br>|  1 | SIMPLE      | tt_student | NULL       | ref  | idx_class_id  | idx_class_id | 4       | const |    1 |   100.00 | NULL  |<br>+----+-------------+------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+<br></code></pre></div></td></tr></table></figure><p>通过 <code>EXPLAIN</code> 输出，可以检查：</p><ul><li>查询是否利用了 <code>class_id</code> 的索引；</li><li>访问类型是否为 <code>range</code> 或 <code>ref</code>，从而判断索引是否有效；</li><li><code>rows</code> 列显示的扫描行数，判断查询过滤效果；</li><li><code>Extra</code> 列是否有额外信息，比如是否需要临时表或排序。</li></ul><p>根据这些信息，你可以决定是否需要重新建立索引，或者调整查询语句来提高性能。</p><h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><p>关注 <code>EXPLAIN</code> 结果可以让 SQL 优化有一些方向，如：</p><h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p>关注 <code>type</code> 列，如果出现 <code>ALL</code>（全表扫描）或 <code>index</code>（全索引扫描），通常意味着索引未被合理利用，应优化查询。</p><table><thead><tr><th>type 值</th><th>可能问题</th><th>解决方案</th></tr></thead><tbody><tr><td><code>ALL</code> (全表扫描)</td><td>查询未使用索引，性能最差</td><td>创建合适的索引、调整 <code>WHERE</code> 条件</td></tr><tr><td><code>index</code> (全索引扫描)</td><td>索引被扫描，但未高效过滤数据</td><td>考虑是否可以改用 <code>WHERE</code> 限制数据范围</td></tr><tr><td><code>range</code> (范围查询)</td><td>使用索引进行范围查找，但扫描行数仍然较多</td><td>确保查询字段上有合适的索引，考虑索引选择性</td></tr><tr><td><code>ref</code></td><td>索引被使用，但匹配的数据较多</td><td>尽量提高索引的唯一性（比如 唯一索引）</td></tr><tr><td><code>eq_ref</code></td><td>索引精准查找，性能很好</td><td>无需优化</td></tr><tr><td><code>const/system</code></td><td>仅查询单行数据，性能最佳</td><td>无需优化</td></tr></tbody></table><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><p>关注 <code>possible_keys</code> 和 <code>key</code>。</p><table><thead><tr><th>possible_keys 和 key</th><th>可能问题</th><th>解决方案</th></tr></thead><tbody><tr><td><code>possible_keys</code> 为空</td><td>没有可用索引</td><td>创建合适的索引</td></tr><tr><td><code>key</code> 为 <code>NULL</code></td><td>没有索引被使用</td><td>调整 <code>WHERE</code> 条件或创建索引</td></tr><tr><td><code>possible_keys</code> 多于 <code>key</code></td><td>有更优索引但未被使用</td><td>使用 <code>FORCE INDEX</code> 或优化查询逻辑</td></tr><tr><td><code>key_len</code> 过小</td><td>使用了复合索引，但未充分利用</td><td>确保索引的最左前缀原则</td></tr></tbody></table><h4 id="扫描行数"><a href="#扫描行数" class="headerlink" title="扫描行数"></a>扫描行数</h4><p>关注 <code>rows</code>，这个参数代表 MySQL 预计要扫描的行数，值越大，查询成本越高。</p><p>关注点：</p><ul><li>确保索引被使用，减少 <code>rows</code> 数量。</li><li><code>rows</code> 过大可能意味着索引选择不合理，需要调整索引或查询逻辑。</li><li>对大表查询时，考虑 <code>LIMIT</code> 限制查询范围。</li></ul><h4 id="额外执行信息"><a href="#额外执行信息" class="headerlink" title="额外执行信息"></a>额外执行信息</h4><p>关注 <code>Extra</code> 列展示的额外执行信息。</p><table><thead><tr><th>Extra 取值</th><th>可能问题</th><th>解决方案</th></tr></thead><tbody><tr><td><code>Using filesort</code></td><td>额外的排序操作，未使用索引排序</td><td>添加合适的索引 (<code>ORDER BY</code> 字段建立索引)</td></tr><tr><td><code>Using temporary</code></td><td>查询使用了临时表，性能较差</td><td>优化 <code>GROUP BY</code>、<code>ORDER BY</code>，尽量使用索引</td></tr><tr><td><code>Using where</code></td><td>使用了 <code>WHERE</code> 过滤条件，但索引可能未充分利用</td><td>确保 <code>WHERE</code> 条件字段有索引</td></tr><tr><td><code>Using index</code></td><td>覆盖索引查询，无需回表</td><td>推荐，尽量让查询满足索引覆盖</td></tr><tr><td><code>Using join buffer</code></td><td><code>JOIN</code> 查询未使用索引，导致 <code>join buffer</code> 过多使用</td><td>给 <code>JOIN</code> 的连接字段创建索引</td></tr></tbody></table><h2 id="索引失效及应对"><a href="#索引失效及应对" class="headerlink" title="索引失效及应对"></a>索引失效及应对</h2><p>对于数据量较大的表，利用好索引往往能让查询效率变得非常高，但 SQL 如果不规范往往会导致索引失效，如以下场景：</p><h3 id="对索引列使用函数或表达式"><a href="#对索引列使用函数或表达式" class="headerlink" title="对索引列使用函数或表达式"></a>对索引列使用函数或表达式</h3><h4 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h4><p>当在 WHERE 子句中对索引列应用函数（如 <code>YEAR()</code>、<code>DATE()</code>、<code>UPPER()</code> 等）或做算术运算时，MySQL 无法直接利用该列的原始索引。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM orders WHERE YEAR(order_date) = 2021;<br></code></pre></div></td></tr></table></figure><h4 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li><p>尽量将常量转换为范围值，避免在索引列上进行函数调用。</p></li><li><p>修改查询，如将上例改写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM orders <br>WHERE order_date BETWEEN &#x27;2021-01-01&#x27; AND &#x27;2021-12-31&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>或者在设计时考虑增加一个存储计算结果的辅助列，并对其建立索引。</p></li></ul><p><strong>注意</strong>：MySQL 8.0 的优化器在某些函数场景也可能部分利用索引的 <code>MRR</code>（<code>Multi-Range Read</code>）或 <code>ICP</code>（<code>Index Condition Pushdown</code>），但大多数情况下仍建议避免对索引列进行函数处理。</p><h3 id="数据类型不匹配或隐式转换"><a href="#数据类型不匹配或隐式转换" class="headerlink" title="数据类型不匹配或隐式转换"></a>数据类型不匹配或隐式转换</h3><h4 id="场景说明-1"><a href="#场景说明-1" class="headerlink" title="场景说明"></a>场景说明</h4><p>如果查询中的常量数据类型与索引列的数据类型不一致，或者表关联字段数据类型不一致，MySQL 可能会进行隐式转换，这往往会使索引失效。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># users表中id字段为数值类型，非字符串类型<br>SELECT * FROM users WHERE id = &#x27;100&#x27;;  -- 字符串 &#x27;100&#x27; 可能引发隐式转换<br></code></pre></div></td></tr></table></figure><h4 id="应对措施-1"><a href="#应对措施-1" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>在编写 SQL 语句时，确保传入的参数与列的数据类型一致，避免不必要的类型转换。</li><li>检查应用层传入的参数，保持数据类型的匹配。</li></ul><h3 id="使用-LIKE-时使用前导通配符"><a href="#使用-LIKE-时使用前导通配符" class="headerlink" title="使用 LIKE 时使用前导通配符"></a>使用 LIKE 时使用前导通配符</h3><h4 id="场景说明-2"><a href="#场景说明-2" class="headerlink" title="场景说明"></a>场景说明</h4><p>当使用 <code>LIKE</code> 模糊查询且模式中以 <code>%</code> 或 <code>_</code> 开头时，MySQL 无法利用索引进行匹配。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM products WHERE name LIKE &#x27;%phone&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="应对措施-2"><a href="#应对措施-2" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>如果业务允许，尽量避免前导通配符；改为后缀通配符，如 <code>LIKE &#39;phone%&#39;</code>。</li><li>当必须使用前导通配符时，可以考虑使用全文索引（<code>FULLTEXT</code>）或其他搜索引擎来替代常规索引。</li></ul><h3 id="OR-条件中部分字段缺少索引"><a href="#OR-条件中部分字段缺少索引" class="headerlink" title="OR 条件中部分字段缺少索引"></a>OR 条件中部分字段缺少索引</h3><h4 id="场景说明-3"><a href="#场景说明-3" class="headerlink" title="场景说明"></a>场景说明</h4><p>在使用 <code>OR</code> 条件连接多个字段时，如果其中某个字段没有索引，整个查询可能会无法利用索引。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM customers <br>WHERE first_name = &#x27;John&#x27; OR last_name = &#x27;Doe&#x27;;<br></code></pre></div></td></tr></table></figure><p>假设只有 <code>first_name</code> 建有索引，而 <code>last_name</code> 没有索引，查询整体可能不会走索引。</p><h4 id="应对措施-3"><a href="#应对措施-3" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>为所有涉及的字段建立适当的索引。</li><li>或者将 <code>OR</code> 查询拆分成两个独立查询，再用 <code>UNION</code> 组合结果，这样可以确保每个子查询都能走索引。</li></ul><h3 id="多列复合索引的最左前缀原则失效"><a href="#多列复合索引的最左前缀原则失效" class="headerlink" title="多列复合索引的最左前缀原则失效"></a>多列复合索引的最左前缀原则失效</h3><h4 id="场景说明-4"><a href="#场景说明-4" class="headerlink" title="场景说明"></a>场景说明</h4><p>对于复合索引，只有在 <code>WHERE</code> 子句中包含索引最左侧连续列时，索引才会生效。如果跳过了最左侧的列，后面的索引将无法被利用。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>假设有复合索引 <code>(a, b, c)</code>，但查询条件仅涉及 <code>b</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM table WHERE b = &#x27;value&#x27;;<br></code></pre></div></td></tr></table></figure><p>此时就会导致整个查询没有用上符合索引。</p><h4 id="应对措施-4"><a href="#应对措施-4" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>设计复合索引时，应根据查询条件的实际使用顺序，合理规划最左前缀。</li><li>根据常用查询调整索引顺序，或者针对单列查询建立独立索引。</li></ul><h3 id="不等于条件和范围查询的特殊情况"><a href="#不等于条件和范围查询的特殊情况" class="headerlink" title="不等于条件和范围查询的特殊情况"></a>不等于条件和范围查询的特殊情况</h3><h4 id="场景说明-5"><a href="#场景说明-5" class="headerlink" title="场景说明"></a>场景说明</h4><p>对于不等于 (<code>!=</code> 或 <code>&lt;&gt;</code>) 条件或范围查询，索引可能无法达到理想的过滤效果，尤其是在数据分布不均的情况下。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM employees WHERE salary &lt;&gt; 5000;<br></code></pre></div></td></tr></table></figure><h4 id="应对措施-5"><a href="#应对措施-5" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>尽量避免在索引列上使用不等于条件，或者改为其他能利用索引的查询条件。</li><li>对于范围查询，要确保索引列选择性较高，以便缩小扫描范围。</li></ul><h2 id="SQL-语法参数优化"><a href="#SQL-语法参数优化" class="headerlink" title="SQL 语法参数优化"></a>SQL 语法参数优化</h2><p>除了利用好索引外，SQL 语法中的参数同样需要引起重视：</p><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><ul><li><strong>字段选择</strong>：避免 <code>SELECT *</code>，明确列名，减少数据传输量。</li><li><strong>DISTINCT 与 GROUP BY</strong>：对结果集进行去重或分组时，注意计算成本，必要时可以通过业务逻辑在应用层实现。</li></ul><h3 id="JOIN-操作"><a href="#JOIN-操作" class="headerlink" title="JOIN 操作"></a>JOIN 操作</h3><ul><li><strong>选择合适的JOIN类型</strong>：内连接（<code>INNER JOIN</code>）通常性能较好，尽量避免使用笛卡尔积。</li><li><strong>索引支持</strong>：<code>JOIN</code> 操作涉及的字段应有索引支持，确保连接条件能够高效匹配。</li><li><strong>顺序优化</strong>：调整 <code>JOIN</code> 顺序，使得大表与小表连接时优先过滤数据。</li></ul><h3 id="条件优化"><a href="#条件优化" class="headerlink" title="条件优化"></a>条件优化</h3><ul><li><p>避免在 <code>WHERE</code> 子句中对索引字段使用函数或进行运算，尽量直接使用常量进行比较。</p></li><li><p>使用范围查询时，合理利用索引前缀。</p></li></ul><h3 id="GROUP-BY-与-ORDER-BY"><a href="#GROUP-BY-与-ORDER-BY" class="headerlink" title="GROUP BY 与 ORDER BY"></a>GROUP BY 与 ORDER BY</h3><ul><li><p>对于排序和分组字段应建立合适的索引。</p></li><li><p>避免在大数据集上进行不必要的排序操作，可考虑在应用层处理部分逻辑。</p></li></ul><h3 id="LIMIT-与分页查询"><a href="#LIMIT-与分页查询" class="headerlink" title="LIMIT 与分页查询"></a>LIMIT 与分页查询</h3><ul><li><strong>索引分页</strong>：对于大数据量分页，使用 “上次记录的最后值” 作为条件进行下一页查询，避免大量数据扫描。</li><li><strong>合理分页大小</strong>：根据业务场景设置合理的分页大小，平衡用户体验与系统性能。</li></ul><h3 id="子查询与预编译"><a href="#子查询与预编译" class="headerlink" title="子查询与预编译"></a>子查询与预编译</h3><ul><li><strong>子查询优化</strong>：尽量将子查询转换为 <code>JOIN</code> 或临时表，降低嵌套层级。</li><li><strong>预编译与参数绑定</strong>：使用预编译语句（<code>Prepared Statement</code>）不仅可以提高执行效率，还能防止 SQL 注入。</li></ul><h2 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>这句话通常出现在数据库的多表 <code>JOIN</code> 查询 优化中，尤其是对于嵌套循环连接（<code>Nested Loop Join</code>） 的场景。其含义为在多表连接中，应该让较小的数据集（“小表”）作为驱动表（外表/驱动器），而较大的数据集（“大表”）作为被驱动表（内表）。这种优化策略有助于提高查询效率。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><strong>驱动表更小，内存缓存更高效</strong>：<ul><li>小表更容易被完全加载到内存中作为驱动表，从而减少磁盘 I/O。</li><li>驱动表每次只需要从内存中取数据，而大表可以按块分批扫描，提高查询效率。</li></ul></li><li><strong>被驱动表通常有索引辅助</strong>：如果被驱动表的连接列上存在索引，查询效率更高，因为每次匹配时能直接利用索引快速定位目标数据。</li><li><strong>网络开销考虑</strong>：分布式数据库中，小表驱动大表可以减少跨节点传输的数据量。例如，先将小表的结果集传输到另一个节点与大表匹配，网络开销更小。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT *<br>FROM a<br>JOIN b<br>ON a.key = b.key;<br></code></pre></div></td></tr></table></figure><ul><li>驱动表：<code>a</code>，<code>JOIN</code> 的处理会先扫描此表。</li><li>被驱动表：<code>b</code>，通过 <code>a.key</code> 扫描此表。</li></ul><p><strong>优化注意</strong>：数据量较小的表放在位置 <code>a</code> 作为驱动表，减少外层扫描次数，提高效率。</p><h4 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT *<br>FROM a<br>WHERE EXISTS (<br>    SELECT 1<br>    FROM b<br>    WHERE b.key = a.key<br>);<br></code></pre></div></td></tr></table></figure><ul><li>驱动表：<code>a</code>，<code>EXISTS</code> 的执行是对此表的每一行数据一次检查是否满足子查询的条件，因此外层表始终都是驱动表。</li><li>被驱动表：<code>b</code>，外层的行作为条件执行此表的查询。</li></ul><p><strong>优化注意</strong>：数据量较小的表放在位置 <code>a</code> 作为驱动表，位置 <code>b</code> 上的表不需要全部扫描，只要有一行匹配即返回 <code>TRUE</code>。</p><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><p><strong>情况1</strong>：子查询在 <code>IN</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT *<br>FROM a<br>WHERE l.key IN (<br>    SELECT b.key<br>    FROM b<br>);<br></code></pre></div></td></tr></table></figure><ul><li>驱动表：<code>a</code>，<code>IN</code> 查询时 MySQL 优化器会对此表逐行扫描，每行数据都与子查询的结果进行匹配，因此外层表是驱动表。</li><li>被驱动表：<code>b</code>，MySQL 会先执行子查询，生成一个中间结果集，然后与外层表的行进行比对。</li></ul><p><strong>优化注意</strong>：如果子查询返回的结果集比较大，可能导致性能问题，这种情况下应考虑将子查询改为 <code>JOIN</code> 或使用索引优化。</p><p><strong>情况2</strong>：多值 <code>IN</code> 的写法。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT *<br>FROM a<br>WHERE a.key IN (1, 2, 3);<br></code></pre></div></td></tr></table></figure><p>这种写法中，<code>a</code> 是驱动表，<code>IN</code> 的常量集合被 MySQL 优化为索引查找。</p><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><strong>不绝对适用</strong>：“小表驱动大表” 是通用原则，但具体是否适用需结合表的大小、索引情况和查询语句的实际执行计划来判断。</li><li><strong>联合索引优先</strong>：被驱动表如果有合适的联合索引，则查询效率可能更高，此时，即使大表作为驱动表也可能具有一定优势。</li><li><strong>分布式系统</strong>：在分布式数据库中，需综合考虑网络传输成本和各节点的计算负载。</li></ol><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>在某些情况下，MySQL 的查询优化器可能主动选择全表扫描而不是使用索引，这是一个经过计算和权衡后的决策，并且实际上查询效率可能更高。以下是可能导致这种情况的原因，以及引发的思考：</p><h3 id="全表扫描更高效场景"><a href="#全表扫描更高效场景" class="headerlink" title="全表扫描更高效场景"></a>全表扫描更高效场景</h3><h4 id="表中的数据量较少"><a href="#表中的数据量较少" class="headerlink" title="表中的数据量较少"></a>表中的数据量较少</h4><p>当表的数据量很少时（如只有几十行或更少），全表扫描一次性读取所有数据的开销可能比使用索引导航到数据位置的开销更低。</p><p><strong>索引的代价</strong>： 索引查找需要进行多次 <code>B+</code> 树节点访问（通常是磁盘 I/O），即使在内存中也存在一定的代价。对于小表来说，这种代价可能高于全表扫描。</p><h4 id="回表代价更高"><a href="#回表代价更高" class="headerlink" title="回表代价更高"></a>回表代价更高</h4><ol><li><p><strong>索引选择性较低</strong>：索引选择性是指索引列中不重复值的比例（公式：选择性 = 不同值的数量 / 总行数）。当索引选择性较低时，大量行具有相同的值，使用索引可能会返回大量数据行，这会导致查询性能不如全表扫描。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM table_name WHERE status = 1;<br></code></pre></div></td></tr></table></figure><p>如果 <code>status</code> 字段的值几乎都是 <code>1</code>（如 99% 的行满足条件），使用索引会导致大量回表操作，而全表扫描一次性读取所有数据可能更高效。</p></li><li><p><strong>索引无法覆盖查询</strong>：如果查询的字段不在索引中，MySQL 需要通过索引定位到主键值，然后再回表查询数据，这会产生额外的 I/O 开销，而全表扫描在这种情况下可能更高效。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT id, name FROM table_name WHERE age &gt; 20;<br></code></pre></div></td></tr></table></figure><p>如果只有 <code>age</code> 建立了索引，但 <code>id</code> 和 <code>name</code> 没有包含在索引中，查询需要频繁回表，效率可能低于直接全表扫描。</p></li></ol><h4 id="查询涉及大量数据行"><a href="#查询涉及大量数据行" class="headerlink" title="查询涉及大量数据行"></a>查询涉及大量数据行</h4><p>如果查询需要返回的行数占总行数的大部分，使用索引将不再具备显著优势，优化器可能会选择全表扫描。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM table_name WHERE age &gt; 5;<br></code></pre></div></td></tr></table></figure><p>如果表中 90% 的记录都符合条件，MySQL 会倾向于全表扫描而不是通过索引逐一定位数据行。</p><h4 id="索引统计信息不准确"><a href="#索引统计信息不准确" class="headerlink" title="索引统计信息不准确"></a>索引统计信息不准确</h4><p>MySQL 优化器根据表的统计信息（如行数、索引选择性等）评估索引的性能。如果统计信息过期或不准确，可能导致优化器选择全表扫描，此时可以手动更新统计信息。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ANALYZE TABLE table_name;<br></code></pre></div></td></tr></table></figure><h3 id="引发思考"><a href="#引发思考" class="headerlink" title="引发思考"></a>引发思考</h3><ul><li><p><strong>索引并非越多越好</strong>：每个索引都有维护成本（写入、更新、删除时需更新索引结构），因此需要合理设计，不合理的索引可能导致查询计划复杂化甚至性能下降。</p></li><li><p><strong>索引设计需结合数据特性</strong>：索引适用于高选择性字段，避免对低选择性字段（如性别、状态等）单独建立索引。对于频繁查询的字段，尽可能设计覆盖索引，避免回表操作。</p></li><li><p><strong>定期更新优化器</strong>：优化器是基于统计信息来选择执行计划的，需要理解数据分布、索引选择性、返回行数与扫描范围的关系，同时定期更新表的统计信息以帮助优化器做出更准确的选择。</p></li><li><p><strong>要关注实际查询执行计划</strong>：使用 <code>EXPLAIN</code>  检查查询的执行计划，分析是否选择了合理的索引路径，如果发现优化器选择全表扫描，而强制索引更快，可能需要调整索引设计或优化 SQL。</p></li><li><p><strong>性能测试与实践的重要性</strong>：理论分析并不总能覆盖所有情况，应通过实际查询测试确认最佳索引策略，在高并发和大数据量场景下，实时测试尤为重要。</p></li></ul><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><h3 id="编写规范化SQL"><a href="#编写规范化SQL" class="headerlink" title="编写规范化SQL"></a>编写规范化SQL</h3><ul><li><strong>清晰明了：</strong> 保持 SQL 结构清晰，避免嵌套过深和复杂联接。</li><li><strong>注释与文档：</strong> 对复杂查询加以注释，便于日后维护和调优。</li></ul><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><ul><li><strong>定期评审：</strong> 根据查询情况和数据量变化定期审查索引使用情况，删除冗余和低效索引。</li><li><strong>监控工具：</strong> 使用慢查询日志和监控工具定期评估索引命中率和性能。</li></ul><h3 id="数据库连接与事务管理"><a href="#数据库连接与事务管理" class="headerlink" title="数据库连接与事务管理"></a>数据库连接与事务管理</h3><ul><li><strong>连接池：</strong> 使用数据库连接池技术，避免频繁创建连接带来的开销。</li><li><strong>事务控制：</strong> 合理划分事务范围，避免长事务锁定资源，同时确保数据一致性。</li></ul><h3 id="代码与数据库解耦"><a href="#代码与数据库解耦" class="headerlink" title="代码与数据库解耦"></a>代码与数据库解耦</h3><ul><li><strong>业务逻辑分离：</strong> 将复杂数据处理逻辑尽可能放在业务层，实现数据查询与业务逻辑的分离。</li><li><strong>缓存策略：</strong> 对热点数据使用缓存策略，降低数据库直接压力。</li></ul><h3 id="定期监控与调优"><a href="#定期监控与调优" class="headerlink" title="定期监控与调优"></a>定期监控与调优</h3><ul><li><strong>性能监控：</strong> 建立完善的性能监控体系，及时发现异常查询。</li><li><strong>版本升级：</strong> 关注MySQL版本更新，利用新版本中引入的性能改进和新特性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在高并发、大数据量的应用场景中，SQL 优化对系统的整体性能至关重要。通过慢查询日志和 <code>SHOW PROFILE</code>，迅速定位个别耗时严重的查询，配合 <code>Performance Schema</code> 进一步挖掘性能瓶颈，掌握执行阶段的每个细节。而 <code>EXPLAIN</code> 则提供了直观的执行计划视图，帮助评估索引使用、扫描行数以及是否产生临时表或文件排序。在实际落地时，仍针对不同类型的 SQL，需要针对性地编写或改写查询。综合运用本文介绍的技巧与工具，在开发和运维阶段持续关注慢查询和性能指标，既能大幅缩短关键 SQL 的响应时间，也能为业务提供更稳定的系统支撑。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MySQL优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引详解</title>
    <link href="/2022/06/26/mysql-index/"/>
    <url>/2022/06/26/mysql-index/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着数据量的持续增长，如何在海量记录中迅速找到目标数据，成为数据库性能优化的关键。索引正是为了解决这一问题而生，它借助专门的数据结构（如 <code>B+</code> 树），帮助数据库在最短时间内定位所需行。MySQL 提供了多种类型的索引以应对不同场景需求：从最常见的主键索引、唯一索引，到专门面向文本搜索的全文索引，以及地理空间场景所需的空间索引。本文将围绕 MySQL 中的索引概念、实现原理和应用技巧展开探讨，帮助读者在开发和运维中高效利用索引来提升查询性能、维护数据一致性。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>索引是一种数据结构，它为数据库表中的一列或多列数据建立映射关系，使得数据库能够快速定位到数据行，而无需遍历整个表。可以把索引看作是书籍的目录，通过目录能迅速找到对应的章节内容。</p><h2 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul><li>主键索引在创建表时通常直接定义。</li><li>主键索引的特点是：唯一性 + 不允许为空。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD PRIMARY KEY (id);<br></code></pre></div></td></tr></table></figure><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li>唯一索引用于确保列值的唯一性，但允许 <code>NULL</code> 值。</li><li>一个表可以有多个唯一索引。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD UNIQUE (email);<br><br>CREATE UNIQUE INDEX idx_email ON table_name (email);<br></code></pre></div></td></tr></table></figure><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><ul><li>普通索引没有唯一性约束，主要用于提高查询效率。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX idx_name (name);<br><br>CREATE INDEX idx_name ON table_name (name);<br></code></pre></div></td></tr></table></figure><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul><li>复合索引在单个索引中包含多个列，用于多列组合查询。</li><li>遵循最左前缀原则，即必须从索引的最左列开始使用。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX idx_name_age (name, age);<br><br>CREATE INDEX idx_name_age ON table_name (name, age);<br></code></pre></div></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><ul><li>用于对文本字段进行全文搜索。</li><li>支持 <code>MyISAM</code> 和 <code>InnoDB</code> 存储引擎。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD FULLTEXT (content);<br><br>CREATE FULLTEXT INDEX idx_content ON table_name (content);<br></code></pre></div></td></tr></table></figure><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li>用于减少大文本字段的索引大小。</li><li>只索引字段的前 N 个字符。</li></ul><p><strong>创建示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE INDEX idx_email_prefix ON table_name (email(10));<br></code></pre></div></td></tr></table></figure><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>MySQL 中最常用的索引实现结构是 <code>B+</code> 树，其特点是所有数据都存储在叶子节点上，并且叶子节点之间通过链表相连，方便进行范围查询。除此之外，还有哈希索引（主要用于 <code>Memory</code> 存储引擎）以及空间索引（用于 <code>GIS</code> 数据）等。</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>对于 <code>InnoDB</code> 引擎，主键索引采用聚簇索引，即数据行本身存储在索引叶子节点；而其他辅助索引（非聚簇索引）存储的是主键值的引用，这种设计便于通过主键 “回表” 获取完整数据。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p><strong>提升查询效率</strong>：</p><ul><li><p><strong>快速定位数据</strong>：索引可以大幅减少数据库需要扫描的行数，避免全表扫描，从而降低 I/O 操作，提高查询速度。</p></li><li><p><strong>支持范围查询和排序</strong>：<code>B+</code> 树的结构非常适合范围查询和有序数据的查找，可用于加速 <code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code> 等条件查询以及 <code>ORDER BY</code> 排序。</p></li><li><p><strong>覆盖查询</strong>：当查询字段全部包含在索引中时（即覆盖索引），可以避免回表操作，进一步提高查询性能。</p></li></ul></li><li><p><strong>数据完整性与约束：</strong></p></li></ul><ul><li><p><strong>唯一性验证</strong>：唯一索引可以保证数据的唯一性，防止重复数据插入。</p></li><li><p><strong>加速关联查询</strong>：在多表关联时，索引能够大幅降低数据匹配的计算量。</p></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>大幅提升查询效率</strong>：对于数据量较大的表，使用合适的索引可以显著减少查询时间。</li><li><strong>降低 I/O 负担</strong>：索引使得数据库能够直接定位到数据位置，减少磁盘读写次数。</li><li><strong>优化排序和分组</strong>：合适的索引可以使排序、分组操作在索引层面完成，节省计算资源。</li><li><strong>支持数据完整性约束</strong>：唯一索引等有助于保证数据质量。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>增加写操作成本</strong>：插入、更新、删除操作时，除了对数据表进行修改，还需要维护相应的索引结构，这会带来额外的 CPU 和磁盘开销。</li><li><strong>占用额外存储空间</strong>：索引需要额外的磁盘空间保存数据结构和辅助信息。</li><li><strong>设计不当可能影响性能</strong>：索引过多或不合理的索引顺序会导致查询优化器选择不合适的执行计划，反而降低性能。</li><li><strong>维护复杂性</strong>：随着数据变化，索引可能会产生碎片，需要定期整理或重建索引。</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="适合使用索引的场景"><a href="#适合使用索引的场景" class="headerlink" title="适合使用索引的场景"></a>适合使用索引的场景</h3><ul><li><strong>大数据量的表</strong>：当数据量较大时，全表扫描的代价很高，使用索引能大幅提高查询效率。</li><li><strong>外键关联字段</strong>：对于频繁与外键关联的表字段，建立索引能大幅降低数据匹配的计算量。</li><li><strong>频繁的查询操作</strong>：对于经常出现在 <code>WHERE</code> 子句、<code>JOIN</code> 条件、<code>ORDER BY</code> 或 <code>GROUP BY</code> 中的字段，应考虑建立索引。</li><li><strong>需要保证数据唯一性</strong>：主键和唯一索引不仅加速查询，同时确保数据的唯一性，防止重复插入。</li><li><strong>范围查询与排序</strong>：例如查询某个时间段的数据或对结果进行排序时，合适的 B+ 树索引能够显著提高效率。</li><li><strong>覆盖索引场景</strong>：如果查询中涉及的列全部包含在某个索引中，则可以避免回表，达到更快的查询响应。</li></ul><h3 id="谨慎或避免使用索引的场景"><a href="#谨慎或避免使用索引的场景" class="headerlink" title="谨慎或避免使用索引的场景"></a>谨慎或避免使用索引的场景</h3><ul><li><strong>频繁的写操作</strong>：插入、更新、删除操作需要同时维护索引，过多或不合理的索引会降低写入性能。</li><li><strong>小数据量的表</strong>：如果表的数据量很少，全表扫描的开销可能远低于维护索引的额外成本，此时使用索引收益不明显。</li><li><strong>不适宜的查询条件</strong>：<ul><li>使用 <code>LIKE &#39;%keyword%&#39;</code> 的模糊匹配，前置通配符会导致索引失效。</li><li>在查询中对索引字段进行函数操作或类型转换，也可能导致无法利用索引。</li></ul></li><li><strong>动态变化的数据</strong>：数据频繁变动的场景下，索引的统计信息可能不够准确，导致查询优化器选择不佳的执行计划，此时需要额外关注索引维护。</li><li><strong>数据重复且分布均匀的字段</strong>：索引选择性是指索引列中不重复值的比例（公式：<code>选择性 = 不同值的数量 / 总行数</code>）。当索引选择性较低时，大量行具有相同的值，使用索引可能会返回大量数据行，这会导致查询性能不如全表扫描。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="主键索引（Primary-Key-Index）"><a href="#主键索引（Primary-Key-Index）" class="headerlink" title="主键索引（Primary Key Index）"></a>主键索引（Primary Key Index）</h3><ul><li><strong>定义</strong>：表中唯一标识每一行数据的索引，不能为空且必须唯一。</li><li><strong>特点</strong>：<code>InnoDB</code> 中采用聚簇索引，数据行直接存储在主键索引中，查询效率高。</li></ul><h3 id="唯一索引（Unique-Index）"><a href="#唯一索引（Unique-Index）" class="headerlink" title="唯一索引（Unique Index）"></a>唯一索引（Unique Index）</h3><ul><li><strong>定义</strong>：除了能加速查询，还能保证字段值的唯一性。</li><li><strong>特点</strong>：与主键索引类似，但允许存在空值（<code>NULL</code>）的情况（具体实现上可能有所不同）。</li></ul><h3 id="普通索引（Non-Unique-或-Index）"><a href="#普通索引（Non-Unique-或-Index）" class="headerlink" title="普通索引（Non-Unique 或 Index）"></a>普通索引（Non-Unique 或 Index）</h3><ul><li><strong>定义</strong>：主要用于加速查询，不对数据的唯一性做限制。</li><li><strong>特点</strong>：适用于大多数查询场景，创建和维护成本相对较低。</li></ul><h3 id="复合索引（Composite-Index）"><a href="#复合索引（Composite-Index）" class="headerlink" title="复合索引（Composite Index）"></a>复合索引（Composite Index）</h3><ul><li><strong>定义</strong>：在同一索引中包含多个列。</li><li><strong>特点</strong>：遵循 “最左前缀原则”，即查询条件中必须包含索引最左边的列才能有效利用复合索引。</li></ul><h3 id="全文索引（Fulltext-Index）"><a href="#全文索引（Fulltext-Index）" class="headerlink" title="全文索引（Fulltext Index）"></a>全文索引（Fulltext Index）</h3><ul><li><strong>定义</strong>：针对文本数据的全文搜索建立的索引。</li><li><strong>特点</strong>：适用于需要对大段文本进行匹配搜索的场景（例如搜索文章内容），但其灵活性和性能在某些场景下不及专门的搜索引擎，如 <code>Elasticsearch</code>。</li></ul><h3 id="空间索引（Spatial-Index）"><a href="#空间索引（Spatial-Index）" class="headerlink" title="空间索引（Spatial Index）"></a>空间索引（Spatial Index）</h3><ul><li><strong>定义</strong>：专门针对地理信息系统（<code>GIS</code>）数据设计的索引。</li><li><strong>特点</strong>：支持二维或多维数据的快速查询，使用场景较为特殊。</li></ul><h3 id="前缀索引-1"><a href="#前缀索引-1" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li><strong>定义</strong>：对文本字段的部分字符建立索引。</li><li><strong>特点</strong>：可以减少索引体积，但可能会影响索引的选择性和精确度。</li></ul><h2 id="索引与-B-树"><a href="#索引与-B-树" class="headerlink" title="索引与 B+ 树"></a>索引与 B+ 树</h2><h3 id="B-树的结构与核心特点"><a href="#B-树的结构与核心特点" class="headerlink" title="B+ 树的结构与核心特点"></a>B+ 树的结构与核心特点</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><code>B+</code> 树是一种多路平衡搜索树，由内部节点（非叶子节点）和叶子节点构成。</p><ul><li><strong>内部节点</strong>：仅存储键值和指向子节点的指针，不存储实际数据。这些节点起到导航作用，帮助快速定位到正确的叶子节点。</li><li><strong>叶子节点</strong>：存储所有的数据记录或数据记录的指针，是实际存储数据的位置。</li></ul><h4 id="有序性与链表结构"><a href="#有序性与链表结构" class="headerlink" title="有序性与链表结构"></a>有序性与链表结构</h4><ul><li><strong>顺序存储</strong>：所有叶子节点通过双向链表连接，保证了数据的顺序性，这使得范围查询、顺序遍历和排序操作非常高效。</li><li><strong>平衡性</strong>：<code>B+</code> 树是一棵平衡树，所有叶子节点都处在同一深度，因此查询时从根到叶子的路径长度固定，降低了磁盘 I/O 次数。</li></ul><h4 id="节点容量与磁盘适应性"><a href="#节点容量与磁盘适应性" class="headerlink" title="节点容量与磁盘适应性"></a>节点容量与磁盘适应性</h4><ul><li><strong>多路分支</strong>：每个节点可以存储多个键值（通常上百个），从而使树的高度很低，即使面对海量数据，也只需访问少量节点即可定位目标数据。</li><li><strong>数据页存储</strong>：<code>B+</code> 树的节点通常与磁盘页（如 <code>InnoDB</code> 中默认的 <code>16KB</code> 页面）相匹配，充分利用磁盘 I/O 的块读取特性，提高存取效率。</li></ul><h3 id="索引对-B-树的利用"><a href="#索引对-B-树的利用" class="headerlink" title="索引对 B+ 树的利用"></a>索引对 B+ 树的利用</h3><h4 id="聚簇索引（Clustered-Index）"><a href="#聚簇索引（Clustered-Index）" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h4><p><strong>数据与索引共存</strong>：<code>InnoDB</code> 的主键索引采用聚簇索引实现，即数据记录本身存储在 <code>B+</code> 树的叶子节点中。这意味着：</p><ul><li>根据主键查询时，直接在叶子节点上即可找到完整数据，无需额外的 “回表” 操作。</li><li>聚簇索引保证了数据的物理顺序与逻辑顺序一致，这对于范围查询和排序都非常有利。</li></ul><h4 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><ul><li><strong>存储方式</strong>：<code>InnoDB</code> 中除主键外的其他索引（辅助索引）也采用 <code>B+</code> 树结构，但它们的叶子节点并不存储实际数据，而是存储相应的索引键和主键值。</li><li><strong>工作流程</strong>：在执行查询时，如果查询条件使用了辅助索引，则首先通过 <code>B+</code> 树快速定位到匹配的主键值，再通过聚簇索引找到完整记录，这一过程称为 “回表” 操作。</li><li><strong>设计原则</strong>：为减少回表次数，常见的优化方式是建立覆盖索引（即查询所需字段均包含在辅助索引中），从而直接在辅助索引中返回结果。</li></ul><h4 id="数据更新与维护"><a href="#数据更新与维护" class="headerlink" title="数据更新与维护"></a>数据更新与维护</h4><ul><li><strong>插入与分裂</strong>：当向 <code>B+</code> 树中插入数据时，如果目标叶子节点已满，会触发节点分裂，进而调整父节点结构以保持平衡。这一过程虽然会带来额外的维护开销，但由于树的高度较低，整体更新代价一般可控。</li><li><strong>缓冲机制</strong>：<code>InnoDB</code> 采用 <code>Buffer Pool</code> 缓存数据页，频繁访问的 <code>B+</code> 树节点（特别是根节点和较高层的内部节点）往往会被缓存在内存中，从而降低磁盘 I/O，进一步提升查询性能。</li></ul><h4 id="范围查询与顺序扫描"><a href="#范围查询与顺序扫描" class="headerlink" title="范围查询与顺序扫描"></a>范围查询与顺序扫描</h4><ul><li><strong>高效区间查找</strong>：由于 <code>B+</code> 树叶子节点之间按键值顺序相连，当执行范围查询（例如 <code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code> 等）时，只需定位到第一个匹配节点，随后沿链表顺序扫描即可，极大地提高了查询效率。</li><li><strong>排序优化</strong>：如果查询要求返回有序数据，<code>B+</code> 树天然的顺序存储特点能够避免额外的排序操作，直接利用索引顺序返回结果。</li></ul><h3 id="图示及说明"><a href="#图示及说明" class="headerlink" title="图示及说明"></a>图示及说明</h3><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/B+tree&innodb.png" alt="B+树结构"></p><h4 id="B-树索引的多级结构"><a href="#B-树索引的多级结构" class="headerlink" title="B+ 树索引的多级结构"></a>B+ 树索引的多级结构</h4><ul><li><p><strong>根节点（Level 2）</strong></p><ul><li><p>通常在 <code>B+</code> 树的最上层（图中为 <code>Page 1</code>）。</p></li><li><p>根节点中只存储索引键（如 <code>1</code>、<code>28</code>、<code>66</code>）和指向下一层节点的指针（如指向 <code>Page 2</code>、<code>Page 3</code>、<code>Page 4</code>）。</p></li><li><p>在 <code>InnoDB</code> 中，这一层的节点往往会被加载在内存里（<code>Buffer Pool</code>）进行缓存，加快定位子节点的速度。</p></li></ul></li><li><p><strong>内部节点（Level 1）</strong></p><ul><li><p>这些页面（图中 <code>Page 2</code>、<code>Page 3</code>、<code>Page 4</code>）承接根节点的下探，也只存储索引键和指向更底层页面的指针。</p></li><li><p>例如 <code>Page 2</code> 中的键值是 <code>1</code>、<code>10</code>、<code>20</code>，它会分别指向 <code>Page 5</code>、<code>Page 6</code>、<code>Page 7</code> 这三个更底层页面。</p></li><li><p>该层的目的仍然是 “导航”，帮助快速锁定目标页所在的叶子节点，而不存储实际行数据。</p></li></ul></li><li><p><strong>叶子节点（Level 0）</strong></p></li></ul><ul><li><p>这里才是真正存储数据的地方（<code>InnoDB</code> 的聚簇索引模式），在图中就是 <code>Page 5</code>、<code>Page 6</code>、<code>Page 7</code>、… <code>Page 13</code>。</p></li><li><p>例如图中 <code>Page 12</code> 叶子节点里存储了 <code>id=78, name=A1, age=20</code> 这样的行数据。</p></li><li><p>所有记录都存放在这一层，这也是 <code>B+</code> 树和 <code>B</code> 树在概念上的一个主要区别：<code>B+</code> 树把所有数据都集中在最底层的叶子节点。</p></li></ul><h4 id="叶子节点间的双向链表"><a href="#叶子节点间的双向链表" class="headerlink" title="叶子节点间的双向链表"></a>叶子节点间的双向链表</h4><p>从图中可以看出，每个叶子节点与相邻节点之间通过双向链表指针（紫色双向箭头）相互连接。这种设计的好处在于：</p><ol><li><strong>范围查询</strong>：可以只用一次索引查找定位到区间起点，然后依次顺序或逆序遍历叶子节点，即可获得完整区间数据；无需反复返回到上层节点。</li><li><strong>顺序存取</strong>：在做排序、扫描等操作时，利用已排序的叶子节点链表可以极大地减少排序或临时表的开销。</li></ol><h4 id="索引键与数据存储的对应关系"><a href="#索引键与数据存储的对应关系" class="headerlink" title="索引键与数据存储的对应关系"></a>索引键与数据存储的对应关系</h4><ol><li><strong>聚簇索引（主键索引）</strong><ul><li><code>InnoDB</code> 将表的主键作为聚簇索引的索引键，图中展示的示例是按 <code>id</code> 字段构建的 <code>B+</code> 树。</li><li>在叶子节点中，索引键和行数据直接保存在同一数据页中（如 <code>Page 12</code> 存了 <code>id=78, name=A1, age=20</code>）。</li><li>当进行基于主键的等值或范围查询时，可以直接根据 <code>B+</code> 树导航到对应叶子节点，快速拿到完整行。</li></ul></li><li><strong>辅助索引（Secondary Index）</strong><ul><li>虽然图里主要展示的是主键索引的结构，但在 <code>InnoDB</code> 中，对非主键字段建立的索引也还是 <code>B+</code> 树。</li><li>辅助索引的叶子节点并不存储整行数据，而是存储 “索引键 + 主键值”。然后通过这个主键值再去回表查询真正的数据行。</li><li>这就是为什么主键在 <code>InnoDB</code> 中极为重要，因为所有辅助索引都依赖它来定位完整数据。</li></ul></li></ol><h4 id="数据页-Page-与-InnoDB-存储"><a href="#数据页-Page-与-InnoDB-存储" class="headerlink" title="数据页 (Page) 与 InnoDB 存储"></a>数据页 (Page) 与 InnoDB 存储</h4><ol><li><strong>InnoDB 的数据页</strong><ul><li><code>InnoDB</code> 默认的页面大小是 <code>16KB</code>（也可配置为 <code>8KB</code> 或 <code>4KB</code> 等），所以图中的每一个 <code>Page X</code> 可以看成 <code>16KB</code> 大小的 “数据块”。</li><li><code>B+</code> 树的节点结构恰巧和 “页” 一一对应，保证在一次磁盘 I/O 读取一个数据页时，可以得到同一个节点的所有索引信息。</li></ul></li><li><strong>内部节点与叶子节点的页面区别</strong><ul><li>内部节点页中主要是 “（键值，指针）” 的对，用来指导查找方向。</li><li>叶子节点页中同样有 “（键值，指针）” ，不过它的指针指向的是实际行记录（聚簇索引的情况下，直接把整行存在同一个数据页；辅助索引则指向主键）。</li><li>由于 <code>B+</code> 树的高扇出特性，当数据量很大时，树高依然很低，一般只需 <code>3 ~ 4</code> 层就能容纳大量行。</li></ul></li></ol><h4 id="关键细节"><a href="#关键细节" class="headerlink" title="关键细节"></a>关键细节</h4><ul><li><p><strong>Level 2（根节点） 中每个键值对应的下级页面</strong>：</p><ul><li>键值区间 <code>[1 ~ 28) =&gt; Page 2</code></li><li>键值区间 <code>[28 ~ 66) =&gt; Page 3</code></li><li>键值区间 <code>[66 ~ +∞) =&gt; Page 4</code></li></ul><p>在实际实现中，可能还会有区间的右边界等定义，但思路类似。</p></li><li><p><strong>Level 1（内部节点） 示例</strong>：</p><ul><li><code>Page 2</code> 拥有键值 <code>1</code>、<code>10</code>、<code>20</code>，对应下级页面分别是 <code>Page 5</code>、<code>Page 6</code>、<code>Page 7</code>。</li><li>当要查找 <code>id = 15</code> 的记录时，会先比对根节点键值，发现应从 <code>Page 2</code> 继续查找，再在 <code>Page 2</code> 中比对 <code>10</code> 和 <code>20</code>，得知应去 <code>Page 6</code> 找最终记录。</li></ul></li><li><p><strong>Level 0（叶子节点） 中的行数据</strong>：</p><ul><li>图中显示的 <code>Page 12</code>、<code>Page 13</code> 等存放了真实的 <code>(id, name, age)</code> 信息，彼此之间通过双向链表衔接。</li><li>叶子节点中同一个页面里可能包含多行数据，具体行数取决于单行大小和 <code>16KB</code> 页的利用率。</li></ul></li><li><p>单向链表指针（绿色箭头）与双向链表指针（紫色箭头）</p><ul><li>一些指针是自上而下的层级指向。</li><li>一些指针是叶子节点之间的横向连接，既可正向又可反向遍历。</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>B+ <strong>树层级</strong>：从根节点、内部节点到叶子节点，每一层各司其职，能在大规模数据情况下依旧保持相对较低的树高。</li><li><strong>聚簇索引融合数据</strong>：<code>InnoDB</code> 将数据行本身保存在叶子节点（主键索引），这使得基于主键的查询和范围扫描非常高效。</li><li><strong>双向链表适合范围扫描</strong>：叶子节点间的双向链表有效提升了区间查询、排序、分组等操作的性能。</li><li><strong>高度与 I/O</strong>：<code>B+</code> 树的高扇出特性使得访问一个节点就能拿到大量索引信息，树高变低，磁盘 I/O 次数也随之减少。</li><li><strong>回表机制</strong>：对辅助索引的查询，最终还是需要通过主键到聚簇索引中取回完整行数据，这里也体现了主键索引在 <code>InnoDB</code> 中的中心地位。</li></ol><h3 id="对比-B-树"><a href="#对比-B-树" class="headerlink" title="对比 B 树"></a>对比 B 树</h3><table><thead><tr><th>特性</th><th><strong>B树</strong></th><th><strong>B+树</strong></th></tr></thead><tbody><tr><td><strong>节点内容</strong></td><td>每个节点同时存储键值和数据记录。</td><td>只有叶子节点存储数据记录，非叶子节点只存储索引键和指针。</td></tr><tr><td><strong>叶子节点链表</strong></td><td>叶子节点之间没有指针连接。</td><td>叶子节点通过双向链表连接，方便顺序遍历和范围查询。</td></tr><tr><td><strong>查找结束位置</strong></td><td>查询可以在任何一个节点结束（可能是非叶子节点）。</td><td>查询必须到达叶子节点才能结束，所有数据存储在叶子节点中。</td></tr><tr><td><strong>树的层级</strong></td><td>树的层级可能较高，因为节点存储数据占用更多空间。</td><td>树的层级更低，因为节点仅存索引键，容量更大。</td></tr><tr><td><strong>范围查询</strong></td><td>范围查询较为复杂，需要遍历多个子树。</td><td>范围查询高效，从叶子节点链表顺序遍历即可。</td></tr></tbody></table><p><strong>为什么 B+ 树更适合作为 MySQL 的索引结构？</strong></p><ol><li><strong>磁盘读写效率更高</strong><ul><li><code>B+</code> 树的非叶子节点只存索引键和指针，单个节点可以容纳更多索引值，树的高度更低。</li><li>查询时需要从根节点到叶子节点，树高较低意味着磁盘 I/O 次数更少，性能更高。</li></ul></li><li><strong>范围查询更高效</strong><ul><li><code>B+</code> 树的叶子节点通过双向链表连接，范围查询只需定位到范围的起点，然后通过链表顺序扫描即可完成，效率非常高。</li><li><code>B</code> 树没有链表结构，范围查询需要回到上层节点，复杂度更高。</li></ul></li><li><strong>数据顺序性更强</strong><ul><li>所有数据都存储在叶子节点，并按键值顺序排列，这种顺序存储方便支持 <code>ORDER BY</code>、<code>GROUP BY</code> 等操作，而无需额外排序。</li></ul></li><li><strong>占用空间更少</strong><ul><li><code>B+</code> 树非叶子节点不存实际数据，因此整体存储空间更小，可以容纳更多索引，减少磁盘访问次数。</li></ul></li><li><strong>一致的查询路径</strong><ul><li>在 <code>B+</code> 树中，所有查询都会到达叶子节点，而 <code>B</code> 树可能在不同层结束。</li><li>一致的路径方便优化查询逻辑，并简化范围查询的实现。</li></ul></li></ol><p>综上，<code>B+</code> 树通过降低树高、优化范围查询、支持顺序存储等特性，大大提高了 MySQL 的查询效率，相比于 <code>B</code> 树是个更优的选择。</p><h2 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h2><h3 id="MyISAM-索引"><a href="#MyISAM-索引" class="headerlink" title="MyISAM 索引"></a>MyISAM 索引</h3><p><code>MyISAM</code> 索引通常与 <code>InnoDB</code> 索引进行对比，如下：</p><ul><li><strong>存储结构与数据存放</strong>：<ul><li><strong>MyISAM：</strong> 数据和索引分别存储在不同的文件中；索引结构一般采用 <code>B-Tree</code>（在本质上也可以认为是 <code>B+</code> 树结构，只是在官方手册或多数资料中常直接称为 <code>B-Tree</code> 索引）。</li><li><strong>InnoDB：</strong> 数据和索引存储在同一表空间中，且采用聚集索引（主键索引）存储数据。</li></ul></li><li><strong>事务支持与锁机制</strong>：<ul><li><strong>MyISAM：</strong> 不支持事务，使用表级锁，适合读多写少的场景。</li><li><strong>InnoDB：</strong> 支持事务、行级锁和外键约束，适用于高并发、事务性要求较高的应用。</li></ul></li><li><strong>全文索引支持</strong>：<ul><li><strong>MyISAM：</strong> 长期支持全文索引。</li><li><strong>InnoDB：</strong> 从 MySQL 5.6 开始也支持全文索引，但在实现细节和性能上有所不同。</li></ul></li></ul><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>哈希索引是基于哈希表实现的索引结构，查找等值匹配时速度极快。</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>仅支持等值查询，不支持范围查询（如 <code>BETWEEN</code>、<code>&lt;</code>、<code>&gt;</code> 等）。</li><li>无法用于排序操作，因为哈希表内部没有顺序性。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>主要用于 <code>Memory</code> 存储引擎中，对于仅依赖精确匹配的场景非常适合。</p><h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><h4 id="基本特性-1"><a href="#基本特性-1" class="headerlink" title="基本特性"></a>基本特性</h4><p>空间索引主要用于存储和查询地理空间数据（<code>GIS</code> 数据），支持数据类型如 <code>POINT</code>、<code>LINESTRING</code>、<code>POLYGON</code> 等。</p><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>常用 <code>R-Tree</code> 算法来实现，对空间数据进行高效的范围搜索和邻近搜索。</p><h4 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h4><ul><li><code>MyISAM</code> 一直支持空间索引。</li><li><code>InnoDB</code> 从较新的版本（如 MySQL 8.0）开始也支持空间索引。</li></ul><h3 id="前缀索引-2"><a href="#前缀索引-2" class="headerlink" title="前缀索引"></a>前缀索引</h3><h4 id="基本特性-2"><a href="#基本特性-2" class="headerlink" title="基本特性"></a>基本特性</h4><p>前缀索引是指只对字符类（如 <code>VARCHAR</code>、<code>TEXT</code>）字段的前若干字符建立索引，而不是整个字段，有助于减少索引占用的存储空间和提高索引构建效率。</p><h4 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>匹配能力不如全值索引精确，查询时可能需要回表验证。</li><li>在设计时需要平衡前缀长度，既要尽可能覆盖区分性，又要控制索引大小。</li></ul><h3 id="全文索引-1"><a href="#全文索引-1" class="headerlink" title="全文索引"></a>全文索引</h3><h4 id="基本特性-3"><a href="#基本特性-3" class="headerlink" title="基本特性"></a>基本特性</h4><p>全文索引用于对文本内容进行自然语言全文搜索，支持复杂的关键字匹配、布尔搜索等。</p><p>支持情况</p><ul><li><code>MyISAM</code> 一直支持全文索引，适合需要搜索大段文本数据的应用（如博客、论坛等）。</li><li><code>InnoDB</code> 从 MySQL 5.6 起也开始支持全文索引，但其实现和性能特性与 <code>MyISAM</code> 有所不同。</li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>全文索引更适合非结构化或半结构化的文本搜索，对于结构化数据推荐使用常规 <code>B-Tree</code> 索引。</p><h2 id="索引统计信息"><a href="#索引统计信息" class="headerlink" title="索引统计信息"></a>索引统计信息</h2><h3 id="基本特性-4"><a href="#基本特性-4" class="headerlink" title="基本特性"></a>基本特性</h3><p>MySQL 内部会对每个索引维护统计信息，如基数、分布情况等，这些信息帮助查询优化器选择最优执行计划。</p><h3 id="更新与维护"><a href="#更新与维护" class="headerlink" title="更新与维护"></a>更新与维护</h3><ul><li>数据变动较大时，统计信息可能需要重新计算；可以通过 <code>ANALYZE TABLE table_name</code> 命令手动更新或通过 <code>SHOW INDEX FROM table_name</code> 查看或评估某个索引的基数。</li><li>一般情况下无需手动干预，优化器会自动利用统计信息进行判断。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>统计信息不准确可能导致查询优化器选择非最优方案，因此在大批量数据更新后适时更新统计信息是个好习惯。</p><h2 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h2><h3 id="基本特性-5"><a href="#基本特性-5" class="headerlink" title="基本特性"></a>基本特性</h3><p>当查询条件中涉及多个不同的索引列时，MySQL 可能采用索引合并（<code>Index Merge</code>）策略，即同时利用多个索引进行过滤，再将结果合并后返回。</p><h3 id="合并方式"><a href="#合并方式" class="headerlink" title="合并方式"></a>合并方式</h3><ul><li><strong>索引交集：</strong> 同时满足多个索引条件的记录。</li><li><strong>索引并集：</strong> 满足任一索引条件的记录，再通过额外过滤得到最终结果。</li></ul><h3 id="使用注意-1"><a href="#使用注意-1" class="headerlink" title="使用注意"></a>使用注意</h3><ul><li>索引合并可以在某些情况下提高查询效率，但也可能引入额外的合并开销。</li><li>优化时需要关注 <code>EXPLAIN</code> 输出，评估是否需要调整索引设计以避免依赖过多的索引合并操作。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>索引既是 MySQL 数据库中提升查询速度的利器，也是一把双刃剑：在查询场景中，合理设计索引能成倍地减少磁盘扫描量，大大加速等值、范围及排序等各类操作；在写入场景中，索引维护会增加额外开销，不当的索引布局反而拖慢插入和更新的性能。掌握索引原理与应用场景，将帮助数据库开发者和运维人员在面对各种复杂查询需求时，找到性能与存储之间的最佳平衡点，为系统提供更卓越的数据处理能力。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MySQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础命令</title>
    <link href="/2022/04/22/docker-commands/"/>
    <url>/2022/04/22/docker-commands/</url>
    
    <content type="html"><![CDATA[<p>随着容器化技术的兴起，Docker已成为现代软件开发和部署的核心工具之一。Docker提供了一种高效的方式来打包、分发和运行应用，无论是在本地开发环境还是在复杂的生产环境中。本文将介绍Docker的基本命令，帮助新用户快速掌握如何使用Docker来创建和管理容器。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p><p>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></p><p>远程仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 卸载旧版本</span><br>sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br><br><span class="hljs-comment"># 设置yum源</span><br>sudo yum install -y yum-utils<br>sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br><br><span class="hljs-comment"># 安装最新版</span><br>sudo yum install docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># 查看版本列表</span><br>yum list docker-ce --showduplicates | sort -r<br><br><span class="hljs-comment"># 安装指定版本</span><br>sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io<br></code></pre></div></td></tr></table></figure><h2 id="生命周期理解"><a href="#生命周期理解" class="headerlink" title="生命周期理解"></a>生命周期理解</h2><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/docker-commands-link.png"></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 镜像搜索</span><br>docker search [名称]<br><br><span class="hljs-comment"># 获取镜像</span><br>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<br><br><span class="hljs-comment"># 查看镜像列表</span><br>docker images [选项] [名称]<br>-a：列出所有镜像（包含中间映像层）<br>-q：只显示镜像id<br>名称：只搜索相关的images，相当于过滤条件<br>-f：其他过滤<br><br><span class="hljs-comment"># 查看docker占用空间</span><br>docker system df<br><br><span class="hljs-comment"># 查看虚悬(旧)镜像</span><br>docker images -f dangling=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 虚悬镜像删除</span><br>docker image prune<br><br><span class="hljs-comment"># 删除镜像</span><br>docker rmi [选项] 镜像名:tag | 镜像id<br>-f：强制删除<br><br><span class="hljs-comment"># 构建镜像</span><br>docker build [选项] PATH<br>-f：指定Dockerfile路径<br>-t：指定镜像名及标签<br><br><span class="hljs-comment"># 镜像导入</span><br>docker load -i 名称.tar<br><br><span class="hljs-comment"># 镜像打包</span><br>docker save 镜像名 -o 名称.tar<br><br><span class="hljs-comment"># 镜像推送</span><br>docker push USERNAME/IMAGES_NAME<br></code></pre></div></td></tr></table></figure><h2 id="容器基础"><a href="#容器基础" class="headerlink" title="容器基础"></a>容器基础</h2><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 运行容器</span><br>docker run [选项] 镜像名:tag|镜像id<br>-f：--name 起别名<br>-d：后台启动<br>-p：端口映射（【宿主机端口】:【容器内部端口】）<br>-v [:ro]：数据卷映射（【宿主机路径】:【容器内路径】），ro容器只读不写，路径不存在则自动创建<br>--mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=宿主机路径(绝对),target=容器路径[,<span class="hljs-built_in">readonly</span>]：挂载目录，路径不存在报错<br>--network [网桥名]：指定网桥<br><br><span class="hljs-comment"># 启动/关闭/重启/强杀</span><br>docker start 容器名或id<br>docker stop 容器名或id<br>docker restart 容器名或id<br>docker <span class="hljs-built_in">kill</span> 容器名或id<br><br><span class="hljs-comment"># 删除容器</span><br> docker [container] rm [选项] 容器名或id<br> docker container prune   <span class="hljs-comment"># 删除所有终止状态的容器</span><br> -f：强制<br><br><span class="hljs-comment"># 组合命令</span><br>docker rm -f $(docker ps -aq)<br><br><span class="hljs-comment"># 容器日志</span><br>docker <span class="hljs-built_in">log</span> [选项] 容器名或id<br>-f：实时展示<br>-tf：加入时间戳的实时展示<br>--tail：只显示尾部日志<br><br><span class="hljs-comment"># 容器内部进程</span><br>docker top 容器名或id<br><br><span class="hljs-comment"># 容器细节</span><br>docker inspect 容器名或id<br><br><span class="hljs-comment"># 进入容器</span><br>docker <span class="hljs-built_in">exec</span> [选项] 容器名或id bash<br>-i：交互模式<br>-t：分配一个伪终端<br><br><span class="hljs-comment"># 复制文件</span><br>docker cp 文件|目录 容器名或id:容器内资源路径<br>docker cp 容器名或id:容器内资源路径 主机目录<br><br><span class="hljs-comment"># 容器打包</span><br>docker commit -m <span class="hljs-string">&quot;描述信息&quot;</span> -a <span class="hljs-string">&quot;作者信息&quot;</span> （容器id或者名称） 打包的镜像名称:标签<br></code></pre></div></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 查看网络信息</span><br>docker network ls<br><br><span class="hljs-comment"># 新建网桥</span><br>docker network create [选项] 网桥名称<br>-d：网络类型，有 bridge overlay<br><br><span class="hljs-comment"># 查看网桥</span><br>docker inspect 网桥名<br><br><span class="hljs-comment"># 删除网桥</span><br>docker network rm 网桥名称<br></code></pre></div></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><table><thead><tr><th><strong>保留字</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的 <code>第一个指令必须是FROM</code></strong></td></tr><tr><td><strong>MAINTAINER</strong></td><td><strong>镜像维护者的姓名和邮箱地址</strong></td></tr><tr><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td><strong>WORKDIR</strong></td><td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td><strong>ENV</strong></td><td><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td><strong>COPY</strong></td><td><strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td><strong>VOLUME</strong></td><td><strong>用来定义容器运行时可以挂载到宿主机的目录，用于数据保存和持久化工作</strong></td></tr><tr><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">networks:</span> <span class="hljs-comment"># 定义网桥</span><br>  <span class="hljs-attr">blog_bridge:</span> <br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:8080&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/blog/nginx/html:/usr/share/nginx/html</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/blog/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># Nginx内部权限</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.27</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/blog/redis/redis.conf:/usr/local/etc/redis/redis.conf</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-string">redis-server</span> <span class="hljs-string">/usr/local/etc/redis/redis.conf</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">daocloud.io/library/rabbitmq:3.8.7</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-literal">no</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5672:5672&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;15672:15672&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/blog/data:/var/lib/rabbitmq/</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br>  <span class="hljs-attr">blog:</span><br>    <span class="hljs-attr">build:</span> <br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span>   <span class="hljs-comment"># Dockerfile所在目录</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile</span><span class="hljs-comment"># 构建文件</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8888:8888&quot;</span><br>    <span class="hljs-attr">depends_on:</span><span class="hljs-comment"># 依赖于哪些容器</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">rabbitmq</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，读者应能够理解Docker的核心功能和操作命令，包括如何安装Docker、管理容器的生命周期、操作镜像、配置网络，以及如何使用Dockerfile和Docker Compose来构建和编排多容器应用。掌握这些基础知识将使开发者能够更有效地利用Docker，提升应用的开发、测试和部署效率。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令</title>
    <link href="/2022/04/21/git-commands/"/>
    <url>/2022/04/21/git-commands/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文将系统地介绍 <code>Git</code> 在实际开发中常用的命令及其用法，包括仓库初始化、配置管理、远程操作、分支和标签管理、子模块使用等。对于刚入门的读者，本文能帮助快速了解基础操作；对于已经熟悉 <code>Git</code> 的开发者，也可将其当作一份全面的参考手册或速查表。</p><h2 id="创建及配置"><a href="#创建及配置" class="headerlink" title="创建及配置"></a>创建及配置</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><code>git init</code> 用于在当前目录下创建一个新的 <code>Git</code> 仓库。执行后，该目录会被 <code>Git</code> 识别为仓库，并创建 <code>.git</code> 目录来存储版本控制信息。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 在当前目录创建一个新的 Git 仓库。</span><br>git init<br><br><span class="hljs-comment"># 在指定目录 &lt;directory&gt; 下初始化 Git 仓库。</span><br>git init &lt;directory&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--bare</code>：创建一个裸仓库（不含工作区的 <code>Git</code> 仓库，通常用于远程仓库）。</li><li><code>--template=&lt;directory&gt;</code>：指定初始化时使用的模板目录。</li><li><code>--separate-git-dir=&lt;git-dir&gt;</code>：指定 <code>.git</code> 目录的存放位置，而非默认的当前目录。</li><li><code>--shared[=&lt;permissions&gt;]</code>：用于多人协作时设置共享权限（适用于团队开发的 <code>Git</code> 服务器）。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个裸仓库 myrepo.git，适用于远程仓库。</span><br>git init --bare myrepo.git<br><br><span class="hljs-comment"># 将 Git 版本控制信息存储在 /path/to/git-dir，而不影响当前目录结构。</span><br>git init --separate-git-dir=/path/to/git-dir<br></code></pre></div></td></tr></table></figure><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p><code>git config</code> 用于设置 <code>Git</code> 的用户信息、编辑器、合并策略等全局或局部配置。</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 设置 Git 的某个配置项。</span><br>git config [--global|--<span class="hljs-built_in">local</span>|--system] &lt;key&gt; &lt;value&gt;<br><br><span class="hljs-comment"># 查看当前所有的 Git 配置项。</span><br>git config --list<br><br><span class="hljs-comment"># 获取某个配置项的值。</span><br>git config &lt;key&gt;<br><br><span class="hljs-comment"># 删除某个配置项。</span><br>git config --<span class="hljs-built_in">unset</span> &lt;key&gt;<br><br><span class="hljs-comment"># 手动编辑配置文件。</span><br>git config --edit<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--local</code>：只对当前 <code>Git</code> 仓库生效（默认），配置存储在 <code>.git/config</code>。</li><li><code>--global</code>：对当前用户所有 <code>Git</code> 仓库生效，配置存储在 <code>~/.gitconfig</code>。</li><li><code>--system</code>：对系统所有用户生效，配置存储在 <code>/etc/gitconfig</code>。</li><li><code>--unset</code>：删除指定的配置项。</li><li><code>--edit</code>：直接编辑 <code>Git</code> 配置文件。</li></ul><h4 id="常见配置项"><a href="#常见配置项" class="headerlink" title="常见配置项"></a>常见配置项</h4><ul><li><code>user.name</code>：设置 <code>Git</code> 用户名。</li><li><code>user.email</code>：设置 <code>Git</code> 用户邮箱。</li><li><code>core.editor</code>：设置默认编辑器。</li><li><code>core.ignorecase</code>：设置是否忽略大小写（<code>Windows</code> 常用）。</li><li><code>core.autocrlf</code>：处理换行符（<code>true</code>：<code>Windows</code>，<code>input</code>：<code>Linux/macOS</code>）。</li><li><code>alias.&lt;shortcut&gt;</code>：创建 <code>Git</code> 命令别名。</li><li><code>diff.tool</code>：设置默认的 <code>diff</code> 工具。</li><li><code>merge.tool</code>：设置默认的合并工具。</li><li><code>push.default</code>：设置 <code>git push</code> 默认行为（如 <code>simple</code> 或 <code>matching</code>）。</li><li><code>credential.helper</code>  设置 <code>Git</code> 认证方式，如 <code>cache</code> 或 <code>store</code>。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 设置 Git 用户名和邮箱，适用于所有仓库。</span><br>git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your.email@example.com&quot;</span><br><br><span class="hljs-comment"># 创建 git st 作为 git status 的别名。</span><br>git config --global alias.st status<br><br><span class="hljs-comment"># 将默认编辑器设置为 Vim。</span><br>git config --global core.editor <span class="hljs-string">&quot;vim&quot;</span><br><br><span class="hljs-comment"># 记住 Git 认证信息，避免每次输入密码。</span><br>git config --global credential.helper store<br></code></pre></div></td></tr></table></figure><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p><code>git remote</code> 用于管理本地 <code>Git</code> 仓库和远程仓库的连接信息，例如添加、删除、查看远程仓库。</p><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 查看当前远程仓库的名称及对应的 URL。</span><br>git remote -v<br><br><span class="hljs-comment"># 添加远程仓库。</span><br>git remote add &lt;name&gt; &lt;url&gt;<br><br><span class="hljs-comment"># 删除远程仓库。</span><br>git remote remove &lt;name&gt;<br><br><span class="hljs-comment"># 重命名远程仓库。</span><br>git remote rename &lt;old_name&gt; &lt;new_name&gt;<br><br><span class="hljs-comment"># 修改远程仓库的 URL。</span><br>git remote set-url &lt;name&gt; &lt;new_url&gt;<br><br><span class="hljs-comment"># 查看远程仓库的详细信息，包括 URL、跟踪的分支等。</span><br>git remote show &lt;name&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-v</code>：显示远程仓库的详细 URL。</li><li><code>add &lt;name&gt; &lt;url&gt;</code>：添加远程仓库。</li><li><code>remove &lt;name&gt;</code>：删除远程仓库。</li><li><code>rename &lt;old&gt; &lt;new&gt;</code>：重命名远程仓库。</li><li><code>set-url &lt;name&gt; &lt;url&gt;</code>：修改远程仓库 URL。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 添加名为 origin 的远程仓库。</span><br>git remote add origin https://github.com/user/repo.git<br><br><span class="hljs-comment"># 删除名为 origin 的远程仓库。</span><br>git remote remove origin<br><br><span class="hljs-comment"># 将 origin 重命名为 upstream。</span><br>git remote rename origin upstream<br></code></pre></div></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p><code>git clone</code> 用于克隆远程 <code>Git</code> 仓库到本地。</p><h4 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 克隆整个远程仓库到本地。</span><br>git <span class="hljs-built_in">clone</span> &lt;repository_url&gt;<br><br><span class="hljs-comment"># 克隆远程仓库到指定目录 &lt;directory&gt;。</span><br>git <span class="hljs-built_in">clone</span> &lt;repository_url&gt; &lt;directory&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;repository_url&gt;</code>：远程仓库 <code>URL</code>（<code>HTTP/HTTPS/SSH</code>）。</li><li><code>&lt;directory&gt;</code>：指定克隆后的目录名称。</li><li><code>--bare</code>：克隆为裸仓库（无工作区）。</li><li><code>--mirror</code>：完全镜像克隆，包括远程分支、标签等。</li><li><code>--branch &lt;branch&gt;</code>：指定克隆的分支。</li><li><code>--depth &lt;depth&gt;</code>：仅克隆指定深度的提交（加速克隆）。</li><li><code>--single-branch</code>：仅克隆单个分支（默认 <code>main</code>/<code>master</code>）。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 克隆 GitHub 仓库到本地。</span><br>git <span class="hljs-built_in">clone</span> https://github.com/user/repo.git<br><br><span class="hljs-comment"># 仅克隆 dev 分支，并限制提交历史为 1 层。</span><br>git <span class="hljs-built_in">clone</span> -b dev --depth 1 https://github.com/user/repo.git<br></code></pre></div></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p><code>git fetch</code> 从远程仓库拉取最新的变更，但不会合并到本地分支。</p><h4 id="基本用法-4"><a href="#基本用法-4" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 拉取远程仓库 &lt;remote&gt; 的所有更新。</span><br>git fetch &lt;remote&gt;<br><br><span class="hljs-comment"># 仅拉取远程 &lt;branch&gt; 分支的更新。</span><br>git fetch &lt;remote&gt; &lt;branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;remote&gt;</code>：远程仓库名称（如 <code>origin</code>）。</li><li><code>&lt;branch&gt;</code>：指定拉取的远程分支。</li><li><code>--all</code>：拉取所有远程仓库的更新。</li><li><code>--prune</code>：删除本地已不存在的远程分支。</li><li><code>--depth &lt;depth&gt;</code>：仅拉取指定深度的提交。</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 从 origin 远程仓库拉取所有更新。</span><br>git fetch origin<br><br><span class="hljs-comment"># 同步远程分支，并删除已被删除的远程分支。</span><br>git fetch origin --prune<br></code></pre></div></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><p><code>git pull</code> 等价于 <code>git fetch</code> + <code>git merge</code>，即拉取远程分支的最新代码并合并到当前分支。</p><h4 id="基本用法-5"><a href="#基本用法-5" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 从远程仓库 &lt;remote&gt; 拉取 &lt;branch&gt; 分支的更新并合并。</span><br>git pull &lt;remote&gt; &lt;branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;remote&gt;</code>：远程仓库名称。</li><li><code>&lt;branch&gt;</code>：远程分支名称。</li><li><code>--rebase</code>：使用 <code>rebase</code> 而非 <code>merge</code> 合并更新。</li><li><code>--depth &lt;depth&gt;</code>：限制拉取的提交历史深度。</li><li><code>--no-commit</code>：拉取更新但不自动提交。</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 从 origin 远程仓库拉取 main 分支的最新代码并合并。</span><br>git pull origin main<br><br><span class="hljs-comment"># 以 rebase 方式拉取并应用远程更新。</span><br>git pull --rebase origin main<br></code></pre></div></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><h4 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a><strong>作用</strong></h4><p><code>git push</code> 用于将本地分支的提交推送到远程仓库。</p><h4 id="基本用法-6"><a href="#基本用法-6" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将本地 &lt;branch&gt; 推送到远程仓库 &lt;remote&gt;。</span><br>git push &lt;remote&gt; &lt;branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;remote&gt;</code>：远程仓库名称。</li><li><code>&lt;branch&gt;</code>：要推送的本地分支。</li><li><code>--force</code> (<code>-f</code>)：强制推送，可能导致远程提交丢失。</li><li><code>--delete</code>：删除远程分支。</li><li><code>--set-upstream</code> (<code>-u</code>)：关联本地分支与远程分支。</li><li><code>--all</code>：推送所有分支。</li><li><code>--tags</code>：推送所有标签。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将 main 分支推送到远程 origin 仓库。</span><br>git push origin main<br><br><span class="hljs-comment"># 删除远程 feature-branch 分支。</span><br>git push origin --delete feature-branch<br><br><span class="hljs-comment"># 强制推送 main 分支，覆盖远程内容（需谨慎）。</span><br>git push -f origin main<br></code></pre></div></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><h4 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h4><p><code>git status</code> 用于查看当前 <code>Git</code> 仓库的状态，主要包括：</p><ul><li>工作目录中有哪些文件被修改或未跟踪。</li><li>哪些文件已添加到暂存区但未提交。</li><li>当前所在分支及是否有未提交的更改。</li></ul><h4 id="基本用法-7"><a href="#基本用法-7" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示工作区和暂存区的文件状态。</span><br>git status<br></code></pre></div></td></tr></table></figure><h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>执行 <code>git status</code> 后，可能看到以下几种状态：</p><ul><li><code>Untracked files</code>：未跟踪的文件，即 <code>Git</code> 还未管理的文件（新文件）。</li><li><code>Changes not staged for commit</code>：已被修改但未添加到暂存区的文件。</li><li><code>Changes to be committed</code>：已添加到暂存区但未提交的文件。</li><li><code>Your branch is ahead of &#39;origin/main&#39; by X commits</code>：当前分支比远程分支多 <code>X</code> 个提交，需要 <code>git push</code>。</li><li><code>nothing to commit, working tree clean</code>：没有任何变更，工作目录是干净的。</li></ul><h4 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-s</code> 或 <code>--short</code>：显示简短格式的状态信息。</li><li><code>-b</code> 或 <code>--branch</code>：显示当前分支信息。</li><li><code>--ignored</code>：也显示被 <code>.gitignore</code> 忽略的文件。</li></ul><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 使用简短格式显示状态。</span><br>git status -s<br><br><span class="hljs-comment"># 输出示例：</span><br>M file1.txt  <span class="hljs-comment"># 修改但未暂存</span><br>A  file2.txt  <span class="hljs-comment"># 新增文件已暂存</span><br>?? file3.txt  <span class="hljs-comment"># 未跟踪文件</span><br><br><br><br><span class="hljs-comment"># 显示当前分支信息。</span><br>git status -b<br><br><span class="hljs-comment"># 输出示例：</span><br><span class="hljs-comment">## main</span><br></code></pre></div></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><h4 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h4><p><code>git diff</code> 用于比较不同版本的文件，常用于：</p><ul><li>比较工作区和暂存区的文件差异。</li><li>比较暂存区和最新提交之间的差异。</li><li>比较两个分支之间的差异。</li><li>比较某次提交与当前分支的差异。</li></ul><h4 id="基本用法-8"><a href="#基本用法-8" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示工作区和暂存区之间的差异。</span><br>git diff<br><br><span class="hljs-comment"># 显示暂存区和上次提交之间的差异。</span><br>git diff --cached<br><br><span class="hljs-comment"># 显示工作区和最新提交之间的差异。</span><br>git diff HEAD<br><br><span class="hljs-comment"># 比较两个分支的差异。</span><br>git diff &lt;branch1&gt; &lt;branch2&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--staged</code> 或 <code>--cached</code>：比较暂存区和上次提交的差异。</li><li><code>--name-only</code>：只显示有差异的文件名。</li><li><code>--name-status</code>：显示文件的变更类型（新增、删除、修改）。</li><li><code>--color</code>：强制启用颜色高亮。</li><li><code>--word-diff</code>：逐词显示变更内容，而非逐行。</li><li><code>--stat</code>：显示统计信息，如修改行数。</li><li><code>-p</code>：显示补丁格式的详细修改内容。</li></ul><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示有变更的文件。</span><br>git diff --name-only<br><br><span class="hljs-comment"># 输出示例：</span><br>file1.txt<br>file2.txt<br><br><br><br><span class="hljs-comment"># 显示统计信息。</span><br>git diff --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 输出示例：</span><br>file1.txt | 10 +++++-----<br>file2.txt |  2 +-<br>2 files changed, 7 insertions(+), 5 deletions(-)<br><br><br><br><span class="hljs-comment"># 比较当前版本和上一个版本的差异。</span><br>git diff HEAD~1 HEAD<br><br><span class="hljs-comment"># 比较 main 和 feature-branch 分支的差异。</span><br>git diff main feature-branch<br></code></pre></div></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><h4 id="作用-9"><a href="#作用-9" class="headerlink" title="作用"></a>作用</h4><p><code>git log</code>：用于查看 <code>Git</code> 提交历史，包括提交信息、提交人、时间、哈希值等。</p><h4 id="基本用法-9"><a href="#基本用法-9" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示完整的提交历史。</span><br>git <span class="hljs-built_in">log</span><br></code></pre></div></td></tr></table></figure><h4 id="参数说明-9"><a href="#参数说明-9" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-p</code>：显示每次提交的详细代码变更（<code>patch</code>）。</li><li><code>--oneline</code>：每条提交仅显示一行（简洁格式）。</li><li><code>--graph</code>：以 ASCII 图形方式展示分支结构。</li><li><code>--decorate</code>：显示分支、标签等附加信息。</li><li><code>--author=&lt;name&gt;</code>：仅显示特定作者的提交。</li><li><code>--since=&lt;date&gt; / --until=&lt;date&gt;</code>：显示特定时间范围内的提交。</li><li><code>--grep=&lt;pattern&gt;</code>：按提交信息搜索。</li><li><code>--stat</code>：显示每次提交修改的文件及变更统计。</li><li><code>--abbrev-commit</code>：仅显示短哈希值。</li></ul><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 以图形方式显示所有分支的提交历史。</span><br>git <span class="hljs-built_in">log</span> --oneline --graph --decorate --all<br><br><span class="hljs-comment"># 输出示例：</span><br>f1e2c1b (HEAD -&gt; main, origin/main) 修复bug<br>* d3b4a6d 添加新功能<br>* a1c2b3d 初始化项目<br><br><br><br><span class="hljs-comment"># 查看 Alice 提交的记录。</span><br>git <span class="hljs-built_in">log</span> --author=<span class="hljs-string">&quot;Alice&quot;</span><br><br><span class="hljs-comment"># 查看 2024 年 1 月份的提交记录。</span><br>git <span class="hljs-built_in">log</span> --since=<span class="hljs-string">&quot;2024-01-01&quot;</span> --until=<span class="hljs-string">&quot;2024-02-01&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><h4 id="作用-10"><a href="#作用-10" class="headerlink" title="作用"></a>作用</h4><p><code>git reflog</code> 记录所有对分支 <code>HEAD</code> 进行的操作（切换分支、提交、合并、<code>reset</code> 等）。</p><h4 id="基本用法-10"><a href="#基本用法-10" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示所有 HEAD 变更历史。</span><br>git reflog<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-10"><a href="#参数说明-10" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>expire=&lt;time&gt;</code>：设定日志保留时间（如 <code>90 days</code>）。</li><li><code>--all</code>：显示所有引用的变更（包括分支、标签等）。</li><li><code>--grep=&lt;pattern&gt;</code>：按提交信息搜索。</li></ul><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git reflog<br><br><span class="hljs-comment"># 输出示例：</span><br>f1e2c1b (HEAD -&gt; main) HEAD@&#123;0&#125;: commit: 修复bug<br>d3b4a6d HEAD@&#123;1&#125;: checkout: moving from dev to main<br>a1c2b3d HEAD@&#123;2&#125;: commit: 初始化项目<br><br><br><br><span class="hljs-comment"># 清除超过 30 天的引用日志。</span><br>git reflog expire --expire=30.days<br></code></pre></div></td></tr></table></figure><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><h4 id="作用-11"><a href="#作用-11" class="headerlink" title="作用"></a>作用</h4><p><code>git blame</code> 用于追踪文件每一行的变更历史，显示是谁在什么时候修改了该行。</p><h4 id="基本用法-11"><a href="#基本用法-11" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示文件 &lt;file&gt; 的行级提交信息。</span><br>git blame &lt;file&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-11"><a href="#参数说明-11" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-L &lt;start&gt;,&lt;end&gt;</code>：仅显示指定行范围的提交信息。</li><li><code>-C</code>：追踪代码块在文件内的移动。</li><li><code>--date</code>：显示日期格式（<code>short</code>, <code>relative</code>, <code>iso</code> 等）。</li><li><code>-w</code>：忽略空白字符的变更。</li></ul><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示 file.txt 第 10 行到 20 行的修改记录。</span><br>git blame -L 10,20 file.txt<br><br><span class="hljs-comment"># 输出示例：</span><br>f1e2c1b  (Alice  2024-08-10)  10  修复错误<br>d3b4a6d  (Bob    2024-08-05)  11  优化代码<br><br><br><br><span class="hljs-comment"># 以 ISO 日期格式显示提交时间。</span><br>git blame --date=iso file.txt<br></code></pre></div></td></tr></table></figure><h3 id="git-shortlog"><a href="#git-shortlog" class="headerlink" title="git shortlog"></a>git shortlog</h3><h4 id="作用-12"><a href="#作用-12" class="headerlink" title="作用"></a>作用</h4><p><code>git shortlog</code> 按作者分类并统计提交次数。</p><h4 id="基本用法-12"><a href="#基本用法-12" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示简要的提交历史。</span><br>git shortlog<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-12"><a href="#参数说明-12" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-s</code>：仅显示每个作者的提交数量。</li><li><code>-n</code>：按提交数量排序。</li><li><code>-e</code>：显示作者的电子邮件。</li></ul><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 按提交数量排序。</span><br>git shortlog -s -n<br><br><span class="hljs-comment"># 输出示例：</span><br>120 Alice<br>85 Bob<br>45 Charlie<br><br><br><br><span class="hljs-comment"># 显示提交数量和邮箱。</span><br>git shortlog -s -e<br><br><span class="hljs-comment"># 输出示例：</span><br>120 Alice &lt;alice@example.com&gt;<br>85 Bob &lt;bob@example.com&gt;<br></code></pre></div></td></tr></table></figure><h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><h4 id="作用-13"><a href="#作用-13" class="headerlink" title="作用"></a>作用</h4><p><code>git show</code> 显示特定提交、分支或对象（标签、文件）的详细信息，包括提交信息、变更的代码等。</p><h4 id="基本用法-13"><a href="#基本用法-13" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示指定提交的详细信息。</span><br>git show &lt;commit&gt;<br><br><span class="hljs-comment"># 显示指定分支的最新提交详情。</span><br>git show &lt;branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-13"><a href="#参数说明-13" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;commit&gt;</code>：指定提交哈希值。</li><li><code>&lt;branch&gt;</code>：指定分支名，查看最近提交详情。</li><li><code>--stat</code>：仅显示文件变更统计信息。</li><li><code>-p</code>：显示补丁格式（默认）。</li><li><code>--name-only</code>：仅显示修改的文件名。</li><li><code>--name-status</code>：显示文件变更类型（新增、删除、修改）。</li></ul><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示 f1e2c1b 提交的详细信息，包括提交信息、修改的文件和代码变更。</span><br>git show f1e2c1b<br><br><span class="hljs-comment"># 显示 HEAD 提交的文件变更统计。</span><br>git show --<span class="hljs-built_in">stat</span> HEAD<br><br><span class="hljs-comment"># 输出示例：</span><br>file1.txt | 10 +++++-----<br>file2.txt |  2 +-<br></code></pre></div></td></tr></table></figure><h2 id="分支及操作"><a href="#分支及操作" class="headerlink" title="分支及操作"></a>分支及操作</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><h4 id="作用-14"><a href="#作用-14" class="headerlink" title="作用"></a>作用</h4><p><code>git branch</code> 用于创建、删除、重命名和查看分支。</p><h4 id="基本用法-14"><a href="#基本用法-14" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 列出所有本地分支。</span><br>git branch<br><br><span class="hljs-comment"># 创建新分支 &lt;branch-name&gt;。</span><br>git branch &lt;branch-name&gt;<br><br><span class="hljs-comment"># 删除本地分支 &lt;branch-name&gt;（已合并的分支）。</span><br>git branch -d &lt;branch-name&gt;<br><br><span class="hljs-comment"># 强制删除本地分支（即使未合并）。</span><br>git branch -D &lt;branch-name&gt;<br><br><span class="hljs-comment"># 重命名分支。</span><br>git branch -m &lt;old-name&gt; &lt;new-name&gt;<br><br><span class="hljs-comment"># 列出远程分支。</span><br>git branch -r<br><br><span class="hljs-comment"># 列出所有分支（本地 + 远程）。</span><br>git branch -a<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-14"><a href="#参数说明-14" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-d</code>：删除本地已合并的分支。</li><li><code>-D</code>：强制删除分支（即使未合并）。</li><li><code>-m</code>：重命名分支。</li><li><code>-r</code>：查看远程分支。</li><li><code>-a</code>：查看所有分支（本地+远程）。</li></ul><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 创建 feature-xyz 分支。</span><br>git branch feature-xyz<br><br><span class="hljs-comment"># 删除 feature-xyz 分支（仅限已合并）。</span><br>git branch -d feature-xyz<br><br><span class="hljs-comment"># 重命名 old-branch 为 new-branch。</span><br>git branch -m old-branch new-branch<br></code></pre></div></td></tr></table></figure><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><blockquote><p>逐步被 <code>git switch</code> 取代，但仍然适用于恢复文件。</p></blockquote><h4 id="作用-15"><a href="#作用-15" class="headerlink" title="作用"></a>作用</h4><p><code>git checkout</code> 主要用于：</p><ul><li>切换分支（已被 <code>git switch</code> 替代）。</li><li>恢复工作区的文件到某个版本。</li></ul><h4 id="基本用法-15"><a href="#基本用法-15" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 切换到 &lt;branch&gt; 分支。</span><br>git checkout &lt;branch&gt;<br><br><span class="hljs-comment"># 从 &lt;old_branch&gt; 分支拉取出 &lt;new_branch&gt; 分支。</span><br>git checkout &lt;new_branch&gt; &lt;old_branch&gt;<br><br><span class="hljs-comment"># 创建并切换到 &lt;new-branch&gt;。</span><br>git checkout -b &lt;new-branch&gt;<br><br><span class="hljs-comment"># 丢弃工作区 &lt;file&gt; 的修改，恢复为上次提交的状态。</span><br>git checkout -- &lt;file&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-15"><a href="#参数说明-15" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-b</code>：创建并切换到新分支。</li><li><code>--</code>：避免歧义，明确指定文件名。</li></ul><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 创建并切换到 feature-xyz 分支。</span><br>git checkout -b feature-xyz<br><br><span class="hljs-comment"># 丢弃 file.txt 的修改。</span><br>git checkout -- file.txt<br></code></pre></div></td></tr></table></figure><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><blockquote><p>作为 <code>git checkout</code> 的替代，更简洁安全。</p></blockquote><h4 id="基本用法-16"><a href="#基本用法-16" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 切换到 &lt;branch&gt; 分支。</span><br>git switch &lt;branch&gt;<br><br><span class="hljs-comment"># 创建并切换到 &lt;new-branch&gt;。</span><br>git switch -c &lt;new-branch&gt;<br><br><span class="hljs-comment"># 切换到上一个分支（类似 cd -）。</span><br>git switch -<br><br><span class="hljs-comment"># 进入分离 HEAD 模式（不绑定任何分支）。</span><br>git switch --detach &lt;branch/commit&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-16"><a href="#参数说明-16" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-c</code>：创建新分支并切换。</li><li><code>--detach</code>：进入分离 <code>HEAD</code> 状态（不会绑定到分支）。</li><li><code>-</code>：上一个分支。</li></ul><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 切换到 feature-xyz 分支。</span><br>git switch feature-xyz<br><br><span class="hljs-comment"># 创建并切换到 new-feature 分支。</span><br>git switch -c new-feature<br><br><span class="hljs-comment"># 切换回上一个分支</span><br>git switch -<br><br><span class="hljs-comment"># 进入分离 HEAD 模式，当前处于 HEAD~2（即两次提交前）</span><br>git switch --detach HEAD~2<br></code></pre></div></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><h4 id="作用-16"><a href="#作用-16" class="headerlink" title="作用"></a>作用</h4><p><code>git merge</code> 用于合并指定分支到当前分支。</p><h4 id="基本用法-17"><a href="#基本用法-17" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将 &lt;branch&gt; 合并到当前分支。</span><br>git merge &lt;branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-17"><a href="#参数说明-17" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--no-ff</code>：禁用 <code>fast-forward</code> 合并，保留 <code>merge commit</code>。</li><li><code>--squash</code>：压缩合并，不自动提交。</li><li><code>--abort</code>：取消正在进行的合并。</li></ul><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 合并 feature-xyz 并保留 merge commit。</span><br>git merge feature-xyz --no-ff<br><br><span class="hljs-comment"># 取消正在进行的合并。</span><br>git merge --abort<br></code></pre></div></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><h4 id="作用-17"><a href="#作用-17" class="headerlink" title="作用"></a>作用</h4><p><code>git rebase</code> 让当前分支的提交叠加到目标分支，使历史更线性。</p><h4 id="基本用法-18"><a href="#基本用法-18" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将当前分支变基到 &lt;base-branch&gt;。</span><br>git rebase &lt;base-branch&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-18"><a href="#参数说明-18" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--interactive</code> (<code>-i</code>)：交互式变基，可编辑提交。</li><li><code>--onto &lt;new-base&gt;</code>：将当前分支基于 <code>&lt;new-base&gt;</code> 重新应用。</li><li><code>--abort</code>：取消变基。</li><li><code>--continue</code>：继续变基（解决冲突后）。</li></ul><h4 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 交互式变基最近 3 次提交。</span><br>git rebase -i HEAD~3<br><br><span class="hljs-comment"># 取消变基。</span><br>git rebase --abort<br></code></pre></div></td></tr></table></figure><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><h4 id="作用-18"><a href="#作用-18" class="headerlink" title="作用"></a>作用</h4><p><code>git cherry-pick</code> 将某个提交复制到当前分支。</p><h4 id="基本用法-19"><a href="#基本用法-19" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将指定提交 commit-hash 应用到当前分支。</span><br>git cherry-pick &lt;commit-hash&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-19"><a href="#参数说明-19" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-n</code>：仅应用变更，不提交。</li><li><code>-x</code>：在提交信息中添加原始提交哈希。</li><li><code>--abort</code>：取消 <code>cherry-pick</code>。</li></ul><h4 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将 a1b2c3d 提交应用到当前分支。</span><br>git cherry-pick a1b2c3d<br></code></pre></div></td></tr></table></figure><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><h4 id="作用-19"><a href="#作用-19" class="headerlink" title="作用"></a>作用</h4><p><code>git revert</code> 用于撤销某次提交，同时保留历史记录，不影响之前的提交。</p><h4 id="基本用法-20"><a href="#基本用法-20" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个新的补丁提交，以撤销 commit-hash。</span><br>git revert &lt;commit-hash&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-20"><a href="#参数说明-20" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-n</code>：仅应用撤销变更，不提交。</li><li><code>--no-edit</code>：使用默认提交信息。</li><li><code>--abort</code>：取消撤销。</li></ul><h4 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 撤销 a1b2c3d，并创建新的提交。</span><br>git revert a1b2c3d<br></code></pre></div></td></tr></table></figure><h2 id="暂存与提交"><a href="#暂存与提交" class="headerlink" title="暂存与提交"></a>暂存与提交</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><h4 id="作用-20"><a href="#作用-20" class="headerlink" title="作用"></a><strong>作用</strong></h4><p><code>git add</code> 将工作区的修改添加到暂存区（<code>Staging Area</code>），等待提交。</p><h4 id="基本用法-21"><a href="#基本用法-21" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将 &lt;file&gt; 添加到暂存区。</span><br>git add &lt;file&gt;<br><br><span class="hljs-comment"># 将所有修改的文件添加到暂存区。</span><br>git add .<br><br><span class="hljs-comment"># 将所有文件（包括新增、修改、删除）添加到暂存区。</span><br>git add -A<br><br><span class="hljs-comment"># 仅添加已修改和已删除的文件，不包括新文件。</span><br>git add -u<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-21"><a href="#参数说明-21" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>.</code>：添加当前目录及子目录所有变更的文件。</li><li><code>-A</code>：添加所有文件（包括新增、修改、删除）。</li><li><code>-u</code>：仅添加已修改和已删除的文件（不包括新文件）。</li><li><code>-p</code>：交互式选择部分变更进行暂存。</li></ul><h4 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 添加 file1.txt 和 file2.txt 到暂存区。</span><br>git add file1.txt file2.txt<br><br><span class="hljs-comment"># 逐块选择哪些修改要添加到暂存区。</span><br>git add -p<br></code></pre></div></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><h4 id="作用-21"><a href="#作用-21" class="headerlink" title="作用"></a>作用</h4><p><code>git commit</code> 将暂存区的变更提交到本地版本库。</p><h4 id="基本用法-22"><a href="#基本用法-22" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 提交暂存区的变更，并附带提交信息。</span><br>git commit -m <span class="hljs-string">&quot;提交信息&quot;</span><br><br><span class="hljs-comment"># 跳过 git add，直接提交已跟踪的文件（不包括新文件）。</span><br>git commit -a -m <span class="hljs-string">&quot;提交信息&quot;</span><br><br><span class="hljs-comment"># 修改上一次提交（追加或修改提交信息）。</span><br>git commit --amend<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-22"><a href="#参数说明-22" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-m &quot;&lt;message&gt;&quot;</code>：直接在命令行输入提交信息。</li><li><code>-a</code>：自动暂存所有已跟踪的文件（省略 <code>git add</code>）。</li><li><code>--amend</code>：修改上一次提交（包括提交信息或文件）。</li><li><code>--no-edit</code>：<code>--amend</code> 时不修改提交信息。</li></ul><h4 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 提交修改，并添加提交信息。</span><br>git commit -m <span class="hljs-string">&quot;修复了一个 bug&quot;</span><br><br><span class="hljs-comment"># 修改上次提交的提交信息。</span><br>git commit --amend -m <span class="hljs-string">&quot;修复了 bug 并优化代码&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><h4 id="作用-22"><a href="#作用-22" class="headerlink" title="作用"></a>作用</h4><p><code>git reset</code> 用于撤销提交、取消暂存或恢复文件到特定状态。</p><h4 id="基本用法-23"><a href="#基本用法-23" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 取消 &lt;file&gt; 的暂存状态，恢复到未暂存状态。</span><br>git reset HEAD &lt;file&gt;<br><br><span class="hljs-comment"># 撤销最近的一次提交，但保留变更（不会修改暂存区和工作区）。</span><br>git reset --soft HEAD~1<br><br><span class="hljs-comment"># 撤销提交，并取消暂存（不会修改工作区）。</span><br>git reset --mixed HEAD~1<br><br><span class="hljs-comment"># 彻底撤销最近一次提交，恢复到该提交前的状态（数据丢失，慎用）。</span><br>git reset --hard HEAD~1<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-23"><a href="#参数说明-23" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--soft</code>：撤销提交，但保留文件在暂存区。</li><li><code>--mixed</code>（默认）：撤销提交，同时取消暂存，但不修改工作区文件。</li><li><code>--hard</code>：彻底撤销提交、暂存和工作区文件（数据不可恢复）。</li></ul><h4 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 撤销最近两次提交，变更仍然保留在暂存区。</span><br>git reset HEAD~2<br><br><span class="hljs-comment"># 回退到上一个提交，并删除所有未提交的修改。</span><br>git reset --hard HEAD~1<br></code></pre></div></td></tr></table></figure><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><h4 id="作用-23"><a href="#作用-23" class="headerlink" title="作用"></a>作用</h4><p><code>git rm</code> 用于从 <code>Git</code> 版本控制中删除文件（可选是否删除本地文件）。</p><h4 id="基本用法-24"><a href="#基本用法-24" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 删除文件 &lt;file&gt;，并在下一次提交时生效。</span><br>git rm &lt;file&gt;<br><br><span class="hljs-comment"># 递归删除目录 &lt;directory&gt;。</span><br>git rm -r &lt;directory&gt;<br><br><span class="hljs-comment"># 仅从 Git 仓库中删除 &lt;file&gt;，保留本地文件。</span><br>git rm --cached &lt;file&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-24"><a href="#参数说明-24" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-r</code>：递归删除目录。</li><li><code>--cached</code>：仅从 <code>Git</code> 版本库中删除文件，保留本地文件。</li><li><code>-f</code>：强制删除文件（即使已修改）。</li></ul><h4 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 删除 logs/ 目录及其中的所有文件。</span><br>git rm -r logs/<br><br><span class="hljs-comment"># 将 file.txt 从 Git 版本库中删除，但不删除本地文件。</span><br>git rm --cached file.txt<br></code></pre></div></td></tr></table></figure><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><h4 id="作用-24"><a href="#作用-24" class="headerlink" title="作用"></a>作用</h4><p><code>git stash</code> 用于临时存储未提交的修改，以便切换分支或执行其他任务，稍后再恢复。</p><h4 id="基本用法-25"><a href="#基本用法-25" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将所有未提交的修改暂存起来，并清空工作区。</span><br>git stash<br><br><span class="hljs-comment"># 查看所有暂存的变更。</span><br>git stash list<br><br><span class="hljs-comment"># 恢复最近的暂存，并从 stash 列表中删除。</span><br>git stash pop<br><br><span class="hljs-comment"># 恢复最近的暂存，但不删除 stash 记录。</span><br>git stash apply<br><br><span class="hljs-comment"># 删除最近的 stash 记录。</span><br>git stash drop<br><br><span class="hljs-comment"># 清空所有暂存的变更。</span><br>git stash clear<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-25"><a href="#参数说明-25" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>list</code>：显示所有 <code>stash</code> 记录。</li><li><code>pop</code>：恢复最近的 <code>stash</code> 并删除记录。</li><li><code>apply</code>：恢复 <code>stash</code> 但不删除记录。</li><li><code>drop</code>：删除最近的 <code>stash</code> 记录。</li><li><code>clear</code>：清空所有 <code>stash</code> 记录。</li></ul><h4 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 暂存所有未提交的修改。</span><br>git stash<br><br><span class="hljs-comment"># 恢复最近的暂存，并从 stash 列表中删除。</span><br>git stash pop<br><br><span class="hljs-comment"># 查看暂存列表：</span><br>git stash list<br><br><span class="hljs-comment"># 输出示例：</span><br>stash@&#123;0&#125;: WIP on main: 123abc 修复 bug<br>stash@&#123;1&#125;: WIP on feature: 456def 添加新功能<br><br><br><br><span class="hljs-comment"># 删除 `stash@&#123;0&#125;` 记录。</span><br>git stash drop stash@&#123;0&#125;<br></code></pre></div></td></tr></table></figure><h3 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h3><h4 id="作用-25"><a href="#作用-25" class="headerlink" title="作用"></a>作用</h4><p><code>git restore</code> 用于恢复工作区中的文件，可以：</p><ul><li>撤销未提交的修改（恢复为上次提交的版本）。</li><li>从暂存区恢复文件（相当于 <code>git reset HEAD &lt;file&gt;</code>）。</li><li>恢复已删除的文件（只要还未提交删除）。</li></ul><h4 id="基本用法-26"><a href="#基本用法-26" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 恢复 &lt;file&gt; 为上次提交的版本（撤销本地修改）。</span><br>git restore &lt;file&gt;<br><br><span class="hljs-comment"># 取消暂存（等效于 git reset HEAD &lt;file&gt;）。</span><br>git restore --staged &lt;file&gt;<br><br><span class="hljs-comment"># 将 &lt;file&gt; 恢复到指定的 &lt;commit&gt; 版本。</span><br>git restore --<span class="hljs-built_in">source</span>=&lt;commit&gt; &lt;file&gt;<br><br><span class="hljs-comment"># 恢复所有文件到上次提交的版本。</span><br>git restore . <br></code></pre></div></td></tr></table></figure><h4 id="参数说明-26"><a href="#参数说明-26" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;file&gt;</code>：需要恢复的文件名。</li><li><code>--staged</code>：从暂存区恢复文件到工作区（撤销 <code>git add</code>）。</li><li><code>--source=&lt;commit&gt;</code>：恢复到指定的提交版本（如 <code>HEAD~1</code>、<code>commit-hash</code>）。</li><li><code>.</code>：恢复所有文件。</li></ul><h4 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 恢复 file.txt，撤销本地修改（但不会影响暂存区），不会撤销 git add 操作。</span><br>git restore file.txt<br><br><span class="hljs-comment"># 取消 git add file.txt，但文件内容不会丢失，仍然在工作区（未暂存状态）。</span><br>git restore --staged file.txt<br><br><span class="hljs-comment"># 撤销所有未提交的修改。</span><br>git restore .<br><br><span class="hljs-comment"># 恢复 file.txt 到 上一次提交（HEAD~1） 的状态。</span><br>git restore --<span class="hljs-built_in">source</span>=HEAD~1 file.txt<br></code></pre></div></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><h4 id="作用-26"><a href="#作用-26" class="headerlink" title="作用"></a>作用</h4><p><code>git tag</code> 用于创建、删除、查看标签。<code>Git</code> 提供两种类型的标签：</p><ol><li><strong>轻量标签（Lightweight Tag）</strong>：仅作为提交的引用，不包含额外信息。</li><li><strong>附注标签（Annotated Tag）</strong>：包含作者、日期、标签信息，存储在 <code>Git</code> 历史中。</li></ol><h4 id="基本用法-27"><a href="#基本用法-27" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 列出所有标签。</span><br>git tag<br><br><span class="hljs-comment"># 创建轻量标签 &lt;tag-name&gt;。</span><br>git tag &lt;tag-name&gt;<br><br><span class="hljs-comment"># 创建附注标签 &lt;tag-name&gt;，并附带描述信息。</span><br>git tag -a &lt;tag-name&gt; -m <span class="hljs-string">&quot;Tag message&quot;</span><br><br><span class="hljs-comment"># 删除本地标签 &lt;tag-name&gt;。</span><br>git tag -d &lt;tag-name&gt;<br><br><span class="hljs-comment"># 推送本地标签 &lt;tag-name&gt; 到远程仓库。</span><br>git push origin &lt;tag-name&gt;<br><br><span class="hljs-comment"># 推送所有本地标签到远程仓库。</span><br>git push origin --tags<br><br><span class="hljs-comment"># 列出符合 v1.* 规则的标签。</span><br>git tag -l <span class="hljs-string">&quot;v1.*&quot;</span><br><br><span class="hljs-comment"># 查看附注标签详情。</span><br>git show &lt;tag-name&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-27"><a href="#参数说明-27" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-a</code>：创建附注标签，需添加描述信息。</li><li><code>-m &quot;&lt;message&gt;&quot;</code>：指定标签的描述信息（用于附注标签）。</li><li><code>-d</code>：删除本地标签。</li><li><code>-l &lt;pattern&gt;</code>：按模式搜索标签（如 <code>v1.*</code>）。</li><li><code>-f</code>：强制覆盖已有标签（需谨慎）。</li></ul><h4 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 创建轻量标签 v1.0。</span><br>git tag v1.0<br><br><span class="hljs-comment"># 创建附注标签 v1.0，并附加描述信息。</span><br>git tag -a v1.0 -m <span class="hljs-string">&quot;First stable release&quot;</span><br><br><span class="hljs-comment"># 删除 v1.0 标签。</span><br>git tag -d v1.0<br><br><span class="hljs-comment"># 推送 v1.0 到远程仓库。</span><br>git push origin v1.0<br><br><span class="hljs-comment"># 推送所有本地标签到远程仓库。</span><br>git push origin --tags<br><br><span class="hljs-comment"># 查看 v1.0 的详细信息。</span><br>git show v1.0<br></code></pre></div></td></tr></table></figure><h3 id="git-describe"><a href="#git-describe" class="headerlink" title="git describe"></a>git describe</h3><h4 id="作用-27"><a href="#作用-27" class="headerlink" title="作用"></a>作用</h4><p><code>git describe</code> 用于显示最近的标签信息，通常用于版本管理，格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tag-name</span>&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">number-of-commits</span>&gt;</span>-g<span class="hljs-tag">&lt;<span class="hljs-name">commit-hash</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>例如：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">v1</span>.<span class="hljs-number">0</span>-<span class="hljs-number">5</span>-gf<span class="hljs-number">3</span>b<span class="hljs-number">1</span>c<span class="hljs-number">2</span>d<br></code></pre></div></td></tr></table></figure><p>表示 <code>v1.0</code> 之后有 5 次提交，最新提交的哈希是 <code>f3b1c2d</code>。</p><h4 id="基本用法-28"><a href="#基本用法-28" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 显示最近的标签信息。</span><br>git describe<br><br><span class="hljs-comment"># 显示最新的任意标签（默认只考虑 annotated tags）。</span><br>git describe --tags<br><br><span class="hljs-comment"># 如果没有标签，返回最近的提交哈希。</span><br>git describe --always<br><br><span class="hljs-comment"># 显示完整格式，包括标签、提交数和哈希。</span><br>git describe --long<br><br><span class="hljs-comment"># 如果工作区有修改，返回 dirty 状态。</span><br>git describe --dirty<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-28"><a href="#参数说明-28" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--tags</code>：允许使用轻量标签。</li><li><code>--always</code>：如果没有标签，则返回提交哈希。</li><li><code>--long</code>：显示完整格式。</li><li><code>--dirty</code>：如果工作区有修改，则标记为 <code>dirty</code>。</li></ul><h4 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git describe<br><br><span class="hljs-comment"># 输出示例：表示距离 v1.0 有 5 次提交，最新提交哈希 f3b1c2d。</span><br>v1.0-5-gf3b1c2d<br><br><br><br>git describe --tags<br><br><span class="hljs-comment"># 输出示例：表示 v1.0.1 之后 3 次提交，最近提交哈希 5d6e8f9。</span><br>v1.0.1-3-g5d6e8f9<br><br><br><br><span class="hljs-comment"># 即使没有标签，也返回提交哈希。</span><br>git describe --always<br><br><span class="hljs-comment"># 输出示例：</span><br>g9a8b7c6<br>sh<br><br><br><br><span class="hljs-comment"># 查看未提交的修改。</span><br>git describe --dirty<br><br><span class="hljs-comment"># 输出示例：</span><br>v1.0-5-gf3b1c2d-dirty<br></code></pre></div></td></tr></table></figure><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a><strong>子模块</strong></h2><p><code>git submodule</code> 提供了一系列命令来管理子模块，这在管理第三方库、依赖项目或大规模分布式开发时非常有用。</p><h4 id="git-submodule-add"><a href="#git-submodule-add" class="headerlink" title="git submodule add"></a>git submodule add</h4><h4 id="作用-28"><a href="#作用-28" class="headerlink" title="作用"></a>作用</h4><p>将另一个 <code>Git</code> 仓库作为子模块添加到当前仓库。</p><h4 id="基本用法-29"><a href="#基本用法-29" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 将另一个 Git 仓库作为子模块添加到当前仓库。</span><br>git submodule add &lt;repository_url&gt; &lt;path&gt;<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-29"><a href="#参数说明-29" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>&lt;repository_url&gt;</code>：远程子模块仓库的地址。</li><li><code>&lt;path&gt;</code>：子模块存放的目录（可选，默认仓库名）。</li></ul><h4 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 在 libs/lib 目录下添加 lib.git 作为子模块。</span><br>git submodule add https://github.com/example/lib.git libs/lib<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-init"><a href="#git-submodule-init" class="headerlink" title="git submodule init"></a>git submodule init</h3><h4 id="作用-29"><a href="#作用-29" class="headerlink" title="作用"></a>作用</h4><p><code>git submodule init</code> 不会拉取子模块的代码，只是让 <code>Git</code> 知道有子模块的存在（注册子模块）。</p><h4 id="基本用法-30"><a href="#基本用法-30" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 初始化所有子模块。</span><br>git submodule init<br><br><span class="hljs-comment"># 仅初始化 &lt;path&gt; 目录下的子模块。</span><br>git submodule init <br></code></pre></div></td></tr></table></figure><h4 id="示例-30"><a href="#示例-30" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 初始化 .gitmodules 文件中定义的子模块。</span><br>git submodule init<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-update"><a href="#git-submodule-update" class="headerlink" title="git submodule update"></a>git submodule update</h3><h4 id="作用-30"><a href="#作用-30" class="headerlink" title="作用"></a>作用</h4><p><code>git submodule update</code> 用于拉取子模块的代码，并将其同步到父仓库指定的提交。</p><h4 id="基本用法-31"><a href="#基本用法-31" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 拉取子模块代码，并将其切换到父仓库记录的提交。</span><br>git submodule update<br><br><span class="hljs-comment"># 递归更新所有嵌套子模块（即子模块中的子模块）。</span><br>git submodule update --recursive<br><br><span class="hljs-comment"># 更新子模块到远程最新版本，而非父仓库记录的提交。</span><br>git submodule update --remote<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-30"><a href="#参数说明-30" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>--recursive</code>：递归更新所有子模块（包括嵌套子模块）。</li><li><code>--remote</code>：更新子模块到远程最新提交，而不是父仓库记录的提交。</li></ul><h4 id="示例-31"><a href="#示例-31" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 递归更新所有子模块，并拉取最新的远程提交。</span><br>git submodule update --recursive --remote<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-status"><a href="#git-submodule-status" class="headerlink" title="git submodule status"></a>git submodule status</h3><h4 id="作用-31"><a href="#作用-31" class="headerlink" title="作用"></a>作用</h4><p><code>git submodule status</code> 显示当前子模块的状态，包括：</p><ul><li><strong>哈希值</strong>：子模块当前指向的提交。</li><li><strong>是否已修改</strong>：如果子模块的 <code>HEAD</code> 与父仓库的记录不同，则会有 <code>+</code> 标记。</li><li><strong>路径</strong>：子模块存放的目录。</li></ul><h4 id="基本用法-32"><a href="#基本用法-32" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 列出所有子模块的状态。</span><br>git submodule status<br></code></pre></div></td></tr></table></figure><h4 id="示例-32"><a href="#示例-32" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git submodule status<br><br><span class="hljs-comment"># 示例输出：</span><br>+f1e2c3b4c5 libs/lib (v1.2-5-gf1e2c3b)<br>- `+` 表示子模块已修改，与父仓库记录的提交不同。<br>- `f1e2c3b4c5` 是子模块当前的提交哈希值。<br>- `libs/lib` 是子模块所在目录。<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-foreach"><a href="#git-submodule-foreach" class="headerlink" title="git submodule foreach"></a>git submodule foreach</h3><h4 id="作用-32"><a href="#作用-32" class="headerlink" title="作用"></a>作用</h4><p><code>git submodule foreach</code> 允许对所有子模块执行批量操作。</p><h4 id="基本用法-33"><a href="#基本用法-33" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 在每个子模块的目录中执行 &lt;command&gt;。</span><br>git submodule foreach &lt;<span class="hljs-built_in">command</span>&gt;<br></code></pre></div></td></tr></table></figure><h4 id="示例-33"><a href="#示例-33" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 在所有子模块中执行 git pull，拉取最新代码。</span><br>git submodule foreach <span class="hljs-string">&#x27;git pull origin main&#x27;</span><br><br><span class="hljs-comment"># 在所有子模块中切换到 main 分支并拉取最新代码。</span><br>git submodule foreach <span class="hljs-string">&#x27;git checkout main &amp;&amp; `Git` pull&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-sync"><a href="#git-submodule-sync" class="headerlink" title="git submodule sync"></a>git submodule sync</h3><h4 id="作用-33"><a href="#作用-33" class="headerlink" title="作用"></a>作用</h4><p>如果父仓库修改了 <code>.gitmodules</code> 文件中的子模块 URL，需要执行 <code>git submodule sync</code> 来同步 URL。</p><h4 id="基本用法-34"><a href="#基本用法-34" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 同步所有子模块的 URL。</span><br>git submodule sync<br><br><span class="hljs-comment"># 仅同步指定子模块 &lt;path&gt;。</span><br>git submodule sync &lt;path&gt;<br></code></pre></div></td></tr></table></figure><h4 id="示例-34"><a href="#示例-34" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 同步 .gitmodules 文件中的所有子模块 URL。</span><br>git submodule sync<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-deinit"><a href="#git-submodule-deinit" class="headerlink" title="git submodule deinit"></a>git submodule deinit</h3><h4 id="作用-34"><a href="#作用-34" class="headerlink" title="作用"></a>作用</h4><p><code>git submodule deinit</code> 取消初始化子模块，使其变成未克隆的状态。</p><h4 id="基本用法-35"><a href="#基本用法-35" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 取消 &lt;path&gt; 目录下的子模块初始化。</span><br>git submodule deinit &lt;path&gt;<br><br><span class="hljs-comment"># 取消所有子模块的初始化。</span><br>git submodule deinit --all<br></code></pre></div></td></tr></table></figure><h4 id="示例-35"><a href="#示例-35" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 取消 libs/lib 目录下的子模块初始化。</span><br>git submodule deinit libs/lib<br></code></pre></div></td></tr></table></figure><h3 id="git-submodule-remove"><a href="#git-submodule-remove" class="headerlink" title="git submodule remove"></a>git submodule remove</h3><h4 id="作用-35"><a href="#作用-35" class="headerlink" title="作用"></a>作用</h4><p>Git 没有 <code>git submodule remove</code>，但可以手动删除子模块。</p><h4 id="基本用法-36"><a href="#基本用法-36" class="headerlink" title="基本用法"></a>基本用法</h4><p>基本步骤如下：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 1. 取消初始化</span><br>git submodule deinit -f &lt;path&gt;<br><br><span class="hljs-comment"># 2. 删除子模块目录</span><br>rm -rf &lt;path&gt; .git/modules/&lt;path&gt;<br><br><span class="hljs-comment"># 3. 从 Git 中移除子模块</span><br>git rm -f &lt;path&gt;<br></code></pre></div></td></tr></table></figure><h3 id="git-clone-–recursive"><a href="#git-clone-–recursive" class="headerlink" title="git clone –recursive"></a>git clone –recursive</h3><h4 id="作用-36"><a href="#作用-36" class="headerlink" title="作用"></a>作用</h4><p>如果一个 <code>Git</code> 仓库包含子模块，直接 <code>git clone</code> 不会自动克隆子模块。需要使用 <code>--recursive</code> 参数。</p><h4 id="基本用法-37"><a href="#基本用法-37" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 克隆仓库并初始化所有子模块。</span><br>git <span class="hljs-built_in">clone</span> --recursive &lt;repository_url&gt;<br><br><span class="hljs-comment"># 先克隆仓库，再初始化子模块（等效于 --recursive）。</span><br>git <span class="hljs-built_in">clone</span> &lt;repository_url&gt;<br>git submodule update --init --recursive<br></code></pre></div></td></tr></table></figure><h4 id="示例-36"><a href="#示例-36" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 克隆 repo.git 并自动拉取子模块。</span><br>git <span class="hljs-built_in">clone</span> --recursive https://github.com/example/repo.git<br></code></pre></div></td></tr></table></figure><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a><strong>清理</strong></h2><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><h4 id="作用-37"><a href="#作用-37" class="headerlink" title="作用"></a>作用</h4><p>删除未跟踪文件，但不会影响已提交或暂存的文件，它只删除：</p><ul><li>未被 <code>Git</code> 跟踪的文件（未 <code>git add</code> 的文件）。</li><li>忽略的文件（如 <code>.gitignore</code> 里的文件，可选择删除）。</li><li>未跟踪的目录（可选择删除）。</li></ul><h4 id="基本用法-38"><a href="#基本用法-38" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 演示模式：显示将要删除的文件，但不会实际删除（安全检查）。</span><br>git clean -n<br><br><span class="hljs-comment"># 强制删除未跟踪的文件（不删除目录）。</span><br>git clean -f<br><br><span class="hljs-comment"># 强制删除未跟踪的文件和目录。</span><br>git clean -fd<br><br><span class="hljs-comment"># 删除所有未跟踪的文件，包括 .gitignore 里忽略的文件。</span><br>git clean -fx<br><br><span class="hljs-comment"># 删除所有未跟踪的文件和目录，包括 .gitignore 里忽略的文件。</span><br>git clean -fxd<br></code></pre></div></td></tr></table></figure><h4 id="参数说明-31"><a href="#参数说明-31" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>-n</code>：仅模拟执行，不删除任何文件，只显示将被删除的文件列表。</li><li><code>-f</code>：强制删除未跟踪的文件（<code>Git</code> 为了安全，不允许 <code>clean</code> 默认执行，需要 <code>-f</code>）。</li><li><code>-d</code>：删除未跟踪的目录（默认只删除文件）。</li><li><code>-x</code>：删除所有未跟踪的文件，包括 <code>.gitignore</code> 里忽略的文件。</li><li><code>-X</code>：仅删除 <code>.gitignore</code> 里忽略的文件（不删除未跟踪但未被忽略的文件）。</li></ul><h4 id="示例-37"><a href="#示例-37" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 演示模式（安全检查）。</span><br>git clean -n<br><br><span class="hljs-comment"># 输出示例：</span><br>Would remove temp.txt<br>Would remove build/<br><span class="hljs-comment"># Would remove 只是模拟执行，未实际删除。</span><br><br><br><br><span class="hljs-comment"># 删除未跟踪的文件。</span><br>git clean -f<br><br><span class="hljs-comment"># 输出示例：</span><br>Removing temp.txt<br><span class="hljs-comment"># 删除 temp.txt（未跟踪的文件），不会删除目录。</span><br><br><br><br><span class="hljs-comment"># 删除未跟踪的文件和目录。</span><br>git clean -fd<br><br><span class="hljs-comment"># 输出示例：</span><br>Removing temp.txt<br>Removing build/<br><span class="hljs-comment"># 删除 `temp.txt（文件），删除 build/（目录）。</span><br><br><br><br><span class="hljs-comment"># 删除所有未跟踪的文件（包括 `.gitignore` 里的文件）。</span><br>git clean -fx<br><br><span class="hljs-comment"># 输出示例：</span><br>Removing temp.txt<br>Removing .env<br>Removing node_modules/<br><span class="hljs-comment"># 删除 .env（被 .gitignore 忽略的文件），删除 .gitignore 里忽略的所有文件。</span><br><br><br><br><span class="hljs-comment"># 仅删除 .gitignore 里忽略的文件。</span><br>git clean -fX<br><br><span class="hljs-comment"># 输出示例：</span><br>Removing .env<br>Removing node_modules/<br><span class="hljs-comment"># 不会删除 temp.txt（未跟踪但未被 .gitignore 忽略），仅删除 .gitignore 中列出的文件。</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Git</code> 提供了丰富且灵活的命令，从简单的 <code>init</code>、<code>add</code>、<code>commit</code>，到高级的 <code>rebase</code>、<code>cherry-pick</code>、<code>submodule</code> 等，覆盖了开发者在项目协作过程中可能遇到的几乎所有场景。掌握这些命令及其常见参数，能大幅提升我们对版本历史的可控性与开发效率。<br>然而，最重要的并不是死记硬背所有命令，而是在实际项目中灵活运用。遇到问题时，及时查看官方文档或 “<code>git &lt;command&gt; --help</code>” 也能快速解惑。希望本篇整理能帮助你在日常开发中更加游刃有余地管理代码。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本管理</tag>
      
      <tag>命令大全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional类</title>
    <link href="/2022/03/18/javase-8-optional/"/>
    <url>/2022/03/18/javase-8-optional/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Java 8 之前，<code>null</code> 值一直是造成程序崩溃（<code>NullPointerException</code>）的“头号公敌”。为了解决空指针带来的隐患，Java 8 引入了 <code>java.util.Optional&lt;T&gt;</code> 类型，用于在类型层面上显式表示“值可能缺失”的语义。本文将从原理、常用方法及示例代码等多个维度，系统地介绍 Optional 的使用和最佳实践。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li><strong>显式表达可选性</strong>：传统做法是通过返回 <code>null</code> 或文档约定，告诉调用方“该值可能为空”，但这依赖于调用方手动检查，容易遗漏。</li><li><strong>减少 NullPointerException</strong>：Optional 提供了一系列链式 API，使得在访问可能为空的值时，可以优雅地进行处理，避免直接调用导致 NPE。</li><li><strong>提升代码可读性</strong>：方法签名返回 <code>Optional&lt;T&gt;</code>，调用者一眼就能看出该值可能不存在，强制其在编译期考虑缺失情况。</li></ol><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalBasics</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建非空 Optional，若传入 null 会抛出 NullPointerException</span><br>        Optional&lt;String&gt; opt1 = Optional.of(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <br>        <span class="hljs-comment">// 创建可空 Optional，允许传入 null</span><br>        Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br>        <br>        <span class="hljs-comment">// 创建空 Optional</span><br>        Optional&lt;String&gt; opt3 = Optional.empty();<br>        <br>        System.out.println(opt1.isPresent());  <span class="hljs-comment">// true</span><br>        System.out.println(opt2.isPresent());  <span class="hljs-comment">// false</span><br>        System.out.println(opt3.isPresent());  <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="常用方法详解"><a href="#常用方法详解" class="headerlink" title="常用方法详解"></a>常用方法详解</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>isPresent()</code></td><td>判断是否包含值</td></tr><tr><td><code>get()</code></td><td>获取值，若为空则抛出 <code>NoSuchElementException</code></td></tr><tr><td><code>ifPresent(Consumer)</code></td><td>值存在时执行回调</td></tr><tr><td><code>orElse(T other)</code></td><td>值为空时返回 <code>other</code></td></tr><tr><td><code>orElseGet(Supplier)</code></td><td>值为空时执行 <code>Supplier</code> 并返回其结果</td></tr><tr><td><code>orElseThrow(Supplier&lt;Throwable&gt;)</code></td><td>值为空时抛出自定义异常</td></tr><tr><td><code>map(Function)</code></td><td>值存在时对其做转换并返回新的 Optional</td></tr><tr><td><code>flatMap(Function)</code></td><td>与 <code>map</code> 类似，但转换函数已返回 Optional，避免嵌套</td></tr><tr><td><code>filter(Predicate)</code></td><td>值存在且满足断言时返回自身，否则返回空 Optional</td></tr></tbody></table><h2 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h2><h3 id="安全地获取嵌套属性"><a href="#安全地获取嵌套属性" class="headerlink" title="安全地获取嵌套属性"></a>安全地获取嵌套属性</h3><p>传统写法容易嵌套多重 <code>null</code> 检查：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String city = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;<br>    Address addr = user.getAddress();<br>    <span class="hljs-keyword">if</span> (addr != <span class="hljs-keyword">null</span>) &#123;<br>        city = addr.getCity();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 Optional 链式调用：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);<br>String city = userOpt<br>    .map(User::getAddress)         <span class="hljs-comment">// Optional&lt;Address&gt;</span><br>    .map(Address::getCity)         <span class="hljs-comment">// Optional&lt;String&gt;</span><br>    .orElse(<span class="hljs-string">&quot;未知城市&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果age小于18，视为非法用户，返回空</span><br>Optional&lt;User&gt; validUser = Optional.ofNullable(user)<br>    .filter(u -&gt; u.getAge() &gt;= <span class="hljs-number">18</span>);<br></code></pre></div></td></tr></table></figure><h3 id="组合默认值与异常"><a href="#组合默认值与异常" class="headerlink" title="组合默认值与异常"></a>组合默认值与异常</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 使用 orElse 提供默认值</span><br>String name = Optional.ofNullable(user.getName())<br>    .orElse(<span class="hljs-string">&quot;匿名用户&quot;</span>);<br><br><span class="hljs-comment">// 使用 orElseThrow 抛出异常</span><br>User nonNullUser = Optional.ofNullable(user)<br>    .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;User 不能为空&quot;</span>));<br></code></pre></div></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul><li><p><strong>与流 (Stream) 结合</strong>：可将 <code>Optional&lt;T&gt;</code> 转成 <code>Stream&lt;T&gt;</code> 以参与流式处理：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;String&gt; cityStream = Optional.ofNullable(user)<br>    .map(User::getAddress)<br>    .map(Address::getCity)<br>    .stream();<br></code></pre></div></td></tr></table></figure></li><li><p><strong>缓存惰性加载</strong>：当默认值计算开销较大时，可使用 <code>orElseGet</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String config = Optional.ofNullable(dbConfig.get(<span class="hljs-string">&quot;key&quot;</span>))<br>    .orElseGet(() -&gt; loadFromFile(<span class="hljs-string">&quot;config.properties&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p><strong>避免 get() 滥用</strong>：尽量通过其他 API 获取值，避免直接调用 <code>get()</code> 而导致潜在的 <code>NoSuchElementException</code>。</p></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li><strong>仅用于方法返回，不要在字段或参数上使用</strong>：Optional 并非序列化友好，也不适合作为类的成员变量或方法参数。</li><li><strong>避免嵌套 Optional</strong>：当方法可能返回 Optional 时，应使用 <code>flatMap</code> 而非 <code>map</code> 返回 <code>Optional&lt;Optional&lt;T&gt;&gt;</code>。</li><li><strong>警惕 orElse 的副作用</strong>：<code>orElse</code> 参数会在方法调用前就被计算，若有昂贵操作，建议使用 <code>orElseGet</code>。</li><li><strong>合理使用 orElseThrow</strong>：对于业务逻辑必须存在的值，使用 <code>orElseThrow</code> 能帮助早期失败并定位问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Optional</code> 是 Java 8 提供的一种“类型级别的空检查”机制，通过链式 API，使得对可能缺失的值进行处理更加安全和可读。合理地使用 Optional，可以有效减少 <code>NullPointerException</code> 的发生，提高代码健壮性和可维护性。本文结合理论与代码示例，展示了 Optional 的基本用法、常用方法、进阶技巧及最佳实践，期望帮助读者在日常开发中更好地驾驭 Optional。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java 8</tag>
      
      <tag>Optional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda与方法引用</title>
    <link href="/2022/03/17/javase-8-lambda-method-refrence/"/>
    <url>/2022/03/17/javase-8-lambda-method-refrence/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>自 Java 8 将 Lambda 表达式与 Stream API 带入主流以来，函数式编程范式彻底改变了 Java 代码的写法与思维方式。它用更简洁的语法兑现了“所见即所得”的业务意图，让遍历、过滤、聚合等操作不再被样板代码淹没，也为并行计算、响应式流水线奠定了基础。本系列文章通过语法速览、内置函数式接口、方法引用、作用域与类型推断、底层实现到综合实践案例的递进式讲解，试图在“广度查缺补漏”的同时，对常用场景做“深度剖析”，帮助读者真正把 Lambda 写得更简洁、可读且高性能。无论你是刚接触 Java 8 的进阶开发者，还是希望在既有代码中全面引入函数式风格的技术主管，都能在本文找到可落地的技巧与避坑指南。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>自 Java 8 引入以来，Lambda 表达式极大地增强了 Java 的表达能力，使得函数式编程风格在 Java 生态中得以落地。本篇文章将从语法、内置接口、实现原理、实践案例与最佳实践等多维度进行系统梳理，查缺补漏，为你提供一份深入且实用的 Java Lambda 深度指南。</p><h3 id="函数式接口与-Lambda"><a href="#函数式接口与-Lambda" class="headerlink" title="函数式接口与 Lambda"></a>函数式接口与 Lambda</h3><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul><li><p><strong>定义</strong>：只包含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解。</p></li><li><p><strong>典型示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">F</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(F from)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="Lambda-是接口实例"><a href="#Lambda-是接口实例" class="headerlink" title="Lambda 是接口实例"></a>Lambda 是接口实例</h4><p>Lambda 本质上是编译期间生成函数式接口的实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Converter&lt;String, Integer&gt; converter = (s) -&gt; Integer.valueOf(s);<br>Integer result = converter.convert(<span class="hljs-string">&quot;123&quot;</span>);  <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><ul><li><p><strong>省略参数类型</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Consumer&lt;String&gt; c = (s) -&gt; System.out.println(s);<br></code></pre></div></td></tr></table></figure></li><li><p><strong>省略括号</strong>（单一参数）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Consumer&lt;String&gt; c = s -&gt; System.out.println(s);<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><ul><li><p><strong>大括号与 return 可省略</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>多语句</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; cmp = (a, b) -&gt; &#123;<br>    System.out.println(a);<br>    System.out.println(b);<br>    <span class="hljs-keyword">return</span> a.compareTo(b);<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="常用内置函数式接口"><a href="#常用内置函数式接口" class="headerlink" title="常用内置函数式接口"></a>常用内置函数式接口</h2><h3 id="Supplier-lt-T-gt"><a href="#Supplier-lt-T-gt" class="headerlink" title="Supplier&lt;T&gt;"></a>Supplier&lt;T&gt;</h3><ul><li><strong>简介</strong>：无参、有返回，用于“生产”一个 T 类型的对象。</li><li><strong>场景</strong>：延迟加载／工厂模式；配置、环境变量或外部资源值的获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 延迟获取当前时间戳</span><br>        Supplier&lt;Long&gt; nowSupplier = () -&gt; System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;当前时间戳：&quot;</span> + nowSupplier.get());<br><br>        <span class="hljs-comment">// 2. 随机数工厂</span><br>        Supplier&lt;Double&gt; randomSupplier = Math::random;<br>        System.out.println(<span class="hljs-string">&quot;随机数：&quot;</span> + randomSupplier.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Consumer-lt-T-gt"><a href="#Consumer-lt-T-gt" class="headerlink" title="Consumer&lt;T&gt;"></a>Consumer&lt;T&gt;</h3><ul><li><strong>简介</strong>：有参、无返回，用于对给定的 T 类型对象执行某种“消费”操作。</li><li><strong>场景</strong>：日志打印、数据持久化、收集结果、对流中每个元素执行副作用。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 打印字符串</span><br>        Consumer&lt;String&gt; printer = System.out::println;<br>        printer.accept(<span class="hljs-string">&quot;Hello, Consumer!&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 对列表中每个元素执行操作</span><br>        java.util.List&lt;Integer&gt; list = java.util.Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        Consumer&lt;Integer&gt; squareAndPrint = x -&gt; System.out.println(x + <span class="hljs-string">&quot; 的平方 = &quot;</span> + (x * x));<br>        list.forEach(squareAndPrint);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h3><ul><li><strong>简介</strong>：有参、有返回，用于将 T 类型转换为 R 类型。</li><li><strong>场景</strong>：数据映射／转换，如 DTO ↔ Entity、字符串解析、数值计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 字符串转整数</span><br>        Function&lt;String, Integer&gt; parseInt = Integer::valueOf;<br>        System.out.println(<span class="hljs-string">&quot;123 转为整数：&quot;</span> + parseInt.apply(<span class="hljs-string">&quot;123&quot;</span>));<br><br>        <span class="hljs-comment">// 2. 对象映射示例：User → UserDTO</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123; <br>            String name; <br>            <span class="hljs-keyword">int</span> age; <br>            <span class="hljs-comment">/* ctor/getters省略 */</span> <br>        &#125;<br>        <br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDTO</span> </span>&#123; <br>            String name; <br>            <span class="hljs-comment">/* ctor/getters/setters */</span> <br>        &#125;<br><br>        Function&lt;User, UserDTO&gt; toDTO = u -&gt; &#123;<br>            UserDTO dto = <span class="hljs-keyword">new</span> UserDTO();<br>            dto.setName(u.name);<br>            <span class="hljs-keyword">return</span> dto;<br>        &#125;;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">30</span>);<br>        UserDTO dto = toDTO.apply(user);<br>        System.out.println(<span class="hljs-string">&quot;DTO 名称：&quot;</span> + dto.getName());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Predicate-lt-T-gt"><a href="#Predicate-lt-T-gt" class="headerlink" title="Predicate&lt;T&gt;"></a>Predicate&lt;T&gt;</h3><ul><li><strong>简介</strong>：有参、返回 boolean，用于对 T 类型值进行“判断”或“过滤”。</li><li><strong>场景</strong>：流过滤、校验、匹配规则判断（如正则、范围校验）。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 判断字符串是否为空</span><br>        Predicate&lt;String&gt; isNotEmpty = s -&gt; s != <span class="hljs-keyword">null</span> &amp;&amp; !s.isEmpty();<br>        System.out.println(isNotEmpty.test(<span class="hljs-string">&quot;&quot;</span>));      <span class="hljs-comment">// false</span><br>        System.out.println(isNotEmpty.test(<span class="hljs-string">&quot;Java&quot;</span>));  <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// 2. 列表中过滤偶数</span><br>        java.util.List&lt;Integer&gt; nums = java.util.Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        nums.stream()<br>            .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            .forEach(System.out::println);  <span class="hljs-comment">// 输出 2, 4</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="UnaryOperator-lt-T-gt"><a href="#UnaryOperator-lt-T-gt" class="headerlink" title="UnaryOperator&lt;T&gt;"></a>UnaryOperator&lt;T&gt;</h3><ul><li><strong>简介</strong>：继承自 Function&lt;T,T&gt;，入参和返回类型相同，用于对 T 类型做“就地”操作或更新。</li><li><strong>场景</strong>：数值或字符串的 “自操作”（+1、取反、拼接）、对象浅拷贝时局部修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnaryOperatorDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 整数加一</span><br>        UnaryOperator&lt;Integer&gt; plusOne = x -&gt; x + <span class="hljs-number">1</span>;<br>        System.out.println(plusOne.apply(<span class="hljs-number">5</span>));  <span class="hljs-comment">// 6</span><br><br>        <span class="hljs-comment">// 2. 字符串追加后缀</span><br>        UnaryOperator&lt;String&gt; addSuffix = s -&gt; s + <span class="hljs-string">&quot;_end&quot;</span>;<br>        System.out.println(addSuffix.apply(<span class="hljs-string">&quot;start&quot;</span>));  <span class="hljs-comment">// start_end</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="BinaryOperator-lt-T-gt"><a href="#BinaryOperator-lt-T-gt" class="headerlink" title="BinaryOperator&lt;T&gt;"></a>BinaryOperator&lt;T&gt;</h3><ul><li><strong>简介</strong>：继承自 BiFunction&lt;T,T,T&gt;，两个 T 类型入参，返回同类型结果，用于“合并”或“聚合”操作。</li><li><strong>场景</strong>：求和、取最大／最小、拼接列表、归约 reduce。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryOperatorDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 两数相加</span><br>        BinaryOperator&lt;Integer&gt; add = Integer::sum;<br>        System.out.println(add.apply(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));  <span class="hljs-comment">// 10</span><br><br>        <span class="hljs-comment">// 2. 列表归约：拼接字符串</span><br>        java.util.List&lt;String&gt; words = java.util.Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        String result = words.stream()<br>            .reduce(<span class="hljs-string">&quot;&quot;</span>, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot;-&quot;</span> + s2);<br>        System.out.println(result);  <span class="hljs-comment">// -a-b-c</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="BiConsumer-lt-T-U-gt"><a href="#BiConsumer-lt-T-U-gt" class="headerlink" title="BiConsumer&lt;T, U&gt;"></a>BiConsumer&lt;T, U&gt;</h3><ul><li><strong>简介</strong>：两个入参、无返回，用于对两种类型的值同时“消费”／执行副作用。</li><li><strong>场景</strong>：Map 遍历（key、value）、双参数日志、事件回调。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiConsumerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        java.util.Map&lt;String, Integer&gt; map = java.util.Map.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>);<br>        BiConsumer&lt;String, Integer&gt; printer = (k, v) -&gt; <br>            System.out.println(<span class="hljs-string">&quot;键=&quot;</span> + k + <span class="hljs-string">&quot;，值=&quot;</span> + v);<br>        map.forEach(printer);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="BiFunction-lt-T-U-R-gt"><a href="#BiFunction-lt-T-U-R-gt" class="headerlink" title="BiFunction&lt;T, U, R&gt;"></a>BiFunction&lt;T, U, R&gt;</h3><ul><li><strong>简介</strong>：两个入参、返回 R，用于将 T、U 两种类型映射／合并成 R。</li><li><strong>场景</strong>：复杂转换／聚合，如根据两个字段构建新对象、联合计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiFunctionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 根据长度和宽度计算面积</span><br>        BiFunction&lt;Double, Double, Double&gt; areaCalc = (l, w) -&gt; l * w;<br>        System.out.println(<span class="hljs-string">&quot;面积：&quot;</span> + areaCalc.apply(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.5</span>));<br><br>        <span class="hljs-comment">// 2. 合并两个列表</span><br>        BiFunction&lt;java.util.List&lt;String&gt;, java.util.List&lt;String&gt;, java.util.List&lt;String&gt;&gt; mergeLists =<br>            (l1, l2) -&gt; &#123;<br>                java.util.List&lt;String&gt; all = <span class="hljs-keyword">new</span> java.util.ArrayList&lt;&gt;(l1);<br>                all.addAll(l2);<br>                <span class="hljs-keyword">return</span> all;<br>            &#125;;<br>        System.out.println(mergeLists.apply(<br>            java.util.Arrays.asList(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>), <br>            java.util.Arrays.asList(<span class="hljs-string">&quot;Z&quot;</span>)));  <span class="hljs-comment">// [X, Y, Z]</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>方法引用（Method References）是对已有方法或构造器的“直接引用”，其本质仍然是一个函数式接口的实例，只不过用 <code>::</code> 把已有方法当作实现体，写法更简洁、可读性更高。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 等价的 Lambda</span><br>Consumer&lt;String&gt; printer1 = s -&gt; System.out.println(s);<br><span class="hljs-comment">// 方法引用</span><br>Consumer&lt;String&gt; printer2 = System.out::println;<br></code></pre></div></td></tr></table></figure><ul><li><strong>语法格式</strong>：<code>ClassOrInstance::methodName</code>。</li><li><strong>前提条件</strong>：被引用的方法签名（参数列表、返回值类型）必须与目标函数式接口的抽象方法相匹配。</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h4><ul><li><strong>理论</strong>：引用某个类的静态方法，形参和返回值与函数式接口抽象方法一致。</li><li><strong>示例</strong>：将字符串转整数、比较大小</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticMethodRef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// Function&lt;T,R&gt; apply(T t) -&gt; R</span><br>        Function&lt;String, Integer&gt; parse = Integer::valueOf;<br>        System.out.println(parse.apply(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// 123</span><br><br>        <span class="hljs-comment">// BiFunction&lt;T,U,R&gt; apply(T t, U u) -&gt; R</span><br>        BiFunction&lt;Integer, Integer, Integer&gt; max = Math::max;<br>        System.out.println(max.apply(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>));    <span class="hljs-comment">// 9</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="特定对象的实例方法引用"><a href="#特定对象的实例方法引用" class="headerlink" title="特定对象的实例方法引用"></a>特定对象的实例方法引用</h4><ul><li><strong>理论</strong>：引用某个已知对象的实例方法，用于对该对象调用方法。</li><li><strong>示例</strong>：打印、日志、更新容器</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceMethodRef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Long&gt; now = System::currentTimeMillis; <span class="hljs-comment">// 也可看作静态方法引用</span><br>        System.out.println(<span class="hljs-string">&quot;当前时间：&quot;</span> + now.get());<br><br>        Consumer&lt;String&gt; printer = System.out::println;<br>        printer.accept(<span class="hljs-string">&quot;Hello, 方法引用!&quot;</span>);<br><br>        String prefix = <span class="hljs-string">&quot;Info: &quot;</span>;<br>        Consumer&lt;String&gt; log = prefix::concat;  <span class="hljs-comment">// 错误示例，concat 会返回新 String，不符合 Consumer，因此改用：</span><br>        <span class="hljs-comment">// Consumer&lt;String&gt; log = s -&gt; System.out.println(prefix + s);</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：只有当实例方法签名（参、返）和接口一致时才能引用。上例中 <code>prefix::concat</code> 返回 <code>String</code>，不符合 <code>Consumer&lt;Void&gt;</code>，因此无法直接用。</p><h4 id="任意类型的任意对象的实例方法引用"><a href="#任意类型的任意对象的实例方法引用" class="headerlink" title="任意类型的任意对象的实例方法引用"></a>任意类型的任意对象的实例方法引用</h4><ul><li><strong>理论</strong>：引用某个类中任意实例的方法，将调用者作为第一个参数隐式传入。</li><li><strong>示例</strong>：比较、拼接、转换</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryInstanceMethodRef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// BiPredicate&lt;T,T&gt; test(T t, T u) -&gt; boolean</span><br>        BiPredicate&lt;String, String&gt; eq = String::equals;<br>        System.out.println(eq.test(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));  <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// BiFunction&lt;T,U,R&gt; apply(T t, U u) -&gt; R</span><br>        BiFunction&lt;String, String, String&gt; join = String::concat;<br>        System.out.println(join.apply(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)); <span class="hljs-comment">// helloworld</span><br><br>        <span class="hljs-comment">// UnaryOperator&lt;T&gt; apply(T t) -&gt; T</span><br>        UnaryOperator&lt;String&gt; toUpper = String::toUpperCase;<br>        System.out.println(toUpper.apply(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// ABC</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h4><ul><li><strong>理论</strong>：用 <code>ClassName::new</code> 引用构造器，隐式映射到函数式接口的 <code>apply</code> 或 <code>get</code> 方法，生成新对象。</li><li><strong>示例</strong>：集合、数组、POJO</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorRef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// Supplier&lt;T&gt; get() -&gt; T</span><br>        Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::<span class="hljs-keyword">new</span>;<br>        List&lt;String&gt; list = listSupplier.get();<br>        list.add(<span class="hljs-string">&quot;x&quot;</span>); <br>        list.add(<span class="hljs-string">&quot;y&quot;</span>);<br>        System.out.println(list);         <span class="hljs-comment">// [x, y]</span><br><br>        <span class="hljs-comment">// Function&lt;Integer, String[]&gt; apply(Integer size) -&gt; String[]</span><br>        Function&lt;Integer, String[]&gt; arrayMaker = String[]::<span class="hljs-keyword">new</span>;<br>        String[] arr = arrayMaker.apply(<span class="hljs-number">5</span>);<br>        System.out.println(arr.length);   <span class="hljs-comment">// 5</span><br><br>        <span class="hljs-comment">// BiFunction&lt;K, V, Map&lt;K,V&gt;&gt; apply(K k, V v) -&gt; Map&lt;K,V&gt;</span><br>        BiFunction&lt;String, Integer, Map&lt;String,Integer&gt;&gt; mapMaker = HashMap::<span class="hljs-keyword">new</span>;<br>        Map&lt;String, Integer&gt; map = mapMaker.apply(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">30</span>);<br>        <span class="hljs-comment">// 注意：HashMap 构造器并非接收 key/value，因此这里只是示例语法，实际场景中多用于支持初始容量等构造器</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用注意与最佳实践"><a href="#使用注意与最佳实践" class="headerlink" title="使用注意与最佳实践"></a>使用注意与最佳实践</h3><ul><li><strong>可读性优先</strong>：方法引用虽然简洁，但有时 Lambda 更直观，避免滥用。</li><li><strong>签名匹配</strong>：引用的方法参数、返回值、抛异常类型都要与函数式接口完全一致。</li><li><strong>调试支持</strong>：方法引用堆栈信息较少，遇到调试困难时可临时改写为 Lambda。</li><li><strong>引用构造器要谨慎</strong>：确保所引用的构造器参数列表和函数式接口签名匹配，否则编译失败。</li></ul><h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><h3 id="变量捕获（Closure）"><a href="#变量捕获（Closure）" class="headerlink" title="变量捕获（Closure）"></a>变量捕获（Closure）</h3><h4 id="本质与限制"><a href="#本质与限制" class="headerlink" title="本质与限制"></a>本质与限制</h4><ul><li><strong>只能捕获“最终（final）或事实上的最终（effectively final）”局部变量</strong>。</li><li>编译器会在内部为每个捕获的局部变量生成一个“隐藏的”字段，Lambda 对象实际持有的是该字段的值副本。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptureDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;                <span class="hljs-comment">// effectively final</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;A&quot;</span>);<br><br>        Runnable r = () -&gt; &#123;<br>            <span class="hljs-comment">// 捕获 x 和 sb</span><br>            System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x);<br>            sb.append(<span class="hljs-string">&quot;B&quot;</span>);       <span class="hljs-comment">// 对对象的修改是允许的</span><br>            System.out.println(<span class="hljs-string">&quot;sb = &quot;</span> + sb);<br>        &#125;;<br><br>        <span class="hljs-comment">// x = 11;                // 若放开此行，x 不再是 effectively final，编译错误！</span><br>        r.run();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>原因</strong>：局部变量存于栈帧，生命周期短；JVM 无法在栈帧销毁后再访问它们。只能把变量的值复制到 Lambda 对象中。</li></ul><h4 id="捕获类型对比"><a href="#捕获类型对比" class="headerlink" title="捕获类型对比"></a>捕获类型对比</h4><table><thead><tr><th>捕获对象</th><th>允许修改？</th><th>底层表现</th></tr></thead><tbody><tr><td>局部基本类型</td><td>只读（必须 final/effectively final）</td><td>值复制到私有字段</td></tr><tr><td>局部引用类型</td><td>引用不可变，引用对象可变</td><td>引用复制到私有字段</td></tr><tr><td>成员变量 &amp; 静态变量</td><td>无限制，可读写</td><td>直接访问外部对象或类变量</td></tr></tbody></table><h3 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h3><h4 id="与匿名内部类的区别"><a href="#与匿名内部类的区别" class="headerlink" title="与匿名内部类的区别"></a>与匿名内部类的区别</h4><ul><li><p><strong><code>this</code> 指向</strong></p><ul><li>匿名内部类：<code>this</code> 指代内部类实例</li><li>Lambda：<code>this</code> 指代外层对象</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeDemo</span> </span>&#123;<br>    Runnable r1 = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-keyword">this</span>.getClass());   <span class="hljs-comment">// 匿名内部类</span><br>        &#125;<br>    &#125;;<br>    Runnable r2 = () -&gt; System.out.println(<span class="hljs-keyword">this</span>.getClass()); <span class="hljs-comment">// 外部类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ScopeDemo().r1.run(); <span class="hljs-comment">// class ScopeDemo$1</span><br>        <span class="hljs-keyword">new</span> ScopeDemo().r2.run(); <span class="hljs-comment">// class ScopeDemo</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="变量遮蔽（Shadowing）"><a href="#变量遮蔽（Shadowing）" class="headerlink" title="变量遮蔽（Shadowing）"></a>变量遮蔽（Shadowing）</h4><ul><li><p>Lambda 不能声明与外层局部变量同名的形参或局部变量，否则编译报错。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShadowDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// 参数名不能和外部 value 同名</span><br>        <span class="hljs-comment">// Consumer&lt;Integer&gt; c = (value) -&gt; System.out.println(value); // 编译错误</span><br>        Consumer&lt;Integer&gt; c = v -&gt; System.out.println(v);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="类型推断与目标类型"><a href="#类型推断与目标类型" class="headerlink" title="类型推断与目标类型"></a>类型推断与目标类型</h2><h3 id="目标类型决定-Lambda-签名"><a href="#目标类型决定-Lambda-签名" class="headerlink" title="目标类型决定 Lambda 签名"></a>目标类型决定 Lambda 签名</h3><p>编译时根据上下文中函数式接口的抽象方法签名，推断 Lambda 参数类型和返回类型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 明确上下文：Function&lt;String,Integer&gt;</span><br>Function&lt;String, Integer&gt; f = s -&gt; s.length();<br><br><span class="hljs-comment">// 泛型方法：类型推断</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mapAndPrint</span><span class="hljs-params">(List&lt;T&gt; list, Function&lt;T,String&gt; mapper)</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br><br>mapAndPrint(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), <span class="hljs-comment">// T 推断为 Integer</span><br>    i -&gt; <span class="hljs-string">&quot;v:&quot;</span> + i);<br></code></pre></div></td></tr></table></figure><h3 id="多重目标类型歧义"><a href="#多重目标类型歧义" class="headerlink" title="多重目标类型歧义"></a>多重目标类型歧义</h3><p>若同一 Lambda 可匹配多个重载方法，需显式指明目标类型：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Function&lt;String,Integer&gt; f)</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(ToIntFunction&lt;String&gt; f)</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br><br>foo(s -&gt; s.length());             <span class="hljs-comment">// 编译错误：二义</span><br>foo((Function&lt;String,Integer&gt;) (s -&gt; s.length())); <span class="hljs-comment">// 强制转换</span><br></code></pre></div></td></tr></table></figure><h2 id="Lambda-简单实现原理"><a href="#Lambda-简单实现原理" class="headerlink" title="Lambda 简单实现原理"></a>Lambda 简单实现原理</h2><h3 id="编译期：invokedynamic-指令"><a href="#编译期：invokedynamic-指令" class="headerlink" title="编译期：invokedynamic 指令"></a>编译期：invokedynamic 指令</h3><ul><li>每个 Lambda 表达式编译为一个 <code>invokedynamic</code> 字节码，链接到 <code>LambdaMetafactory</code>。</li><li>编译器生成一个私有静态方法（或实例方法）承载 Lambda 体，方法签名与函数式接口一致。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 源码</span><br>Runnable r = <span class="hljs-literal">()</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Hi&quot;</span>);<br><br><span class="hljs-comment">// 编译后（伪码）</span><br><span class="hljs-keyword">private</span> static void lambda<span class="hljs-constructor">$0()</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Hi&quot;</span>);<br>&#125;<br>…<br>invokedynamic BootstrapMethod #<span class="hljs-number">0</span>, args: <span class="hljs-constructor">MethodHandle(<span class="hljs-params">lambda$0</span>)</span>, <span class="hljs-constructor">MethodType(Runnable)</span><br></code></pre></div></td></tr></table></figure><h3 id="运行时：动态生成或重用实现类"><a href="#运行时：动态生成或重用实现类" class="headerlink" title="运行时：动态生成或重用实现类"></a>运行时：动态生成或重用实现类</h3><ul><li>第一次执行 <code>invokedynamic</code> 时，<code>LambdaMetafactory</code> 会：<ol><li>为目标函数式接口生成一个 <em>call site</em></li><li>创建一个实现该接口的代理类（可缓存）</li><li>将捕获的值或对象引用以私有字段形式塞入实例，并返回该实例</li></ol></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>性能</strong>：避免了匿名内部类的类加载与反射开销；调用点可内联优化。</li><li><strong>内存</strong>：相同签名且捕获内容相同的 Lambda 会复用实现类。</li></ul><h2 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h2><h3 id="与-Stream-API-结合使用"><a href="#与-Stream-API-结合使用" class="headerlink" title="与 Stream API 结合使用"></a>与 Stream API 结合使用</h3><h4 id="数据过滤与映射"><a href="#数据过滤与映射" class="headerlink" title="数据过滤与映射"></a>数据过滤与映射</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;User&gt; users = userRepository.findAll();<br><br><span class="hljs-comment">// 筛选年龄在 18–30 岁之间的用户，提取用户名列表并去重</span><br>List&lt;String&gt; names = users.stream()<br>    .filter(u -&gt; u.getAge() &gt;= <span class="hljs-number">18</span> &amp;&amp; u.getAge() &lt;= <span class="hljs-number">30</span>)<br>    .map(User::getUsername)<br>    .distinct()<br>    .collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><h4 id="分组与聚合"><a href="#分组与聚合" class="headerlink" title="分组与聚合"></a>分组与聚合</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 按性别分组，统计每组的平均年龄</span><br>Map&lt;Gender, Double&gt; avgAgeByGender = users.stream()<br>    .collect(Collectors.groupingBy(<br>        User::getGender,<br>        Collectors.averagingInt(User::getAge)<br>    ));<br></code></pre></div></td></tr></table></figure><h4 id="并行流（Parallel-Stream）"><a href="#并行流（Parallel-Stream）" class="headerlink" title="并行流（Parallel Stream）"></a>并行流（Parallel Stream）</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 并行计算所有订单总额</span><br><span class="hljs-keyword">double</span> total = orders.parallelStream()<br>    .mapToDouble(Order::getAmount)<br>    .sum();<br></code></pre></div></td></tr></table></figure><p><strong>提示</strong>：并行流适合 CPU 密集型、无共享可变状态的场景，对 I/O 或有线程安全风险的数据结构应避免。</p><h3 id="函数组合与复用"><a href="#函数组合与复用" class="headerlink" title="函数组合与复用"></a>函数组合与复用</h3><p>Java 8 的 <code>Function</code>、<code>Predicate</code> 等提供了 <code>andThen</code>、<code>compose</code>、<code>and</code>、<code>or</code> 方法，可动态拼接多段逻辑。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Function&lt;String, String&gt; trim  = String::trim;<br>Function&lt;String, String&gt; upper = String::toUpperCase;<br>Function&lt;String, String&gt; addBrackets = s -&gt; <span class="hljs-string">&quot;[&quot;</span> + s + <span class="hljs-string">&quot;]&quot;</span>;<br><span class="hljs-comment">// 先 trim，再转大写，最后加中括号</span><br>Function&lt;String, String&gt; pipeline = trim.andThen(upper).andThen(addBrackets);<br>System.out.println(pipeline.apply(<span class="hljs-string">&quot;  hello world  &quot;</span>));  <br><span class="hljs-comment">// 输出： [HELLO WORLD]</span><br><br>Predicate&lt;User&gt; isAdult   = u -&gt; u.getAge() &gt;= <span class="hljs-number">18</span>;<br>Predicate&lt;User&gt; isActive  = User::isActive;<br>Predicate&lt;User&gt; validUser = isAdult.and(isActive);<br><span class="hljs-comment">// 用于流过滤或校验</span><br><span class="hljs-keyword">boolean</span> ok = validUser.test(user);<br></code></pre></div></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>函数式接口方法通常不允许声明受检异常，常见做法是包裹或转换：</p><h4 id="内部-try-catch-包装"><a href="#内部-try-catch-包装" class="headerlink" title="内部 try/catch 包装"></a>内部 try/catch 包装</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Path&gt; paths = <span class="hljs-comment">/* … */</span>;<br>paths.forEach(path -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.lines(path).forEach(System.out::println);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UncheckedIOException(e);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="通用异常包装器"><a href="#通用异常包装器" class="headerlink" title="通用异常包装器"></a>通用异常包装器</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThrowingConsumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Consumer&lt;T&gt; <span class="hljs-title">wrapper</span><span class="hljs-params">(ThrowingConsumer&lt;T&gt; tc)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tc.accept(t);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 用法</span><br>paths.forEach(ThrowingConsumer.wrapper(p -&gt; &#123;<br>    <span class="hljs-comment">// 可能抛 IOException</span><br>    Files.copy(p, targetDir.resolve(p.getFileName()));<br>&#125;));<br></code></pre></div></td></tr></table></figure><h3 id="调试与性能问题"><a href="#调试与性能问题" class="headerlink" title="调试与性能问题"></a>调试与性能问题</h3><h4 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h4><ul><li><strong>临时回退为匿名类／Lambda 内部加日志</strong>：当堆栈不清晰时，可将方法引用改回 <code>(x)-&gt;&#123; /*…*/ &#125;</code> 形式，方便打断点。</li><li><strong>IDE 支持</strong>：IntelliJ 可在 Lambda 表达式上右键 “Jump to Source” 或加断点。</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li><p><strong>避免过度装箱／拆箱</strong>：对于基本类型流，优先使用 <code>IntStream</code>、<code>LongStream</code> 等原始流，避免 <code>Stream&lt;Integer&gt;</code> 带来的装拆箱开销。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐</span><br>Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).map(i -&gt; i * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 推荐</span><br>IntStream intS = IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).map(i -&gt; i * <span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure></li><li><p><strong>复用函数实例</strong>：对于在循环中频繁使用的 Lambda／方法引用，建议先存为静态常量，避免重复分配。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;String&gt; IS_ALPHA = s -&gt; s.chars().allMatch(Character::isLetter);<br><span class="hljs-comment">// … in code …</span><br>list.stream().filter(IS_ALPHA).count();<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><ul><li><strong>可读性优先</strong>：简单操作可用方法引用／链式 Lambda，复杂逻辑拆成具名方法再引用。</li><li><strong>避免状态共享</strong>：Lambda 内尽量别改外部可变变量，防止并行时竞态。</li><li><strong>合理选用流类型</strong>：顺序流、并行流根据任务特性选择；避免无意义的 <code>parallelStream()</code>。</li><li><strong>控制异常范围</strong>：封装受检异常，统一转换为运行时异常，或在顶层做统一捕获与处理。</li><li><strong>小心短路操作</strong>：<code>findFirst()</code>、<code>anyMatch()</code>、<code>limit()</code> 等会短路遍历，流操作链中可借此优化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lambda 本质上是“携带数据的行为”：</p><ol><li>语法层面带来极简的函数式接口实例化；</li><li>实现层面得益于 <code>invokedynamic</code> + <code>LambdaMetafactory</code> 的按需生成与复用，既避免了匿名内部类的额外开销，也让 JIT 有机会做深度内联优化；</li><li>实践层面与 Stream、Optional、CompletableFuture 等新 API 相互成就，实现了声明式、并行友好且高度可组合的代码风格。</li></ol><p>在实际项目中，我们应秉持以下原则：</p><ul><li><strong>可读性优先</strong>——给复杂逻辑起名字而非堆叠表达式；</li><li><strong>副作用最小化</strong>——对外不可变、对内可复用；</li><li><strong>性能与调试并重</strong>——合理选择顺序/并行流、基本类型流，必要时以日志或匿名类回退来定位问题；</li><li><strong>统一异常策略</strong>——将受检异常包裹为运行时异常或在顶层集中处理。</li></ul><p>当你以这些原则为尺，将 Lambda 与传统面向对象思想互补使用，既能享受函数式带来的高效与优雅，也能避免“过度魔法”造成的维护困境。愿本文成为你在 Java 世界里精进函数式思维的指南针。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java 8</tag>
      
      <tag>Lambda</tag>
      
      <tag>方法引用</tag>
      
      <tag>函数式接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream API</title>
    <link href="/2022/03/14/javase-8-stream/"/>
    <url>/2022/03/14/javase-8-stream/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java 8引入了<code>Stream</code>API，它标志着Java对函数式编程支持的一大步。<code>Stream</code>提供了一个高级抽象，使得集合操作更为简洁，同时提高了多核处理能力的利用。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>把真正的函数式编程风格引入到Java中，<code>java.util.stream</code>包下</li><li>提供了一种高效且易于使用的处理数据（主要为集合类）的方式，可以进行处理集合，执行查找、过滤、映射数据等操作</li><li><code>Stream</code>不改变源对象，会返回一个新的<code>Stream</code></li><li>代码书写干净、简洁、高效</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/steam.png"></p><ol><li><p>创建Stream</p><p>一个数据源，如集合、数组，获取一个流</p></li><li><p>中间操作</p><p>一个中间操作过程，对数据源进行处理</p></li><li><p>终止操作</p><p>执行终止操作，就开始执行中间操作链，并产生结果，执行终止操作后，stream流不再可操作性，如：对同一stream流执行两次遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    IntStream stream = Arrays.stream(ints);<br>    stream.forEach(System.out::println);<br>    stream.forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p>报错</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/steamError.png"></p><h2 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h2><ol><li><p>通过集合创建</p></li><li><p>通过数组创建</p></li><li><p>Stream.of(T… values)</p></li><li><p>并行流</p></li><li><p>无限流</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通过集合类创建</span><br>    Stream&lt;Integer&gt; listStream = Collections.singleton(<span class="hljs-number">1</span>).stream();<br>    <span class="hljs-comment">// 通过数组创建</span><br>    IntStream arrayStream = Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br>    <span class="hljs-comment">// 通过Stream类创建</span><br>    Stream&lt;Integer&gt; streamStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 并行流</span><br>    Stream&lt;Integer&gt; parallelStream = Collections.singleton(<span class="hljs-number">1</span>).parallelStream();<br>    <span class="hljs-comment">// 无限流</span><br>    Stream&lt;Integer&gt; iterateStream = Stream.iterate(<span class="hljs-number">1</span>, s -&gt; s + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作可以拼接形成一个流水线</p><p>为方便测试，创建<code>Person</code>类和初始化列表<code>List&lt;Person&gt;</code>，详见文章底部附[1]</p><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><ol><li><code>Stream &lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code> 过滤某些元素</li><li><code>Stream &lt;T&gt; limit(long maxSize);</code> 限制长度</li><li><code>Stream &lt;T&gt; skip(long n);</code> 跳过某些元素</li><li><code>Stream &lt;T&gt; distinct();</code> 去重，通过<code>hashCode</code>和<code>equals</code>判定重复</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; list = initList();<br>    Stream&lt;Person&gt; stream = list.stream()<br>        .distinct()<br>        .filter(p -&gt; p.getAge() &gt; <span class="hljs-number">10</span>)<br>        .skip(<span class="hljs-number">2</span>)<br>        .limit(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);</code> 对流中元素进行操作</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] rank = &#123;<span class="hljs-number">1</span>&#125;;<br>    List&lt;Person&gt; list = initList();<br>    Stream&lt;Person&gt; stream = list.stream()<br>        .peek(p -&gt; p.setRank(rank[<span class="hljs-number">0</span>]++));<span class="hljs-comment">// 设置排名</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li><code>Stream &lt;T&gt; sorted();</code> 默认的排序，自然排序</li><li><code>Stream &lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</code> 通过Comparator接口自定义排序规则</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>        .sorted();  <span class="hljs-comment">// 0, 1, 2, 3, 5</span><br><br>    List&lt;Person&gt; list = initList();<br>    Stream&lt;Person&gt; stream2 = list.stream()<br>        .sorted(Comparator.comparingInt(Person::getAge));<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ol><li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code> 将流中每个值转换成另一个值并拼接成新的流</li><li><code>&lt;R&gt; Stream &lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</code> 将流中的每个值转换为另一个流，再把所有的流都拼接成一个流</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; list = initList();<br>    Stream&lt;Integer&gt; ageStream1 = list.stream()<br>        .map(Person::getAge);<br>    IntStream ageStream2 = list.stream()<br>        .mapToInt(Person::getAge);<br><br>    Stream&lt;String&gt; hobbyStream = list.stream()<br>        .flatMap(p -&gt; p.getHobbies().stream())  <span class="hljs-comment">// 篮球 足球 围棋 棒球 唱歌 桌球 健身 网游 游泳</span><br>        .distinct();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><ol><li><code>boolean allMatch / anyMatch / noneMatch(Predicate&lt;? super T&gt; predicate);</code> 是否 全部 / 部分 / 不 匹配断言型函数定义的规则</li><li><code>Optional\&lt;T&gt; findFirst();</code> 查找第一个元素</li><li><code>Optional\&lt;T&gt; findAny();</code> 查找任意一个元素</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; list = initList();<br>    <span class="hljs-keyword">boolean</span> b1 = list.stream()<br>        .allMatch(p -&gt; p.getAge() &gt; <span class="hljs-number">20</span>);<span class="hljs-comment">// false</span><br>    <span class="hljs-keyword">boolean</span> b2 = list.stream()<br>        .anyMatch(p -&gt; p.getAge() &gt; <span class="hljs-number">20</span>);<span class="hljs-comment">// false</span><br>    <span class="hljs-keyword">boolean</span> b3 = list.stream()<br>        .noneMatch(p -&gt; p.getAge() &gt; <span class="hljs-number">20</span>);<span class="hljs-comment">// true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li><code>long count();</code> 获取流中元素的个数</li><li><code>Optional &lt;T&gt; max / min(Comparator&lt;? super T&gt; comparator);</code> 查找流中最大 / 小的元素，<code>Comparator</code>类型函数</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; list = initList();<br>    <span class="hljs-keyword">long</span> count = list.stream()<br>        .count();<br>    Optional&lt;Person&gt; maxAgePerson = list.stream()<br>        .max(Comparator.comparingInt(Person::getAge));<span class="hljs-comment">// 年龄最大的Person</span><br>    Optional&lt;Person&gt; minAgePerson = list.stream()<br>        .max(Comparator.comparingInt(Person::getAge));<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li><code>void forEach(Consumer&lt;? super T&gt; action);</code> 接收消费型函数，循环所有的元素</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; list = initList();<br>    list.stream()<br>        .forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p>将流中的元素都结合起来，得到一个值，如计算总和</p><ol><li><code>T reduce(T identity, BinaryOperator &lt;T&gt; accumulator);</code> 将所有的元素都结合起来得到一个值，并指定初始值</li><li><code>Optional &lt;T&gt; reduce(BinaryOperator &lt;T&gt; accumulator);</code> 将所有的元素都结合起来得到一个值，无指定初始值</li><li><code>&lt;R&gt; R reduce(R identity, BiFunction&lt;R, ? super P_OUT, R&gt; accumulator, BinaryOperator &lt;R&gt; combiner);</code> 并行流特有方法，并行流中的元素进行reduce操作，初始值为第1个参数，再将并行流的结果进行参数3的reduce操作</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    Integer sum1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>        .reduce(<span class="hljs-number">2</span>, Integer::sum);       <span class="hljs-comment">// 23</span><br>    Optional&lt;Integer&gt; sum2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>        .reduce(Integer::sum);          <span class="hljs-comment">// 21</span><br>    List&lt;Integer&gt; list1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; list3 = list1.parallelStream()<br>        .reduce(list2,<br>                (l1, l2) -&gt; &#123;<br>                    ArrayList&lt;Integer&gt; tempList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(l1);<br>                    tempList.add(l2);<br>                    <span class="hljs-keyword">return</span> tempList;<br>                &#125;,<br>                (l1, l2) -&gt; &#123;<br>                    ArrayList&lt;Integer&gt; tempList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(l1);<br>                    tempList.addAll(l2);<br>                    System.out.println(tempList);<br>                    <span class="hljs-keyword">return</span> tempList;<br>                &#125;);<br>    System.out.println();<br>    System.out.println(list3);<br>    <br>    <span class="hljs-comment">/* list2为：</span><br><span class="hljs-comment">        [5, 6]</span><br><span class="hljs-comment">        [4, 5, 6]</span><br><span class="hljs-comment">        [2, 3]</span><br><span class="hljs-comment">        [1, 2, 3]</span><br><span class="hljs-comment">        [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><ol><li><code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);</code> 使用收集器对此流的元素执行可变归约操作 </li><li><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code> 封装了用作collect(Supplier, BiConsumer, BiConsumer)参数的函数，允许重用收集策略和收集操作的组合，例如多级分组或分区</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Person&gt; personList = initList();<br>    Map&lt;String, String&gt; collect = list.stream()<br>                .collect(HashMap::<span class="hljs-keyword">new</span>, (m, e) -&gt; m.put(e.getNo(), e.getName()), HashMap::putAll);<br>    List&lt;Person&gt; list = personList.stream()<br>        .collect(Collectors.toList());<br>    Set&lt;Person&gt; set = personList.stream()<br>        .collect(Collectors.toSet());<br>    LinkedList&lt;Person&gt; linkedList = personList.stream()<br>        .collect(Collectors.toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Collectors</code>的其他常见方法：</p><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td>toList</td><td>List&lt;T&gt;</td><td>收集为List</td></tr><tr><td>toSet</td><td>Set&lt;T&gt;</td><td>收集为Set</td></tr><tr><td>toCollection</td><td>Collection&lt;T&gt;</td><td>收集为创建的集合</td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>summingInt</td><td>Integer</td><td>对流中元素的整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td></tr></tbody></table><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>流式编程<code>DEBUG</code>，在添加断点的时候可以单独为一个中间操作加上断点，也可以加上行断点，对于整个中间操作过程可以通过<code>Trace Current Stream Chain</code>查看</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8BDebug.gif"></p><p>附[1]：</p><p><code>Person</code>类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String no;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rank;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Person person = (Person) o;<br>        <span class="hljs-keyword">return</span> no.equals(person.no);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(no);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试列表<code>List&lt;Person&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Person&gt; <span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    Person zs = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;002&quot;</span>, <span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-number">15</span>, Arrays.asList(<span class="hljs-string">&quot;篮球&quot;</span>, <span class="hljs-string">&quot;足球&quot;</span>), <span class="hljs-number">0</span>);<br>    Person ls = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;001&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-number">12</span>, Arrays.asList(<span class="hljs-string">&quot;围棋&quot;</span>, <span class="hljs-string">&quot;足球&quot;</span>), <span class="hljs-number">0</span>);<br>    Person ww = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;005&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-number">16</span>, Arrays.asList(<span class="hljs-string">&quot;棒球&quot;</span>, <span class="hljs-string">&quot;唱歌&quot;</span>), <span class="hljs-number">0</span>);<br>    Person zl = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;004&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-number">12</span>, Arrays.asList(<span class="hljs-string">&quot;篮球&quot;</span>, <span class="hljs-string">&quot;桌球&quot;</span>), <span class="hljs-number">0</span>);<br>    Person tq = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;003&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-number">13</span>, Arrays.asList(<span class="hljs-string">&quot;健身&quot;</span>, <span class="hljs-string">&quot;网游&quot;</span>), <span class="hljs-number">0</span>);<br>    Person zb = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;006&quot;</span>, <span class="hljs-string">&quot;zb&quot;</span>, <span class="hljs-number">18</span>, Arrays.asList(<span class="hljs-string">&quot;游泳&quot;</span>, <span class="hljs-string">&quot;足球&quot;</span>), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> Arrays.asList(zs, ls, ww, zl, tq, zb);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>Stream</code>API是现代Java编程中不可或缺的一部分，它使得数据的批量处理更加直观和简洁。通过链式调用，开发者可以编写出既简洁又强大的数据处理逻辑。然而，<code>Stream</code>的滥用或不当使用也可能导致性能下降，因此理解其内部机制和适当使用是至关重要的。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java8</tag>
      
      <tag>Stream API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的日期时间类</title>
    <link href="/2022/02/15/javase-8-datetime/"/>
    <url>/2022/02/15/javase-8-datetime/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Java 8之前，日期和时间的管理一直是Java开发中的痛点。<code>java.time</code>包的推出彻底改变了这一局面，提供了一套全新的日期和时间API，解决了旧API如<code>Date</code>和<code>Calendar</code>中存在的问题。                                                                                                                                                                                                                                                                                                                                                                                         </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><code>Date</code>类和<code>Calendar</code>类存在问题：可变性、偏移性、<code>Calendar</code>无法格式化、线程不安全、无法处理闰秒等</li><li>新的API：<code>java.time</code>，包含：本地日期（<code>LocalDate</code>）、本地时间（<code>LocalTime</code>）、本地日期时间（<code>LocalDateTime</code>）、时区（<code>ZonedDateTime</code>）、持续时间（<code>Duration</code>）</li><li>Date类也增加了<code>toInstant()</code>方法用于把<code>Date</code>转换成新的表示形式</li></ul><p>注：无特殊说明一般<code>LocalDateTime</code>实例的方法在<code>LocalDate</code>或<code>LocalTime</code>中有相同的或类似的，由于篇幅原因只列举<code>LocalDateTime</code>的<code>API</code>。</p><h2 id="创建日期时间"><a href="#创建日期时间" class="headerlink" title="创建日期时间"></a>创建日期时间</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前时间</span><br>    LocalDateTime time1 = LocalDateTime.now();<br>    LocalDateTime time2 = LocalDateTime.now(ZoneId.systemDefault());<br>    LocalDateTime time3 = LocalDateTime.now(Clock.systemDefaultZone());<br><br>    <span class="hljs-comment">// 指定时间</span><br>    LocalDateTime time4 = LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">13</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>, <span class="hljs-number">233</span>);<br><br>    <span class="hljs-comment">// 从字符串解析时间</span><br>    LocalDateTime time5 = LocalDateTime.parse(<span class="hljs-string">&quot;2022-03-21T09:23:55.233&quot;</span>);<br>    LocalDateTime time6 = LocalDateTime.parse(<span class="hljs-string">&quot;2022-02-23 07:12:45&quot;</span>, DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>    <span class="hljs-comment">// 时间戳</span><br>    LocalDateTime time7 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());<br>    LocalDateTime time8 = Instant.ofEpochMilli(<span class="hljs-number">1656866702010L</span>).atZone(ZoneId.systemDefault()).toLocalDateTime();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="获取年月日时分秒"><a href="#获取年月日时分秒" class="headerlink" title="获取年月日时分秒"></a>获取年月日时分秒</h2><p>以时间<code>2022-02-15T21:23:54.401</code>为例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime localDateTime = LocalDateTime.now();      <span class="hljs-comment">// 2022-02-15T21:23:54.401</span><br>    <span class="hljs-keyword">int</span> year = localDateTime.getYear();                     <span class="hljs-comment">// 2022</span><br>    Month month = localDateTime.getMonth();                 <span class="hljs-comment">// FEBRUARY，英文</span><br>    <span class="hljs-keyword">int</span> monthValue = localDateTime.getMonthValue();         <span class="hljs-comment">// 2，value为数值</span><br>    <span class="hljs-keyword">int</span> dayOfYear = localDateTime.getDayOfYear();           <span class="hljs-comment">// 46</span><br>    <span class="hljs-keyword">int</span> dayOfMonth = localDateTime.getDayOfMonth();         <span class="hljs-comment">// 15</span><br>    DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();     <span class="hljs-comment">// TUESDAY</span><br>    <span class="hljs-keyword">int</span> hour = localDateTime.getHour();                     <span class="hljs-comment">// 21</span><br>    <span class="hljs-keyword">int</span> minute = localDateTime.getMinute();                 <span class="hljs-comment">// 23</span><br>    <span class="hljs-keyword">int</span> second = localDateTime.getSecond();                 <span class="hljs-comment">// 54</span><br>    <span class="hljs-keyword">int</span> nano = localDateTime.getNano();                     <span class="hljs-comment">// 401000000，纳秒</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="修改日期时间"><a href="#修改日期时间" class="headerlink" title="修改日期时间"></a>修改日期时间</h2><p><code>LocalDateTime</code>的修改并不是修改原有的时间，而是返回一个新的想同类型的日期时间，可直接修改对应的年月日时分秒，也可使用<code>with</code>，接收指定日期进行修改</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime localDateTime = LocalDateTime.now();<br>    LocalDateTime localDateTime1 = localDateTime.withYear(<span class="hljs-number">2023</span>);<br>    LocalDateTime localDateTime2 = localDateTime.withMonth(<span class="hljs-number">3</span>);<br>    LocalDateTime localDateTime3 = localDateTime.withDayOfMonth(<span class="hljs-number">23</span>);<br>    LocalDateTime localDateTime4 = localDateTime.withHour(<span class="hljs-number">12</span>);<br>    LocalDateTime localDateTime5 = localDateTime.withMinute(<span class="hljs-number">23</span>);<br>    LocalDateTime localDateTime6 = localDateTime.withSecond(<span class="hljs-number">33</span>);<br>    LocalDateTime localDateTime7 = localDateTime.withNano(<span class="hljs-number">233000000</span>);<br>    LocalDateTime localDateTime8 = localDateTime.withDayOfYear(<span class="hljs-number">233</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时间矫正器"><a href="#时间矫正器" class="headerlink" title="时间矫正器"></a>时间矫正器</h2><p>根据一个日期获取指定的时间，如本月第一天、最后一天、下个月第一天等等指定日期，都是返回新的本地时间</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 本月第一天</span><br>localDateTime.with(TemporalAdjusters.firstDayOfMonth());<br>    <span class="hljs-comment">// 本月最后一天</span><br>    localDateTime.with(TemporalAdjusters.lastDayOfMonth());<br>    <span class="hljs-comment">// 下个月第一天</span><br>    localDateTime.with(TemporalAdjusters.firstDayOfNextMonth());<br>    <span class="hljs-comment">// 今年第一天</span><br>    localDateTime.with(TemporalAdjusters.firstDayOfYear());<br>    <span class="hljs-comment">// 今年最后一天</span><br>    localDateTime.with(TemporalAdjusters.lastDayOfYear());<br>    <span class="hljs-comment">// 明年第一天</span><br>    localDateTime.with(TemporalAdjusters.firstDayOfNextYear());<br>    <span class="hljs-comment">// 本月第一个周一</span><br>    localDateTime.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));<br>    <span class="hljs-comment">// 本月最后一个周一</span><br>    localDateTime.with(TemporalAdjusters.lastInMonth(DayOfWeek.MONDAY));<br>    <span class="hljs-comment">// 本月开始算起，第n个周几，-1表示本月最后一个</span><br>    localDateTime.with(TemporalAdjusters.dayOfWeekInMonth(-<span class="hljs-number">1</span>, DayOfWeek.MONDAY));<br>    <span class="hljs-comment">// 下一个周一</span><br>    localDateTime.with(TemporalAdjusters.next(DayOfWeek.MONDAY));<br>    <span class="hljs-comment">// 下一个周二，如果当前是周二则返回当前日期</span><br>    localDateTime.with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));<br>    <span class="hljs-comment">// 上一个周一</span><br>    localDateTime.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));<br>    <span class="hljs-comment">// 上一个周二，如果当前是周二则返回当前日期</span><br>    localDateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.TUESDAY));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h2><p>两个日期比较，是否在前或在后</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    LocalDateTime future = LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">22</span>, <span class="hljs-number">233</span>);<br>    System.out.println(now.isBefore(future));<br>    System.out.println(now.isAfter(future));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时间量"><a href="#时间量" class="headerlink" title="时间量"></a>时间量</h2><p>注意时间量有正负之分</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    LocalDateTime future = LocalDateTime.parse(<span class="hljs-string">&quot;2022-6-30 23:59:59&quot;</span>, DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));<br>    <span class="hljs-comment">// 通过时间比较创建</span><br>    Duration duration1 = Duration.between(now, future);<br>    <span class="hljs-comment">// 手动创建，可通过API或指定单位及数量</span><br>    Duration duration2 = Duration.ofDays(<span class="hljs-number">20</span>);<br>    Duration duration3 = Duration.of(<span class="hljs-number">10</span>, ChronoUnit.DAYS);<br>    <span class="hljs-comment">// 通过字符串解析创建</span><br>    Duration duration4 = Duration.parse(<span class="hljs-string">&quot;PT1089H45M&quot;</span>);<br>    <span class="hljs-comment">// 常用API</span><br>    Duration duration5 = Duration.between(future, now);<br>    <span class="hljs-comment">// 取绝对值</span><br>    Duration duration6 = duration5.abs();<br>    <span class="hljs-comment">// 与其他时间比较</span><br>    <span class="hljs-keyword">int</span> i = duration6.compareTo(duration5);<br>    <span class="hljs-comment">// 是否相同</span><br>    <span class="hljs-keyword">boolean</span> equals = duration6.equals(duration5);<br>    <span class="hljs-comment">// 等份划分</span><br>    Duration duration7 = duration6.dividedBy(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 取纳秒，与getNano相同</span><br>    <span class="hljs-keyword">long</span> nano = duration6.get(ChronoUnit.NANOS);<br>    <span class="hljs-comment">// 取秒</span><br>    <span class="hljs-keyword">long</span> second = duration6.get(ChronoUnit.SECONDS);<br>    <span class="hljs-comment">// 判断是否为负</span><br>    <span class="hljs-keyword">boolean</span> negative = duration6.isNegative();<br>    <span class="hljs-comment">// 是否为0</span><br>    <span class="hljs-keyword">boolean</span> isZero = duration6.isZero();<br>    <span class="hljs-comment">// 减去特定时间，可指定单位及数量</span><br>    Duration duration8 = duration6.minus(duration7);<br>    Duration duration9 = duration6.minusDays(<span class="hljs-number">2</span>);<br>    Duration duration10 = duration6.minus(<span class="hljs-number">3</span>, ChronoUnit.DAYS);<br>    <span class="hljs-comment">// 返回负数</span><br>    Duration negated = duration6.negated();<br>    <span class="hljs-comment">// 增加时间，可指定单位及数量</span><br>    Duration duration11 = duration6.plus(<span class="hljs-number">2</span>, ChronoUnit.DAYS);<br>    Duration duration12 = duration6.plusHours(<span class="hljs-number">3</span>);<br>    Duration duration13 = duration6.plus(duration2);<br>    <span class="hljs-comment">// 转换为天数、时分秒等（向下取整）</span><br>    <span class="hljs-keyword">long</span> days = duration6.toDays();<br>    <span class="hljs-comment">// 转换为纳秒</span><br>    <span class="hljs-keyword">long</span> nanos = duration6.toNanos();<br>    <span class="hljs-comment">// 修改秒数，不修改纳秒数</span><br>    Duration duration14 = duration6.withSeconds(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">// 修改纳秒，但不修改其他单位如时分秒</span><br>    Duration duration15 = duration6.withNanos(<span class="hljs-number">2333</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时期时间量"><a href="#时期时间量" class="headerlink" title="时期时间量"></a>时期时间量</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDate now = LocalDate.now();<br>    LocalDate future = LocalDate.parse(<span class="hljs-string">&quot;2022-12-31&quot;</span>, DateTimeFormatter.ISO_DATE);<br>    <span class="hljs-comment">// 通过比较创建</span><br>    Period period = now.until(future);<br>    <span class="hljs-comment">// 手动创建</span><br>    Period period1 = Period.ofDays(<span class="hljs-number">10</span>);<br>    Period period2 = Period.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>    Period period3 = Period.ofWeeks(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 字符串解析</span><br>    Period period4 = Period.parse(<span class="hljs-string">&quot;P2M2D&quot;</span>);<br>   <span class="hljs-comment">// 是否相等</span><br>    <span class="hljs-keyword">boolean</span> equals = period4.equals(period1);<br>    <span class="hljs-comment">// 相加</span><br>    Period period5 = period4.plus(period2);<br>    <span class="hljs-comment">// 只接受YEARS、MONTHS、DAYS，与getYears等效</span><br>    <span class="hljs-keyword">long</span> l = period4.get(ChronoUnit.YEARS);<br>    <span class="hljs-comment">// 获取月份、天数等</span><br>    <span class="hljs-keyword">int</span> months = period4.getMonths();<br>    <span class="hljs-keyword">int</span> days = period4.getDays();<br>    <span class="hljs-comment">// 是否为负数</span><br>    <span class="hljs-keyword">boolean</span> negative = period4.isNegative();<br>    <span class="hljs-comment">// 是否为零</span><br>    <span class="hljs-keyword">boolean</span> zero = period4.isZero();<br>    <span class="hljs-comment">// 相减</span><br>    Period minus = period4.minus(period1);<br>    <span class="hljs-comment">// 减去月数，可选年、日</span><br>    Period period6 = period4.minusMonths(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 取反</span><br>    Period negated = minus.negated();<br>    <span class="hljs-comment">// 标准化</span><br>    Period period7 = period4.normalized();<br>    <span class="hljs-comment">// 相加</span><br>    Period period8 = period4.plus(period5);<br>    <span class="hljs-comment">// 加若干天</span><br>    Period period9 = period4.plusDays(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 从指定的日期中减去次周期</span><br>    LocalDate localDate = (LocalDate) period4.subtractFrom(LocalDate.now());<br>    <span class="hljs-comment">// 修改月数等</span><br>    Period period10 = period4.withMonths(<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    <span class="hljs-comment">// 年份加减</span><br>    LocalDateTime localDateTime1 = now.plusYears(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime11 = now.minusYears(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 月份加减</span><br>    LocalDateTime localDateTime2 = now.plusMonths(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime12 = now.minusMonths(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 周加减</span><br>    LocalDateTime localDateTime3 = now.plusWeeks(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime13 = now.minusWeeks(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 日期加减</span><br>    LocalDateTime localDateTime4 = now.plusDays(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime14 = now.minusDays(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 小时加减</span><br>    LocalDateTime localDateTime5 = now.plusHours(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime15 = now.minusHours(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 分钟加减</span><br>    LocalDateTime localDateTime6 = now.plusMinutes(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime16 = now.minusMinutes(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 秒数加减</span><br>    LocalDateTime localDateTime7 = now.plusSeconds(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime17 = now.minusSeconds(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 毫秒加减</span><br>    LocalDateTime localDateTime8 = now.plusNanos(<span class="hljs-number">2</span>);<br>    LocalDateTime localDateTime18 = now.minusNanos(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 加减的另一种形式</span><br>    LocalDateTime LocalDateTime9 = now.plus(<span class="hljs-number">20</span>, ChronoUnit.DAYS);<br>    LocalDateTime LocalDateTime19 = now.minus(<span class="hljs-number">20</span>, ChronoUnit.DAYS);<br>    LocalDateTime localDateTime0 = now.plus(Duration.ofSeconds(<span class="hljs-number">200</span>));<br>    LocalDateTime localDateTime10 = now.minus(Duration.ofSeconds(<span class="hljs-number">200</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时区时间"><a href="#时区时间" class="headerlink" title="时区时间"></a>时区时间</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 默认时区</span><br>    ZonedDateTime zonedDateTime1 = ZonedDateTime.now();<br>    ZonedDateTime zonedDateTime2 = ZonedDateTime.now(ZoneId.systemDefault());<br>    <span class="hljs-comment">// 指定时区</span><br>    ZonedDateTime newYorkTime = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br>    <span class="hljs-comment">// 时区转换</span><br>    ZonedDateTime shanghaiTime = newYorkTime.withZoneSameInstant(ZoneId.of(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>));<br>    <span class="hljs-comment">// 转换为本地时间</span><br>    LocalDateTime localDateTime = newYorkTime.toLocalDateTime();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 中时区的时间</span><br>    Instant now = Instant.now();<br>    <span class="hljs-comment">// 转为时区时间：东八区</span><br>    OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));<br>    <span class="hljs-comment">// 毫秒时间戳</span><br>    <span class="hljs-keyword">long</span> epochMilli = now.toEpochMilli();<br>    <span class="hljs-comment">// 秒时间戳</span><br>    <span class="hljs-keyword">long</span> epochSecond = now.getEpochSecond();<br>    <span class="hljs-comment">// 当前纳秒</span><br>    <span class="hljs-keyword">int</span> nano = now.getNano();<br>    <span class="hljs-comment">// 实例化：通过给定的毫秒数/秒数</span><br>    Instant instant = Instant.ofEpochSecond(<span class="hljs-number">1675888882</span>);<br>    <span class="hljs-comment">// 通过时间戳创建时区时间</span><br>    ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime localDateTime = LocalDateTime.now();<br>    <span class="hljs-comment">// 转换为时间戳</span><br>    Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant();<br>    LocalDate localDate = localDateTime.toLocalDate();<br>    LocalTime localTime = localDateTime.toLocalTime();<br>    <span class="hljs-comment">// 时间截断至天：2022-06-24T00:00</span><br>    LocalDateTime localDateTime1 = localDateTime.truncatedTo(ChronoUnit.DAYS);<br>    <span class="hljs-comment">// 时间截断至时：2022-06-24T20:00</span><br>    LocalDateTime localDateTime2 = localDateTime.truncatedTo(ChronoUnit.HOURS);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>可使用系统默认的格式化，一般其中<code>FormatStyle.MEDIUM</code>格式<code>为 yyyy-MM-dd HH:mm:ss</code> ，也可以自定义格式，用于格式化或解析</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LocalDateTime now = LocalDateTime.now();<br>    <span class="hljs-comment">//2022-06-23T23:20:54.762</span><br>    DateTimeFormatter.ISO_DATE_TIME.format(now);<br>    <span class="hljs-comment">//2022-06-23</span><br>    DateTimeFormatter.ISO_DATE.format(now);<br>    <span class="hljs-comment">//23:20:54.762</span><br>    DateTimeFormatter.ISO_TIME.format(now);<br>    <span class="hljs-comment">//20220623</span><br>    DateTimeFormatter.BASIC_ISO_DATE.format(now);<br>    <span class="hljs-comment">//2022-W25-4</span><br>    DateTimeFormatter.ISO_WEEK_DATE.format(now);<br>    <span class="hljs-comment">//22-6-23 下午11:20</span><br>    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(now);<br>    <span class="hljs-comment">//2022-6-23 23:20:54</span><br>    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(now);<br>    <span class="hljs-comment">//2022年6月23日 下午11时20分54秒</span><br>    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).format(now);<br>    <span class="hljs-comment">//2022年6月23日 星期四 下午11时20分54秒 CT，需指定地区</span><br>    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).withZone(ZoneId.systemDefault()).format(now);<br>    <span class="hljs-comment">//2022-06-23 23:20:54</span><br>    DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(now);<br>    <span class="hljs-comment">//2022-06-23 星期四 23:20:54</span><br>    DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd EE HH:mm:ss&quot;</span>, Locale.CHINA).format(now);<br>    <span class="hljs-comment">//2022-06-23T15:20:54.789Z</span><br>    DateTimeFormatter.ISO_INSTANT.format(Instant.now());<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>API</code>之间的转换</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/TimeConversionAPI.png"></p><p>新旧日期时间类之间的转换</p><table><thead><tr><th align="left">类</th><th>To 遗留类</th><th>From 遗留类</th></tr></thead><tbody><tr><td align="left">Instant 与 Date</td><td>Date.from(instant)</td><td>date.toInstant()</td></tr><tr><td align="left">Instant 与 Timestamp</td><td>Timestamp.from(instant)</td><td>timstamp.toInstant()</td></tr><tr><td align="left">ZonedDateTime 与 GregorianCanlendar</td><td>GregorianCalendar.from(zonedDateTime)</td><td>gregorianCalendar.toZonedDateTime()</td></tr><tr><td align="left">LocalDate 与 Time(sql)</td><td>Date.valueOf(localDate)</td><td>date.toLocalDate()</td></tr><tr><td align="left">LocalTime 与 Time(sql)</td><td>Date.valueOf(localDate)</td><td>date.toLocalTime()</td></tr><tr><td align="left">LocalTime 与 Timestamp</td><td>Timestamp.valueOf(localDateTime)</td><td>timestamp.toLocalDateTime()</td></tr><tr><td align="left">ZonedId 与 TimeZond</td><td>Timezone.getTimeZone(id)</td><td>timeZone.toZoneId()</td></tr><tr><td align="left">DateTimeFormatter 与 DateFormat</td><td>formatter.toFormat()</td><td>无</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="不可变性和线程安全"><a href="#不可变性和线程安全" class="headerlink" title="不可变性和线程安全"></a>不可变性和线程安全</h3><ul><li>新的<code>java.time</code>类是不可变的，并且天生是线程安全的。这意味着在多线程环境中，不需要额外的同步操作，从而可以减少线程阻塞和管理开销，提高性能。</li><li>旧的<code>Date</code>和<code>Calendar</code>类是可变的，如果在多线程环境中使用，需要额外的同步措施，这可能导致性能下降。</li></ul><h3 id="API设计和内部实现"><a href="#API设计和内部实现" class="headerlink" title="API设计和内部实现"></a>API设计和内部实现</h3><ul><li>新<code>API</code>使用更清晰和更直观的方法来处理日期和时间，这使得操作更加高效。例如，<code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>Instant</code>等类提供了精确到纳秒的时间表示，而<code>Calendar</code>类的时间精度只到毫秒。</li><li>新日期时间类通常执行更快，因为它们依赖于更现代的<code>Java</code>语言特性，如流处理和<code>Lambda</code>表达式。</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul><li>性能测试表明，在执行大量的日期时间计算时，<code>java.time</code> 通常比旧的<code>Date</code>和<code>Calendar</code>更快。这是由于新<code>API</code>在内部实现上更优化，以及不可变对象可以更好地利用现代多核处理器。</li><li>在日期解析和格式化方面，<code>java.time.format.DateTimeFormatter</code>是线程安全的，而旧的<code>SimpleDateFormat</code>则不是。在高并发场景下，<code>DateTimeFormatter</code>无需像<code>SimpleDateFormat</code>那样进行同步，因此表现出更好的性能。</li></ul><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><ul><li>新<code>API</code>的类设计为不可变对象，有助于减少内存泄漏的风险和优化垃圾收集过程。尽管每个操作都返回一个新对象，但<code>Java</code>虚拟机<code>（JVM）</code>的优化和现代垃圾回收机制可以有效管理这些短生命周期的对象。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新的日期和时间API设计精良，易于理解和使用，同时解决了线程安全问题，提高了日期和时间操作的效率。它支持多种日期和时间操作，包括时区处理、持续时间计算等，极大地丰富了Java在日期和时间管理方面的能力。对于所有需要精确处理日期和时间的应用，使用新API无疑是一个更优的选择。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单了解Vue.nextTick</title>
    <link href="/2022/02/07/vue-nexttick/"/>
    <url>/2022/02/07/vue-nexttick/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在日常开发中，理解前端框架处理数据和视图更新的机制是非常重要的，尤其是在处理复杂交互和动态内容时。本文通过一个具体的问题实例，探讨了Vue.js中的<code>nextTick</code>函数的重要性和应用。                                                                                                                                                                                                                    </p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>demo：通过<code>v-if</code>渲染<code>table</code>组件后，获取这个组件的引用，并对其进行下一步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-table v-if=&quot;tableVisible&quot; ref=&quot;table&quot;&gt;<br>      &lt;el-table-column prop=&quot;xxx&quot; label=&quot;xxx&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;<br>    &lt;/el-table&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;Test&quot;,<br>  data() &#123;<br>    return &#123;<br>      tableVisible: false,<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    showTable() &#123;<br>      this.tableVisible = true;<br>      const table = this.$refs[&#x27;table&#x27;];<br>      console.log(table);<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>当触发<code>showTable</code>方法时，控制台打印为：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span><br></code></pre></div></td></tr></table></figure><p>当再次点击的时候，又能获取组件的引用</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">VueComponent &#123;<span class="hljs-attr">_uid</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">_isVue</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">__v_skip</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">_scope</span>: EffectScope, <span class="hljs-attr">$options</span>: &#123;…&#125;, …<br></code></pre></div></td></tr></table></figure><p>这与预想的不太一样，预想中第一次触发方法就能获取到组件的引用</p><p>最终解决方法为：<strong>将获取DOM作为Vue.nextTick(callback)的回调函数逻辑</strong>，即</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">showTable</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.tableVisible = !<span class="hljs-built_in">this</span>.tableVisible;<br>  <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> table = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&#x27;table&#x27;</span>];<br>    <span class="hljs-built_in">console</span>.log(table)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时就跟预期一样，页面刷新后第一次点击按钮就能获取到组件的引用</p><h2 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h2><p>在Vue官方文档《深入响应式原理》中有这样一段话：</p><blockquote><p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用</p></blockquote><p>理解：</p><ol><li><strong>异步更新机制</strong>：Vue 更新 DOM 的过程是异步执行的。这意味着当数据变化时，Vue 不会立即更新 DOM，而是把这些数据变更的操作放入一个队列中。在同一个事件循环<code>（event loop）</code>中，所有的数据变更都会被缓冲到这个队列里。这个机制能有效地整合在短时间内多次数据变更的操作，避免不必要的 DOM 更新，从而提升性能。</li><li><strong>去重操作</strong>：如果在同一个事件循环中一个数据依赖（watcher）被多次触发，它只会被推入队列一次。这种去重是非常重要的，因为它减少了不必要的计算和 DOM 操作。</li><li><strong>事件循环的下一个“tick”</strong>：Vue 会在事件循环的下一个“tick”中，处理并刷新这个队列，执行实际的（已去重的）DOM 更新。Vue 内部使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 或 <code>setImmediate</code> 来管理这个异步队列。如果这些都不可用，它会使用 <code>setTimeout(fn, 0)</code>。</li><li><strong>Vue.nextTick() 的使用</strong>：在实际开发中，有时候我们需要在 Vue 更新 DOM 之后立即执行某些操作。由于 Vue 的 DOM 更新是异步的，直接在数据变更后操作 DOM 可能得不到更新后的结果。Vue 提供了 <code>Vue.nextTick(callback)</code> 方法来解决这个问题。这个方法会在 DOM 更新完成后执行提供的回调函数，确保你可以操作最新的 DOM 状态。</li></ol><p>这个机制是Vue.js提高性能和效率的关键，同时它也支持了Vue.js的数据驱动的设计哲学，即尽可能避免直接操作 DOM，而是通过数据来控制UI。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>手动触发等待 DOM 更新：<code>nextTick()</code> 最直接的用途。当数据改变后，想要立即基于新的 DOM 状态执行某些操作时，<code>nextTick()</code> 是必要的。</p></li><li><p>Vue生命周期钩子函数如果要操作DOM，一定要放在<code>Vue.$nextTick</code>的回调函数中，确保数据变更后拿到最新的DOM。</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Vue.$nextTick</code>返回的是一个<code>Promise</code>对象，因此可以使用<code>ES2017 async/await</code>完成相同的事情，如</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">showTable</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.tableVisible = !<span class="hljs-built_in">this</span>.tableVisible;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$nextTick();<br>  <span class="hljs-keyword">const</span> table = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&#x27;table&#x27;</span>];<br>  <span class="hljs-built_in">console</span>.log(table)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时同样可以获得table组件的DOM引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于后端开发人员来说，虽然主要关注的是服务器、数据库和API的开发，但对前端框架的基本理解将极大地促进开发流程和跨团队协作。本文是一篇后端开发者遇到的前端问题解析，通过分析Vue.js的<code>nextTick</code>功能，展示了如何处理Vue组件和DOM更新的典型问题。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——线程池</title>
    <link href="/2021/08/23/javase-cp-threadpool/"/>
    <url>/2021/08/23/javase-cp-threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在高并发环境下，线程创建与销毁的频繁切换会带来额外的开销。线程池通过对线程的复用、可控的队列和多种灵活的拒绝策略，让并发编程在性能、可维护性和扩展性上达到平衡。本文系统介绍了 Java 并发编程中的线程池概念和关键实现方式：从 <code>ThreadPoolExecutor</code> 核心原理到常见线程池类型的应用场景，再到 <code>Fork/Join</code> 框架、线程池管理与调优策略，全方位助力开发者编写更高效的并发程序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程池（<code>Thread Pool</code>）是一种多线程处理技术，通过预先创建并维护一定数量的线程来执行并发任务。其核心思想包括：</p><ul><li><strong>资源复用</strong>：重复使用固定数量的线程处理多个任务，避免频繁创建和销毁线程带来的开销。</li><li><strong>任务管理</strong>：通过队列管理提交的任务，控制任务的执行顺序与优先级。</li><li><strong>状态维护</strong>：线程池负责监控线程状态，包括空闲、忙碌和终止等。</li></ul><p>在 Java 中，<code>java.util.concurrent</code> 包提供了丰富的线程池实现，如 <code>ThreadPoolExecutor</code>、<code>Executors</code> 工具类等，方便开发者根据需求创建和管理线程池。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><strong>提高性能</strong><ul><li><strong>减少创建和销毁开销</strong>：线程池通过复用线程，避免每次任务执行都创建新线程，从而降低系统开销和响应时间。</li><li><strong>资源优化</strong>：通过控制线程数量，防止过多线程导致系统资源耗尽（如 CPU 过载、内存不足等）。</li></ul></li><li><strong>任务管理</strong><ul><li><strong>统一调度</strong>：线程池提供任务队列和调度机制，有序地管理大量并发任务，提升任务处理的可预测性和稳定性。</li><li><strong>灵活配置</strong>：支持自定义线程数量、队列类型、拒绝策略等，满足不同应用场景的需求。</li></ul></li><li><strong>简化编程模型</strong><ul><li>开发者无需手动管理线程生命周期，降低并发编程复杂度，更专注于业务逻辑实现。</li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>资源复用与性能提升</strong>：通过复用线程减少频繁创建和销毁线程的开销，提高系统响应速度和吞吐量。</li><li><strong>统一管理与控制</strong>：集中管理线程，便于监控、调优和维护，避免资源泄露和线程过多导致的性能问题。</li><li><strong>可配置性强</strong>：提供多种配置参数（如核心线程数、最大线程数、队列类型、拒绝策略等），满足不同场景需求。</li><li><strong>提高稳定性</strong>：通过合理设置线程池参数和拒绝策略，可以防止系统因资源竞争或过载而崩溃，提高系统稳定性。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>配置复杂</strong>：参数设置不当可能导致性能瓶颈或资源浪费。需要深入理解线程池工作原理，根据应用特点进行调优。</li><li><strong>有限的灵活性</strong>：固定线程池大小可能无法应对突然增加的任务负载；动态调整线程数虽然灵活，但增加了管理复杂性。</li><li><strong>潜在的死锁与资源竞争</strong>：如果任务间存在依赖关系或不当的锁机制设计，线程池内的线程可能发生死锁或频繁竞争资源，影响系统正常运行。</li></ul><h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code> 是 Java 中实现线程池功能的核心类，位于 <code>java.util.concurrent</code> 包中。其主要构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123; ... &#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>corePoolSize</code>：核心线程数，始终保持活动的线程数。</li><li><code>maximumPoolSize</code>：池中允许的最大线程数。</li><li><code>keepAliveTime</code> 和 <code>unit</code>：非核心线程的空闲存活时间及其单位，当空闲时间超过该值时被回收。</li><li><code>workQueue</code>：用于存放等待执行任务的工作队列。</li><li><code>threadFactory</code>：用于创建新线程的线程工厂。</li><li><code>handler</code>：任务拒绝策略，当线程池和队列都满时的处理方式。</li></ul><p><strong>示例</strong>：创建了一个核心 5 线程，最大 10 线程的线程池，并采用默认线程工厂和拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>    <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>    Executors.defaultThreadFactory(),<br>    <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()<br>);<br>executor.execute(() -&gt; &#123;<br>    <span class="hljs-comment">// 执行任务代码</span><br>&#125;);<br>executor.shutdown();<br></code></pre></div></td></tr></table></figure><h3 id="核心和最大线程数"><a href="#核心和最大线程数" class="headerlink" title="核心和最大线程数"></a>核心和最大线程数</h3><h4 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h4><ul><li>线程池在正常情况下维护的最小线程数。即使没有任务需要执行，这些核心线程也会一直存在（除非设置了允许核心线程超时回收）。</li><li>当提交新任务时，如果当前运行线程数少于核心数，则立即创建新线程处理任务，即使其他线程处于空闲状态。</li></ul><h4 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h4><ul><li>线程池能够容纳的最大线程数。它决定了线程池在面对任务洪峰时能够扩展到的线程数上限。</li><li>当任务队列已满且当前线程数达到核心数时，会继续创建非核心线程，直到达到最大线程数。</li><li>超过最大线程数后，若有新任务提交，则根据拒绝策略处理。</li></ul><h4 id="两者关系与调度策略"><a href="#两者关系与调度策略" class="headerlink" title="两者关系与调度策略"></a>两者关系与调度策略</h4><ul><li><p><strong>任务提交顺序：</strong></p><ol><li>如果当前线程数 &lt; <code>corePoolSize</code>，新任务会创建新的线程执行。</li><li>如果当前线程数 ≥ <code>corePoolSize</code>，将任务放入工作队列等待执行。</li><li>若队列已满且当前线程数 &lt; <code>maximumPoolSize</code>，则创建新线程处理任务。</li><li>若线程数达到 <code>maximumPoolSize</code> 且队列已满，则任务由拒绝策略处理。</li></ol></li><li><p><strong>调优考虑：</strong></p><p>选择合适的核心和最大线程数取决于应用需求、任务类型和系统资源，避免过多线程导致资源竞争或过少线程造成性能瓶颈。</p></li></ul><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><h4 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h4><ul><li>工作队列（<code>BlockingQueue&lt;Runnable&gt;</code>）用于存放等待执行的任务。</li><li>它的类型和容量会直接影响线程池的行为和性能。</li></ul><h4 id="常见队列类型"><a href="#常见队列类型" class="headerlink" title="常见队列类型"></a>常见队列类型</h4><ul><li><strong>无界队列</strong>（如 <code>LinkedBlockingQueue</code> 默认无界）：允许无限制的任务积压，但可能导致线程池无法扩展到最大线程数。</li><li><strong>有界队列</strong>（如 <code>ArrayBlockingQueue</code>）：限制队列容量，有助于控制资源使用和拒绝压力，但可能因队列满而触发拒绝策略。</li><li><strong>直接交付队列</strong>（如 <code>SynchronousQueue</code>）：不存储任务，直接将任务移交给线程处理，通常与无限制的最大线程配合使用。</li></ul><h4 id="对线程池影响"><a href="#对线程池影响" class="headerlink" title="对线程池影响"></a>对线程池影响</h4><ul><li>队列为空时，线程池创建新线程处理任务；队列非空时，新任务入队等待空闲线程处理。</li><li>队列类型和容量决定了在什么情况下线程池会扩展线程数量或触发拒绝策略。</li></ul><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>线程工厂（<code>ThreadFactory</code>）用于创建新线程，提供了一种定制化线程创建方式。</li><li>通过实现 <code>ThreadFactory</code> 接口，可以设置线程的名称、优先级、守护状态等属性，便于调试和管理。</li></ul><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadFactory customFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br>        thread.setName(<span class="hljs-string">&quot;MyPoolThread-&quot;</span> + counter.getAndIncrement());<br>        thread.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> thread;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>将此工厂传递给 <code>ThreadPoolExecutor</code> 构造器，使线程池使用自定义的线程创建规则。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>当线程池中的线程数达到 <code>maximumPoolSize</code> 且工作队列已满时，新提交的任务无法被接受，这时会触发拒绝策略。</li><li><code>RejectedExecutionHandler</code> 接口定义了如何处理被拒绝的任务。</li></ul><h4 id="常见拒绝策略"><a href="#常见拒绝策略" class="headerlink" title="常见拒绝策略"></a>常见拒绝策略</h4><ol><li><strong>AbortPolicy（默认）</strong>：抛出 <code>RejectedExecutionException</code>，任务被拒绝并终止执行。</li><li><strong>CallerRunsPolicy</strong>：由调用者线程执行该任务，如果线程池已关闭则丢弃任务。</li><li><strong>DiscardPolicy</strong>：直接丢弃新任务，不抛出异常。</li><li><strong>DiscardOldestPolicy</strong>：丢弃最旧的未处理任务，将新任务提交到队列尾部。</li></ol><h4 id="定制拒绝策略"><a href="#定制拒绝策略" class="headerlink" title="定制拒绝策略"></a>定制拒绝策略</h4><p>可以实现 <code>RejectedExecutionHandler</code> 接口，定义自定义的拒绝行为。例如记录日志、存储到外部系统等。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRejectedExecutionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;任务被拒绝，执行自定义处理逻辑&quot;</span>);<br>        <span class="hljs-comment">// 可以将任务保存到外部系统、日志记录或重试机制</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><h4 id="生命周期与状态"><a href="#生命周期与状态" class="headerlink" title="生命周期与状态"></a>生命周期与状态</h4><p><code>ThreadPoolExecutor</code> 通过内部状态管理线程池的生命周期，主要状态包括：</p><ol><li><strong>RUNNING</strong>：初始状态，接受新任务和处理队列中的任务。</li><li><strong>SHUTDOWN</strong>：调用 <code>shutdown()</code> 后进入该状态，不再接收新任务，但继续处理队列中已提交的任务。</li><li><strong>STOP</strong>：调用 <code>shutdownNow()</code> 或遇到严重故障时进入状态，不再接收新任务，尝试停止正在执行的任务并清空队列。</li><li><strong>TIDYING</strong>：所有任务已终止，工作线程空闲后进入此状态，准备进行资源清理。</li><li><strong>TERMINATED</strong>：完全终止状态，线程池生命周期结束。</li></ol><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li>从 <code>RUNNING</code> 到 <code>SHUTDOWN</code>：调用 <code>shutdown()</code> 方法。</li><li>从 <code>RUNNING</code> 或 <code>SHUTDOWN</code> 到 <code>STOP</code>：调用 <code>shutdownNow()</code> 方法。</li><li>当所有任务完成且线程清理结束后，进入 <code>TIDYING</code>，再到 T<code>ERMINATED</code>。</li></ul><h4 id="监控与管理"><a href="#监控与管理" class="headerlink" title="监控与管理"></a>监控与管理</h4><ul><li>可以通过线程池提供的方法（如 <code>isShutdown()</code>, <code>isTerminated()</code> 等）查询状态。</li><li>状态有助于合理地关闭线程池、释放资源及保证程序正确终止。</li></ul><h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><h3 id="固定数量线程池（FixedThreadPool）"><a href="#固定数量线程池（FixedThreadPool）" class="headerlink" title="固定数量线程池（FixedThreadPool）"></a>固定数量线程池（FixedThreadPool）</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>固定数量线程池通过 <code>Executors.newFixedThreadPool(int nThreads)</code> 创建，其核心线程数和最大线程数均设置为 <code>nThreads</code>。线程池始终维护固定数量的线程。</p><h4 id="特点与行为"><a href="#特点与行为" class="headerlink" title="特点与行为"></a>特点与行为</h4><ul><li><strong>线程数固定</strong>：始终保持 <code>nThreads</code> 个活动线程，无论任务负载如何变化。</li><li><strong>任务队列</strong>：使用无界任务队列（如 <code>LinkedBlockingQueue</code>），新任务会被放入队列中等待空闲线程处理。</li><li><strong>适用场景</strong>：适用于可预知任务量、需要控制并发线程数以避免资源耗尽的场景，如服务器固定数量的处理线程。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：线程数固定，易于预测系统资源使用。</li><li><strong>缺点</strong>：队列无界可能导致内存增长；无法动态调整线程数应对突发负载。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThreadPoolExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个固定大小为5的线程池</span><br>        ExecutorService fixedPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 提交若干任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            fixedPool.execute(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;FixedThreadPool - 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 由线程 &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        fixedPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="可缓存线程池（CachedThreadPool）"><a href="#可缓存线程池（CachedThreadPool）" class="headerlink" title="可缓存线程池（CachedThreadPool）"></a>可缓存线程池（CachedThreadPool）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>可缓存线程池通过 <code>Executors.newCachedThreadPool()</code> 创建，其核心线程数为 0，最大线程数为无限大，使用 <code>SynchronousQueue</code> 作为任务队列。</p><h4 id="特点与行为-1"><a href="#特点与行为-1" class="headerlink" title="特点与行为"></a>特点与行为</h4><ul><li><strong>动态线程创建</strong>：没有核心线程限制，新任务提交时若无闲置线程则创建新线程。</li><li><strong>线程回收</strong>：空闲线程超过 60 秒未使用将被回收，减少资源占用。</li><li><strong>任务队列</strong>：使用无容量的同步队列（<code>SynchronousQueue</code>），任务必须有线程立即处理，否则创建新线程。</li><li><strong>适用场景</strong>：适用于执行大量短期异步任务，任务量波动较大，对响应速度要求高的场景。</li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：灵活应对任务峰谷变化，线程可复用提高性能。</li><li><strong>缺点</strong>：线程数无限制增长可能导致资源耗尽，需要谨慎使用。</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedThreadPoolExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个可缓存的线程池</span><br>        ExecutorService cachedPool = Executors.newCachedThreadPool();<br><br>        <span class="hljs-comment">// 提交若干任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            cachedPool.execute(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;CachedThreadPool - 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 由线程 &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        cachedPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="单线程池（SingleThreadExecutor）"><a href="#单线程池（SingleThreadExecutor）" class="headerlink" title="单线程池（SingleThreadExecutor）"></a>单线程池（SingleThreadExecutor）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>单线程池通过 <code>Executors.newSingleThreadExecutor()</code> 创建，内部实际是固定大小为 1 的线程池。</p><h4 id="特点与行为-2"><a href="#特点与行为-2" class="headerlink" title="特点与行为"></a>特点与行为</h4><ul><li><strong>单一线程执行</strong>：始终只有一个工作线程顺序执行提交的任务，保证任务按提交顺序依次完成。</li><li><strong>任务队列</strong>：任务被放入一个无界队列等待执行。</li><li><strong>适用场景</strong>：需要串行化任务执行并确保任务顺序性，如日志记录、顺序处理事件等。</li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：简单易用，保证任务执行顺序。</li><li><strong>缺点</strong>：单线程可能成为性能瓶颈，不适合并行处理任务。</li></ul><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadExecutorExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个单线程池</span><br>        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();<br><br>        <span class="hljs-comment">// 提交若干任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            singleThreadPool.execute(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;SingleThreadExecutor - 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 由线程 &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        singleThreadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="计划线程池（ScheduledThreadPool）"><a href="#计划线程池（ScheduledThreadPool）" class="headerlink" title="计划线程池（ScheduledThreadPool）"></a>计划线程池（ScheduledThreadPool）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>计划线程池通过 <code>Executors.newScheduledThreadPool(int corePoolSize)</code> 创建，它支持任务延迟执行或周期执行。</p><h4 id="特点与行为-3"><a href="#特点与行为-3" class="headerlink" title="特点与行为"></a>特点与行为</h4><ul><li><strong>定时与周期任务</strong>：提供方法 <code>schedule()</code>、<code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code> 实现延迟执行和周期性任务。</li><li><strong>核心线程数固定</strong>：保持指定数量的核心线程，处理定时任务。</li><li><strong>任务队列</strong>：内部使用延时队列（<code>DelayedWorkQueue</code>）管理等待执行的任务。</li><li><strong>适用场景</strong>：适用于需要在未来某个时刻执行或周期执行的任务，如定时数据备份、定期报告生成等。</li></ul><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：专门设计用于定时任务，调度精准可靠。</li><li><strong>缺点</strong>：线程池大小固定，不会动态扩展，且仅用于调度场景，不适合一般的高并发任务处理。</li></ul><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTaskExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>        log.info(<span class="hljs-string">&quot;主线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br><br>        <span class="hljs-comment">// 延迟2秒执行一次任务</span><br>        scheduledPool.schedule(() -&gt; log.info(<span class="hljs-string">&quot;延迟任务执行，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName()), <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br>        <span class="hljs-comment">// 每隔3秒周期性执行一次任务，初始延迟1秒</span><br>        scheduledPool.scheduleAtFixedRate(() -&gt; log.info(<span class="hljs-string">&quot;周期任务执行，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName()), <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br>        <span class="hljs-comment">// 为演示效果暂停一段时间后关闭</span><br>        scheduledPool.schedule(() -&gt; &#123;<br>            scheduledPool.shutdown();<br>            log.info(<span class="hljs-string">&quot;关闭线程池&quot;</span>);<br>        &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="工作窃取线程池（WorkStealingPool）"><a href="#工作窃取线程池（WorkStealingPool）" class="headerlink" title="工作窃取线程池（WorkStealingPool）"></a>工作窃取线程池（WorkStealingPool）</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>工作窃取线程池通过 <code>Executors.newWorkStealingPool()</code> 创建，基于 <code>ForkJoinPool</code> 实现，适用于大规模并行任务的分治处理。</p><h4 id="特点与行为-4"><a href="#特点与行为-4" class="headerlink" title="特点与行为"></a>特点与行为</h4><ul><li><strong>工作窃取算法</strong>：每个线程维护自己的任务队列，当完成本地任务后，可从其他线程队列窃取任务，提高资源利用率。</li><li><strong>动态线程管理</strong>：线程数通常等于可用处理器核心数，能根据任务负载动态调节。</li><li><strong>任务类型</strong>：适合大量小任务的并行处理，通过递归分解任务和结果合并实现。</li><li><strong>适用场景</strong>：计算密集型任务、分治算法、递归任务等需要并行执行的复杂计算场景。</li></ul><h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：高效利用多核 CPU，减小线程闲置时间，提高并行度。</li><li><strong>缺点</strong>：主要针对 CPU 密集型任务设计，对 I/O 密集型任务可能不适用；调试和监控相对复杂。</li></ul><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkStealingPoolExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个工作窃取线程池，默认线程数等于可用处理器核心数</span><br>        ExecutorService workStealingPool = Executors.newWorkStealingPool();<br><br>        <span class="hljs-comment">// 提交若干任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            workStealingPool.submit(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;WorkStealingPool - 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 由线程 &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 注意：WorkStealingPool使用的是守护线程，主线程需要等待任务完成才能看到输出结果</span><br>        <span class="hljs-comment">// 这里简单地让主线程睡眠一段时间</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        <span class="hljs-comment">// WorkStealingPool不需要显示关闭，它会在没有更多任务时自动退出</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="任务执行与处理"><a href="#任务执行与处理" class="headerlink" title="任务执行与处理"></a>任务执行与处理</h2><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><h4 id="execute-Runnable-task"><a href="#execute-Runnable-task" class="headerlink" title="execute(Runnable task)"></a>execute(Runnable task)</h4><ul><li>定义在 <code>Executor</code> 接口中，用于提交不需要返回值的任务。</li><li>接受一个实现了 <code>Runnable</code> 接口的任务，并将其提交到线程池执行。</li><li>如果任务在执行过程中抛出异常，异常会被线程池捕获并传递到未捕获异常处理器，通常会在控制台输出堆栈跟踪，但不会影响其他任务。</li></ul><h4 id="submit-Callable-task"><a href="#submit-Callable-task" class="headerlink" title="submit(Callable task)"></a>submit(Callable task)</h4><ul><li>定义在 <code>ExecutorService</code> 接口中，支持提交实现了 <code>Runnable</code> 或 <code>Callable</code> 的任务。</li><li>返回一个 <code>Future</code> 对象，用于获取任务的执行结果或检查任务状态：<ul><li>提交 <code>Runnable</code> 时返回 <code>Future&lt;?&gt;</code>，结果为 <code>null</code>（除非使用 <code>submit(Runnable, T result)</code> 提供默认结果）。</li><li>提交 <code>Callable&lt;V&gt;</code> 时返回 <code>Future&lt;V&gt;</code>，可通过 <code>Future.get()</code> 获取结果或抛出异常。</li></ul></li><li>异常处理不同：<ul><li>对于通过 <code>submit()</code> 提交的任务，异常会被封装在 <code>Future</code> 中，并在调用 <code>Future.get()</code> 时抛出 <code>ExecutionException</code>。</li></ul></li></ul><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskSubmissionExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 使用 execute() 提交任务，无返回值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            executor.execute(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;使用 execute() 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot;，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 submit() 提交任务，有返回值</span><br>        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;使用 submit() 执行任务，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            <span class="hljs-comment">// 模拟异常抛出</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 若无异常，返回一个整数</span><br>        &#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试获取结果，会抛出 ExecutionException</span><br>            Integer result = future.get();<br>            log.info(<span class="hljs-string">&quot;任务执行结果：&#123;&#125;&quot;</span>, result);<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException ee) &#123;<br>            log.error(<span class="hljs-string">&quot;任务执行异常：&quot;</span>, ee.getCause());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50.903</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">1</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50.903</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">0</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50.907</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 submit() 执行任务，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50.907</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">2</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">50.908</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 任务执行结果：<span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure><p>由运行结果可知，<code>execute</code> 执行的任务没有返回值，在线程池内部的线程执行；而 <code>submit</code> 执行的任务可以在调用线程获取到返回值以及异常。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="概念与方式"><a href="#概念与方式" class="headerlink" title="概念与方式"></a>概念与方式</h4><ul><li>任务调度指的是线程池如何安排和执行提交的任务。<code>ThreadPoolExecutor</code> 内部通过任务队列和工作线程协同完成任务分派与执行。</li><li>调度过程通常包括任务入队、取出、执行及线程复用等步骤：<ol><li><strong>任务入队</strong>：当提交任务时，根据线程池当前线程数与核心线程数、队列容量等条件决定是创建新线程还是将任务放入队列等待。</li><li><strong>任务取出与执行</strong>：空闲线程从队列中取出任务并执行；执行完成后回归空闲状态以处理后续任务。</li><li><strong>动态调整</strong>：根据任务负载，线程池可能扩展或回收线程（非核心线程超过空闲时间）。</li></ol></li></ul><h4 id="定时与周期调度"><a href="#定时与周期调度" class="headerlink" title="定时与周期调度"></a>定时与周期调度</h4><p>对于计划线程池（<code>ScheduledThreadPoolExecutor</code>），任务调度更为灵活：</p><ul><li>提供 <code>schedule()</code>、<code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code> 方法，实现延迟执行、固定速率周期执行和固定延迟周期执行。</li><li>内部通过延时队列管理任务，确保任务按照预定时间准确执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTaskExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>        log.info(<span class="hljs-string">&quot;主线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br><br>        <span class="hljs-comment">// 延迟2秒执行一次任务</span><br>        scheduledPool.schedule(() -&gt; log.info(<span class="hljs-string">&quot;延迟任务执行，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName()), <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br><br>        <span class="hljs-comment">// 每隔3秒周期性执行一次任务，初始延迟1秒</span><br>        scheduledPool.scheduleAtFixedRate(() -&gt; log.info(<span class="hljs-string">&quot;周期任务执行，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName()), <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br>        <span class="hljs-comment">// 为演示效果暂停一段时间后关闭</span><br>        scheduledPool.schedule(() -&gt; &#123;<br>            scheduledPool.shutdown();<br>            log.info(<span class="hljs-string">&quot;关闭线程池&quot;</span>);<br>        &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">42.551</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 主线程：<span class="hljs-selector-tag">main</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">43.594</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 周期任务执行，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">44.593</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 延迟任务执行，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">46.592</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 周期任务执行，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">49.601</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 周期任务执行，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">52.594</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 周期任务执行，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">52.594</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ScheduledTaskExample</span> - 关闭线程池<br></code></pre></div></td></tr></table></figure><p>由运行结果可知，程序已实现定时调度。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h4><ul><li>**execute(Runnable task)**：<ul><li>如果任务内部抛出未捕获的异常，该异常将由线程池的工作线程捕获，并根据线程的未捕获异常处理器（<code>UncaughtExceptionHandler</code>）处理。</li><li>异常不会传播回调用线程，任务会终止但不影响线程池其他任务执行。</li></ul></li><li>**submit(Callable task)**：<ul><li>异常会被封装在返回的 <code>Future</code> 对象内部。调用 <code>Future.get()</code> 时会抛出 <code>ExecutionException</code>，其原因即为任务执行过程中抛出的异常。</li><li>通过 <code>Future</code> 可以捕获并处理这些异常，而不会影响其他正在执行的任务。</li></ul></li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskSubmissionExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 使用 execute() 提交任务，无返回值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            executor.execute(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;使用 execute() 执行任务 &quot;</span> + taskId + <span class="hljs-string">&quot;，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>                <span class="hljs-keyword">if</span> (taskId == <span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;execute异常示例&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 submit() 提交任务，有返回值</span><br>        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;使用 submit() 执行任务，线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            <span class="hljs-comment">// 模拟异常抛出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;submit异常示例&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 若无异常，返回一个整数</span><br>        &#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试获取结果，会抛出 ExecutionException</span><br>            Integer result = future.get();<br>            log.info(<span class="hljs-string">&quot;任务执行结果：&#123;&#125;&quot;</span>, result);<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException ee) &#123;<br>            log.error(<span class="hljs-string">&quot;任务执行异常：&quot;</span>, ee.getCause());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21.590</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">0</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21.590</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">1</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21.596</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 execute() 执行任务 <span class="hljs-number">2</span>，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21.596</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 使用 submit() 执行任务，线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21.598</span> <span class="hljs-selector-attr">[main]</span> ERROR s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span> - 任务执行异常：<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: submit异常示例<br>at space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">1</span>(TaskSubmissionExample<span class="hljs-selector-class">.java</span>:<span class="hljs-number">32</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.run</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">266</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1149</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">624</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;pool-1-thread-2&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: execute异常示例<br>at space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.TaskSubmissionExample</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(TaskSubmissionExample<span class="hljs-selector-class">.java</span>:<span class="hljs-number">24</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1149</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">624</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br></code></pre></div></td></tr></table></figure><p>由运行结果可知，<code>execute</code> 执行时出现的异常会在线程中被抛出，而 <code>submit</code> 执行时出现的异常会在调用 <code>Future</code> 对象的 <code>get</code> 方法时被抛出。</p><h4 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h4><ul><li>可在线程池外层包装任务，或使用自定义的 <code>ThreadFactory</code> 设置未捕获异常处理器，以捕获并处理异常。注意：异常处理器只能对通过 <code>execute</code> 提交的任务进行异常捕获，通过 <code>submit</code> 提交的任务不会捕获，应通过 返回 <code>Feature</code> 对象的 <code>get</code> 方法获取。</li><li>对于 <code>Callable</code> 任务，可在 <code>call()</code> 方法内自行捕获异常并返回特定结果或状态。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory defaultFactory = Executors.defaultThreadFactory();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread thread = defaultFactory.newThread(r);<br>        <span class="hljs-comment">// 设置未捕获异常处理器</span><br>        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;线程 &#123;&#125; 捕获到异常: &quot;</span>, t.getName(), e);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> thread;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadFactoryExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 使用自定义工厂创建线程池</span><br>        ExecutorService executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                <span class="hljs-number">2</span>,<br>                <span class="hljs-number">4</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<br>                <span class="hljs-keyword">new</span> CustomThreadFactory(),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()<br>        );<br>        executor.execute(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;execute线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;自定义工厂异常示例&quot;</span>);<br>        &#125;);<br>        Future&lt;Object&gt; future = executor.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;submit线程：&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;自定义工厂异常示例&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;submit任务执行结果: &#123;&#125;&quot;</span>, future.get());<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            log.error(<span class="hljs-string">&quot;submit任务执行异常: &quot;</span>, e);<br>        &#125;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行程序，运行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">09</span>:<span class="hljs-number">27.135</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span> - execute线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">09</span>:<span class="hljs-number">27.135</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span> - submit线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">09</span>:<span class="hljs-number">27.141</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> ERROR s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.CustomThreadFactory</span> - 线程 pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 捕获到异常: <br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: 自定义工厂异常示例<br>at space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(CustomThreadFactory<span class="hljs-selector-class">.java</span>:<span class="hljs-number">41</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1149</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">624</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br><span class="hljs-number">02</span>:<span class="hljs-number">09</span>:<span class="hljs-number">27.141</span> <span class="hljs-selector-attr">[main]</span> ERROR s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span> - submit任务执行异常: <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ExecutionException</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: 自定义工厂异常示例<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.report</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">122</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.get</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">192</span>)<br>at space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span><span class="hljs-selector-class">.main</span>(CustomThreadFactory<span class="hljs-selector-class">.java</span>:<span class="hljs-number">48</span>)<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: 自定义工厂异常示例<br>at space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.CustomThreadFactoryExample</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">1</span>(CustomThreadFactory<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.run</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">266</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1149</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">624</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br></code></pre></div></td></tr></table></figure><p>由运行结果可知，异常处理器只能对通过 <code>execute</code> 提交的任务进行异常捕获，通过 <code>submit</code> 提交的任务则时通过返回 <code>Feature</code> 对象的 <code>get</code> 方法获取。</p><h3 id="任务处理和监控"><a href="#任务处理和监控" class="headerlink" title="任务处理和监控"></a>任务处理和监控</h3><h4 id="任务结果处理"><a href="#任务结果处理" class="headerlink" title="任务结果处理"></a>任务结果处理</h4><p>通过 <code>submit()</code> 返回的 <code>Future</code> 对象。</p><ul><li>使用 <code>future.isDone()</code> 检查任务是否完成。</li><li>调用 <code>future.get()</code> 获取任务执行结果，此方法会阻塞直到任务完成。</li><li>使用超时参数的 <code>future.get(timeout, unit)</code> 在指定时间内等待结果，超时则抛出异常。</li></ul><h4 id="任务监控"><a href="#任务监控" class="headerlink" title="任务监控"></a>任务监控</h4><p>线程池本身的监控方法。</p><ul><li><code>getActiveCount()</code>：获取当前正在执行任务的线程数量。</li><li><code>getCompletedTaskCount()</code>：获取已完成的任务数量。</li><li><code>getTaskCount()</code>：获取线程池已提交任务的总数。</li><li><code>getQueue()</code>：获取当前任务队列，可用于监控等待执行的任务数等。</li></ul><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService executor = Executors.newSingleThreadExecutor();<br><br>Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟任务执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务完成&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 检查任务是否完成，并获取结果</span><br><span class="hljs-keyword">while</span> (!future.isDone()) &#123;<br>    log.info(<span class="hljs-string">&quot;任务未完成，等待中...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 监控线程池状态</span><br><span class="hljs-keyword">while</span> (threadPool.getActiveCount() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 监控线程池状态</span><br>    log.info(<span class="hljs-string">&quot;----------------------&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;活跃线程数: &quot;</span> + threadPool.getActiveCount());<br>    log.info(<span class="hljs-string">&quot;已完成任务数: &quot;</span> + threadPool.getCompletedTaskCount());<br>    log.info(<span class="hljs-string">&quot;队列等待任务数: &quot;</span> + threadPool.getQueue().size());<br>    log.info(<span class="hljs-string">&quot;----------------------&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h2><p><code>Fork/Join</code> 框架是 Java 7 引入的一种用于并行任务处理的高级并发框架，旨在简化利用多核处理器进行大规模并行计算的编程模型。</p><h3 id="核心概念与结构"><a href="#核心概念与结构" class="headerlink" title="核心概念与结构"></a>核心概念与结构</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>分而治之：</p><ul><li>将一个大任务拆分成若干较小的子任务，并递归地对子任务继续拆分。</li><li>当子任务足够小或满足某个条件时直接计算。</li><li>最后将子任务的计算结果合并为最终结果。</li></ul><h4 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h4><ul><li><strong>ForkJoinPool</strong>：框架的核心执行器，相当于传统线程池的升级版，专门设计用于执行由 <code>ForkJoinTask</code> 分解的小任务。</li><li>**ForkJoinTask&lt;V&gt;**：所有可提交给 <code>ForkJoinPool</code> 执行的任务的抽象类，主要子类有：<ul><li><strong>RecursiveAction</strong>：不返回结果的任务。</li><li>**RecursiveTask&lt;V&gt;**：返回结果的任务，适用于需要合并计算结果的场景。</li></ul></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p><code>ForkJoinPool</code> 采用工作窃取（<code>work-stealing</code>）算法来提高处理器利用率：</p><ul><li>每个工作线程维护一个双端队列存储任务。</li><li>线程从自己的队列末尾获取任务执行，确保局部性并减少竞争。</li><li>当某个线程队列为空时，它会尝试从其他线程队列的头部“窃取”任务执行，从而平衡各个线程的负载。</li></ul><h4 id="任务分解与合并流程"><a href="#任务分解与合并流程" class="headerlink" title="任务分解与合并流程"></a>任务分解与合并流程</h4><ol><li><strong>划分任务（fork）</strong>：大任务递归地调用 <code>fork()</code> 方法，将自己拆分成多个子任务，并将子任务提交给工作队列。</li><li><strong>执行任务</strong>：工作线程不断从其队列取任务执行，若队列空闲则尝试窃取其他线程的任务。</li><li><strong>合并结果（join）</strong>：子任务执行完毕后，父任务通过调用 <code>join()</code> 方法等待并收集子任务结果，进行合并计算。</li></ol><h3 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="创建自定义任务"><a href="#创建自定义任务" class="headerlink" title="创建自定义任务"></a>创建自定义任务</h4><p>通常通过扩展 <code>RecursiveTask&lt;V&gt;</code> 或 <code>RecursiveAction</code> 类来定义可拆分的任务。</p><p>**RecursiveTask&lt;V&gt;**：<code>SumTask</code> 类通过递归的方式将数组求和任务拆分成更小的子任务。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 拆分阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SumTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] data, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = end - start;<br>        <span class="hljs-keyword">if</span> (length &lt;= THRESHOLD) &#123;<br>            <span class="hljs-comment">// 小任务直接计算</span><br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) &#123;<br>                sum += data[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 拆分任务</span><br>            <span class="hljs-keyword">int</span> mid = start + length / <span class="hljs-number">2</span>;<br>            SumTask leftTask = <span class="hljs-keyword">new</span> SumTask(data, start, mid);<br>            SumTask rightTask = <span class="hljs-keyword">new</span> SumTask(data, mid, end);<br>            leftTask.fork();            <span class="hljs-comment">// 异步执行左边任务</span><br>            <span class="hljs-keyword">long</span> rightResult = rightTask.compute(); <span class="hljs-comment">// 同步计算右边任务</span><br>            <span class="hljs-keyword">long</span> leftResult = leftTask.join();      <span class="hljs-comment">// 等待左边任务结果</span><br>            <span class="hljs-keyword">return</span> leftResult + rightResult;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="提交任务到-ForkJoinPool"><a href="#提交任务到-ForkJoinPool" class="headerlink" title="提交任务到 ForkJoinPool"></a>提交任务到 ForkJoinPool</h4><p>使用 <code>ForkJoinPool</code> 来执行自定义任务，自动管理工作线程和任务调度，利用工作窃取算法提升并行处理性能。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造测试数据</span><br>        <span class="hljs-keyword">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1000000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>            data[i] = i;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建 ForkJoinPool 实例</span><br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool();<br><br>        <span class="hljs-comment">// 创建任务</span><br>        SumTask task = <span class="hljs-keyword">new</span> SumTask(data, <span class="hljs-number">0</span>, data.length);<br><br>        <span class="hljs-comment">// 提交任务并获取结果</span><br>        <span class="hljs-keyword">long</span> result = pool.invoke(task);<br>        log.info(<span class="hljs-string">&quot;数组总和为: &quot;</span> + result);<br><br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">31</span>:<span class="hljs-number">07.646</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.forkjoin</span><span class="hljs-selector-class">.ForkJoinExample</span> - 数组总和为: <span class="hljs-number">499999500000</span><br></code></pre></div></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><strong>高效的并行处理</strong>：利用多核 CPU，通过任务拆分和工作窃取算法最大化并行性。</li><li><strong>简化并行编程</strong>：相比手动创建和管理线程，<code>Fork/Join</code> 框架抽象出任务分解与合并的细节，使并行编程更易实现。</li><li><strong>弹性伸缩</strong>：<code>ForkJoinPool</code> 动态调整线程数、平衡负载，适应不同的计算密集型任务需求。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>计算密集型任务</strong>：如大规模数组处理、递归算法、图像处理等，可以利用多核并行提升性能。</li><li><strong>可分解的大任务</strong>：任务能够拆分为相互独立的小子任务，并在子任务完成后合并结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>合理设置拆分阈值</strong>：拆分太细会导致任务管理开销大，拆分太粗则无法充分并行。根据任务特点调整 <code>THRESHOLD</code> 值以平衡开销与并行度。</li><li><strong>避免共享可变状态</strong>：<code>Fork/Join</code> 任务应尽量避免竞争和锁定，以充分发挥并行计算的优势。</li><li><strong>监控与调优</strong>：使用 JVM 提供的监控工具观察 <code>ForkJoinPool</code> 的线程利用情况和任务队列长度，适时调整池大小或任务拆分策略。</li><li><strong>I/O 密集型任务</strong>：如果在任务拆分完成后还有大量 I/O 等操作，实际并不能获得理想的并行收益，甚至可能在超线程机下出现线程倾斜的现象，需要真实测试与调优。</li></ul><h2 id="性能调优与最佳实践"><a href="#性能调优与最佳实践" class="headerlink" title="性能调优与最佳实践"></a>性能调优与最佳实践</h2><h3 id="如何选择适合的线程池类型"><a href="#如何选择适合的线程池类型" class="headerlink" title="如何选择适合的线程池类型"></a>如何选择适合的线程池类型</h3><h4 id="任务性质分析"><a href="#任务性质分析" class="headerlink" title="任务性质分析"></a>任务性质分析</h4><ul><li><strong>CPU 密集型任务</strong>：适合使用固定大小线程池（<code>FixedThreadPool</code>）或工作窃取线程池（<code>WorkStealingPool</code>），保证线程数与可用 CPU 核心数匹配，避免线程上下文切换开销。</li><li><strong>I/O密集型任务</strong>：由于等待 I/O 操作占用线程时间较长，可使用可缓存线程池（<code>CachedThreadPool</code>）或增加固定线程池的线程数，以提高并发处理能力。</li><li><strong>周期性或延时任务</strong>：采用计划线程池（<code>ScheduledThreadPool</code>），专用于定时调度任务，确保任务按计划执行。</li><li><strong>任务数量大且短小</strong>：使用工作窃取线程池（<code>WorkStealingPool</code>）和 <code>ForkJoin</code> 框架，将任务拆分为更小的子任务并行处理，提高吞吐量。</li></ul><h4 id="业务需求匹配"><a href="#业务需求匹配" class="headerlink" title="业务需求匹配"></a>业务需求匹配</h4><ul><li>如果任务执行顺序有要求，可选择单线程池（<code>SingleThreadExecutor</code>）。</li><li>对于动态变化的任务负载，使用可缓存线程池能快速扩展和回收线程以适应变化。</li></ul><p>结合任务特点和系统资源，选择最优的线程池类型，避免盲目使用默认配置带来的性能瓶颈。</p><h3 id="线程池大小的确定"><a href="#线程池大小的确定" class="headerlink" title="线程池大小的确定"></a>线程池大小的确定</h3><p>合理设置核心线程数与最大线程数至关重要：</p><h4 id="计算型任务"><a href="#计算型任务" class="headerlink" title="计算型任务"></a>计算型任务</h4><ul><li><p>一般设置线程数等于 CPU 核心数（或略大于核心数），以充分利用 CPU 资源，避免线程过多导致的上下文切换。</p></li><li><p>常用经验公式：</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">最佳线程数 = CPU 核心数 * (<span class="hljs-number">1</span> + 等待时间/计算时间)<br></code></pre></div></td></tr></table></figure><p>对于CPU密集型任务，等待时间 ≈ 0，即最佳线程数 ≈ 核心数。</p></li></ul><h4 id="I-O-密集型任务"><a href="#I-O-密集型任务" class="headerlink" title="I/O 密集型任务"></a>I/O 密集型任务</h4><ul><li>由于线程多数时间等待 I/O 响应，可设置线程数大于 CPU 核心数，以弥补 I/O 等待期间的资源浪费。</li><li>根据等待与计算比率调整线程数，参考上述公式合理增加线程数。</li></ul><h4 id="动态调整与测试"><a href="#动态调整与测试" class="headerlink" title="动态调整与测试"></a>动态调整与测试</h4><ul><li>通过压力测试和性能分析工具，模拟实际工作负载，不断调整核心线程数和最大线程数，以找到最佳配置点。</li><li>考虑任务执行时长、波动性及系统硬件条件，采用分步调优方式逐步优化配置。</li></ul><h3 id="监控线程池性能"><a href="#监控线程池性能" class="headerlink" title="监控线程池性能"></a>监控线程池性能</h3><p>有效的监控有助于及时发现性能瓶颈和异常状况：</p><h4 id="线程池内置方法"><a href="#线程池内置方法" class="headerlink" title="线程池内置方法"></a>线程池内置方法</h4><p>使用 <code>ThreadPoolExecutor</code> 提供的监控方法定期记录上述指标变化、分析线程池负载和任务积压情况。</p><h4 id="JMX和可视化监控"><a href="#JMX和可视化监控" class="headerlink" title="JMX和可视化监控"></a>JMX和可视化监控</h4><ul><li>将线程池状态通过 <code>JMX</code> 暴露，结合监控工具（如 <code>VisualVM</code>、<code>JConsole</code>、<code>Prometheus + Grafana</code> 等）实时观察线程池运行状态。</li><li>设置报警阈值，如队列长度超过预设范围或活动线程数长期接近最大值，触发告警以便及时调整。</li></ul><h4 id="日志记录与分析"><a href="#日志记录与分析" class="headerlink" title="日志记录与分析"></a>日志记录与分析</h4><p>在关键任务调度和异常处理处记录日志，分析异常堆栈和任务执行时长，优化任务处理逻辑。</p><h3 id="优化线程使用和队列配置"><a href="#优化线程使用和队列配置" class="headerlink" title="优化线程使用和队列配置"></a>优化线程使用和队列配置</h3><p>根据实际业务需求和监控数据，对线程和队列进行优化：</p><h4 id="合适的工作队列选择"><a href="#合适的工作队列选择" class="headerlink" title="合适的工作队列选择"></a>合适的工作队列选择</h4><ul><li><strong>无界队列（如 LinkedBlockingQueue）</strong>：适用于任务提交速率恒定、内存充足的场景，但可能导致任务堆积过多。</li><li><strong>有界队列（如 ArrayBlockingQueue）</strong>：控制任务积压量，结合拒绝策略处理过载情况，防止资源耗尽。</li><li><strong>同步队列（SynchronousQueue）</strong>：适用于对响应时间要求高且希望动态调整线程数的场景。</li></ul><h4 id="调整线程池参数"><a href="#调整线程池参数" class="headerlink" title="调整线程池参数"></a>调整线程池参数</h4><ul><li>合理设置 <code>keepAliveTime</code>，让非核心线程在空闲时被回收，降低资源消耗。</li><li>配置合适的拒绝策略（<code>RejectedExecutionHandler</code>），如 <code>CallerRunsPolicy</code> 将任务退回调用线程，保证任务不丢失但牺牲部分响应能力。</li></ul><h4 id="线程使用优化"><a href="#线程使用优化" class="headerlink" title="线程使用优化"></a>线程使用优化</h4><ul><li>避免在任务内部进行长时间阻塞操作或过多的同步等待，尽量使用异步 I/O 或分解任务逻辑。</li><li>使用自定义 <code>ThreadFactory</code> 设置线程优先级、命名等信息，便于问题排查和线程调度优化。</li></ul><h4 id="队列与任务匹配"><a href="#队列与任务匹配" class="headerlink" title="队列与任务匹配"></a>队列与任务匹配</h4><ul><li>根据任务特点选择队列类型。例如，短小任务可使用无界队列提高吞吐量；而大任务积压可能适合有界队列限制数量，避免资源耗尽。</li><li>调整队列容量与线程池大小的平衡，确保既能高效利用线程，又不致于因队列过长导致延迟增加。</li></ul><h2 id="线程池的管理与维护"><a href="#线程池的管理与维护" class="headerlink" title="线程池的管理与维护"></a>线程池的管理与维护</h2><h3 id="安全地关闭线程池"><a href="#安全地关闭线程池" class="headerlink" title="安全地关闭线程池"></a>安全地关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p><code>shutdown()</code> 方法会启动线程池的有序关闭过程：</p><ol><li><strong>停止接收新任务</strong>：线程池不再接受新提交的任务。</li><li><strong>继续执行已提交任务</strong>：包括已在队列中的任务和正在执行的任务。</li><li><strong>等待所有任务完成</strong>：直到所有任务执行完毕，线程池才会完全关闭。</li></ol><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p><code>shutdownNow()</code> 方法会尝试立即停止所有正在执行的任务，并返回尚未开始执行的任务列表：</p><ol><li><strong>停止接收新任务</strong>：与 <code>shutdown()</code> 方法相同。</li><li><strong>尝试中断正在执行的任务</strong>：通过中断线程来尝试停止任务执行。</li><li><strong>返回未执行的任务</strong>：返回一个 <code>List&lt;Runnable&gt;</code>，包含所有尚未执行的任务。</li></ol><h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h4><p>为了确保线程池能够有序地关闭，同时处理可能的异常或超时，可以结合使用 <code>shutdown()</code> 和 <code>awaitTermination()</code> 方法。以下是一个实现优雅关闭的示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GracefulShutdownExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 提交任务</span><br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                log.info(<span class="hljs-string">&quot;任务1完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;任务1被中断&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">4000</span>);<br>                log.info(<span class="hljs-string">&quot;任务2完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;任务2被中断&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 优雅关闭</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS)) &#123;<br>                log.info(<span class="hljs-string">&quot;任务未完成，尝试立即关闭&quot;</span>);<br>                executor.shutdownNow();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;主线程被中断，立即关闭线程池&quot;</span>);<br>            executor.shutdownNow();<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;线程池关闭完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">00.772</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.GracefulShutdownExample</span> - 任务<span class="hljs-number">1</span>完成<br><span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">01.772</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.GracefulShutdownExample</span> - 任务<span class="hljs-number">2</span>完成<br><span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">01.772</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.GracefulShutdownExample</span> - 线程池关闭完成<br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>shutdown()</code> 调用后，线程池不再接受新任务，但会继续执行已提交的任务。</li><li><code>awaitTermination(long timeout, TimeUnit unit)</code> 方法会阻塞当前线程，直到线程池关闭或者达到指定的超时时间。</li><li>如果在指定时间内线程池未关闭，则调用 <code>shutdownNow()</code> 强制关闭线程池。</li><li>通过捕获 <code>InterruptedException</code>，确保在主线程被中断时能够及时关闭线程池并恢复中断状态。</li></ul><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>在某些情况下，应用程序可能需要在 JVM 关闭时自动关闭线程池，可以使用钩子线程（<code>Shutdown Hook</code>）来实现。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShutdownHookExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 提交任务</span><br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">4000</span>);<br>                log.info(<span class="hljs-string">&quot;任务1完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;任务1被中断&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 添加钩子线程</span><br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;JVM 关闭，开始关闭线程池&quot;</span>);<br>            executor.shutdown();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS)) &#123;<br>                    executor.shutdownNow();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                executor.shutdownNow();<br>                Thread.currentThread().interrupt();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;线程池已关闭&quot;</span>);<br>        &#125;));<br><br>        <span class="hljs-comment">// 模拟应用程序运行</span><br>        log.info(<span class="hljs-string">&quot;应用程序运行中，按 Ctrl+C 终止...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序、等待一段时间后，手动关闭程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.332</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ShutdownHookExample</span> - 应用程序运行中，按 Ctrl+C 终止...<br><span class="hljs-number">02</span>:<span class="hljs-number">44</span>:<span class="hljs-number">01.336</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ShutdownHookExample</span> - 任务<span class="hljs-number">1</span>完成<br><span class="hljs-number">02</span>:<span class="hljs-number">44</span>:<span class="hljs-number">06.765</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ShutdownHookExample</span> - JVM 关闭，开始关闭线程池<br><span class="hljs-number">02</span>:<span class="hljs-number">44</span>:<span class="hljs-number">06.766</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.ShutdownHookExample</span> - 线程池已关闭<br></code></pre></div></td></tr></table></figure><p>由运行结果可知，当 JVM 接收到关闭信号，钩子线程会自动执行，确保线程池得到适当关闭。</p><h3 id="线程池资源的回收"><a href="#线程池资源的回收" class="headerlink" title="线程池资源的回收"></a>线程池资源的回收</h3><h4 id="线程池的关闭与资源回收"><a href="#线程池的关闭与资源回收" class="headerlink" title="线程池的关闭与资源回收"></a>线程池的关闭与资源回收</h4><p>如前述，正确关闭线程池是释放其资源的前提。调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 后，线程池会逐步释放其内部资源，包括：</p><ul><li><strong>线程对象</strong>：线程池中的工作线程会终止并释放其占用的内存。</li><li><strong>任务队列</strong>：任务队列中的任务会被清空（在 <code>shutdownNow()</code> 的情况下）。</li><li><strong>其他内部资源</strong>：如与JVM交互的本地资源句柄等。</li></ul><h4 id="避免线程池的资源泄露"><a href="#避免线程池的资源泄露" class="headerlink" title="避免线程池的资源泄露"></a>避免线程池的资源泄露</h4><p>资源泄露通常是由于线程池未正确关闭，导致工作线程持续存在，进而阻塞JVM的正常关闭。以下是避免资源泄露的最佳实践：</p><ul><li><strong>确保线程池被关闭</strong>：在应用程序结束前，确保所有线程池都已经调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法。</li><li><strong>使用 Try-Finally 块管理线程池</strong>：确保在异常情况下线程池也能被正确关闭。</li><li><strong>使用钩子线程</strong>：如前述，确保在JVM关闭时线程池得到适当关闭。</li></ul><h3 id="动态调整线程池参数"><a href="#动态调整线程池参数" class="headerlink" title="动态调整线程池参数"></a>动态调整线程池参数</h3><p>在实际应用中，线程池的负载和任务特性可能会随着时间变化。动态调整线程池的参数（如核心线程数、最大线程数、任务队列等），可以更好地适应负载变化，提高系统性能和资源利用率。Java的 <code>ThreadPoolExecutor</code> 提供了多种方法来动态调整线程池参数。</p><ul><li>**void setCorePoolSize(int corePoolSize)**：设置线程的核心数量。</li><li>**void setMaximumPoolSize(int maximumPoolSize)**：设置允许的最大线程数。</li><li>**void setRejectedExecutionHandler(RejectedExecutionHandler handler)**：为不可执行的任务设置新的处理程序。</li></ul><h3 id="合理利用线程池钩子函数"><a href="#合理利用线程池钩子函数" class="headerlink" title="合理利用线程池钩子函数"></a>合理利用线程池钩子函数</h3><p>通过继承 <code>ThreadPoolExecutor</code> 并覆盖其钩子方法（如 <code>beforeExecute()</code>, <code>afterExecute()</code>, <code>terminated()</code>），实现任务执行前后的自定义逻辑。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.beforeExecute(t, r);<br>        log.info(<span class="hljs-string">&quot;任务开始执行，由线程：&quot;</span> + t.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.afterExecute(r, t);<br>        log.info(<span class="hljs-string">&quot;任务执行完成&quot;</span>);<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;任务执行异常: &quot;</span> + t.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.terminated();<br>        log.info(<span class="hljs-string">&quot;线程池已终止&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadPoolExecutorExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> CustomThreadPoolExecutor(<br>                <span class="hljs-number">2</span>,<br>                <span class="hljs-number">4</span>,<br>                <span class="hljs-number">60</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">2</span>)<br>        );<br><br>        <span class="hljs-comment">// 提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.info(<span class="hljs-string">&quot;任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 执行中&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.139</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务开始执行，由线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span><br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.139</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务开始执行，由线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.139</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务开始执行，由线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutorExample</span> - 任务 <span class="hljs-number">4</span> 执行中<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutorExample</span> - 任务 <span class="hljs-number">1</span> 执行中<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutorExample</span> - 任务 <span class="hljs-number">0</span> 执行中<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务执行完成<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务执行完成<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务执行完成<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务开始执行，由线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.158</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务开始执行，由线程：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span><br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">39.168</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutorExample</span> - 任务 <span class="hljs-number">2</span> 执行中<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">39.168</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutorExample</span> - 任务 <span class="hljs-number">3</span> 执行中<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">39.168</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务执行完成<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">39.168</span> <span class="hljs-selector-attr">[pool-1-thread-3]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 任务执行完成<br><span class="hljs-number">02</span>:<span class="hljs-number">55</span>:<span class="hljs-number">39.168</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> INFO  s<span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.t</span><span class="hljs-selector-class">.CustomThreadPoolExecutor</span> - 线程池已终止<br></code></pre></div></td></tr></table></figure><p>由运行结果可知，自定义 <code>ThreadPoolExecutor</code> 中的钩子函数已实现了逻辑定制。</p><h2 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h2><p>在 Java 线程池的管理与维护过程中，以下最佳实践能够帮助开发者有效地管理线程池，优化系统性能：</p><ol><li><strong>始终关闭线程池</strong>：确保在应用程序结束前，所有线程池都得到适当的关闭，防止资源泄露和阻塞JVM关闭。</li><li><strong>选择合适的线程池类型</strong>：根据任务特性（CPU 密集型、I/O 密集型等）和业务需求，选择最适合的线程池类型，避免资源浪费或性能瓶颈。</li><li><strong>合理设置线程池参数</strong>：通过计算和测试确定核心线程数、最大线程数和任务队列容量，确保线程池能够高效处理任务负载。</li><li><strong>动态调整线程池</strong>：结合监控数据，动态调整线程池参数以适应负载变化，提升系统弹性和资源利用率。</li><li><strong>选择合适的队列</strong>：使用无限队列（如 <code>LinkedBlockingQueue</code> 默认情况下的无界队列）可能导致任务堆积过多，消耗大量内存，甚至导致系统崩溃。最佳实践为使用有界队列（如 <code>ArrayBlockingQueue</code>），合理设置队列容量。</li><li><strong>实现自定义拒绝策略和钩子方法</strong>：根据具体业务需求，定制任务被拒绝时的处理逻辑和任务执行前后的行为，增强线程池的可控性和可维护性。</li><li><strong>监控线程池状态</strong>：定期监控线程池的运行状态和资源使用情况，及时发现和解决潜在的问题，确保系统稳定运行。</li><li><strong>异常处理</strong>：在异步任务中捕获和处理异常，避免异常传播导致线程池线程终止；使用 <code>@Async</code> 方法返回 <code>Future</code> 或 <code>CompletableFuture</code>，通过 <code>Future</code> 捕获异常；配置自定义的 <code>ThreadFactory</code>，设置 <code>UncaughtExceptionHandler</code> 处理未捕获异常。</li><li><strong>避免共享可变状态</strong>：在并发任务中，尽量避免共享可变数据，减少同步需求和潜在的死锁风险。</li><li><strong>使用高质量的任务</strong>：确保提交到线程池的任务执行时间合理，避免长时间阻塞或频繁抛出异常，提升线程池的整体效率。</li></ol><p>通过遵循这些管理与维护策略，可以充分发挥Java线程池的优势，提升应用程序的并发处理能力和系统稳定性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 线程池为并发编程提供了完善的“任务提交—执行—管理”框架，极大减轻了开发者在多线程环境下手动管理线程的负担。</p><ul><li>通过 <code>ThreadPoolExecutor</code>，我们可以灵活地配置核心/最大线程数、任务队列、拒绝策略等参数，实现对 CPU 和内存资源的合理调度；</li><li><code>Fork/Join</code> 框架则让分治算法和大规模并行计算变得简单；</li><li>结合 <code>shutdown</code> 与 <code>awaitTermination</code>、钩子线程等手段，能实现安全且可控地关闭线程池、避免资源泄漏；</li><li>通过对性能监控与调优技术（如自定义线程工厂、合理队列容量、定制化拒绝策略、合理拆分阈值）进行持续完善，线程池可以在复杂的生产环境中保持高吞吐、低延迟和良好的稳定性。</li></ul><p>合理运用这些线程池机制能显著提高 Java 应用在多核时代的并发能力，为业务提供可靠和高效的支持。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——其他工具类补充</title>
    <link href="/2021/08/19/javase-cp-other-utils/"/>
    <url>/2021/08/19/javase-cp-other-utils/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Java 并发编程中，JDK 除了提供锁、线程池、并发容器等常见核心内容，还包含了一些用于特殊场景的工具类，以满足多线程协同工作的多种需求。<code>LockSupport</code>、<code>CyclicBarrier</code>、<code>Phaser</code> 与 <code>Exchanger</code> 等便是其中典型代表。它们在底层同步机制上各有巧妙设计，在不同应用场景下能发挥巨大作用。本文将带你系统认识这些工具类的工作原理、使用场景与常见示例，为日后编写更高效更易维护的并发程序提供指引。</p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>LockSupport</code> 提供了对线程阻塞和唤醒的底层支持，是构建高级同步工具（如 <code>Lock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等）的基础，类似于操作系统中的线程调度机制。它通过维护每个线程的许可（<code>permit</code>）来控制线程的阻塞和唤醒，而不依赖于传统的监视器锁（如 <code>synchronized</code> 关键字）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>许可机制</strong>：每个线程拥有一个许可，初始状态为无许可。<code>unpark</code> 方法会发放一个许可，<code>park</code> 方法会消耗一个许可。</li><li><strong>非阻塞的许可获取</strong>：即使在调用 <code>park</code> 之前调用了 <code>unpark</code>，也不会阻塞线程，因为许可已经存在。</li><li><strong>灵活性高</strong>：不像 <code>Object.wait</code> 和 <code>Object.notify</code> 依赖于监视器锁，<code>LockSupport</code> 的阻塞和唤醒操作是独立的，更加灵活。</li></ul><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>阻塞线程</strong>：调用 <code>LockSupport.park()</code> 或其变种方法，使当前线程进入阻塞状态，等待被唤醒。</li><li><strong>唤醒线程</strong>：其他线程调用 <code>LockSupport.unpark(Thread thread)</code>，为目标线程发放一个许可，允许其继续执行。</li><li><strong>许可管理</strong>：每个线程的许可是独立管理的，多次调用 <code>unpark</code> 只会增加一个许可，而不会累积。</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>LockSupport</code> 基于操作系统的底层线程调度机制，通过 JVM 提供的本地方法实现线程的阻塞和唤醒。它维护了每个线程的许可状态：</p><ul><li><strong>park</strong>：如果许可存在，消耗许可并返回；否则，将线程阻塞，等待许可的到来。</li><li><strong>unpark</strong>：为指定线程增加一个许可，如果线程已经阻塞，则唤醒它；否则，许可会被保存，后续的 <code>park</code> 调用会立即返回。</li></ul><p>这种许可机制避免了传统的基于监视器锁的阻塞方法（如 <code>wait/notify</code>）可能出现的竞态条件和死锁问题。</p><h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="阻塞相关方法"><a href="#阻塞相关方法" class="headerlink" title="阻塞相关方法"></a>阻塞相关方法</h4><ul><li>**public static void park()**：阻塞当前线程，直到被唤醒或被中断。</li><li>**public static void park(Object blocker)**：阻塞当前线程，并关联一个阻塞器对象，便于调试和监控。</li><li>**public static void parkNanos(long nanos)**：阻塞当前线程，最多阻塞指定的纳秒时间。</li><li>**public static void parkUntil(long deadline)**：阻塞当前线程，直到指定的绝对时间（毫秒时间戳）。</li></ul><h4 id="唤醒相关方法"><a href="#唤醒相关方法" class="headerlink" title="唤醒相关方法"></a>唤醒相关方法</h4><ul><li>**public static void unpark(Thread thread)**：唤醒指定线程，发放一个许可。</li></ul><h4 id="许可相关方法"><a href="#许可相关方法" class="headerlink" title="许可相关方法"></a>许可相关方法</h4><ul><li>**public static boolean isBlocked(Thread thread)**：检查指定线程是否被阻塞（Java 9 引入）。</li><li>**public static Object getBlocker(Thread thread)**：获取阻塞线程的阻塞器对象（Java 9 引入）。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>构建锁（Lock）</strong>：如 <code>ReentrantLock</code> 的内部实现依赖于 <code>LockSupport</code> 来阻塞和唤醒线程。</li><li><strong>实现线程池</strong>：线程池中的工作线程可能需要被阻塞，等待任务到来，然后被唤醒执行任务。</li><li><strong>构建信号量和屏障</strong>：如 <code>Semaphore</code> 和 <code>CyclicBarrier</code> 等同步器的实现。</li><li><strong>自定义阻塞队列</strong>：在实现“生产者-消费者模型”时，可以使用 <code>LockSupport</code> 控制生产者和消费者的阻塞与唤醒。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>使用 <code>LockSupport</code> 阻塞和唤醒线程。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockSupportExample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread blockerThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;当前线程调用 park()&quot;</span>);<br>            LockSupport.park();<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                log.info(<span class="hljs-string">&quot;线程检测到中断状态&quot;</span>);<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;线程恢复&quot;</span>);<br>        &#125;);<br><br>        blockerThread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 确保 blockerThread 已经调用 park</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;主线程调用 unpark 唤醒 blockerThread&quot;</span>);<br>        LockSupport.unpark(blockerThread);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">01</span>:<span class="hljs-number">08.998</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.LockSupportExample</span> - 当前线程调用 park()<br><span class="hljs-number">15</span>:<span class="hljs-number">01</span>:<span class="hljs-number">09.996</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.LockSupportExample</span> - 主线程调用 unpark 唤醒 blockerThread<br><span class="hljs-number">15</span>:<span class="hljs-number">01</span>:<span class="hljs-number">09.996</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.LockSupportExample</span> - 线程恢复<br></code></pre></div></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>并发编程中的许多阻塞方法如 <code>wait()</code>、<code>sleep()</code>、<code>join()</code> 在线程被中断时会抛出<code>InterruptedException</code>，但 <code>park</code> 和 <code>unpark</code> 不会，对已终止或不存在的线程调用 <code>unpark</code> 也不会报错，<code>park</code> 则会响应中断状态并且程序会重新从阻塞的地方开始执行。</li><li>使用 <code>LockSupport</code> 需要确保对同一线程调用的 <code>unpark</code> 不会丢失许可，即线程 <code>park</code> 之后一定要有其他线程调用 <code>unpark</code> 给线程分发许可，避免线程永久阻塞。</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>CyclicBarrier</code> 是Java提供的一个同步工具类，位于 <code>java.util.concurrent</code> 包中。它允许一组线程在某个同步点等待，直到所有线程都到达该同步点后，所有线程才能继续执行。这种机制非常适用于需要多线程协作完成某些阶段性任务的场景。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>可重用性</strong>：<code>CyclicBarrier</code> 可以在所有线程通过屏障后重置，允许它被多次使用。</li><li><strong>屏障动作</strong>：在所有线程到达屏障点后，可以执行一个预定义的任务（屏障动作），该任务由一个 <code>Runnable</code> 对象定义。</li><li><strong>等待方式</strong>：线程可以选择阻塞等待所有其他线程到达屏障，或在等待超时时放弃等待。</li><li><strong>灵活性</strong>：适用于需要分阶段执行的并发任务，如并行计算、分布式任务协调等。</li></ul><h3 id="使用流程-1"><a href="#使用流程-1" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建 CyclicBarrier 实例</strong>：指定参与屏障的线程数量，并可选地提供一个屏障动作。</li><li><strong>线程到达屏障点</strong>：每个线程在需要等待的地方调用 <code>await()</code> 方法，等待其他线程到达屏障。</li><li><strong>所有线程到达屏障</strong>：当所有参与的线程都调用了 <code>await()</code> 方法后，屏障被触发，所有线程继续执行后续操作，同时执行屏障动作（如果有）。</li><li><strong>重置屏障</strong>：<code>CyclicBarrier</code> 可以被重用，适用于多个循环或阶段。</li></ol><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><code>CyclicBarrier</code> 的内部机制主要基于一个计数器和一个等待队列。当创建 <code>CyclicBarrier</code> 时，指定了需要等待的线程数量（参与者数量）。每当一个线程调用 <code>await()</code> 方法时，计数器减 1。如果计数器仍然大于 0，线程将被阻塞，直到其他线程也调用了 <code>await()</code>。当计数器达到 0 时，所有被阻塞的线程将被唤醒，同时执行屏障动作（如果定义了）。</p><p><strong>关键点</strong>：</p><ul><li><strong>计数器管理</strong>：每调用一次 <code>await()</code>，计数器减 1。当计数器达到 0 时，重置计数器，允许<code>CyclicBarrier</code>再次被使用。</li><li><strong>屏障动作</strong>：<code>CyclicBarrier</code> 允许在所有线程到达屏障时执行一个额外的任务（屏障动作），该任务由一个 <code>Runnable</code> 对象定义。</li><li><strong>重用性</strong>：在所有线程通过屏障后，<code>CyclicBarrier</code> 会重置计数器，允许其再次被用于下一个循环或阶段。</li><li><strong>错误处理</strong>：如果在等待过程中，有线程中断或其他异常导致屏障破裂（<code>BrokenBarrierException</code>），所有等待的线程将抛出异常，确保不会永久阻塞。</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**CyclicBarrier(int parties)**：创建一个 <code>CyclicBarrier</code>，指定参与屏障的线程数量（<code>parties</code>）。</li><li>**CyclicBarrier(int parties, Runnable barrierAction)**：创建一个 <code>CyclicBarrier</code>，指定参与屏障的线程数量，并定义一个屏障动作（<code>barrierAction</code>），当所有线程到达屏障点时执行。</li></ul><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul><li>**int await()**：使当前线程等待，直到所有参与线程都调用了 <code>await()</code> 方法。成功通过屏障时，返回当前线程的屏障索引。</li><li>**int await(long timeout, TimeUnit unit)**：使当前线程等待，直到所有参与线程都调用了 <code>await()</code> 方法，或等待超时。如果超时，抛出 <code>TimeoutException</code>。</li><li>**boolean isBroken()**：查询屏障是否已经破裂。</li><li>**int getNumberWaiting()**：返回当前等待屏障的线程数量。</li><li>**int getParties()**：返回屏障的参与线程数量。</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>**void reset()**：重置屏障，丢弃所有等待线程。所有等待的线程将抛出 <code>BrokenBarrierException</code>。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>CyclicBarrier</code> 适用于需要多个线程协同完成某些阶段性任务的场景，以下是一些典型的应用场景：</p><ul><li><strong>分阶段计算</strong>：在并行计算中，数据被分成多个部分，由不同的线程处理。每个线程完成一部分计算后，需要等待其他线程完成，然后进行下一阶段的计算。</li><li><strong>模拟并发测试</strong>：在测试环境中，使用 <code>CyclicBarrier</code> 可以让多个线程同时开始执行某个任务，以模拟高并发场景，评估系统性能。</li><li><strong>多线程游戏开发</strong>：在游戏开发中，可能需要多个线程协同完成某些任务，如渲染、物理计算、AI决策等。<code>CyclicBarrier</code> 可以确保各个线程在每一帧同步更新。</li><li><strong>多线程数据处理</strong>：在数据处理系统中，可能需要多个线程并行处理数据的不同部分，完成后再汇总结果。<code>CyclicBarrier</code> 可以协调这些线程在每个处理阶段同步。</li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>模拟多线程分阶段计算，四个工作线程需要完成三个阶段的计算。每完成一个阶段，所有线程都必须到达屏障点，屏障动作被执行，然后进入下一阶段。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM_THREADS = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CyclicBarrier barrier;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrierExample</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建CyclicBarrier实例，指定4个参与线程，并定义屏障动作</span><br>        barrier = <span class="hljs-keyword">new</span> CyclicBarrier(NUM_THREADS, () -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;所有线程已到达屏障，开始执行屏障动作。&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">workerTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> workerId)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> phase = <span class="hljs-number">1</span>; phase &lt;= <span class="hljs-number">3</span>; phase++) &#123;<br>                log.info(<span class="hljs-string">&quot;Worker &quot;</span> + workerId + <span class="hljs-string">&quot; 正在执行阶段 &quot;</span> + phase + <span class="hljs-string">&quot; 的任务...&quot;</span>);<br>                Thread.sleep((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 模拟工作时间</span><br>                log.info(<span class="hljs-string">&quot;Worker &quot;</span> + workerId + <span class="hljs-string">&quot; 已完成阶段 &quot;</span> + phase + <span class="hljs-string">&quot; 的任务，等待其他线程...&quot;</span>);<br>                barrier.await(); <span class="hljs-comment">// 等待所有线程完成当前阶段</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWorkers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= NUM_THREADS; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> workerId = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; workerTask(workerId), <span class="hljs-string">&quot;Worker-&quot;</span> + workerId).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CyclicBarrierExample example = <span class="hljs-keyword">new</span> CyclicBarrierExample();<br>        example.startWorkers();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.328</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 正在执行阶段 <span class="hljs-number">1</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.328</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 正在执行阶段 <span class="hljs-number">1</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.328</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 正在执行阶段 <span class="hljs-number">1</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.328</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 正在执行阶段 <span class="hljs-number">1</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.402</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 已完成阶段 <span class="hljs-number">1</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.498</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 已完成阶段 <span class="hljs-number">1</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.722</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 已完成阶段 <span class="hljs-number">1</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 已完成阶段 <span class="hljs-number">1</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - 所有线程已到达屏障，开始执行屏障动作。<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 正在执行阶段 <span class="hljs-number">2</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 正在执行阶段 <span class="hljs-number">2</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 正在执行阶段 <span class="hljs-number">2</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.863</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 正在执行阶段 <span class="hljs-number">2</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">00.998</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 已完成阶段 <span class="hljs-number">2</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.492</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 已完成阶段 <span class="hljs-number">2</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.768</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 已完成阶段 <span class="hljs-number">2</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 已完成阶段 <span class="hljs-number">2</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - 所有线程已到达屏障，开始执行屏障动作。<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 正在执行阶段 <span class="hljs-number">3</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 正在执行阶段 <span class="hljs-number">3</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 正在执行阶段 <span class="hljs-number">3</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">01.807</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 正在执行阶段 <span class="hljs-number">3</span> 的任务...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">02.376</span> <span class="hljs-selector-attr">[Worker-4]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">4</span> 已完成阶段 <span class="hljs-number">3</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">02.431</span> <span class="hljs-selector-attr">[Worker-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">2</span> 已完成阶段 <span class="hljs-number">3</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">02.496</span> <span class="hljs-selector-attr">[Worker-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">1</span> 已完成阶段 <span class="hljs-number">3</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">02.700</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - Worker <span class="hljs-number">3</span> 已完成阶段 <span class="hljs-number">3</span> 的任务，等待其他线程...<br><span class="hljs-number">15</span>:<span class="hljs-number">29</span>:<span class="hljs-number">02.700</span> <span class="hljs-selector-attr">[Worker-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.aqs</span><span class="hljs-selector-class">.CyclicBarrierExample</span> - 所有线程已到达屏障，开始执行屏障动作。<br></code></pre></div></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>线程中断</strong>：如果在等待过程中，某个线程被中断，<code>CyclicBarrier</code> 会破裂（<code>isBroken()</code> 返回 <code>true</code>），其他等待的线程将抛出 <code>BrokenBarrierException</code>。需要处理好异常，避免程序崩溃。</li><li><strong>确保所有线程都到达屏障</strong>：如果某个线程永远不会调用 <code>await()</code>，其他线程将永久等待，导致死锁。需要确保所有参与线程都能正常到达屏障点。</li><li><strong>屏障动作的执行</strong>：屏障动作由一个独立的线程执行，通常是最后一个到达屏障的线程。如果屏障动作抛出异常，会导致 <code>CyclicBarrier</code> 破裂，影响其他等待线程。</li><li><strong>重用性</strong>：<code>CyclicBarrier</code> 是可重用的，可以在多次循环中使用，但需要确保每次使用时所有参与线程都能正确调用<code>await()</code>。</li></ul><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><code>Phaser</code> 是一种可重用的同步器，支持多阶段（<code>phase</code>）的任务执行，并允许动态地注册和注销参与的线程。它主要用于协调一组线程在多个阶段上的同步点，确保所有参与线程在每个阶段完成后再进入下一个阶段。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>多阶段同步</strong>：支持多个同步点（阶段），每个阶段结束后进入下一个阶段。</li><li><strong>动态参与</strong>：可以在运行时动态地增加或减少参与的线程数。</li><li><strong>可重复使用</strong>：类似于 <code>CyclicBarrier</code>，<code>Phaser</code> 可以在多个阶段重复使用。</li><li><strong>灵活性高</strong>：提供了更多的控制方法，如提前终止、获取当前阶段等。</li></ul><h3 id="使用流程-2"><a href="#使用流程-2" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建 Phaser 实例</strong>：指定初始参与者数量，或者使用默认构造方法后动态注册。</li><li><strong>注册参与者</strong>：通过构造时指定或在运行时调用 <code>register()</code> 方法增加参与者。</li><li><strong>执行阶段任务</strong>：每个参与者在完成当前阶段的任务后，调用 <code>arriveAndAwaitAdvance()</code> 等方法，等待其他参与者到达同步点。</li><li><strong>进入下一阶段</strong>：所有参与者到达同步点后，<code>Phaser</code> 进入下一阶段，参与者继续执行下一阶段的任务。</li><li><strong>注销参与者</strong>：任务完成后，参与者可以调用 <code>arriveAndDeregister()</code> 方法注销，减少参与者数量。</li><li><strong>终止 Phaser</strong>：当所有阶段任务完成或需要提前终止时，可以调用 <code>forceTermination()</code> 或其他终止方法。</li></ol><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>Phaser</code> 的内部实现基于可变的参与者数量和阶段计数。它维护一个阶段计数器（<code>phase</code>），以及当前阶段需要到达的参与者数量。当参与者调用同步方法（如 <code>arriveAndAwaitAdvance()</code>）时，<code>Phaser</code> 会记录到达的参与者数量，并在所有参与者到达后，递增阶段计数器，释放所有等待的线程，进入下一阶段。</p><p><strong>主要机制</strong>：</p><ul><li><strong>阶段（Phase）</strong>：表示同步的当前阶段，每完成一个阶段后递增。</li><li><strong>参与者（Parties）</strong>：需要同步的线程数量，可以动态增加或减少。</li><li><strong>到达（Arrive）</strong>：参与者完成当前阶段的任务，通知 <code>Phaser</code>。</li><li><strong>等待（Await）</strong>：参与者等待其他参与者到达同步点。</li><li><strong>注销（Deregister）</strong>：参与者完成所有任务后，从 <code>Phaser</code> 中注销，减少参与者数量。</li></ul><h3 id="常用-API-1"><a href="#常用-API-1" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**Phaser()**：创建一个未注册任何参与者的 <code>Phaser</code>。</li><li>**Phaser(int parties)**：创建一个并注册指定数量参与者的 <code>Phaser</code>。</li></ul><h4 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h4><ul><li>**int register()**：动态注册一个参与者，返回当前阶段。</li><li>**int bulkRegister(int parties)**：动态注册多个参与者。</li><li>**int arriveAndDeregister()**：到达同步点并注销当前参与者。</li><li>**int deregister()**：仅注销当前参与者，不到达同步点。</li></ul><h4 id="阶段到达与等待"><a href="#阶段到达与等待" class="headerlink" title="阶段到达与等待"></a>阶段到达与等待</h4><ul><li>**int arrive()**：到达同步点，不等待其他参与者。</li><li>**int arriveAndAwaitAdvance()**：到达同步点，并等待其他参与者到达后进入下一阶段。</li><li>**int arriveAndDeregister()**：到达同步点，并注销当前参与者。</li><li>**onAdvance(int phase, int registeredParties)**：在每次到达同步点时自定义额外的行为或者决定是否终止 phaser。</li></ul><h4 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h4><ul><li>**int getPhase()**：获取当前阶段数。</li><li>**int getRegisteredParties()**：获取当前注册的参与者数量。</li><li>**int getArrivedParties()**：获取当前阶段已到达的参与者数量。</li><li>**boolean isTerminated()**：检查 <code>Phaser</code> 是否已终止。</li></ul><h4 id="终止控制"><a href="#终止控制" class="headerlink" title="终止控制"></a>终止控制</h4><ul><li>**boolean forceTermination()**：强制终止 <code>Phaser</code>，所有等待的线程会被释放。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>Phaser</code> 适用于以下场景：</p><ul><li><strong>多阶段任务协调</strong>：如分阶段的计算任务，每个阶段需要所有参与者完成后再进入下一阶段。</li><li><strong>动态参与者管理</strong>：参与者数量在运行时可能会变化，例如任务池中动态增加或减少工作线程。</li><li><strong>复杂的同步需求</strong>：需要多个同步点或条件，<code>Phaser</code> 提供了更高的灵活性。</li><li><strong>分布式系统中的同步</strong>：在分布式计算中，不同节点可能需要在不同阶段进行同步。</li></ul><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>动态的注册参与者。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhaserExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Phaser phaser = <span class="hljs-keyword">new</span> Phaser(<span class="hljs-number">1</span>); <span class="hljs-comment">// 主线程注册</span><br><br>        <span class="hljs-comment">// 主线程创建并启动2个子线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadId = i;<br>            phaser.register(); <span class="hljs-comment">// 动态注册参与者</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; - 阶段1开始&quot;</span>);<br>                <span class="hljs-comment">// 模拟阶段1的工作</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; - 阶段1完成，等待其他线程&quot;</span>);<br>                phaser.arriveAndAwaitAdvance();<br><br>                System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; - 阶段2开始&quot;</span>);<br>                <span class="hljs-comment">// 模拟阶段2的工作</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; - 阶段2完成，等待其他线程&quot;</span>);<br>                phaser.arriveAndAwaitAdvance();<br><br>                phaser.arriveAndDeregister(); <span class="hljs-comment">// 到达并注销</span><br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 主线程也参与同步</span><br>        System.out.println(<span class="hljs-string">&quot;Main thread - 阶段1等待&quot;</span>);<br>        phaser.arriveAndAwaitAdvance();<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread - 阶段2等待&quot;</span>);<br>        phaser.arriveAndAwaitAdvance();<br><br>        phaser.arriveAndDeregister(); <span class="hljs-comment">// 主线程注销</span><br><br>        System.out.println(<span class="hljs-string">&quot;所有阶段完成，Phaser 终止&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">30.540</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">2</span> - 阶段<span class="hljs-number">1</span>开始<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">30.540</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">1</span> - 阶段<span class="hljs-number">1</span>开始<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">30.540</span> <span class="hljs-selector-attr">[main]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Main thread - 阶段<span class="hljs-number">1</span>等待<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.044</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">1</span> - 阶段<span class="hljs-number">1</span>完成，等待其他线程<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.044</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">2</span> - 阶段<span class="hljs-number">1</span>完成，等待其他线程<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.044</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">2</span> - 阶段<span class="hljs-number">2</span>开始<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.044</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">1</span> - 阶段<span class="hljs-number">2</span>开始<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.044</span> <span class="hljs-selector-attr">[main]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Main thread - 阶段<span class="hljs-number">2</span>等待<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.557</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">1</span> - 阶段<span class="hljs-number">2</span>完成，等待其他线程<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.557</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - Thread <span class="hljs-number">2</span> - 阶段<span class="hljs-number">2</span>完成，等待其他线程<br><span class="hljs-number">15</span>:<span class="hljs-number">53</span>:<span class="hljs-number">31.557</span> <span class="hljs-selector-attr">[main]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.PhaserExample</span> - 所有阶段完成，Phaser 终止<br></code></pre></div></td></tr></table></figure><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>避免死锁</strong>：确保所有注册的参与者都能到达同步点，否则会导致永久等待。</li><li><strong>动态调整参与者</strong>：在多线程环境下动态注册和注销参与者时，需要小心管理，避免竞态条件。</li><li><strong>中断处理</strong>：<code>Phaser</code> 的同步方法不会抛出 <code>InterruptedException</code>，需要手动检查中断状态。</li><li><strong>资源管理</strong>：使用完 <code>Phaser</code> 后，确保所有参与者已注销，避免资源泄漏。</li></ul><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>Exchanger&lt;V&gt;</code> 是一个用于两个线程之间交换数据的同步点。它允许两个线程在某个同步点相遇，并交换彼此持有的数据。每个线程在调用 <code>exchange</code> 方法时，会阻塞直到另一个线程也到达该同步点，随后两者交换数据并继续执行。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>双线程交换</strong>：<code>Exchanger</code> 设计用于两个线程之间的数据交换，不适用于多于两个线程的场景。</li><li><strong>同步点</strong>：两个线程必须在同一个同步点到达，才能进行数据交换。</li><li><strong>阻塞与超时</strong>：线程在等待交换时会阻塞，可以选择设置超时时间以避免无限等待。</li><li><strong>可重复使用</strong>：<code>Exchanger</code> 可以在多次交换中重复使用，不需要为每次交换创建新的实例。</li></ul><h3 id="使用流程-3"><a href="#使用流程-3" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建 Exchanger 实例</strong>：指定交换的数据类型。</li><li><strong>准备数据</strong>：每个线程准备好要交换的数据。</li><li><strong>调用 exchange 方法</strong>：线程调用 <code>exchange</code> 方法，传入要交换的数据，并接收对方线程传回的数据。</li><li><strong>处理交换结果</strong>：线程获取到对方线程传回的数据后，继续执行后续操作。</li></ol><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p><code>Exchanger</code> 内部维护了一个同步点，当两个线程调用 <code>exchange</code> 方法时：</p><ol><li>第一个到达的线程会在同步点等待，直到第二个线程也到达。</li><li>当第二个线程到达时，<code>Exchanger</code> 会将两个线程传入的数据进行交换。</li><li>两个线程各自接收对方传入的数据，然后继续执行。</li></ol><p><code>Exchanger</code> 的实现基于 <code>AbstractQueuedSynchronizer</code>（AQS），利用其状态管理和队列机制来控制线程的阻塞和唤醒。</p><h3 id="常用-API-2"><a href="#常用-API-2" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**Exchanger()**：创建一个新的 <code>Exchanger</code> 实例，用于交换指定类型的数据。</li></ul><h4 id="交换方法"><a href="#交换方法" class="headerlink" title="交换方法"></a>交换方法</h4><ul><li><strong>V exchange(V x) throws InterruptedException</strong>：在同步点等待另一个线程到达，并交换数据。该方法会阻塞直到另一个线程也调用 <code>exchange</code>。</li><li><strong>V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException</strong>：在指定的等待时间内等待另一个线程到达并交换数据。如果超时未交换成功，则抛出 <code>TimeoutException</code>。</li></ul><h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>**int getParties()**：返回参与交换的线程数，通常为2。</li><li>**int getMaximumWaitTime()**：返回最大等待时间。</li></ul><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>生产者-消费者模型</strong>：两个线程在生产和消费数据时，可以使用 <code>Exchanger</code> 实现数据的高效交换。</li><li><strong>双缓冲技术</strong>：在需要两个缓冲区交替使用的场景，如图像处理、音视频流处理等，可以使用 <code>Exchanger</code> 实现缓冲区的交换。</li><li><strong>数据处理流水线</strong>：在多阶段的数据处理流水线中，两个相邻阶段的线程可以通过 <code>Exchanger</code> 进行数据交换。</li><li><strong>协同计算</strong>：两个线程需要在某些计算步骤上进行协同工作，并交换中间结果。</li></ul><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><p>基本的双线程数据交换。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangerExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个 Exchanger，用于交换 String 类型的数据</span><br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> Exchanger&lt;&gt;();<br><br>        <span class="hljs-comment">// 线程A</span><br>        Thread threadA = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String data = <span class="hljs-string">&quot;数据A&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.info(<span class="hljs-string">&quot;线程A准备交换的数据: &quot;</span> + data);<br>                String receivedData = exchanger.exchange(data);<br>                log.info(<span class="hljs-string">&quot;线程A接收到的数据: &quot;</span> + receivedData);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                log.info(<span class="hljs-string">&quot;线程A被中断&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程A&quot;</span>);<br><br>        <span class="hljs-comment">// 线程B</span><br>        Thread threadB = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String data = <span class="hljs-string">&quot;数据B&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.info(<span class="hljs-string">&quot;线程B准备交换的数据: &quot;</span> + data);<br>                String receivedData = exchanger.exchange(data);<br>                log.info(<span class="hljs-string">&quot;线程B接收到的数据: &quot;</span> + receivedData);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                log.info(<span class="hljs-string">&quot;线程B被中断&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程B&quot;</span>);<br><br>        threadA.start();<br>        threadB.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">23.173</span> <span class="hljs-selector-attr">[线程A]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.ExchangerExample</span> - 线程A准备交换的数据: 数据A<br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">23.173</span> <span class="hljs-selector-attr">[线程B]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.ExchangerExample</span> - 线程B准备交换的数据: 数据B<br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">23.175</span> <span class="hljs-selector-attr">[线程A]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.ExchangerExample</span> - 线程A接收到的数据: 数据B<br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">23.175</span> <span class="hljs-selector-attr">[线程B]</span> INFO  space<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.other</span><span class="hljs-selector-class">.ExchangerExample</span> - 线程B接收到的数据: 数据A<br></code></pre></div></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>仅适用于两个线程之间的数据交换</strong>：<code>Exchanger</code> 设计用于两个线程之间的数据交换，多于两个线程使用时会引发不可预测的行为。</li><li><strong>exchange 方法死锁风险</strong>：<code>exchange()</code> 方法会让当前线程阻塞，直到另一个线程到达并交换数据。如果配对线程未到达，则线程会一直阻塞，可能导致死锁。</li><li><strong>exchange 方法会被中断</strong>：如果线程在 <code>exchange()</code> 方法中被中断，会抛出 <code>InterruptedException</code>，导致交换失败。</li><li><strong>仅交换对象引用</strong>：<code>Exchanger</code> 仅交换对象的引用，而不会复制对象，确保交换的数据在多线程环境下的可变性可控，尤其是 <code>List</code>、<code>Map</code> 等可变对象，应特别注意并发修改问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在多线程协作的复杂场景中，使用合理的并发工具能大幅简化代码、减少错误风险：</p><ul><li><code>LockSupport</code> 以灵活的许可方式实现阻塞/唤醒，突破了传统 <code>wait/notify</code> 的局限，是众多并发组件的底层基石；</li><li><code>CyclicBarrier</code> 注重“多线程并发到达同一个关口”，适合分阶段执行的同步；</li><li><code>Phaser</code> 则是对 <code>Barrier</code> 的进一步扩展，支持可变线程数与更多交互方法，适合多阶段且参与者动态变化的场景；</li><li><code>Exchanger</code> 专注于“双线程交换数据”这一需求，让两条线程能够在同一同步点互相交换对象。</li></ul><p>通过充分了解它们各自的特性与适用情境，开发者能更从容地编写高质量多线程应用，既保证正确性，又在可维护性与性能之间取得最佳平衡。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>并发工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——Copy-On-Write</title>
    <link href="/2021/08/17/javase-cp-cow/"/>
    <url>/2021/08/17/javase-cp-cow/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在高并发读场景下，如果读操作远多于写操作，传统的互斥锁可能成为瓶颈。<code>Copy-On-Write</code>（<code>COW</code>）机制旨在充分利用“读多写少”的特性：对数据结构的写操作时才进行复制，从而极大地降低读操作的竞争与锁开销。本文将从 <code>COW</code> 的原理、在 Java 中的具体实现（<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>）以及使用注意事项等方面展开，帮助你在特定场景下写出更高效、更易维护的多线程程序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Copy-On-Write</code>（简称 <code>COW</code>）机制是一种在多线程环境下用于提高读操作效率的并发策略。其核心思想是：当有写操作（如新增、修改、删除）发生时，并不直接在原有数据结构上进行修改，而是先拷贝一份新的副本，然后在副本上进行写操作。写操作结束后，再将引用指向新的数据结构，从而避免了对读操作的阻塞。</p><p>Java 标准库中提供了写时复制的集合类，<code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 等类就是基于写时复制机制实现的线程安全集合，它们在读操作远多于写操作的场景下有不错的性能表现。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><code>COW</code> 机制的核心思想是：写操作时进行“复制”，读操作时直接访问原有对象。这样做可以显著减少在读高并发时竞争同一把锁的情况。也就是说，<code>COW</code> 使得读操作无需阻塞写操作，写操作也无需阻塞读操作。</p><p>在 Java 的 <code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 中，都遵循下面的流程：</p><ol><li>当调用写操作方法（如 <code>add()</code>、<code>remove()</code>、<code>set()</code> 等）时，它会先复制当前容器的全部内容到一个新数组中。</li><li>在新数组上执行对应的写操作。</li><li>写操作完成后，将容器内部引用切换到新数组上。</li></ol><pre><code class=" mermaid">graph TD    A[原始数据] --&gt; B[读取请求]    A --&gt; C[修改请求]    C --&gt; D[创建副本]    D --&gt; E[修改副本]    E --&gt; F[替换引用]</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></div></td></tr></table></figure><ul><li>内部维护volatile数组保证可见性。</li></ul><h3 id="读操作原理"><a href="#读操作原理" class="headerlink" title="读操作原理"></a>读操作原理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>读操作直接使用当下有效的内部数组（即当前引用所指向的数组）进行遍历或读取。</li><li>读取过程中容器内部引用不会改变，对读操作而言是可见且稳定的。</li></ul><h3 id="写操作原理"><a href="#写操作原理" class="headerlink" title="写操作原理"></a>写操作原理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>写操作需要先获取一定的锁（通常是对象级锁）。</li><li>一旦获取到锁，容器内部会拷贝原数组并在副本上进行对应的操作（如添加元素、删除元素等）。</li><li>完成之后，将引用从旧数组切换到新的数组，写操作结束。</li><li>由于拷贝发生在写操作期间，所有对旧数组的读操作都不受影响，新操作完成后，后续的读操作则看到新的数组。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>高效的并发读取</strong>：读操作几乎无锁，因为读操作直接访问的是共享的数据结构，能保证在大多数情况下无锁或最小化锁开销。</li><li><strong>线程安全</strong>：多个读操作可以同时进行，且不会互相阻塞，也不会被写操作阻塞。写操作在拷贝完成并更新引用后，读操作会立即看到更新后的新副本。</li><li><strong>迭代器的弱一致性</strong>：迭代器基于快照，避免了<code>ConcurrentModificationException</code>，适合于某些需要遍历集合的场景。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>高内存消耗</strong>：每次写操作都需要复制整个数据结构，对于大规模数据结构和频繁写操作，会导致内存消耗增大。</li><li><strong>写操作性能较低</strong>：写操作需要复制数据副本，导致写性能较低，不适用于写操作频繁的场景。</li><li><strong>延迟写入</strong>：由于写操作是在副本上进行，可能会带来一定的延迟，影响实时性要求较高的应用。</li><li><strong>GC 压力</strong>：每次写操作均会重新复制所有元素对 <code>GC</code> 造成的压力，这在长时间运行的高并发系统中可能显著增大 <code>Full GC</code> 的触发频率，需要在实际应用中谨慎评估。</li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><strong>读多写少的并发场景</strong>：系统参数配置、配置信息缓存、热点数据缓存等读取操作远多于写入操作场景，<code>COW</code> 可以提供高效的并发读取性能。</li><li><strong>不需要实时一致性</strong>：对读操作来说，容器内部的数据在写操作瞬间可能已经“旧”了。但对大多数场景来说，这个瞬时不一致通常可以接受，并能显著提升读性能。</li><li><strong>需要迭代且不希望迭代过程中被修改</strong>：<code>COW</code> 提供了基于快照的迭代器，避免了迭代过程中集合被修改导致的问题。</li><li><strong>内存相对充裕</strong>：由于每次写操作都会创建新副本，占用更多的内存，所以对内存的消耗有一定要求。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Java在并发包<code>java.util.concurrent</code>中提供了两种基于写时复制的集合实现：</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是 <code>List</code> 接口的线程安全实现，基于数组实现，并采用写时复制策略。它适用于读多写少的场景，如缓存列表、事件监听器列表等。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li>底层使用一个 <code>volatile</code> 修饰的数组 <code>array</code> 来存储元素。</li><li>写操作（如<code>add</code>、<code>set</code>、<code>remove</code>等）会先加锁，然后创建一个新的数组副本，进行修改后将引用指向这个新数组。</li><li>读取操作（如<code>get</code>、<code>iterator</code>等）直接读取当前的 <code>array</code> 数组，无需加锁。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>线程安全</strong>：所有的修改操作都是通过复制底层数组来实现的，确保了线程安全。</li><li><strong>高效的并发读取</strong>：读取操作无需加锁，可以高效地并发执行。</li><li><strong>迭代器的弱一致性</strong>：迭代器基于创建时的数组快照，因此不会抛出<code>ConcurrentModificationException</code>，但可能不会反映最新的修改。</li></ul><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p><code>CopyOnWriteArraySet</code> 是 <code>Set</code> 接口的线程安全实现，基于 <code>CopyOnWriteArrayList</code> 实现。它确保集合中没有重复的元素，适用于需要保证元素唯一且读多写少的场景。</p><h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li>基于 <code>CopyOnWriteArrayList</code> 实现，所有添加元素的操作都会检查元素是否已存在，避免重复。</li><li>写操作与 <code>CopyOnWriteArrayList</code> 相同，创建新的数组副本进行修改。</li><li>读取操作无需加锁，可以高效地并发执行。</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>线程安全</strong>：继承自 <code>CopyOnWriteArrayList</code>，通过 <code>COW</code> 机制实现。</li><li><strong>保证元素唯一</strong>：通过内部机制确保集合中不包含重复元素。</li><li><strong>高效的并发读取</strong>：与<code>CopyOnWriteArrayList</code>相同，读取操作无需加锁。</li></ul><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假设有一个共享的列表，多个线程需要频繁读取和偶尔写入元素。没有适当的同步机制，可能会导致数据不一致或竞态条件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTestClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(String element)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        list.add(element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> List&lt;String&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ListTestClient client = <span class="hljs-keyword">new</span> ListTestClient();<br>        List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 启动多个线程添加元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; client.addElement(<span class="hljs-string">&quot;Element&quot;</span>));<br>            threads.add(t);<br>            t.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 启动多个线程读取列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                List&lt;String&gt; currentList = client.getList();<br>                System.out.println(<span class="hljs-string">&quot;List size: &quot;</span> + currentList.size());<br>            &#125;);<br>            threads.add(t);<br>            t.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程完成</span><br>        threads.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;Final list size: &quot;</span> + client.getList().size());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个程序中，多个线程同时对 <code>list</code> 进行读写操作，缺乏同步机制可能导致数据不一致、异常抛出（如 <code>ConcurrentModificationException</code>）等问题。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="synchronized解决"><a href="#synchronized解决" class="headerlink" title="synchronized解决"></a>synchronized解决</h3><p>可以使用 <code>synchronized</code> 关键字对添加和读取操作进行同步，确保同一时刻只有一个线程可以修改或读取列表，从而避免竞态条件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTestClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到列表（同步方法）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(String element)</span> </span>&#123;<br>        list.add(element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取列表（同步方法）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> List&lt;String&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(list);<br>    &#125;<br><br>    <span class="hljs-comment">// main 方法同上</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="COW解决"><a href="#COW解决" class="headerlink" title="COW解决"></a>COW解决</h3><p>写时复制通过在写操作时复制数据结构，修改副本，然后将副本替换原始数据，确保读操作无需加锁即可安全进行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加元素到列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(String element)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>    list.add(element);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>COW</code> 不用在业务代码中显式地加锁，只需要将存储元素的列表实现替换为 <code>CopyOnWriteArrayList</code> 即可，最大程度减少了代码入侵、使代码简洁易懂。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><strong>优先确认业务场景</strong>：只有在“读多写少”且“不需要强实时一致性”的情况下，才适合使用 <code>COW</code>。否则可能引起不必要的内存浪费和写开销。</li><li><strong>批量写入优化</strong>：批量添加时应该使用 <code>addAll</code>，提高性能。</li><li><strong>控制写操作频率</strong>：若写操作比较频繁，<code>CopyOnWriteArrayList</code> 或 <code>CopyOnWriteArraySet</code> 的性能会大幅下降。可以考虑其他并发集合，如 <code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentLinkedQueue</code> 等，或使用锁等手段进行同步。</li><li><strong>避免数据体量过大</strong>：因为每次写都会复制整个内部数组，大体量数据的情况下会消耗较多的 CPU 和内存。</li><li><strong>使用迭代器遍历时要小心修改</strong>：虽然不会抛 <code>ConcurrentModificationException</code>，但要注意遍历的结果和真实数据可能不同步。如果读取过程中有新数据加入，当前迭代器看不到。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Copy-On-Write</code> 策略巧妙地分离了“读”与“写”对数据结构的影响：所有读线程都共享一份当前的稳定数据，写线程则在副本上完成更新后再切换引用，从而使读操作无须在锁中等待。在读多写少、不追求实时一致且内存相对充裕的场景下，Java 的 <code>CopyOnWriteArrayList</code> 与 <code>CopyOnWriteArraySet</code> 能够明显减少读写竞争，大幅提升系统在高并发读访问下的吞吐量与响应速度。但若应用对写操作性能要求较高，或数据规模非常庞大，那么频繁的复制会带来额外的 CPU 与内存开销，此时可考虑更适合的并发数据结构（如 <code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、或基于锁分段的方案）来平衡读写需求。通过结合自身业务特点来选择不同并发容器，才能做到性能与成本的双赢。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>Copy-On-Write</tag>
      
      <tag>COW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——AQS</title>
    <link href="/2021/08/15/javase-cp-aqs/"/>
    <url>/2021/08/15/javase-cp-aqs/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java 并发包（<code>java.util.concurrent</code>）为开发者提供了种类丰富的同步工具与并发数据结构，极大简化了多线程编程的难度。其中，<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）作为核心框架，为各种锁与同步器提供了统一的基础。理解 <code>AQS</code> 的设计理念与工作机制，有助于深入掌握如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>BlockingQueue</code> 等重要类的内部实现与使用技巧。<br>本文将依次介绍 <code>AQS</code> 的原理、常见子类的应用场景和关键 API，并通过示例演示如何借助这些同步工具来构建健壮、高效的并发程序。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>AQS</code>（ <code>AbstractQueuedSynchronizer</code>），是 <code>java.util.concurrent.locks</code> 包中的一个抽象类，设计用于构建依赖于一个或多个状态的同步器，为实现阻塞锁和其他同步器（如信号量、事件等）提供了基础。它通过一个整型的状态（<code>int state</code>）和一个 <code>FIFO</code> 的等待队列（<code>CLH</code> 队列）来管理线程的获取和释放资源的过程。即：<code>AQS</code> 通过一个共享的整型 <code>state</code> 及 <code>FIFO</code> 等待队列，为独占或共享场景下的线程获取和释放资源提供了通用框架。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p><strong>基于状态的同步</strong>：<code>AQS</code> 使用一个整型的状态变量来表示同步状态。例如，<code>ReentrantLock</code>使用该状态表示锁是否被占用及重入次数。</p></li><li><p><strong>FIFO 等待队列</strong>：当线程无法获取到同步状态时，会被封装成一个节点并加入到等待队列中，按照 <code>FIFO</code> 的顺序排队等待。</p></li><li><p><strong>独占与共享模式</strong>：<code>AQS</code> 支持两种模式：</p></li></ul><ul><li><strong>独占模式</strong>：一次只能有一个线程获取同步状态（如独占锁）。</li><li><strong>共享模式</strong>：多个线程可以同时获取同步状态（如信号量）。</li></ul><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p><code>AQS</code> 的核心在于通过 <code>CAS（Compare-And-Swap）</code> 操作来确保对状态变量的原子更新，并通过等待队列来管理线程的等待与唤醒。</p><h4 id="获取同步状态"><a href="#获取同步状态" class="headerlink" title="获取同步状态"></a>获取同步状态</h4><p>当线程尝试获取同步状态时，会调用 <code>acquire</code> 方法。具体流程如下：</p><ol><li><strong>尝试获取</strong>：调用 <code>tryAcquire</code> 方法（需要子类实现），如果成功，线程获得同步状态，方法返回。</li><li><strong>加入队列</strong>：如果获取失败，线程会被封装成节点并加入等待队列。</li><li><strong>阻塞等待</strong>：线程会被阻塞，直到它被唤醒。</li></ol><h4 id="释放同步状态"><a href="#释放同步状态" class="headerlink" title="释放同步状态"></a>释放同步状态</h4><p>当线程释放同步状态时，会调用 <code>release</code> 方法。具体流程如下：</p><ol><li><strong>尝试释放</strong>：调用 <code>tryRelease</code> 方法（需要子类实现），如果成功，状态被释放。</li><li><strong>唤醒下一个</strong>：检查等待队列中是否有等待的线程，如果有，根据独占或共享模式唤醒相应的线程。</li></ol><h4 id="独占与共享模式"><a href="#独占与共享模式" class="headerlink" title="独占与共享模式"></a>独占与共享模式</h4><ul><li><strong>独占模式</strong>：线程在独占模式下获取同步状态，如果失败则进入等待队列。释放时唤醒下一个独占的线程。</li><li><strong>共享模式</strong>：多个线程可以同时获取同步状态，适用于信号量等场景。释放时可能需要唤醒多个线程。</li></ul><h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p><code>AQS</code> 依赖于 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 方法来实现对状态变量的原子操作，确保线程安全。</p><h4 id="自旋与阻塞"><a href="#自旋与阻塞" class="headerlink" title="自旋与阻塞"></a>自旋与阻塞</h4><p>当线程尝试获取同步状态失败时，会通过自旋或阻塞的方式等待被唤醒。<code>AQS</code> 通过 <code>LockSupport</code> 类提供的 <code>park</code> 和 <code>unpark</code> 方法来实现线程的阻塞与唤醒。</p><h4 id="节点（Node）状态"><a href="#节点（Node）状态" class="headerlink" title="节点（Node）状态"></a>节点（Node）状态</h4><p>等待队列中的每个节点都包含了线程信息以及其在队列中的状态（如是否取消、是否在独占或共享模式下等待等）。</p><h4 id="唤醒机制"><a href="#唤醒机制" class="headerlink" title="唤醒机制"></a>唤醒机制</h4><p>当同步状态被释放时，<code>AQS</code> 会根据队列的顺序唤醒等待中的线程。在独占模式下，通常只唤醒队列中的第一个线程；在共享模式下，可能会唤醒多个线程。</p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>以下是  <code>AQS</code> 中一些关键的方法及其作用：</p><ul><li>**acquire(int arg)**：独占模式下获取同步状态，如果获取失败则将线程加入等待队列并阻塞。</li><li>**release(int arg)**：独占模式下释放同步状态，并唤醒等待队列中的下一个线程。</li><li>**acquireShared(int arg)**：共享模式下获取同步状态，如果获取失败则将线程加入等待队列并阻塞。</li><li>**releaseShared(int arg)**：共享模式下释放同步状态，并唤醒等待队列中的所有适合的线程。</li><li>**tryAcquire(int arg)**：尝试以独占模式获取同步状态，子类需要实现此方法。</li><li>**tryRelease(int arg)**：尝试以独占模式释放同步状态，子类需要实现此方法。</li><li>**tryAcquireShared(int arg)**：尝试以共享模式获取同步状态，子类需要实现此方法。</li><li>**tryReleaseShared(int arg)**：尝试以共享模式释放同步状态，子类需要实现此方法。</li></ul><h3 id="常见子类"><a href="#常见子类" class="headerlink" title="常见子类"></a>常见子类</h3><p>Java 标准库中有多个同步器是基于 <code>AQS</code> 实现的，以下是一些常见的例子：</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code> 是基于<code>AQS</code>的一个可重入锁。它通过<code>AQS</code>的独占模式实现锁的获取与释放，并支持公平锁和非公平锁两种模式。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p><code>Semaphore</code>（信号量）是基于 <code>AQS</code> 的一个共享模式同步器。它通过 <code>AQS</code> 的共享模式管理许可的获取与释放，允许多个线程同时获取许可。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><code>CountDownLatch</code> 是基于 <code>AQS</code> 的一个同步工具，它允许一个或多个线程等待直到一组操作完成。它使用 <code>AQS</code> 的共享模式来管理等待线程的唤醒。</p><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p><code>ReentrantReadWriteLock</code> 是基于 <code>AQS</code> 实现的一个读写锁。它使用 <code>AQS</code> 的共享模式来管理多个读锁和独占的写锁。</p><h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>ReentrantLock</code>（可重入锁）是Java提供的一种可重入的互斥锁，允许同一个线程多次获取同一把锁而不会发生死锁。它提供了与 <code>synchronized</code> 关键字类似的基本行为，但具有更高的灵活性和更丰富的功能，如可中断锁获取、公平锁、定时锁获取等。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>可重入性</strong>：同一线程可以多次获取同一把锁，锁的持有计数会自动递增。</li><li><strong>公平性</strong>：支持公平锁和非公平锁两种模式。</li><li><strong>可中断性</strong>：可以响应中断，允许线程在等待锁时被中断。</li><li><strong>锁获取的尝试</strong>：支持尝试获取锁的机制，如 <code>tryLock</code>。</li><li><strong>Condition 支持</strong>：提供 <code>Condition</code> 接口，支持更灵活的线程协调。</li></ul><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建 ReentrantLock 实例</strong>：可以选择创建公平锁或非公平锁。</li><li><strong>获取锁</strong>：在需要保护的代码块之前调用 <code>lock()</code> 方法获取锁。</li><li><strong>执行同步代码</strong>：在获取锁后执行需要同步的代码。</li><li><strong>释放锁</strong>：在同步代码执行完毕后，通过 <code>unlock()</code> 方法释放锁。通常在 <code>finally</code> 块中释放锁，以确保锁的释放。</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>ReentrantLock</code> 是基于 <code>AbstractQueuedSynchronizer</code> 实现的。<code>AQS</code> 提供了一个基于 <code>FIFO</code> 队列的同步器框架，<code>ReentrantLock</code> 通过 <code>AQS</code> 的独占模式实现锁的获取与释放。以下是其内部工作原理的关键点：</p><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p><code>ReentrantLock</code> 允许同一个线程多次获取锁，每次获取锁时，内部的 <code>holdCount</code>（持有计数）会递增。当线程释放锁时，持有计数会递减，直到为零时，锁才真正被释放，其他等待的线程才能获取锁。</p><h4 id="公平与非公平锁"><a href="#公平与非公平锁" class="headerlink" title="公平与非公平锁"></a>公平与非公平锁</h4><ul><li><strong>非公平锁</strong>：默认情况下，<code>ReentrantLock</code> 是非公平的。线程在获取锁时，不考虑等待队列中的线程，可能会导致“插队”现象，提高吞吐量但可能导致某些线程长时间等待。</li><li><strong>公平锁</strong>：通过构造方法可以创建公平锁。公平锁按照线程请求锁的顺序来分配锁，避免了“插队”，但可能会略微降低吞吐量。</li></ul><h4 id="锁的获取与释放"><a href="#锁的获取与释放" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h4><ul><li><strong>获取锁</strong>：线程调用 <code>lock()</code> 方法时，尝试通过 <code>AQS</code> 的 <code>tryAcquire</code> 方法获取锁。如果锁可用（<code>state</code> 为 0），则成功获取并将 <code>state</code> 设置为 1。如果锁不可用，则线程被加入到等待队列中，等待锁的释放。</li><li><strong>释放锁</strong>：线程调用 <code>unlock()</code> 方法时，通过<code>AQS</code>的 <code>tryRelease</code> 方法释放锁。如果当前线程是锁的持有者，持有计数减一。当持有计数为 0 时，锁被释放，<code>AQS</code> 唤醒等待队列中的下一个线程。</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="锁的获取与释放-1"><a href="#锁的获取与释放-1" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h4><ul><li>**lock()**：获取锁，如果锁不可用，则等待。</li><li>**lockInterruptibly()**：获取锁，允许线程在等待锁时被中断。</li><li>**tryLock()**：尝试获取锁，立即返回，成功则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>**tryLock(long timeout, TimeUnit unit)**：尝试获取锁，在指定的时间内获取，成功则返回 <code>true</code>，超时则返回 <code>false</code>。</li><li>**unlock()**：释放锁。</li></ul><h4 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h4><ul><li>**new ReentrantLock(boolean fair)**：构造方法，<code>fair</code> 为 <code>true</code> 创建公平锁，<code>false</code> 创建非公平锁。</li></ul><h4 id="Condition支持"><a href="#Condition支持" class="headerlink" title="Condition支持"></a>Condition支持</h4><ul><li>**newCondition()**：返回一个与锁绑定的 <code>Condition</code> 实例，用于实现线程间的协调等待与通知。</li></ul><h4 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h4><ul><li>**isLocked()**：查询锁是否被任何线程持有。</li><li>**isHeldByCurrentThread()**：查询当前线程是否持有锁。</li><li>**getHoldCount()**：获取当前线程持有锁的次数。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要可中断锁获取</strong>：使用 <code>lockInterruptibly()</code> 方法允许线程在等待锁时响应中断，这是 <code>synchronized</code> 关键字无法实现的。</li><li><strong>需要公平锁</strong>：在需要严格按照线程请求锁的顺序进行锁分配的场景中，可以使用公平锁，避免线程饥饿。</li><li><strong>需要尝试锁获取</strong>：通过 <code>tryLock()</code> 方法，可以尝试获取锁而不会无限期等待，适用于需要在一定条件下放弃操作的场景。</li><li><strong>需要多个 Condition</strong>：<code>ReentrantLock</code> 支持创建多个 <code>Condition</code> 对象，用于实现更复杂的线程协调，比 <code>Object</code> 的 <code>wait/notify</code> 更灵活。</li><li><strong>高度竞争的场景</strong>：在高度竞争的多线程环境中，<code>ReentrantLock</code> 可以提供更好的性能和更细粒度的锁控制。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>实现“生产者-消费者模型”</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_CAPACITY = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 锁对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">// 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = lock.newCondition();<br>    <span class="hljs-comment">// 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        lock.lockInterruptibly(); <span class="hljs-comment">// 支持可中断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == MAX_CAPACITY) &#123;<br>                notFull.await();<span class="hljs-comment">// 等待队列有空位</span><br>            &#125;<br>            queue.offer(value);<br>            System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + value);<br>            notEmpty.signal(); <span class="hljs-comment">// 通知消费者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        lock.lockInterruptibly(); <span class="hljs-comment">// 支持可中断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                notEmpty.await();<span class="hljs-comment">// 等待队列有数据</span><br>            &#125;<br>            <span class="hljs-keyword">int</span> value = queue.poll();<br>            System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + value);<br>            notFull.signal(); <span class="hljs-comment">// 通知生产者</span><br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="与-Synchronized-比较"><a href="#与-Synchronized-比较" class="headerlink" title="与 Synchronized 比较"></a>与 Synchronized 比较</h3><p>虽然 <code>ReentrantLock</code> 和 <code>synchronized</code> 都用于实现互斥锁，但它们在功能和使用上有一些显著的区别：</p><table><thead><tr><th>特性</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td><strong>可重入性</strong></td><td>支持，默认可重入</td><td>支持，默认可重入</td></tr><tr><td><strong>公平性</strong></td><td>支持公平锁和非公平锁</td><td>不支持公平性</td></tr><tr><td><strong>可中断性</strong></td><td>支持 <code>lockInterruptibly()</code></td><td>不支持，可被中断</td></tr><tr><td><strong>尝试锁获取</strong></td><td>支持 <code>tryLock()</code> 和带超时的 <code>tryLock</code></td><td>不支持</td></tr><tr><td><strong>多个 Condition 支持</strong></td><td>支持多个 <code>Condition</code> 实例</td><td>每个对象只有一个隐式条件（<code>wait/notify</code>）</td></tr><tr><td><strong>性能</strong></td><td>在低竞争下可能略慢于 <code>synchronized</code></td><td>在低竞争下性能较好</td></tr><tr><td><strong>代码灵活性</strong></td><td>需要显式获取和释放锁，代码更灵活</td><td>隐式获取和释放锁，代码较简洁</td></tr></tbody></table><p><strong>选择使用</strong>：</p><ul><li>如果需要更灵活的锁机制，如公平性、可中断锁获取、多个条件变量等，建议使用 <code>ReentrantLock</code>。</li><li>如果只是需要简单的互斥锁，并且不需要额外的功能，<code>synchronized</code> 更加简洁且易于使用。</li></ul><h3 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 在 <code>ReentrantLock</code> 的基础上增加了读锁、写锁的区分：</p><ul><li><strong>读锁（Read Lock）</strong>：多个线程可以同时持有读锁，只要没有线程持有写锁。适用于不修改共享资源的操作，可通过 <code>ReentrantReadWriteLock.ReadLock  readLock()</code>  获取。</li><li><strong>写锁（Write Lock）</strong>：一次只能有一个线程持有写锁，并且在持有写锁时，所有的读锁和写锁都被阻塞。适用于修改共享资源的操作，可通过 <code>ReentrantReadWriteLock.WriteLock writeLock()</code>  获取。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockExample</span> </span>&#123;<br>    <span class="hljs-comment">// 读写锁对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();<br>    <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sharedData = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">()</span> </span>&#123;<br>        readLock.lock(); <span class="hljs-comment">// 获取读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;Reading data: &quot;</span> + sharedData);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock(); <span class="hljs-comment">// 释放读锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        writeLock.lock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            sharedData = value;<br>            System.out.println(<span class="hljs-string">&quot;Writing data: &quot;</span> + sharedData);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock(); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，会发现所有的读操作一起运行。</p><p><code>ReentrantReadWriteLock</code> 是 Java 并发编程中一个强大且灵活的锁机制，特别适用于读操作远多于写操作的场景。</p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><code>StampedLock</code> 是 Java 8 引入的一种新的锁机制，位于 <code>java.util.concurrent.locks</code> 包中。与 <code>ReentrantReadWriteLock</code> 相比，<code>StampedLock</code> 提供了一种基于能力的锁管理方式，其中锁的获取和释放通过使用票据（<code>stamps</code>）来控制，此票据可用于释放锁或检查锁是否有效。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p><code>StampedLock</code> 支持三种模式的锁：</p><ul><li><strong>写锁</strong>：独占锁，阻止其他读锁和写锁。</li><li><strong>读锁</strong>：共享锁，允许多个线程同时获取读锁，但不允许写锁。</li><li><strong>乐观读</strong>：一种尝试不阻塞写锁获取的读锁，需要通过检查印记后确认数据有效性。</li></ul><h3 id="使用流程-1"><a href="#使用流程-1" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>获取锁</strong>：根据需要的锁类型（读锁、写锁或乐观读），使用相应的方法获取锁，并返回一个印记 <code>stamp</code>。</li><li><strong>操作共享数据</strong>：在持有锁的保护下操作数据。</li><li><strong>释放锁</strong>：使用印记来释放锁。</li></ol><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><code>StampedLock</code> 的设计主要是为了优化读多写少的场景，通过提供一种不总是需要阻塞读操作的机制（乐观读）。其原理包括：</p><ul><li><strong>印记管理</strong>：每次锁获取或释放都伴随一个唯一的印记，这有助于管理锁的状态和验证操作的有效性。</li><li><strong>锁模式</strong>：支持三种锁模式，允许在不同情况下选择最适合的锁。</li><li><strong>乐观读锁</strong>：允许线程假定没有写操作，进行读取，后续需要通过印记来验证读取的数据是否在读取过程中被修改。</li></ul><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><ul><li><code>writeLock()</code>：获取写锁。</li><li><code>unlockWrite(long stamp)</code>：释放写锁。</li><li><code>tryConvertToWriteLock(long stamp)</code>：尝试升级为写锁。</li></ul><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><ul><li><code>readLock()</code>：获取读锁。</li><li><code>unlockRead(long stamp)</code>：释放读锁。</li><li><code>tryConvertToReadLock(long stamp)</code>：尝试降级为读锁，失败返回 0</li></ul><h4 id="乐观读锁"><a href="#乐观读锁" class="headerlink" title="乐观读锁"></a>乐观读锁</h4><ul><li><code>tryOptimisticRead()</code>：尝试获取乐观读锁。</li><li><code>validate(long stamp)</code>：检查在乐观读期间是否有写锁被获取。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>大量读操作，少量写操作的数据结构</strong>：如缓存、配置信息的读取。</li><li><strong>需要降低锁竞争的场景</strong>：提高系统的并发能力。</li><li><strong>替代 ReadWriteLock 的场景</strong>：当需要非阻塞的读取操作时，<code>StampedLock</code> 提供了更好的性能。</li></ul><h3 id="锁降级-升级"><a href="#锁降级-升级" class="headerlink" title="锁降级/升级"></a>锁降级/升级</h3><h4 id="锁降级（Write-→-Read）"><a href="#锁降级（Write-→-Read）" class="headerlink" title="锁降级（Write → Read）"></a>锁降级（Write → Read）</h4><p><strong>适用场景</strong>：</p><ul><li>需要短暂写入，但后续是长期读取，避免写锁阻塞其他读操作。</li><li>数据修改后不希望立即释放锁，确保后续的读操作读取的是一致的数据。</li><li>减少写锁持有时间，提高并发能力。</li></ul><p><strong>执行流程</strong>：</p><ol><li>线程先获取写锁，修改数据。</li><li>尝试降级为读锁（避免长期持有写锁）。</li><li>如果降级失败，释放写锁后重新获取读锁。</li><li>继续执行读取操作，不会阻塞其他读线程。</li></ol><p><strong>代码示例</strong>：配置缓存更新</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockDowngradeExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sharedData = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAndRead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.writeLock(); <span class="hljs-comment">// 1. 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            sharedData++; <span class="hljs-comment">// 2. 修改数据</span><br>            System.out.println(<span class="hljs-string">&quot;Updated sharedData to: &quot;</span> + sharedData);<br><br>            <span class="hljs-comment">// 3. 尝试降级为读锁，减少对其他线程的影响</span><br>            stamp = lock.tryConvertToReadLock(stamp);<br>            <span class="hljs-keyword">if</span> (stamp == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 降级失败，重新获取读锁</span><br>                lock.unlockWrite(stamp);<br>                stamp = lock.readLock();<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;Reading after update: &quot;</span> + sharedData);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LockDowngradeExample example = <span class="hljs-keyword">new</span> LockDowngradeExample();<br>        example.updateAndRead();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="锁升级（Read-→-Write）"><a href="#锁升级（Read-→-Write）" class="headerlink" title="锁升级（Read → Write）"></a>锁升级（Read → Write）</h4><p><strong>适用场景</strong>：</p><ul><li>需要在读取数据后进行修改（如乐观读发现数据变更）。</li><li>不能直接持有写锁，否则影响并发性能。</li><li>需要确保数据一致性，防止并发更新问题。</li></ul><p><strong>执行流程</strong>：</p><ol><li>先获取乐观读锁（<code>tryOptimisticRead()</code>），非阻塞提高性能。</li><li>读取数据后，验证是否被其他线程修改。</li><li>如果数据未变更，直接返回。</li><li>如果数据已变更：<ul><li>先退化为悲观读锁，确保数据正确性。</li><li>尝试升级到写锁，如果成功，则直接修改数据。</li><li>如果升级失败，释放读锁并重新获取写锁（防止死锁）。</li></ul></li></ol><p><strong>代码示例</strong>：基于 <code>StampedLock</code> 的乐观读升级</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockUpgradeExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sharedData = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readThenMaybeWrite</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="hljs-comment">// 1. 获取乐观读锁</span><br>        <span class="hljs-keyword">int</span> data = sharedData;<br>        <br>        <span class="hljs-comment">// 2. 验证读锁是否仍然有效</span><br>        <span class="hljs-keyword">if</span> (!lock.validate(stamp)) &#123;<br>            <span class="hljs-comment">// 3. 退化为悲观读锁，确保数据一致性</span><br>            stamp = lock.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                data = sharedData;<br>                <span class="hljs-comment">// 4. 可能需要升级为写锁</span><br>                <span class="hljs-keyword">long</span> writeStamp = lock.tryConvertToWriteLock(stamp);<br>                <span class="hljs-keyword">if</span> (writeStamp != <span class="hljs-number">0L</span>) &#123; <span class="hljs-comment">// 5. 成功升级</span><br>                    stamp = writeStamp;<br>                    sharedData = data + <span class="hljs-number">1</span>;<br>                    System.out.println(<span class="hljs-string">&quot;Upgraded to write lock. Updated sharedData to: &quot;</span> + sharedData);<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 6. 失败，释放读锁后重新获取写锁</span><br>                    lock.unlockRead(stamp);<br>                    stamp = lock.writeLock();<br>                    sharedData = data + <span class="hljs-number">1</span>;<br>                    System.out.println(<span class="hljs-string">&quot;Acquired write lock separately. Updated sharedData to: &quot;</span> + sharedData);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock(stamp);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Final sharedData: &quot;</span> + sharedData);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LockUpgradeExample example = <span class="hljs-keyword">new</span> LockUpgradeExample();<br>        example.readThenMaybeWrite();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>StampedLock</code> 不可重入，一个线程不能重复获取同一类型的锁，否则会死锁。</li><li>乐观读锁可能在执行过程中失效，必须通过 <code>validate()</code> 检测，并可能需要回退到悲观读锁或升级为写锁。</li><li>锁降级是允许的（<code>write → read</code>），但锁升级不被支持（<code>read → write</code> 必须释放后重新获取）。</li><li>在复杂的并发环境下，可以结合降级（减少锁竞争）和升级（确保数据一致性）优化性能。</li></ul><h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Semaphore</code>（信号量）是一种用于控制多个线程对共享资源访问的计数器。信号量维护了一个内部计数器，表示可用的许可（<code>permits</code>）数量，确保系统资源的有效利用和防止资源过载。线程在访问资源前需要获取一个许可，访问完成后释放许可。信号量可以用来实现互斥锁（当许可数量为 1 时）或限制资源的并发访问数量（许可数量大于 1 时）。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>许可机制</strong>：信号量通过许可数量来控制并发访问的线程数量。</li><li><strong>阻塞与非阻塞</strong>：当许可不足时，线程可以选择阻塞等待或立即返回。</li><li><strong>公平性</strong>：信号量可以设置为公平（<code>FIFO</code>）或非公平，决定线程获取许可的顺序。</li><li><strong>计数器</strong>：内部维护一个计数器，表示当前可用的许可数量。</li></ul><h3 id="使用流程-2"><a href="#使用流程-2" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建 Semaphore 实例</strong>：指定初始许可数量和可选的公平性参数。</li><li><strong>获取许可</strong>：在访问受限资源前，调用 <code>acquire()</code> 方法获取一个许可。如果许可不足，线程将被阻塞，直到有许可可用。</li><li><strong>执行同步操作</strong>：在获取许可后，执行需要受限访问的代码。</li><li><strong>释放许可</strong>：操作完成后，调用 <code>release()</code> 方法释放许可，允许其他等待的线程获取许可。</li></ol><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>Semaphore</code> 的核心原理基于许可的获取与释放机制。它通过一个内部计数器来跟踪可用的许可数量：</p><ul><li><strong>获取许可（acquire）</strong>：当线程调用 <code>acquire()</code> 方法时，信号量的计数器减 1。如果计数器为负，表示当前没有足够的许可，线程将被阻塞，直到有许可可用。</li><li><strong>释放许可（release）</strong>：当线程调用 <code>release()</code> 方法时，信号量的计数器加 1。如果有等待的线程被阻塞，信号量会唤醒其中一个线程，使其可以获取许可继续执行。</li></ul><p><code>Semaphore</code> 可以设置为公平或非公平：</p><ul><li><strong>公平信号量</strong>：按照线程请求许可的顺序（<code>FIFO</code>）来分配许可，避免线程饥饿。</li><li><strong>非公平信号量</strong>：线程获取许可时不考虑顺序，可能会导致某些线程长期等待，但吞吐量较高。</li></ul><h3 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**Semaphore(int permits)**：创建一个具有指定许可数量的非公平信号量。</li><li>**Semaphore(int permits, boolean fair)**：创建一个具有指定许可数量和公平性策略的信号量。</li></ul><h4 id="获取与释放许可"><a href="#获取与释放许可" class="headerlink" title="获取与释放许可"></a>获取与释放许可</h4><ul><li>**void acquire()**：获取一个许可，如果许可不可用，则线程被阻塞，直到有许可可用。</li><li>**void acquire(int permits)**：获取指定数量的许可。</li><li>**boolean tryAcquire()**：尝试获取一个许可，立即返回，成功则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>**boolean tryAcquire(long timeout, TimeUnit unit)**：在指定的等待时间内尝试获取一个许可，成功则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>**void release()**：释放一个许可。</li><li>**void release(int permits)**：释放指定数量的许可。</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>**int availablePermits()**：返回当前可用的许可数量。</li><li>**int getQueueLength()**：返回等待获取许可的线程数量。</li><li>**boolean hasQueuedThreads()**：判断是否有线程在等待许可。</li><li>**boolean isFair()**：判断信号量是否为公平信号量。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>限制并发访问数量</strong>：例如，限制同时访问数据库连接池的线程数量，防止过多线程导致资源耗尽。</li><li><strong>实现互斥锁</strong>：当<code>Semaphore</code>的许可数量设置为1时，可以用来实现互斥锁，确保同一时间只有一个线程访问资源。</li><li><strong>控制流量</strong>：在网络编程中，使用信号量来控制并发请求的数量，防止服务器过载。</li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>限制并发访问数量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2个许可</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessResource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (semaphore.tryAcquire(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS)) &#123; <span class="hljs-comment">// 尝试在500ms内获取许可</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; acquired a permit.&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟资源访问</span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release(); <span class="hljs-comment">// 释放许可</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; released a permit.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; could not acquire a permit.&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SemaphoreExample example = <span class="hljs-keyword">new</span> SemaphoreExample();<br><br>        <span class="hljs-comment">// 创建3个线程尝试获取许可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(example::accessResource, <span class="hljs-string">&quot;Thread-&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个示例中，第三个线程尝试在 500 毫秒内获取许可，但由于前两个线程持有许可，第三个线程在超时后未能获取许可并返回。</p><h2 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>CountDownLatch</code> 是一种同步工具，用于协调多个线程之间的执行顺序。它基于一个计数器，初始化时设置为某个数值，每当一个线程完成其任务后，就将计数器减一。当计数器的值达到零时，所有等待的线程被唤醒，继续执行后续操作。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>单向同步</strong>：<code>CountDownLatch</code> 是单向的，计数器一旦达到零，不能重置或增加。</li><li><strong>不可重用</strong>：一旦计数器达到零，<code>CountDownLatch</code> 不能再次使用。如果需要可重用的同步工具，可以考虑 <code>CyclicBarrier</code>。</li><li><strong>等待与通知机制</strong>：一个或多个线程等待，直到其他线程完成各自的操作。</li><li><strong>线程安全</strong>：<code>CountDownLatch</code> 是线程安全的，适用于多线程环境。</li></ul><h3 id="使用流程-3"><a href="#使用流程-3" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>创建CountDownLatch实例</strong>：在初始化时设置计数器的值（即需要等待的事件数量）。</li><li>**等待线程调用 await()**：一个或多个线程调用 <code>await()</code> 方法，进入等待状态，直到计数器达到 0。</li><li>**计数线程调用 countDown()**：其他线程在完成各自的任务后，调用 <code>countDown()</code> 方法将计数器减 1。</li><li><strong>释放等待线程</strong>：当计数器的值达到零时，所有等待的线程被唤醒，继续执行后续操作。</li></ol><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p><code>CountDownLatch</code> 的核心原理基于一个内部的计数器，该计数器初始化时设定为需要等待的事件数量。主要工作流程包括：</p><ul><li><strong>计数器管理</strong>：计数器的值表示还需要多少个事件完成。当某个事件完成时，调用 <code>countDown()</code> 方法将计数器减一。</li><li><strong>等待机制</strong>：调用 <code>await()</code> 方法的线程会被阻塞，直到计数器的值达到零。</li><li><strong>释放机制</strong>：当计数器达到零时，所有等待的线程被唤醒，继续执行后续代码。</li></ul><p><strong>关键点</strong>：</p><ul><li><strong>线程协调</strong>：<code>CountDownLatch</code> 主要用于协调线程之间的执行顺序，确保某些操作在其他操作完成后才开始。</li><li><strong>不可重用</strong>：一旦计数器达到 0，<code>CountDownLatch</code> 不能再次使用。如果需要多次使用同步工具，可以考虑 <code>CyclicBarrier</code>。</li><li><strong>无依赖性</strong>：等待线程和计数线程可以在不同的时间启动和结束，<code>CountDownLatch</code> 不强制它们的执行顺序。</li></ul><h3 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**CountDownLatch(int count)**：创建一个 <code>CountDownLatch</code>，计数器初始化为指定的 <code>count</code> 值。<code>count</code> 必须大于零。</li></ul><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul><li>**void await()**：使当前线程等待，直到计数器的值达到 0。</li><li>**void await(long timeout, TimeUnit unit)**：使当前线程等待，直到计数器的值达到 0，或等待时间超过指定的 <code>timeout</code>。</li><li>**boolean await(long timeout, TimeUnit unit)**：类似于 <code>await(long, TimeUnit)</code>，但在等待超时后返回一个布尔值，表示是否成功等待到计数器为 0。</li><li>**void countDown()**：将计数器的值减 1。如果计数器的值达到 0，则释放所有等待的线程。</li><li>**long getCount()**：返回当前计数器的值。</li></ul><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>等待多个线程完成</strong>：在主线程需要等待多个工作线程完成任务后再继续执行的场景。例如，启动多个服务后，等待所有服务启动完成再进行后续操作。</li><li><strong>事件触发机制</strong>：在一个事件触发前，其他线程需要等待某些条件的满足。例如，加载配置文件完成后，其他线程才能开始处理请求。</li><li><strong>测试并发性能</strong>：在测试环境中，使用 <code>CountDownLatch</code> 来启动多个线程同时执行某个操作，以测试系统的并发性能。</li><li><strong>线程依赖关系</strong>：在复杂的多线程任务中，某些线程的执行依赖于其他线程的完成情况，使用 <code>CountDownLatch</code> 来管理这些依赖关系。</li></ul><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>主线程启动多个工作线程，并等待所有工作线程完成后继续执行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM_WORKERS = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(NUM_WORKERS);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">workerTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> workerId)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Worker &quot;</span> + workerId + <span class="hljs-string">&quot; started.&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟工作任务</span><br>            Thread.sleep((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">2000</span>));<br>            System.out.println(<span class="hljs-string">&quot;Worker &quot;</span> + workerId + <span class="hljs-string">&quot; finished.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            latch.countDown(); <span class="hljs-comment">// 完成任务后，计数器减一</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startTasks</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= NUM_WORKERS; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> workerId = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; workerTask(workerId)).start();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread waiting for workers to finish.&quot;</span>);<br>        latch.await(); <span class="hljs-comment">// 等待计数器达到零</span><br>        System.out.println(<span class="hljs-string">&quot;All workers finished. Main thread proceeding.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatchExample example = <span class="hljs-keyword">new</span> CountDownLatchExample();<br>        example.startTasks();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>一次性使用</strong>：<code>CountDownLatch</code> 是一次性的，计数器一旦达到 0，无法重置或重新使用。如果需要可重用的同步工具，可以考虑 <code>CyclicBarrier</code>。</li><li><strong>确保 countDown 调用</strong>：在使用 <code>CountDownLatch</code> 时，必须确保所有需要调用 <code>countDown()</code> 的线程都能够正常执行，否则可能导致等待线程永久阻塞。</li><li><strong>避免死锁</strong>：如果 <code>await()</code> 方法被调用后，相关线程无法调用 <code>countDown()</code>，将导致死锁。因此，在设计使用 <code>CountDownLatch</code> 的同步逻辑时，需要确保计数器能够正确地递减到 0。</li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p><code>BlockingQueue</code> 是一个支持两个附加操作的 <code>Queue</code> 接口：</p><ol><li><strong>在队列为空时等待获取元素</strong>：当线程尝试从一个空的队列中获取元素时，该线程会被阻塞，直到队列中有元素可供获取。</li><li><strong>在队列满时等待插入元素</strong>：当线程尝试向一个有容量限制且已满的队列中插入元素时，该线程会被阻塞，直到队列中有空间可用。</li></ol><p><code>BlockingQueue</code> 的这些特性使其在多线程环境下能够有效地协调生产者和消费者之间的工作，避免资源竞争和数据不一致的问题。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>线程安全</strong>：所有的 <code>BlockingQueue</code> 实现都是线程安全的，内部通过锁机制或其他同步技术保证并发操作的正确性。</li><li><strong>阻塞操作</strong>：提供了在无法立即完成操作时阻塞线程的方法，简化了线程间的协调。</li><li><strong>容量限制</strong>：可以选择有界队列（有固定容量）或无界队列（容量无限制）。</li><li><strong>多种实现</strong>：提供了多种不同特性的实现类，以适应不同的应用场景。</li></ul><h3 id="使用流程-4"><a href="#使用流程-4" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><strong>选择合适的 BlockingQueue 实现类</strong>：根据具体需求选择适当的实现类，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等。</li><li><strong>创建 BlockingQueue 实例</strong>：根据需要设置队列的容量和其他参数。</li><li><strong>生产者线程插入元素</strong>：生产者线程向队列中插入元素，可能会因为队列满而被阻塞。</li><li><strong>消费者线程获取元素</strong>：消费者线程从队列中获取元素，可能会因为队列为空而被阻塞。</li><li><strong>处理元素</strong>：消费者线程处理获取到的元素。</li><li><strong>重复上述过程</strong>：生产者和消费者线程持续执行插入和获取操作，直到完成任务。</li></ol><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><h4 id="内部同步机制"><a href="#内部同步机制" class="headerlink" title="内部同步机制"></a>内部同步机制</h4><ul><li><strong>锁机制</strong>：大多数 <code>BlockingQueue</code> 实现类使用内部锁（如 <code>ReentrantLock</code>）来保护队列的状态，确保在插入和获取元素时的线程安全。</li><li><strong>条件变量</strong>：通过条件变量（<code>Condition</code>）实现线程的等待和通知机制。当队列满时，生产者线程等待；当队列为空时，消费者线程等待。</li></ul><h4 id="阻塞策略"><a href="#阻塞策略" class="headerlink" title="阻塞策略"></a>阻塞策略</h4><ul><li><strong>生产者插入元素时的阻塞</strong>：当队列已满，生产者线程调用 <code>put()</code> 方法插入元素时会被阻塞，直到有空间可用。</li><li><strong>消费者获取元素时的阻塞</strong>：当队列为空，消费者线程调用 <code>take()</code> 方法获取元素时会被阻塞，直到有元素可用。</li></ul><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><p>一些 <code>BlockingQueue</code> 实现类支持公平性选项，决定线程获取锁的顺序。公平性有助于避免线程饥饿，但可能会稍微降低吞吐量。</p><h3 id="常用API-4"><a href="#常用API-4" class="headerlink" title="常用API"></a>常用API</h3><p><code>BlockingQueue</code> 接口继承自 <code>Queue</code>，并增加了一些用于阻塞操作的方法。以下是一些常用的方法：</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><ul><li>**boolean add(E e)**：向队列中添加元素，如果队列已满则抛出 <code>IllegalStateException</code>。</li><li>**boolean offer(E e)**：尝试向队列中添加元素，如果队列已满则返回 <code>false</code>。</li><li>**void put(E e)**：向队列中添加元素，如果队列已满则阻塞，直到有空间可用。</li><li>**boolean offer(E e, long timeout, TimeUnit unit)**：尝试在指定时间内向队列中添加元素，如果队列已满则在超时后返回 <code>false</code>。</li></ul><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><ul><li>**E remove()**：从队列中移除并返回头部元素，如果队列为空则抛出 <code>NoSuchElementException</code>。</li><li>**E poll()**：从队列中移除并返回头部元素，如果队列为空则返回 <code>null</code>。</li><li>**E take()**：从队列中移除并返回头部元素，如果队列为空则阻塞，直到有元素可用。</li><li>**E poll(long timeout, TimeUnit unit)**：尝试在指定时间内从队列中移除并返回头部元素，如果队列为空则在超时后返回 <code>null</code>。</li></ul><h4 id="检查队列状态"><a href="#检查队列状态" class="headerlink" title="检查队列状态"></a>检查队列状态</h4><ul><li>**int size()**：返回队列中元素的数量。</li><li>**boolean isEmpty()**：检查队列是否为空。</li><li>**boolean contains(Object o)**：检查队列是否包含指定的元素。</li><li>**int remainingCapacity()**：返回队列剩余的容量。</li></ul><h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>**Iterator&lt;E&gt; iterator()**：返回队列的迭代器。</li><li>**void clear()**：清空队列中的所有元素。</li></ul><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>生产者-消费者模型</strong>：<code>BlockingQueue</code> 是实现“生产者-消费者模型”的理想选择。生产者线程将数据放入队列，消费者线程从队列中获取数据进行处理。</li><li><strong>任务调度</strong>：在任务调度系统中，可以使用 <code>BlockingQueue</code> 来存储待执行的任务，多个工作线程从队列中获取任务并执行。</li><li><strong>数据流处理</strong>：在数据流处理系统中，<code>BlockingQueue</code> 可用于在不同处理阶段之间传递数据，确保数据的有序和线程安全的传递。</li><li><strong>线程池中的任务队列</strong>：Java 的线程池实现（如 <code>ThreadPoolExecutor</code>）内部使用 <code>BlockingQueue</code> 来存储待执行的任务，线程池中的工作线程从队列中获取任务并执行。</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>在高并发系统中，<code>BlockingQueue</code> 可以用于控制并发流量，限制同时处理的请求数量，防止系统过载。</p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h4><p>使用 <code>ArrayBlockingQueue</code> 或 <code>LinkedBlockingQueue</code> 实现“生产者-消费者模型”。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerExample</span> </span>&#123;<br>    <span class="hljs-comment">// 有界队列（ArrayBlockingQueue实现），容量为5</span><br>    <span class="hljs-comment">// private final BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); </span><br>    <br>    <span class="hljs-comment">// 无界队列（LinkedBlockingQueue实现，也可以限制容量，推荐限制容量）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(); <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产者方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            queue.put(i); <span class="hljs-comment">// 插入元素，如果队列满则阻塞</span><br>            System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + i);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消费者方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> value = queue.take(); <span class="hljs-comment">// 获取元素，如果队列为空则阻塞</span><br>                System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + value);<br>                Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟处理时间</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ProducerConsumerExample example = <span class="hljs-keyword">new</span> ProducerConsumerExample();<br><br>        <span class="hljs-comment">// 创建生产者线程</span><br>        List&lt;Thread&gt; producerThreads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = i;<br>            Thread producerThread = <span class="hljs-keyword">new</span> Thread(() -&gt; example.producer(value), <span class="hljs-string">&quot;Producer-&quot;</span> + i);<br>            producerThreads.add(producerThread);<br>        &#125;<br>        <span class="hljs-comment">// 创建消费者线程</span><br>        Thread consumerThread = <span class="hljs-keyword">new</span> Thread(example::consumer, <span class="hljs-string">&quot;Consumer&quot;</span>);<br><br>        <span class="hljs-comment">// 启动线程</span><br>        producerThreads.forEach(Thread::start);<br>        consumerThread.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="优先级任务"><a href="#优先级任务" class="headerlink" title="优先级任务"></a>优先级任务</h4><p>使用 <code>PriorityBlockingQueue</code> 实现优先级任务处理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueueExample</span> </span>&#123;<br>    <span class="hljs-comment">// 定义任务类，实现Comparable接口以支持优先级排序</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Task</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> priority;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> priority)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.priority = priority;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Task other)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(other.priority, <span class="hljs-keyword">this</span>.priority); <span class="hljs-comment">// 高优先级先处理</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, priority=&quot;</span> + priority + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Task&gt; queue = <span class="hljs-keyword">new</span> PriorityBlockingQueue&lt;&gt;();<br><br>    <span class="hljs-comment">// 生产者方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>        Task[] tasks = &#123;<br>            <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;Task1&quot;</span>, <span class="hljs-number">3</span>),<br>            <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;Task2&quot;</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;Task3&quot;</span>, <span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;Task4&quot;</span>, <span class="hljs-number">5</span>),<br>            <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;Task5&quot;</span>, <span class="hljs-number">4</span>)<br>        &#125;;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>                queue.put(task); <span class="hljs-comment">// 插入任务</span><br>                System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + task);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 消费者方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Task task = queue.take(); <span class="hljs-comment">// 获取任务</span><br>                System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + task);<br>                Thread.sleep(<span class="hljs-number">400</span>); <span class="hljs-comment">// 模拟消费时间</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        PriorityBlockingQueueExample example = <span class="hljs-keyword">new</span> PriorityBlockingQueueExample();<br><br>        <span class="hljs-comment">// 创建生产者线程</span><br>        Thread producerThread = <span class="hljs-keyword">new</span> Thread(example::producer, <span class="hljs-string">&quot;Producer&quot;</span>);<br>        <span class="hljs-comment">// 创建消费者线程</span><br>        Thread consumerThread = <span class="hljs-keyword">new</span> Thread(example::consumer, <span class="hljs-string">&quot;Consumer&quot;</span>);<br><br>        producerThread.start();<br>        consumerThread.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h3><p>使用 <code>DelayQueue</code> 实现延时任务（只有在延迟时间到期时才能获取元素）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueueExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">// 定义延迟任务类，实现Delayed接口</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Delayed</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startTime;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelayedTask</span><span class="hljs-params">(String name, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.startTime = System.currentTimeMillis() + unit.toMillis(delay);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">long</span> remaining = startTime - System.currentTimeMillis();<br>            <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.MILLISECONDS);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Delayed other)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-keyword">this</span>.startTime, ((DelayedTask) other).startTime);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DelayedTask&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, startTime=&quot;</span> + startTime + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BlockingQueue&lt;DelayedTask&gt; delayQueue = <span class="hljs-keyword">new</span> DelayQueue&lt;&gt;();<br><br>        <span class="hljs-comment">// 生产者线程，插入延迟任务</span><br>        Thread producer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                delayQueue.put(<span class="hljs-keyword">new</span> DelayedTask(<span class="hljs-string">&quot;Task1&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>                System.out.println(<span class="hljs-string">&quot;Produced Task1 with 3 seconds delay.&quot;</span>);<br>                delayQueue.put(<span class="hljs-keyword">new</span> DelayedTask(<span class="hljs-string">&quot;Task2&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>                System.out.println(<span class="hljs-string">&quot;Produced Task2 with 1 second delay.&quot;</span>);<br>                delayQueue.put(<span class="hljs-keyword">new</span> DelayedTask(<span class="hljs-string">&quot;Task3&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS));<br>                System.out.println(<span class="hljs-string">&quot;Produced Task3 with 5 seconds delay.&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Producer&quot;</span>);<br><br>        <span class="hljs-comment">// 消费者线程，获取延迟任务</span><br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    DelayedTask task = delayQueue.take(); <span class="hljs-comment">// 阻塞直到任务到期</span><br>                    System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + task.name + <span class="hljs-string">&quot; at &quot;</span> + DATE_TIME_FORMATTER.format(LocalDateTime.now()));<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Task3&quot;</span>.equals(task.name)) &#123;<br>                        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 结束条件</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Consumer&quot;</span>);<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>选择合适的实现类</strong>：根据具体需求选择合适的 <code>BlockingQueue</code> 实现类。例如，<code>ArrayBlockingQueue</code> 适用于固定容量的场景，<code>LinkedBlockingQueue</code> 适用于需要动态扩展的场景，<code>PriorityBlockingQueue</code> 适用于需要按优先级处理元素的场景。</li><li><strong>避免死锁</strong>：确保生产者和消费者能够正常运行，避免由于队列满或空导致的永久阻塞。合理设置队列容量和处理速度。</li><li><strong>处理异常</strong>：在使用阻塞操作时，注意处理 <code>InterruptedException</code>，以确保线程能够响应中断信号。</li><li><strong>资源管理</strong>：对于有界队列，合理设置队列容量，避免内存溢出或资源浪费。</li><li><strong>线程协调</strong>：确保生产者和消费者的数量与队列容量相匹配，以实现最佳的并发性能。</li></ul><h3 id="队列选择"><a href="#队列选择" class="headerlink" title="队列选择"></a>队列选择</h3><p><code>BlockingQueue</code> 是 <code>Queue</code> 接口的扩展，提供了在队列为空或满时的阻塞操作。以下是 <code>BlockingQueue</code> 与其他常用队列的比较：</p><table><thead><tr><th>特性</th><th>BlockingQueue</th><th>LinkedList (Queue)</th><th>PriorityQueue</th><th>ArrayDeque (Queue)</th></tr></thead><tbody><tr><td><strong>阻塞操作</strong></td><td>支持（通过 <code>put</code> 和 <code>take</code> 方法）</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td><strong>线程安全</strong></td><td>大多数实现是线程安全的</td><td>非线程安全</td><td>非线程安全</td><td>非线程安全</td></tr><tr><td><strong>有界/无界</strong></td><td>支持有界和无界实现</td><td>通常无界</td><td>通常无界</td><td>通常无界</td></tr><tr><td><strong>元素顺序</strong></td><td><code>FIFO</code></td><td><code>FIFO</code></td><td>按优先级排序</td><td><code>FIFO</code></td></tr><tr><td><strong>常用实现类</strong></td><td><code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>DelayQueue</code> 等</td><td><code>LinkedList</code></td><td><code>PriorityQueue</code></td><td><code>ArrayDeque</code></td></tr></tbody></table><p><strong>选择使用</strong>：</p><ul><li><strong>BlockingQueue</strong>：在需要线程安全的阻塞操作时使用，如“生产者-消费者模型”、任务调度等。</li><li><strong>LinkedList</strong>：在单线程环境下或通过外部同步机制保证线程安全时使用，适合需要频繁插入和删除的场景。</li><li><strong>PriorityQueue</strong>：在需要按照优先级顺序处理元素时使用，但需注意其非线程安全性。</li><li><strong>ArrayDeque</strong>：在需要高效的双端队列操作时使用，适合单线程环境或通过外部同步机制保证线程安全的场景。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇围绕 <code>AQS</code> 及其衍生的多种并发工具（锁、信号量、倒计时门闩、读写锁、阻塞队列等）进行了系统性阐述：</p><ul><li><code>AQS</code> 通过一个共享的整型 <code>state</code> 及 <code>FIFO</code> 等待队列，为独占或共享场景下的线程获取和释放资源提供了通用框架。</li><li>在此基础上，Java 并发库构建了多种实用的同步类，如 <code>ReentrantLock</code>（可重入互斥锁）、<code>Semaphore</code>（信号量）、<code>CountDownLatch</code>（一次性门闩）、<code>ReentrantReadWriteLock</code>（读写锁）等，用来应对不同的并发访问需求。</li><li>同时，<code>BlockingQueue</code>、<code>StampedLock</code> 等更高级数据结构和锁机制能满足更细粒度的需求，如延迟队列、优先级调度、乐观读等。</li></ul><p>实际应用中，应根据业务特性（线程竞争程度、读写比、是否需要可中断或公平锁等）选用合适的并发组件，并充分理解它们所带来的性能和可维护性影响，从而在安全性与效率之间取得最佳平衡。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——不可变设计</title>
    <link href="/2021/08/11/javase-cp-final/"/>
    <url>/2021/08/11/javase-cp-final/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程编程中，如何保证数据的一致性与安全性往往是一大挑战。不可变对象在这方面提供了一种极其简洁有效的思路：如果一个对象从创建到销毁都不能被修改，那么不同线程之间自然无需为它的读写发生竞争。本文将由浅入深地讲解不可变对象在 Java 中的定义及实现方式，并结合实际应用场景，说明它为何在高并发下能带来显著的安全与性能优势。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不可变对象是指一旦创建后，其内部状态（即成员变量）无法被修改的对象。在 Java 中，实现不可变对象通常需要遵循以下原则：</p><ol><li><strong>所有字段为 final</strong>：确保字段在构造后不可更改。</li><li><strong>类被声明为 final</strong>：防止子类修改行为。</li><li><strong>不提供修改状态的方法</strong>：如 <code>setter</code> 方法。</li><li><strong>确保对可变字段的深拷贝</strong>：防止通过引用修改内部状态。</li></ol><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutablePerson</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImmutablePerson</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="并发编程中的优势"><a href="#并发编程中的优势" class="headerlink" title="并发编程中的优势"></a>并发编程中的优势</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>不可变对象天然线程安全。由于其状态不可更改，多个线程可以安全地共享同一个不可变对象，而无需额外的同步机制。这大大简化了并发编程中的复杂性，避免了竞争条件和数据不一致的问题。</p><h3 id="无需同步"><a href="#无需同步" class="headerlink" title="无需同步"></a>无需同步</h3><p>传统的可变对象在多线程环境下需要通过 <code>synchronized</code> 关键字或其他同步机制来确保线程安全，而不可变对象则不需要。这不仅减少了代码的复杂性，还提高了性能，因为同步通常会带来额外的开销。</p><h3 id="简化缓存和共享"><a href="#简化缓存和共享" class="headerlink" title="简化缓存和共享"></a>简化缓存和共享</h3><p>由于不可变对象不可更改，它们可以安全地缓存和共享。例如，Java 的 <code>String</code> 类就是不可变的，这使得字符串常量池的实现成为可能，提升了性能和内存利用率。</p><h3 id="避免死锁和竞态条件"><a href="#避免死锁和竞态条件" class="headerlink" title="避免死锁和竞态条件"></a>避免死锁和竞态条件</h3><p>使用不可变对象可以避免许多并发编程中常见的问题，如死锁和竞态条件，因为多个线程无法改变对象的状态，从而减少了资源竞争的可能性。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="使用-final-关键字"><a href="#使用-final-关键字" class="headerlink" title="使用 final 关键字"></a>使用 final 关键字</h3><p>将类声明为 <code>final</code>，防止被继承和修改。将所有字段声明为 <code>private final</code>，确保字段在构造后不可更改。</p><h3 id="防御性拷贝"><a href="#防御性拷贝" class="headerlink" title="防御性拷贝"></a>防御性拷贝</h3><p>对于包含可变对象的字段，需要在构造方法中进行深拷贝，并在 <code>getter</code> 方法中返回副本，防止外部修改内部状态。</p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutablePerson</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Date birthDate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImmutablePerson</span><span class="hljs-params">(String name, Date birthDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.birthDate = <span class="hljs-keyword">new</span> Date(birthDate.getTime()); <span class="hljs-comment">// 深拷贝</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(birthDate.getTime()); <span class="hljs-comment">// 返回副本</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="不提供修改方法"><a href="#不提供修改方法" class="headerlink" title="不提供修改方法"></a>不提供修改方法</h3><p>不提供任何会修改对象状态的方法，如 <code>setter</code> 方法，确保对象一旦创建后状态不变。</p><h3 id="使用不可变集合"><a href="#使用不可变集合" class="headerlink" title="使用不可变集合"></a>使用不可变集合</h3><p>Java 提供了一些不可变集合，如 <code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code>（自 Java 9 起）。使用这些不可变集合可以确保集合内容在创建后不可更改。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; immutableList = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>在多线程环境下，可以安全地共享不可变对象，避免每个线程都创建自己的副本，从而节省内存和提升性能。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedResource</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutablePerson PERSON = <span class="hljs-keyword">new</span> ImmutablePerson(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImmutablePerson <span class="hljs-title">getPerson</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> PERSON;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>多个线程可以调用 <code>SharedResource.getPerson()</code> 安全地获取同一个 <code>ImmutablePerson</code> 实例，而无需担心线程安全问题。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>不可变对象是函数式编程的核心，Java 8 引入的函数式接口和流（<code>Streams</code>）等特性鼓励使用不可变设计，提升代码的可读性和可维护性。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>List&lt;String&gt; upperCaseNames = names.stream()<br>                                   .map(String::toUpperCase)<br>                                   .collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p>在这个例子中，原始的 <code>names</code> 列表是不可变的，流操作生成的新列表 <code>upperCaseNames</code> 也是不可变的，确保了线程安全。</p><h3 id="缓存和备忘录模式"><a href="#缓存和备忘录模式" class="headerlink" title="缓存和备忘录模式"></a>缓存和备忘录模式</h3><p>不可变对象适合用于缓存，因为它们可以安全地被多个线程共享而无需同步。例如，Java 的 <code>String</code> 类在实现字符串常量池时就利用了不可变性。</p><h3 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h3><p>在高性能并发应用中，无锁编程是提升吞吐量的关键技术。不可变对象通过消除对同步的需求，天然支持无锁编程。</p><p><strong>示例</strong>：使用 <code>AtomicReference</code> 来管理不可变对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockFreeCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;ImmutableCounter&gt; counterRef = <br>        <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-keyword">new</span> ImmutableCounter(<span class="hljs-number">0</span>));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        ImmutableCounter current;<br>        ImmutableCounter updated;<br>        <span class="hljs-keyword">do</span> &#123;<br>            current = counterRef.get();<br>            updated = <span class="hljs-keyword">new</span> ImmutableCounter(current.getValue() + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">while</span> (!counterRef.compareAndSet(current, updated));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> counterRef.get().getValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImmutableCounter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，<code>ImmutableCounter</code> 是不可变的，通过 <code>AtomicReference</code> 实现了线程安全的无锁计数器。</p><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><h3 id="减少同步开销"><a href="#减少同步开销" class="headerlink" title="减少同步开销"></a>减少同步开销</h3><p>由于不可变对象无需同步机制，避免了因锁竞争带来的性能瓶颈，特别是在高并发场景下，显著提升了系统的吞吐量。</p><h3 id="提升缓存命中率"><a href="#提升缓存命中率" class="headerlink" title="提升缓存命中率"></a>提升缓存命中率</h3><p>不可变对象可以安全地被缓存和共享，提升了缓存命中率，减少了内存的重复使用。</p><h3 id="优化内存管理"><a href="#优化内存管理" class="headerlink" title="优化内存管理"></a>优化内存管理</h3><p>由于不可变对象不会改变状态，垃圾回收器可以更高效地管理内存，减少了内存碎片。</p><h3 id="增加对象创建的成本"><a href="#增加对象创建的成本" class="headerlink" title="增加对象创建的成本"></a>增加对象创建的成本</h3><p>需要注意的是，不可变对象在需要频繁创建新实例的场景下，可能会带来一定的性能开销。因此，在设计时需要权衡不可变性带来的好处与对象创建的成本，比如在读少写多的场景下，不可变设计可能会导致过多实例被创建，带来 <code>GC</code> 压力。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="尽量使用现有的不可变类"><a href="#尽量使用现有的不可变类" class="headerlink" title="尽量使用现有的不可变类"></a>尽量使用现有的不可变类</h3><p>Java 提供了许多不可变类，如 <code>String</code>、<code>Integer</code>、<code>LocalDate</code> 等，优先使用它们可以减少自定义不可变类的工作量。</p><h3 id="合理设计不可变类"><a href="#合理设计不可变类" class="headerlink" title="合理设计不可变类"></a>合理设计不可变类</h3><p>确保不可变类的构造方法能够完全初始化所有字段，并避免在构造过程中泄露 <code>this</code> 引用。</p><h3 id="结合其他线程安全机制"><a href="#结合其他线程安全机制" class="headerlink" title="结合其他线程安全机制"></a>结合其他线程安全机制</h3><p>在某些复杂场景下，可以将不可变对象与 <code>volatile</code> 或 <code>Atomic</code> 类结合使用，以实现更高效的并发控制。</p><h3 id="使用不可变集合-1"><a href="#使用不可变集合-1" class="headerlink" title="使用不可变集合"></a>使用不可变集合</h3><p>尽量使用 Java 提供的不可变集合（如 <code>List.of()</code>, <code>Set.of()</code>），避免手动创建不可变集合，以减少错误。</p><h3 id="避免过度使用"><a href="#避免过度使用" class="headerlink" title="避免过度使用"></a>避免过度使用</h3><p>虽然不可变对象有诸多优势，但在某些需要频繁修改状态的场景下，过度使用不可变对象可能导致性能下降。因此，应根据具体需求合理选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不可变是 Java 并发编程里十分重要的设计思想之一。在多线程环境中，不可变对象具有天然线程安全、无需同步、容易共享等优势，可以显著简化程序逻辑并规避锁竞争、死锁等问题。但与此同时，也要意识到不可变对象在需要高频修改的场景下可能导致额外的对象创建开销。实际系统中，可以将不可变设计与其他并发模式结合使用，以平衡程序的可维护性和性能。通过合理地使用不可变对象（尤其是结合如 <code>AtomicReference</code> 这样的原子类），我们能够写出更简洁、更安全且运行效率更佳的并发程序。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>不可变设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——无锁</title>
    <link href="/2021/08/09/javase-cp-nonlock/"/>
    <url>/2021/08/09/javase-cp-nonlock/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在高并发应用中，传统的锁（<code>synchronized</code>、<code>ReentrantLock</code> 等）容易成为性能瓶颈，不仅会造成线程阻塞，也可能引入死锁、优先级反转等问题。无锁编程正是针对这一痛点而生，通过底层的原子操作（尤其是 <code>CAS</code>）实现线程安全，尽可能减少阻塞和上下文切换，使系统在多核环境下保持较高的可扩展性和吞吐量。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>无锁编程是一种在多线程环境中实现线程安全的方法，它通过原子操作来保证数据一致性，而不依赖传统的锁机制（如 <code>ReentrantLock</code> 或 <code>synchronized</code>）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>高效性</strong>：避免了线程因锁竞争而进入阻塞状态，减少上下文切换的开销。</li><li><strong>无锁安全性</strong>：无需担心死锁、锁饥饿或优先级反转等传统锁机制中的问题。</li><li><strong>乐观并发控制</strong>：假设大部分操作不会产生冲突，只有在冲突时才通过 <code>CAS</code> 重试解决。</li><li><strong>自旋等待</strong>：在发生冲突时，通过自旋重试（而不是阻塞线程）完成操作，这可能导致一定的 CPU 开销。</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>原子操作是指不可分割的操作，在执行过程中不会被中断或干扰。即使在多线程环境中，原子操作也能保证操作的完整性和一致性。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>不可分割性</strong>：整个操作要么完全执行成功，要么完全失败，不会出现中间状态。</li><li><strong>线程安全性</strong>：多线程同时执行原子操作时，不需要额外的同步措施，操作本身已经是线程安全的。</li><li><strong>硬件支持</strong>：通常依赖底层硬件（CPU）指令实现，如 <code>cmpxchg</code>（比较并交换）或 <code>lock</code> 指令。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><code>CAS（Compare And Swap/Set）</code> 是一种原子操作，用于在多线程环境下进行无锁同步。其<strong>核心思想</strong>是：</p><ol><li>对某个内存地址（变量）读取当前值 <code>V</code>。</li><li>与预期值 <code>A</code> 进行比较。</li><li>如果 <code>V</code> 与 <code>A</code> 相等，则将该内存地址的值更新为 <code>B</code>；否则，不进行更新。</li></ol><p>简要流程可表示为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(A, B)</span>:</span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(value == A)</span> </span>&#123;<br>    value = B;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在Java中，<code>AtomicInteger</code>、<code>AtomicLong</code> 等原子类就依赖底层的 <code>CAS</code> 指令来实现无锁并发。</p><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>100 个线程实现对库存的扣减，使库存从 100 减少到 0。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockTestClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> stock = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 减库存</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseStock</span><span class="hljs-params">()</span> </span>&#123;<br>        stock--;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取库存</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stock;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StockTestClient stock = <span class="hljs-keyword">new</span> StockTestClient();<br>        List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(stock::decreaseStock);<br>            threads.add(t);<br>            t.start();<br>        &#125;<br>        threads.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;stock = &quot;</span> + stock.getStock());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个程序中，由于缺乏同步机制，因此多个线程同时读取和修改 <code>stock</code> 时，无法保证减库存操作的安全，产生了竞态条件，导致更新操作覆盖或丢失，最终导致输出的结果是不确定的。</p><h4 id="synchronized-解决"><a href="#synchronized-解决" class="headerlink" title="synchronized 解决"></a>synchronized 解决</h4><p>可以用 <code>synchronized</code> 保证同一时刻只有一个线程可以执行减库存操作，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseStock</span><span class="hljs-params">()</span> </span>&#123;<br>    stock--;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="CAS解决"><a href="#CAS解决" class="headerlink" title="CAS解决"></a>CAS解决</h4><p>根据前面提到的 <code>CAS</code> 概念，修改程序的库存字段和减库存方法如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger stock = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 减库存（无锁方式）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseStock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> current = stock.get();<br>        <span class="hljs-keyword">if</span> (stock.compareAndSet(current, current - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 等价于 stock.getAndDecrement();</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取库存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> stock.get();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码解析</strong>：</p><ol><li><code>AtomicInteger</code> 的使用：<code>stock</code> 被声明为 <code>AtomicInteger</code>，它内部维护了一个 <code>volatile</code> 整型变量，确保内存可见性。</li><li>在一个循环体中，获取当前库存，使用 <code>AtomicInteger</code> 的 <code>compareAndSet</code> 方法保证自减操作的原子性，将库存值减 1，成功则退出循环，否则继续。</li></ol><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p><code>ABA</code> 问题，即在最终比较前变量从 <code>A</code> 变为 <code>B</code> 再变回 <code>A</code>，最后比较的时候结果是一致的，但中间某个时间的比较可能是不一致的，<code>CAS</code> 无法检测到这个过程。</p><p>为了更好地解决 <code>CAS</code> 可能带来的 <code>ABA</code> 问题，可以使用 <code>AtomicStampedReference</code> 或 <code>AtomicMarkableReference</code>，通过引入版本号或标记来增强 <code>CAS</code> 操作的可靠性。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; stock = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 减库存（无锁，解决ABA问题）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseStock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] stampHolder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        Integer currentStock = stock.get(stampHolder);<br>        <span class="hljs-keyword">int</span> currentStamp = stampHolder[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (currentStock &lt;= <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> updated = stock.compareAndSet(currentStock, currentStock - <span class="hljs-number">1</span>, currentStamp, currentStamp + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (updated) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取库存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> stock.getReference();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码解析</strong>：</p><ol><li><strong>AtomicStampedReference</strong>：除了存储引用，还维护了一个版本号（<code>stamp</code>），在 <code>CAS</code> 操作时，不仅比较当前值，还比较版本号，避免 <code>ABA</code> 问题。</li><li><strong>compareAndSet 方法</strong>：只有在值和版本号都匹配时，才会进行更新操作。</li></ol><h2 id="无锁类"><a href="#无锁类" class="headerlink" title="无锁类"></a>无锁类</h2><h3 id="Atomic-类"><a href="#Atomic-类" class="headerlink" title="Atomic 类"></a>Atomic 类</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java 的 <code>java.util.concurrent.atomic</code>  包提供了一系列的原子类（<code>Atomic Classes</code>），用于执行原子性操作。这些类基于底层的 <code>CAS（Compare-And-Swap）</code> 操作，提供了一种高效的无锁编程方式，避免了显式的同步和锁机制。</p><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><ul><li>**int get()**：获取当前值。</li><li>**void set(int newValue)**：设置新值。</li><li>**int getAndIncrement()**：获取当前值并自增。</li><li>**int incrementAndGet()**：自增后获取新值。</li><li>**boolean compareAndSet(int expect, int update)**：如果当前值等于预期值，则更新为新值。</li></ul><h5 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h5><ul><li>类似于 <code>AtomicInteger</code>，用于 <code>long</code> 类型。</li></ul><h5 id="AtomicReference-lt-V-gt"><a href="#AtomicReference-lt-V-gt" class="headerlink" title="AtomicReference&lt;V&gt;"></a>AtomicReference&lt;V&gt;</h5><ul><li>**V get()**：获取当前引用。</li><li>**void set(V newValue)**：设置新引用。</li><li>**boolean compareAndSet(V expect, V update)**：如果当前引用等于预期值，则更新为新引用。</li></ul><h5 id="AtomicStampedReference-lt-V-gt"><a href="#AtomicStampedReference-lt-V-gt" class="headerlink" title="AtomicStampedReference&lt;V&gt;"></a>AtomicStampedReference&lt;V&gt;</h5><p>可解决 <code>ABA</code> 问题，通过附加的版本号进行比较和更新。</p><ul><li>**V getReference()**：获取当前引用。</li><li>**int getStamp()**：获取当前版本号。</li><li>**boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)**：比较并设置新值及版本号。</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>Atomic</code> 类通过 <code>Unsafe</code> 类提供的底层 <code>CAS</code> 操作实现原子性。每个 <code>Atomic</code> 类内部维护一个 <code>volatile</code> 变量，并利用 <code>CAS</code> 操作确保在多线程环境下对该变量的更新是安全的。例如，<code>AtomicInteger</code> 内部使用 <code>Unsafe</code> 的 <code>compareAndSwapInt</code> 方法来实现 <code>compareAndSet</code> 操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unsafe = Unsafe.getUnsafe();<br>            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, expect, update);<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法省略</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>无锁队列是一种线程安全的队列实现，允许多个线程并发地插入和移除元素，而无需使用锁。Java 标准库中的 <code>ConcurrentLinkedQueue</code> 就是一个典型的无锁队列。</p><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><ul><li>**boolean add(E e)**：将指定元素插入队列的尾部。</li><li>**boolean remove(Object o)**：删除队列中第一个匹配的元素。</li><li>**boolean offer(E e)**：将指定元素插入队列的尾部。</li><li>**E poll()**：移除并返回队列头部的元素，队列为空时返回 <code>null</code>。</li><li>**E peek()**：返回队列头部的元素，但不移除它，队列为空时返回 <code>null</code>。</li><li>**boolean isEmpty()**：判断队列是否为空。</li><li>**int size()**：返回队列的元素个数（非常量时间操作）。</li><li>**boolean contains(Object o)**：判断链表中是否存在指定元素。</li><li>**Iterator&lt;E&gt; iterator()**：返回链表的迭代器。</li></ul><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>ConcurrentLinkedQueue</code> 基于 <code>Michael &amp; Scott Queue</code> 算法实现，这是一个典型的无锁队列算法。该算法使用单向链表和 <code>CAS</code> 操作来维护队列的头部和尾部指针。</p><ul><li><p><strong>节点结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">volatile</span> E item;<br>    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br><br>    Node(E item) &#123;<br>        <span class="hljs-keyword">this</span>.item = item;<br>        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>插入（Enqueue）</strong>：</p><ol><li>创建一个新节点。</li><li>通过 <code>CAS</code> 操作将当前尾节点的 <code>next</code> 指针指向新节点。</li><li>更新尾指针指向新节点。</li></ol></li><li><p><strong>移除（Dequeue）</strong>：</p><ol><li>读取当前头节点和其下一个节点。</li><li>通过 <code>CAS</code> 操作更新头指针指向下一个节点。</li><li>返回下一个节点的元素。</li></ol></li></ul><p>这种设计确保了多个线程可以同时进行插入和移除操作，而不需要锁。</p><h3 id="无锁双端队列"><a href="#无锁双端队列" class="headerlink" title="无锁双端队列"></a>无锁双端队列</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>无锁双端队列是一种线程安全的双端队列实现，允许多个线程并发地插入和移除元素，而无需使用锁，可用于实现队列和栈结构。Java标准库中的 <code>ConcurrentLinkedDeque</code> 就是一个典型的无锁双端队列。</p><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><ul><li>**void addFirst(E e)**：将指定元素插入队列头部。</li><li>**void addLast(E e)**：将指定元素插入队列尾部。</li><li>**E removeFirst()**：移除并返回队列头部的元素，队列为空时返回 null。</li><li>**E removeLast()**：移除并返回队列尾部的元素，队列为空时返回 null。</li><li>**boolean offerFirst()**：将指定元素插入队列的头部。</li><li>**boolean offerLast()**：将指定元素插入队列的尾部。</li><li>**E pollFirst()**：移除队并返回队列头部的元素，队列为空时返回 null。</li><li>**E pollLast()**：移除队并返回队列尾部的元素，队列为空时返回 null。</li><li>**E peekFirst()**：返回队列头部的元素，但不移除它，队列为空时返回 null。</li><li>**E peekLast()**：返回队列尾部的元素，但不移除它，队列为空时返回 null。</li><li>无锁队列的所有 API。</li></ul><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>ConcurrentLinkedDeque</code> 基于双向链表和 <code>CAS</code> 操作实现，允许高效的并发插入和移除操作。其核心思想如下：</p><ul><li><p><strong>节点结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">volatile</span> E item;<br>    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; prev;<br>    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br><br>    Node(E item) &#123;<br>        <span class="hljs-keyword">this</span>.item = item;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>双端操作</strong>：</p><ul><li><strong>插入（AddFirst/AddLast）</strong>：<ol><li>创建一个新节点。</li><li>通过CAS操作将新节点链接到队列的头部或尾部。</li><li>更新头指针或尾指针指向新节点。</li></ol></li><li><strong>移除（PollFirst/PollLast）</strong>：<ol><li>读取当前头节点或尾节点。</li><li>通过CAS操作更新头指针或尾指针指向下一个或上一个节点。</li><li>返回被移除节点的元素。</li></ol></li></ul></li><li><p><strong>无锁设计</strong>：</p><ul><li>通过原子操作确保多个线程可以安全地并发修改队列的两端，而不需要锁。</li><li>使用 <strong>标记删除</strong> 技术处理节点的逻辑删除，避免竞态条件。</li></ul></li></ul><h3 id="无锁哈希表"><a href="#无锁哈希表" class="headerlink" title="无锁哈希表"></a>无锁哈希表</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p><code>ConcurrentHashMap</code> 是 Java 标准库中用于高并发场景下的线程安全哈希表实现。虽然 <code>ConcurrentHashMap</code> 采用了“分段锁”（在 JDK 7 之前）或“ <code>CAS</code> + 局部同步”相结合（在 JDK 8 及以后）的方式、并非完全无锁，但它但在大部分读操作时无锁，对写操作采用细粒度或局部锁，并行度依然较高。</p><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><ul><li>**V put(K key, V value)**：将指定键值对插入映射，如果键已存在则更新其值。</li><li>**V get(Object key)**：获取指定键对应的值。</li><li>**V remove(Object key)**：移除指定键对应的键值对。</li><li>**boolean containsKey(Object key)**：判断映射中是否存在指定键。</li><li>**Set&lt;K&gt; keySet()**：返回映射中的所有键。</li><li>**V putIfAbsent(K key, V value)**：只有在键不存在时才插入键值对。</li></ul><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><p>在 <code>JDK 8</code> 及以后，<code>ConcurrentHashMap</code> 采用了基于节点的锁分离和 <code>CAS</code> 操作 的设计，具体包括：</p><ul><li><strong>节点类型</strong>：<ul><li><strong>普通节点（TreeNode）</strong>：用于处理哈希冲突，基于红黑树实现高效的查找。</li><li><strong>ForwardingNode</strong>：用于扩容过程中指向新表。</li></ul></li><li><strong>插入和更新</strong>：<ul><li>使用 <code>synchronized</code> 或 <code>CAS</code> 操作对桶中的链表或红黑树进行修改，确保线程安全。</li></ul></li><li><strong>扩容</strong>：<ul><li>当负载因子达到阈值时，进行表的扩容。使用 <code>synchronized</code> 保证扩容过程中的线程安全。</li></ul></li><li><strong>无锁读操作</strong>：<ul><li>大多数读操作（如 <code>get</code>）不需要锁，通过 <code>volatile</code> 关键字保证内存可见性。</li></ul></li></ul><h3 id="无锁集合"><a href="#无锁集合" class="headerlink" title="无锁集合"></a>无锁集合</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><code>ConcurrentSkipListSet</code> 是 Java 标准库中基于跳表（<code>Skip List</code>）实现的线程安全且有序的集合（<code>Set</code>）类。跳表是一种多层链表结构，支持高效的查找、插入和删除操作。<code>ConcurrentSkipListSet</code> 通过无锁算法实现高并发下的操作，并且保证元素的自然顺序或使用指定的比较器顺序。</p><h4 id="常用API-4"><a href="#常用API-4" class="headerlink" title="常用API"></a>常用API</h4><ul><li>**boolean add(E e)**：向集合中添加指定元素，如果元素已存在则不添加。</li><li>**boolean remove(Object o)**：移除集合中指定的元素。</li><li>**boolean contains(Object o)**：判断集合中是否存在指定元素。</li><li>**Iterator&lt;E&gt; iterator()**：返回集合的迭代器，支持弱一致性（<code>weakly consistent</code>）。</li><li>**int size()**：返回集合中元素的数量。</li><li>**boolean isEmpty()**：判断集合是否为空。</li><li>**void clear()**：移除集合中的所有元素。</li><li>**E first()**：返回集合中第一个（最小）元素。</li><li>**E last()**：返回集合中最后一个（最大）元素。</li></ul><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>ConcurrentSkipListSet</code> 基于 <code>ConcurrentSkipListMap</code> 实现，其底层结构为跳表。跳表通过多层链表的结构实现高效的有序存取，具体原理如下：</p><ul><li><p><strong>节点结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> E key;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> topLevel;<br>    <span class="hljs-keyword">final</span> AtomicReferenceArray&lt;Node&lt;E&gt;&gt; next;<br><br>    Node(E key, <span class="hljs-keyword">int</span> height) &#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.topLevel = height;<br>        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">new</span> AtomicReferenceArray&lt;&gt;(height + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>跳表结构</strong>：</p><ul><li><strong>多层链表</strong>：每个节点在不同的层上有不同数量的指针，允许快速跳跃式搜索。</li><li><strong>随机层级</strong>：新节点的层级通过随机算法决定，保证跳表的平均性能。</li></ul></li><li><p><strong>并发操作</strong>：</p><ul><li><strong>插入（Add）</strong>：<ol><li>在每一层找到插入位置。</li><li>使用CAS操作插入新节点的指针，确保线程安全。</li></ol></li><li><strong>移除（Remove）</strong>：<ol><li>在每一层找到要移除的节点。</li><li>使用CAS操作更新前驱节点的指针，逻辑删除节点。</li></ol></li><li><strong>查找（Contains）</strong>：<ol><li>从最高层开始，逐层向下搜索。</li><li>使用无锁的方式遍历链表，确保高效的并发访问。</li></ol></li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>无锁编程适用于多种高并发和性能敏感的场景，尤其在以下领域表现突出：</p><h3 id="高并发计数器与统计"><a href="#高并发计数器与统计" class="headerlink" title="高并发计数器与统计"></a>高并发计数器与统计</h3><p><strong>应用示例</strong>：</p><ul><li><strong>网站访问计数器</strong>：在高流量的网站中，记录页面访问次数需要高效的原子操作。</li><li><strong>实时统计系统</strong>：如在线游戏中的实时玩家统计、金融系统中的交易计数等。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>高效的原子增减操作，如使用 <code>AtomicInteger</code> 或 <code>LongAdder</code>，避免了锁的竞争，提升吞吐量。</li></ul><h3 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h3><p><strong>应用示例</strong>：</p><ul><li><strong>消息队列</strong>：如 <code>Kafka</code>、<code>RabbitMQ</code> 中的内部消息存储。</li><li><strong>任务调度系统</strong>：线程池中的任务队列。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>使用无锁队列（如 <code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>），支持高效的并发插入和移除操作，减少锁带来的阻塞和上下文切换开销。</li></ul><h3 id="实时系统与低延迟应用"><a href="#实时系统与低延迟应用" class="headerlink" title="实时系统与低延迟应用"></a>实时系统与低延迟应用</h3><p><strong>应用示例</strong>：</p><ul><li><strong>高频交易系统</strong>：金融交易系统对延迟极其敏感，需要快速响应。</li><li><strong>实时数据处理</strong>：如流处理框架中的数据管道。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>无锁数据结构和算法能够提供更低的延迟和更高的吞吐量，满足实时性要求。</li></ul><h3 id="高性能缓存系统"><a href="#高性能缓存系统" class="headerlink" title="高性能缓存系统"></a>高性能缓存系统</h3><p><strong>应用示例</strong>：</p><ul><li><strong>分布式缓存</strong>：如 <code>Redis</code>、<code>Memcached</code> 内部的数据存储。</li><li><strong>本地缓存</strong>：如 <code>Guava Cache</code>、<code>Caffeine</code> 中的高速缓存实现。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>无锁哈希表（如 <code>ConcurrentHashMap</code>）支持高效的并发访问和更新，减少缓存命中和写入的延迟。</li></ul><h3 id="多核并行计算"><a href="#多核并行计算" class="headerlink" title="多核并行计算"></a>多核并行计算</h3><p><strong>应用示例</strong>：</p><ul><li><strong>并行算法</strong>：如并行排序、并行图算法。</li><li><strong>大规模数据处理</strong>：如 <code>MapReduce</code>、<code>Spark</code> 中的数据并行处理。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>通过无锁数据结构和原子操作，充分利用多核处理器的并行能力，提升计算性能。</li></ul><h3 id="分布式系统中的共享数据结构"><a href="#分布式系统中的共享数据结构" class="headerlink" title="分布式系统中的共享数据结构"></a>分布式系统中的共享数据结构</h3><p><strong>应用示例</strong>：</p><ul><li><strong>分布式锁服务</strong>：如 <code>Zookeeper</code>、<code>Etcd</code> 中的分布式锁实现。</li><li><strong>共享状态管理</strong>：如分布式缓存、一致性哈希环等。</li></ul><p><strong>无锁优势</strong>：</p><ul><li>无锁算法在分布式环境中可以减少锁的争用和网络延迟，提高系统的可扩展性和可靠性。</li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>无锁编程通过避免传统锁机制，能够在特定场景下显著提升性能。然而，其实际效果受多种因素影响，以下是详细的性能分析：</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="1-避免锁的阻塞和上下文切换"><a href="#1-避免锁的阻塞和上下文切换" class="headerlink" title="1. 避免锁的阻塞和上下文切换"></a>1. 避免锁的阻塞和上下文切换</h4><ul><li><strong>传统锁</strong>：在高并发场景下，多个线程竞争同一个锁，导致部分线程被阻塞，频繁的上下文切换增加了系统开销。</li><li><strong>无锁机制</strong>：通过原子操作（如 <code>CAS</code>）实现同步，避免了线程阻塞和上下文切换，提升并发性能。</li></ul><h4 id="2-提高吞吐量"><a href="#2-提高吞吐量" class="headerlink" title="2. 提高吞吐量"></a>2. 提高吞吐量</h4><ul><li><strong>无锁数据结构</strong>：如无锁队列、无锁栈，允许多个线程同时进行插入和移除操作，显著提升吞吐量。</li></ul><h4 id="3-减少死锁和优先级反转的风险"><a href="#3-减少死锁和优先级反转的风险" class="headerlink" title="3. 减少死锁和优先级反转的风险"></a>3. 减少死锁和优先级反转的风险</h4><ul><li><strong>传统锁</strong>：可能导致死锁、锁饥饿和优先级反转等问题，影响系统稳定性。</li><li><strong>无锁机制</strong>：避免了显式锁的使用，自然规避了这些问题，提升系统可靠性。</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><h4 id="1-CAS操作的重试开销"><a href="#1-CAS操作的重试开销" class="headerlink" title="1. CAS操作的重试开销"></a>1. CAS操作的重试开销</h4><ul><li><strong>高冲突场景</strong>：在竞争激烈的情况下，<code>CAS</code> 操作可能频繁失败并重试，导致大量自旋，消耗 CPU 资源，影响性能。</li><li><strong>自旋消耗</strong>：无锁操作依赖于自旋等待，长时间的自旋会浪费大量 CPU 时间。</li></ul><h4 id="2-ABA问题带来的复杂性"><a href="#2-ABA问题带来的复杂性" class="headerlink" title="2. ABA问题带来的复杂性"></a>2. ABA问题带来的复杂性</h4><ul><li><strong>ABA问题解决方案复杂</strong>：<code>CAS</code> 带来的 <code>ABA</code> 问题需要使用带版本号的引用（如 <code>AtomicStampedReference</code>），增加了实现的复杂性。</li></ul><h4 id="3-只能针对单一变量的原子操作"><a href="#3-只能针对单一变量的原子操作" class="headerlink" title="3. 只能针对单一变量的原子操作"></a>3. 只能针对单一变量的原子操作</h4><ul><li><strong>多变量更新</strong>：无锁编程通常只能保证单一变量的原子性，对于需要同时更新多个变量的操作，需要更复杂的设计，如使用锁或其他同步机制。</li></ul><h4 id="3-可维护性和可读性较差"><a href="#3-可维护性和可读性较差" class="headerlink" title="3. 可维护性和可读性较差"></a>3. 可维护性和可读性较差</h4><ul><li><strong>代码复杂度</strong>：无锁算法逻辑相对复杂，代码难以理解和维护，增加了开发和调试的难度。</li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>以下通过简单的实验对比无锁和传统锁在高并发场景下的性能表现。</p><h4 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h4><ul><li>100 个线程同时对同一个计数器进行自增操作。</li></ul><h4 id="传统锁实现"><a href="#传统锁实现" class="headerlink" title="传统锁实现"></a>传统锁实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            e.printStackTrace();<br>        &#125;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        LockCounter counter = <span class="hljs-keyword">new</span> LockCounter();<br>        List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; counter.increment());<br>            threads.add(t);<br>            t.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.join();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;Final count (Lock): &quot;</span> + counter.getCount());<br>        System.out.println(<span class="hljs-string">&quot;Time taken: &quot;</span> + (end - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="无锁实现"><a href="#无锁实现" class="headerlink" title="无锁实现"></a>无锁实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            e.printStackTrace();<br>        &#125;<br>        count.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count.get();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AtomicCounter counter = <span class="hljs-keyword">new</span> AtomicCounter();<br>        List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; counter.increment());<br>            threads.add(t);<br>            t.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.join();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;Final count (Atomic): &quot;</span> + counter.getCount());<br>        System.out.println(<span class="hljs-string">&quot;Time taken: &quot;</span> + (end - start) / <span class="hljs-number">1_000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Final</span> <span class="hljs-built_in">count</span> (Lock): <span class="hljs-number">1000</span><br><span class="hljs-type">Time</span> taken: <span class="hljs-number">1444</span> ms<br><br><span class="hljs-keyword">Final</span> <span class="hljs-built_in">count</span> (<span class="hljs-keyword">Atomic</span>): <span class="hljs-number">1000</span><br><span class="hljs-type">Time</span> taken: <span class="hljs-number">91</span> ms<br></code></pre></div></td></tr></table></figure><ul><li><strong>传统锁</strong>：较高的时间消耗，随着线程数量的增加，时间显著上升。</li><li><strong>无锁（Atomic）</strong>：较低的时间消耗，在高并发下表现更优。</li></ul><p><strong>注意</strong>：实际性能还受具体硬件、JVM 实现和其他环境因素影响，但在大多数情况下，无锁编程在高并发场景下具有显著的性能优势。</p><h2 id="与传统锁比较"><a href="#与传统锁比较" class="headerlink" title="与传统锁比较"></a>与传统锁比较</h2><p>无锁编程和传统锁（如 <code>synchronized</code>、<code>ReentrantLock</code>）在并发控制上各有优缺点。以下从多个维度进行对比：</p><table><thead><tr><th></th><th><strong>无锁编程（Lock-Free）</strong></th><th><strong>传统锁（Locking）</strong></th></tr></thead><tbody><tr><td><strong>并发模型</strong></td><td>乐观并发，假设大多数情况下不会发生冲突</td><td>悲观并发，假设资源竞争频繁</td></tr><tr><td><strong>阻塞与非阻塞</strong></td><td>非阻塞，线程不会因等待锁而被阻塞</td><td>阻塞，线程可能因等待锁而进入阻塞状态</td></tr><tr><td><strong>死锁风险</strong></td><td>无死锁风险</td><td>存在死锁、锁饥饿、优先级反转等问题</td></tr><tr><td><strong>性能表现</strong></td><td>高并发下性能优异，避免上下文切换和锁竞争带来的开销</td><td>在低并发下性能较好，但高并发下性能可能下降</td></tr><tr><td><strong>实现复杂度</strong></td><td>高，实现和调试复杂，需要处理 ABA 问题，多变量的更新实现更为复杂</td><td>低，实现简单，易于理解和维护</td></tr><tr><td><strong>适用场景</strong></td><td>高并发、低延迟、无需要跨多个变量的原子操作</td><td>需要强一致性、多步骤操作或对复杂数据结构的同步</td></tr><tr><td><strong>可扩展性</strong></td><td>良好，适用于多核处理器和大规模并发环境</td><td>限制较多，锁的粒度和数量可能影响可扩展性</td></tr><tr><td><strong>公平性</strong></td><td>不保证线程获取资源的顺序</td><td>可以通过锁的策略（如公平锁）保证一定的公平性</td></tr><tr><td><strong>内存消耗</strong></td><td>通常较低，只需维护少量原子变量和版本号</td><td>可能较高，尤其是复杂锁机制或大量锁对象的情况下</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无锁编程与传统锁机制相比，具有非阻塞、高并发、无死锁等重要优势。在 Java 中，这种思路体现在 <code>Atomic</code> 原子类（<code>AtomicInteger</code>、<code>AtomicReference</code> 等）、无锁队列（<code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>）、部分无锁哈希结构（<code>ConcurrentHashMap</code>）以及基于跳表的有序集合（<code>ConcurrentSkipListSet</code>）等多种实用组件中。</p><p>当然，无锁并不适合所有场景：对多变量的原子更新操作或复杂的同步逻辑，往往仍需使用更重量级的锁或其他同步工具。总体而言，是否引入无锁编程需要结合业务逻辑、并发冲突频率及对系统延迟的要求来综合考量，才能在性能与实现难度之间取得平衡。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>无锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——Java内存模型</title>
    <link href="/2021/08/06/javase-cp-jmm/"/>
    <url>/2021/08/06/javase-cp-jmm/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程并发环境中，如何确保线程对共享数据的访问和修改是正确而一致的，是一个核心且复杂的问题。Java 内存模型（JMM） 就是为了解决这一问题而引入的抽象约定。本文将带你从 <code>JMM</code> 的基本概念出发，逐步理解并掌握 <code>volatile</code> 关键字的语义，以及 <code>happens-before</code> 规则对并发程序正确性的重大意义。</p><h2 id="JMM-概述"><a href="#JMM-概述" class="headerlink" title="JMM 概述"></a>JMM 概述</h2><p><code>JMM</code>，全称为 Java 内存模型（<code>Java Memory Model</code>），是 Java 虚拟机（JVM）中的一种抽象模型，规定了线程如何与内存交互。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><code>JMM</code> 定义了两种内存区域：</p><ul><li><strong>主内存（Main Memory）</strong>：<ul><li>这是所有线程共享的内存区域。</li><li>所有线程的共享变量都存储在主内存中，线程需要从主内存中读取共享变量，并将修改后的值写回主内存。</li></ul></li><li><strong>工作内存（Working Memory）</strong>：<ul><li>每个线程有自己独立的工作内存（线程本地内存）。</li><li>线程的工作内存存储该线程使用的变量副本（包括共享变量的副本）。线程执行时对变量的操作首先在工作内存中进行，最终通过同步机制与主内存交换数据。</li><li>线程的工作内存并不是一个物理内存区域，而是一个抽象的概念，表示线程在执行时对数据的本地副本。</li></ul></li></ul><h3 id="内存之间的交互"><a href="#内存之间的交互" class="headerlink" title="内存之间的交互"></a>内存之间的交互</h3><ul><li><strong>读取和写入</strong>：线程通过以下操作与主内存交互：<ul><li><strong>写入（write）</strong>：将工作内存中的数据写回到主内存。</li><li><strong>读取（read）</strong>：从主内存读取数据到工作内存。</li></ul></li><li>每个线程对共享变量的操作（如读取、写入）最终会通过工作内存与主内存之间的交换来影响其他线程。</li></ul><h3 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h3><ul><li><strong>可见性</strong>：确保一个线程对共享变量的修改能够及时被其他线程看到，避免“脏读”。</li><li><strong>原子性</strong>：保证某些操作是不可中断的，要么完全执行，要么完全不执行，避免竞态条件。</li><li><strong>有序性</strong>：控制线程执行操作的顺序，避免由于CPU和JVM优化造成的指令重排序问题。</li></ul><h3 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a><strong>设计哲学</strong></h3><ul><li><code>JMM</code> 的设计并不关注如何实现内存管理，而是提供了一种高层的抽象视图来规范线程间的内存交互行为。</li><li>它的设计旨在保证并发程序的正确性，同时尽可能让程序的执行效率得到优化。</li></ul><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>多个线程可以访问和修改的变量。Java 中的实例字段、静态字段和数组元素都可以作为共享变量。</p><p><strong>问题</strong>：多个线程同时访问共享变量时，可能会出现数据一致性问题，导致线程间的操作相互影响。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedVariablesTestClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (b) &#123;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        b = <span class="hljs-keyword">false</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;main: b -&gt; &quot;</span> + b);<br><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序后，程序应该会在 3 秒后打印</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">main</span>: b -&gt;</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>但之后程序并没有停止，即线程 <code>t1</code> 中的 <code>while</code> 条件仍然成立，线程 <code>t1</code> 中的变量 <code>b</code> 似乎与主线程的变量 <code>b</code> 值不相同。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol><li><strong>工作内存与主内存的隔离</strong>：<ul><li>每个线程都有自己的工作内存（缓存），主内存是共享的。线程 <code>t1</code> 在执行时可能会从工作内存中读取 <code>b</code> 的值，而不是每次都从主内存中获取最新的值。如果主线程修改了 <code>b</code>，线程 <code>t1</code> 的工作内存并不会立刻被更新。</li></ul></li><li><strong>缺乏可见性保证</strong>：<ul><li>默认情况下，Java 中的普通变量（非 <code>volatile</code>）在多个线程间并没有同步更新机制。虽然主线程修改了 <code>b</code> 的值，但是 <code>t1</code> 线程并没有强制去主内存中读取这个值，它可能一直在使用缓存中的 <code>b</code> 值。由于没有同步机制，这个修改对于线程 <code>t1</code> 是不可见的。</li></ul></li><li><strong>JMM（Java内存模型）</strong>：<ul><li>JMM 规定了如何在多线程中读取和写入共享变量，但默认情况下，它没有保证线程之间的立即可见性。也就是说，线程 <code>t1</code> 对共享变量 <code>b</code> 的读取可能不会反映主线程对 <code>b</code> 的修改，直到线程 <code>t1</code> 再次从主内存读取该变量。</li></ul></li></ol><pre><code class=" mermaid">sequenceDiagram    participant t1 as 线程 t1    participant main as 主线程    participant main_mem as 主内存    participant t1_mem as t1 工作内存    main-&gt;&gt;main_mem: 线程主内存中的 b = true    main-&gt;&gt;t1_mem: 线程 t1 工作内存中的 b = true    t1-&gt;&gt;t1_mem: t1 读取 b (b = true)    t1-&gt;&gt;t1: t1 执行 while 循环 (b = true)    main-&gt;&gt;main: 主线程阻塞 3 秒    main-&gt;&gt;main_mem: 主线程将 b 修改为 false    main-&gt;&gt;main: 打印 b = false    t1-&gt;&gt;t1_mem: t1 检查工作内存中的 b (b = true)    t1-&gt;&gt;t1: t1 继续执行 while 循环 (b = true)    note right of t1: 直到下一次读取主内存中的 b，t1 才能看到主线程的修改</code></pre><p><strong>总结</strong>：在多线程程序中，线程间的共享数据可能会因为工作内存和主内存之间的交互机制而出现数据不一致的情况。例如：</p><ul><li>一个线程修改了某个共享变量的值，但由于缓存和优化机制，其他线程可能并不能立即看到该修改。</li><li>线程执行过程中，CPU 可能对指令进行重排序，导致线程执行的顺序与代码的书写顺序不一致，可能引发错误。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，表示该变量在多个线程中是共享的。使用 <code>volatile</code> 修饰的变量具有特殊的内存语义，可以在一定程度上保证变量的可见性和有序性，但不保证操作的原子性。</p><h3 id="作用和特性"><a href="#作用和特性" class="headerlink" title="作用和特性"></a>作用和特性</h3><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><p>可见性指的是当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。默认情况下，线程可能会将变量缓存在自己的工作内存中，导致其他线程无法及时感知到这个变化。使用 <code>volatile</code> 关键字可以确保对变量的写操作对所有线程立即可见。</p><h4 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h4><p>有序性指的是程序执行的顺序与代码书写的顺序是否一致。编译器和处理器可能会对指令进行重排序以优化性能，这可能导致程序执行的顺序与预期不符。<code>volatile</code> 关键字禁止特定类型的指令重排序，确保变量的读写操作按照代码的顺序执行，从而增强程序的可预测性。</p><h4 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h4><p>原子性指的是一个操作在执行过程中不可被中断，要么全部执行，要么完全不执行。<code>volatile</code> 并不保证操作的原子性，例如自增操作（<code>i++</code>）不是原子性的，即使 <code>i</code> 被声明为 <code>volatile</code>，多个线程同时对其进行操作仍然可能导致竞态条件。</p><h4 id="性能较好"><a href="#性能较好" class="headerlink" title="性能较好"></a>性能较好</h4><p><code>volatile</code> 是一种轻量级的同步机制，如果仅需可见性，而无需保证复合操作的原子性，相比于 <code>synchronized</code>，它对性能的开销较小。它不需要获取和释放锁，因此适用于需要保证可见性的简单场景。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="影响Java-内存模型-JMM"><a href="#影响Java-内存模型-JMM" class="headerlink" title="影响Java 内存模型 (JMM)"></a>影响Java 内存模型 (JMM)</h4><p><code>volatile</code> 关键字通过以下方式影响 JMM 的行为：</p><ol><li><strong>可见性保证</strong>：对 <code>volatile</code> 变量的写操作会立即刷新到主内存，读操作则会从主内存中重新读取。</li><li><strong>禁止指令重排序</strong>：在 <code>volatile</code> 变量前后的指令不会被重排序，以确保操作的有序性。</li></ol><h4 id="内存屏障-Memory-Barriers"><a href="#内存屏障-Memory-Barriers" class="headerlink" title="内存屏障 (Memory Barriers)"></a>内存屏障 (Memory Barriers)</h4><p>内存屏障是一种低级别的指令，用于限制 CPU 和编译器对指令的重排序。<code>volatile</code> 关键字在实现上依赖于内存屏障，通过在读写 <code>volatile</code> 变量时插入内存屏障，确保操作的顺序性和可见性。</p><p>具体来说：</p><ul><li><strong>写屏障（Write Barrier）</strong>：在写 <code>volatile</code> 变量之前，会插入一个写屏障，确保在此屏障之前的所有写操作在此屏障之后的写操作之前完成。</li><li><strong>读屏障（Read Barrier）</strong>：在读 <code>volatile</code> 变量之后，会插入一个读屏障，确保在此屏障之前的所有读操作在此屏障之后的读操作之前完成。</li></ul><p>这种屏障机制有效地防止了编译器和 CPU 对 <code>volatile</code> 变量的相关操作进行重排序。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p><code>volatile</code> 常用于定义标志位，控制线程的执行。例如，使用 <code>volatile</code> 来控制线程的停止与启动。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileFlagExample</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread worker = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                <span class="hljs-comment">// 执行任务</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Worker 线程停止。&quot;</span>);<br>        &#125;);<br>        worker.start();<br><br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        running = <span class="hljs-keyword">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;主线程设置 running 为 false。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码解析</strong>：</p><ol><li>定义静态变量 <code>running</code>，作为 <code>worker</code> 线程的运行条件。</li><li>主线程睡眠 3 秒后，将 <code>worker</code> 线程的运行条件 <code>running</code> 置为 <code>false</code>。</li><li>由于 <code>running</code> 使用了 <code>volatile</code> 修饰，保证了可见性，所以 <code>worker</code> 线程的读操作会从主内存中读取到最新的值。</li></ol><h4 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h4><p><code>volatile</code> 关键字在双重检查锁定（<code>Double-Checked Locking</code>）模式中至关重要，确保实例在初始化时的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码解析</strong>：</p><ol><li>定义静态变量 <code>instance</code>。</li><li>私有化 <code>Singleton</code> 类的构造器。</li><li>第一次检查 <code>instance == null</code>，判断是否已有实例，有则返回，同时避免每次都进入同步块。</li><li><code>synchronized</code> 代码块确保在多线程环境下只有一个线程可以执行实例的创建逻辑。</li><li>第二次检查 <code>instance == null</code>，判断其他线程未创建实例（通过 <code>volatile</code> 保证线程之间的可见性）。</li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>volatile</th><th>synchronized</th></tr></thead><tbody><tr><td><strong>可见性</strong></td><td>保证</td><td>锁机制保证</td></tr><tr><td><strong>原子性</strong></td><td>不保证</td><td>可保证</td></tr><tr><td><strong>性能</strong></td><td>轻量，开销小</td><td>涉及锁，开销大</td></tr><tr><td><strong>适用场景</strong></td><td>状态标志位和单一变量的简单同步</td><td>对多个变量或复杂操作进行原子性同步</td></tr></tbody></table><h2 id="3种关键特性保证"><a href="#3种关键特性保证" class="headerlink" title="3种关键特性保证"></a>3种关键特性保证</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><ul><li><strong>synchronized</strong>：同步机制保证了在同一时间只有一个线程能够执行同步块中的代码，从而保证了操作的原子性。</li></ul><h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><ul><li><strong>volatile</strong>：对 <code>volatile</code> 变量的写操作会立即对其他线程可见。<code>volatile</code> 变量的读取总是从主内存中获取，而不是从线程的本地缓存中获取，写操作会直接写回到主内存，保证了修改的及时可见性。</li><li><strong>synchronized</strong>：当一个线程获取了锁并修改了共享变量，其他线程在释放锁之前无法读取该变量，从而确保了变量对其他线程的可见性。</li><li><strong>final</strong>：对于 <code>final</code> 修饰的变量，特别是对象的引用，保证了构造完成后它们的可见性。<code>final</code> 变量的初始化具有特别的内存访问语义，确保了它在构造函数完成后，对其他线程可见。</li></ul><h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><ul><li><p><strong>volatile</strong>：<code>volatile</code> 关键字禁止特定类型的指令重排序，确保变量的读写操作按照代码的顺序执行。</p></li><li><p><strong>synchronized</strong>：<code>synchronized</code> 语句中的操作会在锁的获取和释放时加上内存屏障，保证同步块中的代码按顺序执行。</p></li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在 Java 内存模型中，<code>happens-before</code> 是用来描述操作之间的执行顺序的一种规则。它是为了保证多线程环境中操作的有序性，并确保正确的可见性和同步。具体来说，<code>happens-before</code> 原则表示在一个线程中的某个操作（例如变量的写入）与另一个线程中的某个操作（例如变量的读取）之间有一个明确的先后关系，前者“发生在”后者之前。</p><ul><li><strong>如果操作A happens-before 操作B</strong>，则可以确保操作A对其他线程的可见性以及操作B在执行时的正确性。简单来说，操作A的结果会在操作B之前对其他线程可见。</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><h4 id="1-程序顺序规则（Program-Order-Rule）"><a href="#1-程序顺序规则（Program-Order-Rule）" class="headerlink" title="1. 程序顺序规则（Program Order Rule）"></a>1. 程序顺序规则（Program Order Rule）</h4><ul><li>在单个线程内，代码执行顺序是线性的，即一个操作在另一个操作之前发生。</li><li><strong>举例</strong>：在同一线程内，如果你执行 <code>a = 1; b = 2;</code>，那么 <code>a = 1</code> 发生在 <code>b = 2</code> 之前。</li></ul><h4 id="2-监视器锁规则（Monitor-Lock-Rule）"><a href="#2-监视器锁规则（Monitor-Lock-Rule）" class="headerlink" title="2. 监视器锁规则（Monitor Lock Rule）"></a>2. <strong>监视器锁规则（Monitor Lock Rule）</strong></h4><ul><li>一个线程释放的锁 <code>happens-before</code> 另一个线程获取该锁。</li><li><strong>举例</strong>：如果线程A执行 <code>lock.lock()</code> 获取锁，并且线程B执行 <code>lock.lock()</code> 获取同一个锁，则线程A释放锁的操作发生在线程B获取锁的操作之前。</li></ul><h4 id="3-volatile-变量规则（Volatile-Variable-Rule）"><a href="#3-volatile-变量规则（Volatile-Variable-Rule）" class="headerlink" title="3. volatile 变量规则（Volatile Variable Rule）"></a>3. <strong>volatile 变量规则（Volatile Variable Rule）</strong></h4><ul><li>对 <code>volatile</code> 变量的写操作 <code>happens-before</code> 任何后续对该变量的读操作。</li><li><strong>举例</strong>：如果线程A将 <code>volatile</code> 变量 <code>x</code> 设置为 <code>true</code>，那么在线程B读取 <code>x</code> 时，线程B能看到线程A的最新值。</li></ul><h4 id="4-传递性规则（Transitivity-Rule）"><a href="#4-传递性规则（Transitivity-Rule）" class="headerlink" title="4. 传递性规则（Transitivity Rule）"></a>4. <strong>传递性规则（Transitivity Rule）</strong></h4><ul><li>如果 <code>A happens-before B</code>，且 <code>B happens-before C</code>，则 <code>A happens-before C</code>。</li><li><strong>举例</strong>：如果 <code>a = 1</code> happens-before <code>b = 2</code>，并且 <code>b = 2</code> happens-before <code>c = 3</code>，则 <code>a = 1</code> happens-before <code>c = 3</code>。</li></ul><h4 id="5-线程启动规则（Thread-Start-Rule）"><a href="#5-线程启动规则（Thread-Start-Rule）" class="headerlink" title="5. 线程启动规则（Thread Start Rule）"></a>5. <strong>线程启动规则（Thread Start Rule）</strong></h4><ul><li>线程的 <code>start()</code> 操作 <code>happens-before</code> 线程中的任何后续操作。</li><li><strong>举例</strong>：如果线程A调用 <code>threadB.start()</code> 启动线程B，那么线程A在 <code>start()</code> 之后的操作会 <code>happens-before</code> 线程B中的操作。</li></ul><h4 id="6-线程中断规则（Thread-Interrupt-Rule）"><a href="#6-线程中断规则（Thread-Interrupt-Rule）" class="headerlink" title="6. 线程中断规则（Thread Interrupt Rule）"></a>6. <strong>线程中断规则（Thread Interrupt Rule）</strong></h4><ul><li>对线程的中断操作 <code>happens-before</code> 线程检测到中断的操作。</li><li><strong>举例</strong>：如果线程A执行 <code>threadB.interrupt()</code> 中断线程B，那么线程B中的 <code>InterruptedException</code> 或 <code>Thread.interrupted()</code> 操作会在 <code>interrupt()</code> 操作之后发生。</li></ul><h4 id="7-线程结束规则（Thread-Join-Rule）"><a href="#7-线程结束规则（Thread-Join-Rule）" class="headerlink" title="7. 线程结束规则（Thread Join Rule）"></a>7. <strong>线程结束规则（Thread Join Rule）</strong></h4><ul><li>线程的 <code>join()</code> 操作 <code>happens-before</code> 线程结束的任何后续操作。</li><li><strong>举例</strong>：如果线程A调用 <code>threadB.join()</code> 等待线程B执行完成，那么线程B的结束会 <code>happens-before</code> 线程A接下来执行的操作。</li></ul><h4 id="8-写-读规则（Write-Read-Rule）"><a href="#8-写-读规则（Write-Read-Rule）" class="headerlink" title="8. 写-读规则（Write-Read Rule）"></a>8. <strong>写-读规则（Write-Read Rule）</strong></h4><ul><li>对一个变量的写操作 <code>happens-before</code> 对同一个变量的后续读操作，如果写和读操作之间有同步机制（如 <code>synchronized</code> 或 <code>volatile</code>）。</li><li><strong>举例</strong>：线程A对 <code>volatile</code> 变量 <code>x</code> 写入值后，线程B读取 <code>x</code> 时，线程B一定能看到线程A的最新写入值。</li></ul><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><ul><li><strong>保证线程间的可见性</strong>： 在多线程程序中，线程可能会在自己的工作内存中缓存变量，导致一个线程对变量的修改对另一个线程不可见。<code>happens-before</code> 的原则保证了某些操作的可见性，避免了线程之间的数据不一致。</li><li><strong>避免数据竞争和竞态条件</strong>： <code>happens-before</code> 确保线程间操作的顺序性和同步，避免了由于不确定的操作顺序而产生的数据竞争问题。</li><li><strong>保证程序的正确性</strong>： 通过 <code>happens-before</code> 规则，JMM确保了在并发执行时，不同线程之间的执行顺序是正确的，从而避免了执行结果不一致的问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 内存模型是并发编程的基础，它将复杂的 CPU 缓存、编译器优化和指令重排序等底层细节，抽象出可见性、原子性和有序性等关键问题，并以 <code>happens-before</code> 规则给予统一的解决方案。通过为共享变量加上 <code>volatile</code> 关键字，可以确保线程间的可见性，部分禁止指令重排序，但无法满足复杂场景对原子性的需求；而像 <code>synchronized</code> 或其它锁机制则进一步强化了原子性，但也带来了更高的性能开销。在实际开发中，需要结合程序对并发程度、性能和安全的要求，来选择合适的同步手段。理解好 <code>JMM</code>，以及如何合理利用 <code>volatile</code> 与 <code>happens-before</code> 规则，将是写出高质量并发程序的关键。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>Java内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——管程Monitor</title>
    <link href="/2021/08/05/javase-cp-monitor/"/>
    <url>/2021/08/05/javase-cp-monitor/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>并发编程的本质是如何安全、高效地管理多个线程对共享资源的访问，而管程切好能够帮助我们在多线程环境中实现对共享资源的互斥访问与条件同步。Java 语言内建了管程机制，通过关键字 <code>synchronized</code> 以及 <code>wait()</code> / <code>notify()</code> 等方法，让开发者能够自然地在代码层面封装共享数据的访问方式、保护临界区，降低并发编程的复杂度。本篇文章将基于管程这一概念，深入探讨其在 JVM 层级的实现细节与常见应用场景，同时结合示例剖析多线程间的经典问题及应对思路。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>管程（Monitor）是一种高级并发控制机制，用于管理多个线程对共享资源的访问，保证线程之间的同步，避免数据竞争和状态不一致问题。Java语言通过内置锁和 <code>Object</code> 类的方法（如 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>）实现了管程的机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>简化同步问题</strong>：管程封装了对共享资源的访问，使得线程之间的协调变得更加简单。使用 <code>synchronized</code> 或其他同步机制时，开发者无需显式地管理锁和线程的状态。</li><li><strong>自动互斥</strong>：管程自动处理线程间的互斥，确保同一时刻只有一个线程可以执行管程内的方法，从而避免了竞态条件。</li><li><strong>线程协调</strong>：管程通过条件变量（如 <code>wait()</code>、<code>notify()</code> 等）提供了线程间的协调机制，生产者和消费者等模式能够更加自然地实现。</li><li><strong>高层次抽象</strong>：管程提供了对共享资源和同步机制的高层次抽象，开发者只需关注如何定义和操作共享资源，不需要关注底层的锁管理。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能开销</strong>：由于管程的锁和同步机制，每次进入管程时都需要获取锁，操作完成后释放锁。这会带来一定的性能开销，尤其是当管程内的操作较为频繁时，性能可能受到影响。</li><li><strong>缺乏灵活性</strong>：管程的实现较为抽象和封闭，可能不适用于所有场景。在一些复杂的并发控制情况下，可能需要更灵活的机制，如显式的锁（<code>ReentrantLock</code>）或其他并发控制策略。</li><li><strong>容易出现假唤醒</strong>：在使用条件变量时，如果没有正确地检查条件，可能会遇到假唤醒的问题，导致线程被错误地唤醒并继续执行。这需要额外的逻辑判断来防止此类问题。</li><li><strong>死锁风险</strong>：如果管程设计不当，仍然可能导致死锁问题，尤其是当多个管程或多个锁的资源互相依赖时。</li><li><strong>复杂性管理</strong>：对于一些复杂的多线程任务，使用管程可能导致程序的可维护性和可理解性下降。尤其是在多个管程相互协作时，代码可能变得难以调试和扩展。</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>锁的获取</strong>：当一个线程需要进入管程执行某些操作时，它首先需要获取该管程的锁。锁的获取是排他性的，这意味着同一时刻只有一个线程能够获得该锁并进入管程。</li><li><strong>条件判断和等待</strong>：如果该线程进入管程后发现某个条件不满足（例如，生产者发现缓冲区已满，消费者发现缓冲区为空），它就会调用 <code>wait()</code> 进入等待队列，直到条件满足。</li><li><strong>唤醒其他线程</strong>：当其他线程修改了共享资源的状态，可能会唤醒等待队列中的某些线程（调用 <code>notify()</code> 或 <code>notifyAll()</code>）。这些线程会重新竞争管程的锁，并继续执行。</li><li><strong>退出和释放锁</strong>：当线程完成了它在管程中的工作后，它会释放锁，使得其他线程可以进入管程。释放锁后，线程会从管程退出。</li></ol><p>以“生产者-消费者模型”对管程的工作流程展开说明：</p><pre><code class=" mermaid">sequenceDiagram    participant P as 生产者    participant C as 消费者    participant B as 缓冲区（管程）    %% 生产者执行过程    P-&gt;&gt;B: 调用 produce(item)    B-&gt;&gt;B: 检查缓冲区是否已满    alt 缓冲区满        B-&gt;&gt;P: 调用 wait() 等待    end    B-&gt;&gt;B: 将 item 添加到缓冲区    B-&gt;&gt;C: 调用 notifyAll() 通知消费者    P-&gt;&gt;P: 返回    %% 消费者执行过程    C-&gt;&gt;B: 调用 consume()    B-&gt;&gt;B: 检查缓冲区是否为空    alt 缓冲区空        B-&gt;&gt;C: 调用 wait() 等待    end    B-&gt;&gt;B: 从缓冲区取出 item    B-&gt;&gt;P: 调用 notifyAll() 通知生产者    C-&gt;&gt;C: 返回</code></pre><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>管程的基本原理可以从以下几个方面进行理解：</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li><strong>互斥锁</strong>：确保同一时刻只有一个线程可以访问共享资源。</li><li><strong>条件变量</strong>：用于线程之间的通信和协作，允许线程在特定条件下进入等待状态或被唤醒。</li><li><strong>同步队列</strong>：线程在等待条件变量时会被加入到一个同步队列中，唤醒时会从队列中取出线程。</li></ul><h3 id="JVM-层级"><a href="#JVM-层级" class="headerlink" title="JVM 层级"></a>JVM 层级</h3><h4 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h4><p>Java 对象在内存中的布局包括对象头、实例数据和对齐填充。对象头中的 <code>Mark Word</code> 存储了锁的信息，包括：</p><ul><li><strong>偏向锁</strong>：记录线程 ID、偏向时间等。</li><li><strong>轻量级锁</strong>：记录锁记录指针（Lock Record）。</li><li><strong>重量级锁</strong>：记录指向 <code>Monitor</code> 对象的指针。</li></ul><p>这也就意味着每个 Java 对象在 JVM 中都具备 <code>Monitor</code> 锁机制。</p><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><ul><li><code>Monitor</code> 依赖于底层的操作系统互斥量实现。</li><li>每个线程请求锁时会尝试进入 <code>Monitor</code>，如果失败，则会进入等待队列。</li></ul><h4 id="对象监视器锁"><a href="#对象监视器锁" class="headerlink" title="对象监视器锁"></a>对象监视器锁</h4><p><code>synchronized</code> 的底层实现依赖于 <code>Monitor</code>，而 <code>Monitor</code> 依托于对象头中的 <code>Mark Word</code> 实现。</p><ul><li>每个对象都对应一个监视器锁，当线程试图访问被 <code>synchronized</code> 修饰的代码块时，需要先获得对象的监视器锁。</li><li>获得锁的线程可以执行同步代码，而其他线程会进入阻塞或等待队列。</li><li>当锁被释放时，其他等待的线程会竞争锁，并根据一定策略（如线程优先级）重新获得执行权。</li></ul><h4 id="虚拟机指令"><a href="#虚拟机指令" class="headerlink" title="虚拟机指令"></a>虚拟机指令</h4><p><code>synchronized</code> 关键字在 Java 字节码中会被编译为以下指令：</p><ol><li><code>monitorenter</code>：<ul><li>用于尝试获取对象的监视器锁。</li><li>进入同步代码块时执行。</li></ul></li><li><code>monitorexit</code>：<ul><li>用于释放对象的监视器锁。</li><li>退出同步代码块时执行。</li></ul></li></ol><p><strong>字节码示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello synchronized&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译后的字节码：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">0: aload_0         // 加载当前对象引用</span><br><span class="hljs-section">1: dup</span><br><span class="hljs-section">2: monitorenter    // 尝试获取监视器锁</span><br><span class="hljs-section">3: getstatic       // 获取 System.out</span><br><span class="hljs-section">6: ldc             // 加载字符串 &quot;Hello synchronized&quot;</span><br><span class="hljs-section">8: invokevirtual   // 调用 println 方法</span><br><span class="hljs-section">11: aload_0        // 加载当前对象引用</span><br><span class="hljs-section">12: monitorexit    // 释放监视器锁</span><br><span class="hljs-section">13: goto 21        // 跳转到结束</span><br><span class="hljs-section">16: astore_1       // 捕获异常</span><br><span class="hljs-section">17: aload_0        // 加载当前对象引用</span><br><span class="hljs-section">18: monitorexit    // 释放监视器锁（异常处理）</span><br><span class="hljs-section">19: aload_1        // 抛出异常</span><br><span class="hljs-section">20: athrow</span><br></code></pre></div></td></tr></table></figure><h4 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h4><p><code>synchronized</code> 锁的状态主要有以下几种，随着锁的竞争激烈程度逐步升级：</p><ol><li><strong>无锁（No Lock）</strong>:<ul><li>没有竞争时，线程直接执行。</li><li>适用于单线程场景。</li></ul></li><li><strong>偏向锁（Biased Locking）</strong>:<ul><li>锁被偏向于第一个获得它的线程。</li><li>后续该线程再次获取锁时，无需加锁解锁操作。</li><li>偏向锁适用于锁竞争极低的场景，提升性能。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）</strong>:<ul><li>通过 <code>CAS（Compare-And-Swap）</code> 操作尝试加锁。</li><li>适用于有少量竞争的场景，减少上下文切换开销。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）</strong>:<ul><li>线程竞争激烈时，升级为重量级锁，线程被阻塞，进入操作系统的调度机制。</li><li>适用于高竞争场景，但开销较大。</li></ul></li></ol><h4 id="锁优化机制"><a href="#锁优化机制" class="headerlink" title="锁优化机制"></a>锁优化机制</h4><p>为了提升锁的性能，JVM 实现了多种优化机制：</p><ul><li><strong>锁消除</strong>：在 <code>JIT</code> 编译时，如果发现某段代码中的锁是线程不可能共享的，会直接消除该锁。</li><li><strong>锁膨胀</strong>：当轻量级锁竞争激烈时，会膨胀为重量级锁。</li><li><strong>锁偏向撤销</strong>：如果偏向锁的线程发生变化，会撤销偏向锁并升级为轻量级锁。</li><li><strong>自适应自旋锁</strong>：在锁竞争时，线程会进行一定次数的自旋操作，避免频繁上下文切换。</li></ul><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>管程的核心特点之一是互斥，即每次只有一个线程能够进入管程执行代码。这是通过给管程中的操作加锁来实现的。在 Java 中，<code>synchronized</code> 关键字或者 <code>ReentrantLock</code> 都可以用于实现互斥访问。每个管程都只有一个锁（也可以理解为一个监视器），同一时刻只有一个线程能够持有这个锁，其他线程必须等待。</p><ul><li>在 Java 中，类的 <code>synchronized</code> 方法或同步块（<code>synchronized block</code>）都隐式地使用了这个锁。</li><li>该锁保护了管程内的共享资源，防止多个线程同时访问这些资源，避免了竞态条件的发生。</li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>除了互斥，管程还使用条件变量来控制线程的执行顺序。当某个线程需要等待某些条件成立时，它可以将自己挂起，并在条件成立时被唤醒。条件变量通常包括 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法（在 Java 中是 <code>Object</code> 类的方法），用于实现线程之间的协作和通信。</p><ul><li><code>wait()</code>：使当前线程进入等待队列，直到被唤醒。</li><li><code>notify()</code>：唤醒一个等待队列中的线程。</li><li><code>notifyAll()</code>：唤醒所有等待队列中的线程。</li></ul><p>通过条件变量，线程可以在满足某些条件时再继续执行，从而避免了不必要的资源竞争。</p><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><p>管程的访问通常是通过特定的方法（称为“入口”）来进行的。每次线程访问管程时，都需要通过这些方法来进入，线程在进入管程之前必须获得锁。在完成操作后，线程可以通过“出口”释放锁，使得其他线程可以进入管程。</p><p>每个管程可以包含多个“入口”方法（例如，增加、减少、检查状态等），但同一时刻只有一个线程能执行这些方法。</p><h3 id="管程的封装"><a href="#管程的封装" class="headerlink" title="管程的封装"></a>管程的封装</h3><p>管程通过封装来隐藏共享资源的细节和同步机制，确保外部线程无法直接访问共享数据。所有对共享资源的操作都必须通过管程提供的方法来进行，从而保证了资源的一致性和线程安全。</p><p>在 Java 中，这通常通过将共享资源和对其操作的实现封装在类内部，避免外部代码直接修改。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="互斥访问"><a href="#互斥访问" class="headerlink" title="互斥访问"></a>互斥访问</h3><p>管程提供了一种机制，确保同一时刻只有一个线程可以访问共享资源，从而实现线程间的互斥。</p><ul><li><strong>数据库连接池管理</strong>：管理数据库连接，确保连接创建、使用和回收的互斥。</li><li><strong>文件系统操作</strong>：在操作系统中，文件的读写需要互斥控制，防止数据损坏。</li><li><strong>硬件设备管理</strong>：控制对打印机、扫描仪等共享硬件的访问，确保操作不会相互干扰。</li></ul><h3 id="条件同步"><a href="#条件同步" class="headerlink" title="条件同步"></a>条件同步</h3><p>管程可以基于条件变量控制线程的执行顺序，允许线程在特定条件下等待或被唤醒。</p><ul><li><strong>生产者-消费者问题</strong>：同步生产者和消费者线程，确保消费者在有产品可消费时才运行。</li><li><strong>任务调度系统</strong>：在任务依赖特定条件（如时间、资源可用性）时启动。</li><li><strong>事件驱动系统</strong>：如 GUI 应用，等待用户操作事件。</li></ul><h3 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h3><p>管程使多个线程能够安全地共享资源，如数据结构、内存等。</p><ul><li><strong>内存管理系统</strong>：操作系统中的内存分配与回收。</li><li><strong>有界队列（Bounded Queue）</strong>：多线程环境中用于任务或消息传递的队列。</li><li><strong>缓冲区管理</strong>：如多媒体应用中的音视频数据缓冲。</li></ul><h3 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3><p>管程支持线程间的协作，使得多个线程可以按照某种逻辑顺序执行，相互之间通过管程进行通信。</p><ul><li><strong>读写锁实现</strong>：允许多个读线程同时访问资源，写线程独占访问。</li><li><strong>信号量管理</strong>：使用管程来实现信号量的功能，控制对某些资源的并发访问数量。</li><li><strong>多线程游戏</strong>：比如在线游戏中，同步多个玩家的动作。</li></ul><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>“生产者-消费者模型”是多线程同步中的经典应用，涉及两个类型的线程：</p><ul><li><strong>生产者（Producer）</strong>：生成数据并将其放入共享缓冲区。</li><li><strong>消费者（Consumer）</strong>：从共享缓冲区中取出数据并进行处理。</li></ul><p>目标是确保生产者和消费者在访问共享缓冲区时不会发生数据竞争，避免缓冲区溢出或空缺。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><strong>互斥访问</strong>：通过 <code>synchronized</code> 关键字确保同一时刻只有一个线程访问缓冲区。</li><li><strong>条件同步</strong>：使用 <code>wait()</code> 和 <code>notifyAll()</code> 方法协调生产者和消费者的等待与唤醒。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; buffer = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 生产者方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (buffer) &#123;<br>            <span class="hljs-comment">// 当缓冲区满时，生产者等待</span><br>            <span class="hljs-keyword">while</span> (buffer.size() == capacity) &#123;<br>                buffer.wait();<br>            &#125;<br>            buffer.add(value);<br>            System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + value);<br>            <span class="hljs-comment">// 唤醒所有等待的线程（消费者）</span><br>            buffer.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 消费者方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (buffer) &#123;<br>            <span class="hljs-comment">// 当缓冲区为空时，消费者等待</span><br>            <span class="hljs-keyword">while</span> (buffer.isEmpty()) &#123;<br>                buffer.wait();<br>            &#125;<br>            <span class="hljs-keyword">int</span> value = buffer.poll();<br>            System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + value);<br>            <span class="hljs-comment">// 唤醒所有等待的线程（生产者）</span><br>            buffer.notifyAll();<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ProducerConsumerExample pc = <span class="hljs-keyword">new</span> ProducerConsumerExample();<br><br>        <span class="hljs-comment">// 生产者线程</span><br>        Thread producer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    pc.produce(i);<br>                    <span class="hljs-comment">// 模拟生产时间</span><br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    pc.consume();<br>                    <span class="hljs-comment">// 模拟消费时间</span><br>                    Thread.sleep(<span class="hljs-number">150</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br><br>        producer.join();<br>        consumer.join();<br><br>        System.out.println(<span class="hljs-string">&quot;Final buffer size: &quot;</span> + pc.buffer.size());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><strong>共享缓冲区</strong>：使用 <code>Queue&lt;Integer&gt;</code> 作为生产者和消费者共享的缓冲区，容量为5。</li><li>**生产者方法 (<code>produce</code>)**：<ul><li>使用 <code>synchronized</code> 块锁定缓冲区对象，确保互斥访问。</li><li>当缓冲区满时，调用 <code>buffer.wait()</code> 使生产者线程进入等待状态。</li><li>生产一个值后，将其添加到缓冲区，并调用 <code>buffer.notifyAll()</code> 唤醒所有等待的线程（主要是消费者）。</li></ul></li><li>**消费者方法 (<code>consume</code>)**：<ul><li>同样使用 <code>synchronized</code> 块锁定缓冲区对象。</li><li>当缓冲区为空时，调用 <code>buffer.wait()</code> 使消费者线程进入等待状态。</li><li>消费一个值后，从缓冲区中取出，并调用 <code>buffer.notifyAll()</code> 唤醒所有等待的线程（主要是生产者）。</li></ul></li><li><strong>主方法</strong>：<ul><li>创建并启动生产者和消费者线程。</li><li>使用 <code>join()</code> 确保主线程等待子线程完成。</li><li>最终打印缓冲区的大小，理想情况下应为0。</li></ul></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>**使用 <code>while</code> 而非 <code>if</code>**：在等待条件时，应该使用 <code>while</code> 循环检查条件，以防止虚假唤醒（Spurious Wakeup）。</li><li><strong>同步块的锁对象</strong>：在此示例中，锁对象为缓冲区 <code>buffer</code>。选择合适的锁对象对于同步至关重要。</li><li><strong>避免过度唤醒</strong>：尽量使用 <code>notify()</code> 而非 <code>notifyAll()</code>，除非确实需要唤醒所有等待线程，以提高性能。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>线程池（Thread Pool）是一种管理和复用多个线程的机制，旨在减少创建和销毁线程的开销，提高系统性能和资源利用率。Java通过 <code>java.util.concurrent</code> 包提供了强大的线程池实现，但在自定义线程池时，也可以使用管程机制来管理线程和任务队列。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li><strong>任务队列的管理</strong>：生产者（任务提交者）向任务队列添加任务，消费者（线程池中的工作线程）从任务队列中获取并执行任务。</li><li><strong>线程的同步与协调</strong>：确保任务队列的线程安全，控制任务的添加和获取，管理线程的等待与唤醒。</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPool</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WorkerThread[] workers;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        workers = <span class="hljs-keyword">new</span> WorkerThread[poolSize];<br>        <span class="hljs-comment">// 初始化并启动工作线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            workers[i] = <span class="hljs-keyword">new</span> WorkerThread(<span class="hljs-string">&quot;Worker-&quot;</span> + i);<br>            workers[i].start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提交任务到线程池</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task 任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (taskQueue) &#123;<br>            taskQueue.add(task);<br>            <span class="hljs-comment">// 唤醒等待的工作线程</span><br>            taskQueue.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (WorkerThread worker : workers) &#123;<br>            worker.interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 工作线程内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkerThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Runnable task;<br><br>            <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>                <span class="hljs-keyword">synchronized</span> (taskQueue) &#123;<br>                    <span class="hljs-keyword">while</span> (taskQueue.isEmpty()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 等待任务</span><br>                            taskQueue.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-comment">// 接收到中断信号，退出线程</span><br>                            Thread.currentThread().interrupt();<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 获取任务</span><br>                    task = taskQueue.poll();<br>                &#125;<br><br>                <span class="hljs-comment">// 执行任务</span><br>                <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; executing task.&quot;</span>);<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                        <span class="hljs-comment">// 捕获并处理任务执行中的异常</span><br>                        System.err.println(<span class="hljs-string">&quot;Task execution failed: &quot;</span> + e.getMessage());<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; shutting down.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTestClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        SimpleThreadPool threadPool = <span class="hljs-keyword">new</span> SimpleThreadPool(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 提交10个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> taskId = i;<br>            threadPool.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟任务执行时间</span><br>                    System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + taskId + <span class="hljs-string">&quot; completed.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有任务完成</span><br>        Thread.sleep(<span class="hljs-number">6000</span>);<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><strong>任务队列</strong>：使用 <code>Queue&lt;Runnable&gt;</code> 作为任务队列，存储待执行的任务。</li><li><strong>工作线程</strong>：<code>WorkerThread</code> 类继承自 <code>Thread</code>，负责从任务队列中获取任务并执行。</li><li>**提交任务 (<code>submit</code>)**：<ul><li>使用 <code>synchronized</code> 块锁定任务队列，确保线程安全地添加任务。</li><li>调用 <code>taskQueue.notify()</code> 唤醒等待的工作线程。</li></ul></li><li>**工作线程运行 (<code>run</code>)**：<ul><li>使用 <code>synchronized</code> 块锁定任务队列。</li><li>当任务队列为空时，调用 <code>taskQueue.wait()</code> 使线程进入等待状态。</li><li>当有任务时，从队列中取出任务并执行。</li><li>捕获并处理任务执行中的异常，避免工作线程因异常终止。</li></ul></li><li>**关闭线程池 (<code>shutdown</code>)**：<ul><li>调用工作线程的 <code>interrupt()</code> 方法，发送中断信号，促使工作线程退出循环并终止。</li></ul></li><li><strong>主方法</strong>：<ul><li>创建一个拥有3个工作线程的线程池。</li><li>提交10个模拟任务，每个任务睡眠500毫秒后打印完成信息。</li><li>主线程等待6秒以确保所有任务完成，然后关闭线程池。</li></ul></li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>任务队列的同步</strong>：所有对任务队列的访问必须在 <code>synchronized</code> 块内进行，确保线程安全。</li><li><strong>工作线程的中断处理</strong>：在工作线程中捕获 <code>InterruptedException</code>，并正确响应中断信号以优雅地终止线程。</li><li><strong>避免死锁</strong>：确保锁的获取顺序一致，避免多个锁的嵌套使用导致死锁。</li><li><strong>任务异常处理</strong>：在工作线程中捕获任务执行中的异常，防止异常导致线程终止。</li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>读写锁（Read-Write Lock）是一种同步机制，允许多个线程同时读取共享资源，但在写入时必须排他。即：</p><ul><li><strong>读锁（Read Lock）</strong>：多个线程可以同时持有，只要没有线程持有写锁。</li><li><strong>写锁（Write Lock）</strong>：独占锁，只有一个线程可以持有，且期间不允许其他线程持有读锁或写锁。</li></ul><p>这种机制适用于读多写少的场景，能够提高并发性能。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><strong>维护读者和写者的计数</strong>：跟踪当前持有读锁和写锁的线程数。</li><li><strong>协调读写访问</strong>：确保写线程在没有读线程时才能写入，读线程在没有写线程时才能读取。</li><li><strong>避免饥饿</strong>：合理调度读者和写者，防止某一方长时间等待。</li></ul><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> readers = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> writers = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> writeRequests = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取读锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">while</span> (writers &gt; <span class="hljs-number">0</span> || writeRequests &gt; <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        readers++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放读锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockRead</span><span class="hljs-params">()</span> </span>&#123;<br>        readers--;<br>        notifyAll();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        writeRequests++;<br>        <span class="hljs-keyword">while</span> (readers &gt; <span class="hljs-number">0</span> || writers &gt; <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        writeRequests--;<br>        writers++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放写锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockWrite</span><span class="hljs-params">()</span> </span>&#123;<br>        writers--;<br>        notifyAll();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReadWriteLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sharedData = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 读操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        rwLock.lockRead();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟读操作时间</span><br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; read data: &quot;</span> + sharedData);<br>            <span class="hljs-keyword">return</span> sharedData;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwLock.unlockRead();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 写操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        rwLock.lockWrite();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟写操作时间</span><br>            Thread.sleep(<span class="hljs-number">150</span>);<br>            sharedData = value;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; wrote data: &quot;</span> + sharedData);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwLock.unlockWrite();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReadWriteLockExample example = <span class="hljs-keyword">new</span> ReadWriteLockExample();<br><br>        <span class="hljs-comment">// 读者线程</span><br>        Runnable reader = () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    example.readData();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 写者线程</span><br>        Runnable writer = () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>                    example.writeData(i * <span class="hljs-number">10</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 启动多个读者和写者线程</span><br>        Thread writerThread = <span class="hljs-keyword">new</span> Thread(writer, <span class="hljs-string">&quot;Writer-1&quot;</span>);<br>        Thread readerThread1 = <span class="hljs-keyword">new</span> Thread(reader, <span class="hljs-string">&quot;Reader-1&quot;</span>);<br>        Thread readerThread2 = <span class="hljs-keyword">new</span> Thread(reader, <span class="hljs-string">&quot;Reader-2&quot;</span>);<br><br>        writerThread.start();<br>        readerThread1.start();<br>        readerThread2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            writerThread.join();<br>            readerThread1.join();<br>            readerThread2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Final shared data: &quot;</span> + example.sharedData);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码解析-2"><a href="#代码解析-2" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li>**读写锁 (<code>ReadWriteLock</code> 类)**：<ul><li><strong>变量</strong>：<ul><li><strong>readers</strong>：当前持有读锁的线程数。</li><li><strong>writers</strong>：当前持有写锁的线程数（0或1）。</li><li><strong>writeRequests</strong>：等待获取写锁的线程数。</li></ul></li><li><strong>方法</strong>：<ul><li>**lockRead()**：获取读锁。若有写线程持有锁或有写线程等待，则读线程进入等待。</li><li>**unlockRead()**：释放读锁，并通知所有等待线程。</li><li>**lockWrite()**：获取写锁。增加写请求计数，若有读锁或写锁被持有，则写线程进入等待。</li><li>**unlockWrite()**：释放写锁，并通知所有等待线程。</li></ul></li></ul></li><li>**共享资源 (<code>sharedData</code>)**：一个整型变量，由多个读者线程读取和写者线程修改。</li><li>**读者方法 (<code>readData</code>)**：<ul><li>调用 <code>rwLock.lockRead()</code> 获取读锁。</li><li>读取 <code>sharedData</code> 并打印。</li><li>调用 <code>rwLock.unlockRead()</code> 释放读锁。</li></ul></li><li>**写者方法 (<code>writeData</code>)**：<ul><li>调用 <code>rwLock.lockWrite()</code> 获取写锁。</li><li>修改 <code>sharedData</code> 并打印。</li><li>调用 <code>rwLock.unlockWrite()</code> 释放写锁。</li></ul></li><li><strong>主方法</strong>：<ul><li>创建并启动一个写者线程和两个读者线程。</li><li>使用 <code>join()</code> 确保主线程等待子线程完成。</li><li>最终打印共享数据的值。</li></ul></li></ol><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>公平性</strong>：上述实现未考虑公平性，即无法保证写线程不会长期被读线程饥饿。可通过引入队列或其他机制实现公平性。</li><li><strong>性能优化</strong>：使用 <code>java.util.concurrent.locks.ReentrantReadWriteLock</code> 提供了更高效和功能丰富的读写锁实现，建议在实际项目中优先使用标准库提供的锁。</li><li><strong>避免死锁</strong>：确保锁的获取和释放顺序一致，避免多锁嵌套引发死锁。</li><li><strong>锁的粒度</strong>：合理设计锁的范围，避免过度锁定导致性能瓶颈。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>死锁是指两个或多个线程由于互相等待对方持有的资源而陷入无限等待的状态，导致这些线程无法继续执行。死锁通常发生在以下四个必要条件同时满足时：</p><ol><li><strong>互斥条件（Mutual Exclusion）</strong>：至少有一个资源是非共享的，即同一时间只能被一个线程占用。</li><li><strong>持有并等待（Hold and Wait）</strong>：一个线程持有至少一个资源，并且正在等待获取其他被其他线程持有的资源。</li><li><strong>非抢占条件（No Preemption）</strong>：已经分配给线程的资源，不能被强行夺取，必须由线程自行释放。</li><li><strong>循环等待（Circular Wait）</strong>：存在一种线程等待资源的环形链，每个线程都在等待下一个线程持有的资源。</li></ol><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ol><li><p><strong>破坏互斥条件</strong>：尽量将资源设计为可共享的，允许多个线程同时访问。</p></li><li><p><strong>破坏持有并等待条件</strong>：要求线程在请求资源时，先释放它已持有的所有资源，或者一次性请求所有需要的资源。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 示例：一次性请求所有资源</span><br><span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>    <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>        <span class="hljs-comment">// 操作</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>破坏非抢占条件</strong>：如果线程已经持有某些资源且请求新的资源被拒绝，则强制释放当前持有的资源。虽然 Java 中无法直接强制抢占锁，但可以设计可抢占的资源管理策略。</p></li><li><p><strong>破坏循环等待条件</strong>：为所有资源按一定顺序编号，并要求线程按编号顺序请求资源，避免形成循环等待。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 资源按顺序编号</span><br><span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>    <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>        <span class="hljs-comment">// 操作</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>在 Java 中，死锁的检测可以借助 <code>ThreadMXBean</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadlockDetector</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadMXBean bean = ManagementFactory.getThreadMXBean();<br>        <span class="hljs-keyword">long</span>[] threadIds = bean.findDeadlockedThreads();<br>        <br>        <span class="hljs-keyword">if</span> (threadIds != <span class="hljs-keyword">null</span>) &#123;<br>            ThreadInfo[] infos = bean.getThreadInfo(threadIds);<br>            System.out.println(<span class="hljs-string">&quot;发现死锁线程：&quot;</span>);<br>            <span class="hljs-keyword">for</span> (ThreadInfo info : infos) &#123;<br>                System.out.println(info.getThreadName());<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;未发现死锁。&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭、思考。他们在吃东西的时候停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一只餐叉，这里哲学家必须用两只餐叉吃东西，且只能使用自己左右手边的那两只餐叉。</p><p>这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大。</p><p>问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。</p><p>可制定的规则如下：</p><ol><li><strong>资源分配的顺序策略</strong>：让编号为奇数的哲学家先拿起左边的叉子，再拿起右边的叉子。通过规定哲学家获取叉子的顺序，可以打破循环等待条件，从而避免死锁。</li><li><strong>限制同时就餐的哲学家数量</strong>：最多 N-1 个哲学家同时就餐（N 是哲学家的总数），确保至少有一只叉子是空闲的，避免所有哲学家同时拿起一只叉子而导致死锁。</li><li><strong>未能拿到两只叉子时释放已拿到的叉子</strong>：如果无法同时拿到两只叉子，就释放已拿到的叉子，即通过避免持有单只叉子而等待另一只叉子，打破了死锁的循环等待条件。</li><li><strong>使用仲裁者（Arbitrator）</strong>：引入一个仲裁者（如一个专门的管理线程）来管理叉子的分配，哲学家在需要叉子时，向仲裁者请求，当仲裁者认为可以安全分配时，才允许哲学家拿起叉子。</li></ol><h3 id="活锁（Livelock）"><a href="#活锁（Livelock）" class="headerlink" title="活锁（Livelock）"></a>活锁（Livelock）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>活锁是指两个或多个线程不断改变自身状态以响应彼此的动作，但实际上没有任何线程能够继续执行有用的工作。与死锁不同，活锁中的线程不会被永久阻塞，它们仍然处于活动状态，但无法完成任务。</p><h4 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h4><ol><li><p><strong>限制重试次数</strong>：为线程的重试操作设置最大次数，超过后放弃或采取其他措施。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> retries = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (retries &lt; MAX_RETRIES) &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquire()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    retries++;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>优先级调整</strong>：调整线程优先级，确保某些线程具有获取资源的优势。</p></li><li><p><strong>设计更好的协议</strong>：确保线程在资源获取时遵循一致的协议，避免无限循环的资源释放与重试。</p></li></ol><h3 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a><strong>检测</strong></h3><p>活锁的检测较为困难，因为线程仍然在运行，不像死锁那样完全停止。通常通过监控线程的状态和行为来识别活锁：</p><ol><li><strong>监控线程活动</strong>：监控线程的执行频率和状态，识别是否存在频繁的资源获取和释放。</li><li><strong>日志分析</strong>：通过日志记录线程的操作步骤，分析是否存在循环的资源操作。</li></ol><h3 id="饥饿（Starvation）"><a href="#饥饿（Starvation）" class="headerlink" title="饥饿（Starvation）"></a>饥饿（Starvation）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>饥饿是指某些线程长期无法获取所需资源，导致它们无法执行。这通常是由于其他高优先级线程持续占用资源，或由于资源分配策略不公平，某些线程得不到足够的执行机会。</p><h4 id="预防-2"><a href="#预防-2" class="headerlink" title="预防"></a>预防</h4><ol><li><p><strong>使用公平锁</strong>：采用公平锁（如 <code>ReentrantLock</code> 的公平性选项），确保锁的获取按照线程请求的顺序进行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 公平锁</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>合理设置线程优先级</strong>：避免过高或过低的线程优先级设置，确保所有线程都有合理的执行机会。</p></li><li><p><strong>避免长时间持有锁</strong>：尽量减少锁的持有时间，避免高优先级线程长时间占用资源。</p></li><li><p><strong>任务分配均衡</strong>：通过合理的任务分配策略，确保所有线程都能获得执行机会。</p></li></ol><h4 id="检测-2"><a href="#检测-2" class="headerlink" title="检测"></a>检测</h4><p>饥饿的检测通常依赖于监控系统的行为和性能指标：</p><ol><li><strong>线程执行时间监控</strong>：监控线程的执行时间，识别某些线程是否长时间处于等待状态。</li><li><strong>性能分析工具</strong>：使用性能分析工具（如 <code>Java VisualVM</code>、<code>JProfiler</code>）检测线程的状态和资源获取情况。</li><li><strong>日志和指标</strong>：通过日志记录和指标监控，识别线程的等待和执行模式，发现饥饿现象。</li></ol><h3 id="虚假唤醒（Spurious-Wakeup）"><a href="#虚假唤醒（Spurious-Wakeup）" class="headerlink" title="虚假唤醒（Spurious Wakeup）"></a>虚假唤醒（Spurious Wakeup）</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>虚假唤醒指的是线程在没有收到明确的通知（<code>notify()</code> 或 <code>notifyAll()</code>）情况下，被唤醒的现象。这可能导致线程在错误的时间继续执行，导致程序逻辑错误。</p><h4 id="预防-3"><a href="#预防-3" class="headerlink" title="预防"></a><strong>预防</strong></h4><p>使用循环检查条件：在调用 <code>wait() </code>  后，使用 <code>while</code> 循环检查条件，而不是 <code>if</code> 语句，确保线程在条件真正满足时才继续执行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!condition) &#123;<br>        lock.wait();<br>    &#125;<br>    <span class="hljs-comment">// 执行操作</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="线上死锁处理"><a href="#线上死锁处理" class="headerlink" title="线上死锁处理"></a>线上死锁处理</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="代码检测"><a href="#代码检测" class="headerlink" title="代码检测"></a>代码检测</h4><p>代码中添加检测死锁程序，检测到以后输出死锁位置：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockTestClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 检测死锁的线程</span><br>        Thread detector = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            ThreadMXBean bean = ManagementFactory.getThreadMXBean();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">long</span>[] deadlockedThreadIds = bean.findDeadlockedThreads();<br>                <span class="hljs-keyword">if</span> (deadlockedThreadIds != <span class="hljs-keyword">null</span>) &#123;<br>                    ThreadInfo[] infos = bean.getThreadInfo(deadlockedThreadIds);<br>                    System.out.println(<span class="hljs-string">&quot;检测到死锁线程:&quot;</span>);<br>                    <span class="hljs-keyword">for</span> (ThreadInfo info : infos) &#123;<br>                        System.out.println(info.getThreadId() + <span class="hljs-string">&quot; &quot;</span> + info.getThreadName() + <span class="hljs-string">&quot; &quot;</span> + info.getLockName() + <span class="hljs-string">&quot; &quot;</span> + info.getBlockedTime());<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 每5秒检测一次</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 设置为守护线程</span><br>        detector.setDaemon(<span class="hljs-keyword">true</span>);<br>        detector.start();<br><br>        <span class="hljs-comment">// 死锁代码</span><br>        Object lock1 = <span class="hljs-keyword">new</span> Object();<br>        Object lock2 = <span class="hljs-keyword">new</span> Object();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;t1持有lock1，尝试获取lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;t2持有lock2，尝试获取lock1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上代码运行后，会打印出死锁信息，如</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">检测到死锁线程:<br>22 Thread<span class="hljs-string">-2</span> java.lang.Object@6c1553f <span class="hljs-string">-1</span><br>21 Thread<span class="hljs-string">-1</span> java.lang.Object@806ab97 <span class="hljs-string">-1</span><br></code></pre></div></td></tr></table></figure><h4 id="软件检测"><a href="#软件检测" class="headerlink" title="软件检测"></a>软件检测</h4><p>使用 <code>Java VisualVM</code> 或 <code>JConsole</code> 连接 JVM 实例检测死锁。</p><p>如 <code>JConsole</code> 连接到 JVM 实例后，在线程页检测死锁：</p><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/jconsole-deadlock-detection.png" alt="JConsole-线程-死锁"></p><h4 id="分析堆栈跟踪"><a href="#分析堆栈跟踪" class="headerlink" title="分析堆栈跟踪"></a>分析堆栈跟踪</h4><p>先通过 <code>jps</code> 获取 Java 进程的 <code>PID</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">C:\Users\yangtao&gt;jps -l<br>25136 space.yangtao.monitor.deadlock.DeadLockTestClient<br>16164 org.jetbrains.jps.cmdline.Launcher<br>11352 sun.tools.jps.Jps<br>12728 com.intellij.idea.Main<br></code></pre></div></td></tr></table></figure><p>使用 <code>jstack</code> 生成线程堆栈跟踪并输出到指定的文件中</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">C:\Users\yangtao&gt;jstack 25136 &gt; t25136.txt<br></code></pre></div></td></tr></table></figure><p>在生成的文件中如果有如下死锁检测报告，则说明进程中含有死锁</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br>  waiting to <span class="hljs-keyword">lock</span> <span class="hljs-keyword">monitor</span> <span class="hljs-number">0x00000237f914ec08</span> (object <span class="hljs-number">0x000000066c17ca60</span>, a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object),<br>  which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br>  waiting to <span class="hljs-keyword">lock</span> <span class="hljs-keyword">monitor</span> <span class="hljs-number">0x00000237fcd6d108</span> (object <span class="hljs-number">0x000000066c17ca70</span>, a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object),<br>  which is held by <span class="hljs-string">&quot;Thread-1&quot;</span><br><br>Java stack information for the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br><span class="hljs-meta">at</span> space<span class="hljs-number">.</span>yangtao<span class="hljs-number">.</span><span class="hljs-keyword">monitor</span><span class="hljs-number">.</span>deadlock<span class="hljs-number">.</span>DeadLockTestClient<span class="hljs-number">.</span>lambda$main<span class="hljs-number">$1</span>(DeadLockTestClient<span class="hljs-number">.</span>java:<span class="hljs-number">64</span>)<br>- waiting to <span class="hljs-keyword">lock</span> &lt;<span class="hljs-number">0x000000066c17ca60</span>&gt; (a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object)<br>- locked &lt;<span class="hljs-number">0x000000066c17ca70</span>&gt; (a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object)<br><span class="hljs-meta">at</span> space<span class="hljs-number">.</span>yangtao<span class="hljs-number">.</span><span class="hljs-keyword">monitor</span><span class="hljs-number">.</span>deadlock<span class="hljs-number">.</span>DeadLockTestClient$$Lambda<span class="hljs-number">$2</span>/<span class="hljs-number">1480010240.</span>run(Unknown Source)<br><span class="hljs-meta">at</span> java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Thread<span class="hljs-number">.</span>run(Thread<span class="hljs-number">.</span>java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br><span class="hljs-meta">at</span> space<span class="hljs-number">.</span>yangtao<span class="hljs-number">.</span><span class="hljs-keyword">monitor</span><span class="hljs-number">.</span>deadlock<span class="hljs-number">.</span>DeadLockTestClient<span class="hljs-number">.</span>lambda$main<span class="hljs-number">$0</span>(DeadLockTestClient<span class="hljs-number">.</span>java:<span class="hljs-number">51</span>)<br>- waiting to <span class="hljs-keyword">lock</span> &lt;<span class="hljs-number">0x000000066c17ca70</span>&gt; (a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object)<br>- locked &lt;<span class="hljs-number">0x000000066c17ca60</span>&gt; (a java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Object)<br><span class="hljs-meta">at</span> space<span class="hljs-number">.</span>yangtao<span class="hljs-number">.</span><span class="hljs-keyword">monitor</span><span class="hljs-number">.</span>deadlock<span class="hljs-number">.</span>DeadLockTestClient$$Lambda<span class="hljs-number">$1</span>/<span class="hljs-number">999966131.</span>run(Unknown Source)<br><span class="hljs-meta">at</span> java<span class="hljs-number">.</span>lang<span class="hljs-number">.</span>Thread<span class="hljs-number">.</span>run(Thread<span class="hljs-number">.</span>java:<span class="hljs-number">748</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></div></td></tr></table></figure><h3 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h3><p>在 Java 中，没有提供一个安全且直接的方式来“杀死”一个正在运行的线程，因为这样做通常会引起一系列严重的问题，如状态不一致、资源泄露等。Java 的设计哲学强调了在多线程环境下保持程序的健壮性和安全性，因此提倡使用合作机制来管理线程的生命周期，而不是强制终止线程。</p><p>如果问题严重到需要强制结束导致死锁的 Java 进程，可以通过杀死整个 Java 进程来间接“杀死”内部的所有线程，包括那些死锁的线程。这通常是在其他所有解决方案失败后的最后手段，因为这样做可能会导致数据丢失或其他副作用。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li><p>通过任务管理器结束进程</p></li><li><p>使用 <code>taskkill</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">taskkill /F /PID &lt;pid_number&gt;<br></code></pre></div></td></tr></table></figure><p>如</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">C:\Users\yangtao&gt;taskkill /F /PID 25136<br>成功: 已终止 PID 为 25136 的进程。<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="Linux-macOS"><a href="#Linux-macOS" class="headerlink" title="Linux / macOS"></a>Linux / macOS</h4><ul><li><p>使用 <code>kill</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 &lt;pid_number&gt;<br></code></pre></div></td></tr></table></figure><p>如</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 25136<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>管程</strong>在 Java 并发编程中扮演了“内置锁与条件变量统一体”的角色，为开发者提供了高层次的锁管理与线程协调机制。通过 <code>synchronized</code>、<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 等基础手段，Java 屏蔽了底层操作系统的锁细节，使得多线程对共享资源的访问更具可读性与安全性。在实际开发中，我们常以管程思想为基础来解决各种并发场景：从生产者-消费者队列管理到线程池线程的调度，再到读写锁的并发读写优化。此外，管程也并非万能，死锁、活锁、饥饿、假唤醒等问题仍需根据具体场景在设计层面或实现层面予以规避和处理。要想写出高质量、高并发又稳定的 Java 程序，需要在理解管程原理的基础上，结合更高级的并发工具（<code>ReentrantLock</code>、<code>Condition</code>、<code>ReentrantReadWriteLock</code> 等）和良好的设计策略，从而最大化地利用多线程优势并保证程序正确性。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>管程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——synchronized</title>
    <link href="/2021/08/03/javase-cp-synchronized/"/>
    <url>/2021/08/03/javase-cp-synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>并发编程的核心目标是让多个线程在同一程序中协作并行，提升整体执行效率，同时保证共享数据的正确性和一致性。在 Java 语言中，<code>synchronized</code> 关键字是实现线程同步最基础、最直观的方式之一。它可以保证同一时刻只有一个线程能执行被同步的代码（或方法），并在线程间建立起可见性保证，从而避免数据竞争和竞态条件。本篇文章将针对 <code>synchronized</code> 的使用场景、使用方式、底层原理及其对程序性能的影响进行系统的说明，并通过示例展示为什么需要同步以及如何正确使用 <code>synchronized</code>。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>synchronized</code> 是Java中用于实现线程同步的关键字，它确保在多线程环境中对共享资源的安全访问。通过使用 <code>synchronized</code> 将修改共享资源的代码部分置于临界区，可以防止多个线程同时访问同一资源，从而避免数据竞争、竞态条件以及其他并发问题。</p><p><code>synchronized</code> 是一种互斥锁，它保证：</p><ul><li><strong>互斥性</strong>：确保同一时间只有一个线程可以执行被同步的代码块或方法。</li><li><strong>内存可见性</strong>：保证一个线程对共享变量的修改对其他线程是可见的。</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>synchronized</code> 可以用于方法或代码块，其工作原理和功能反映了管程的特性：</p><ul><li><strong>互斥</strong>：确保同一时刻只有一个线程可以执行同步的代码块。</li><li><strong>等待/通知机制</strong>：提供了一种让线程等待某个条件的方法，并在条件满足时接收通知继续执行。</li></ul><p>（在下一章节中，会详细的对管程展开说明）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>通过在方法声明上添加 <code>synchronized</code> 关键字，使整个方法成为同步方法。同步方法的锁对象取决于方法是静态的还是实例的：</p><ul><li><strong>实例方法</strong>：锁对象为当前实例（this）。</li><li><strong>静态方法</strong>：锁对象为当前类的 <code>Class</code> 对象。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 实例同步方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-comment">// 静态同步方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 静态方法的锁是 SynchronizedExample.class</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>简单易用</strong>：无需显式指定锁对象。</li><li><strong>锁粒度大</strong>：整个方法被锁住，可能导致不必要的性能开销。</li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>通过在方法内部使用 <code>synchronized</code> 代码块，可以更精细地控制锁的范围和粒度。同步代码块允许指定一个锁对象，提供更灵活的同步机制。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-comment">// 需要同步的代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedBlockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<span class="hljs-comment">// 使用当前实例的不可变变量作为锁</span><br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anotherMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 使用当前实例作为锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">classLevelLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedBlockExample.class) &#123;<br>            <span class="hljs-comment">// 使用类对象作为锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>更细粒度</strong>：只锁定必要的代码段，减少锁的持有时间，提高性能。</li><li><strong>灵活性</strong>：可以选择不同的锁对象，实现更复杂的同步需求。</li></ul><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>每个 Java 对象都有一个关联的锁，不同实例之间互不影响。当一个线程进入一个被 <code>synchronized</code> 修饰的实例方法或同步代码块时，它必须持有该对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 使用当前实例作为锁</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p>类锁是与类相关联的锁，所有实例共享，同一时间只能有一个线程持有类锁。它通过 <code>synchronized</code> 静态方法或同步类对象实现。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticIncrement</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 类锁</span><br>    count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">classLockMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (ClassLockExample.class) &#123; <span class="hljs-comment">// 类锁</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>可重入指的是同一个线程可以多次获取同一把锁，而不会导致死锁。这意味着如果一个线程已经持有了某个锁，它可以再次获取该锁而不会被阻塞。</p><p>Java的 <code>synchronized</code> 机制天然支持重入锁。当一个线程已经持有对象锁时，可以在同一个线程中再次获取该锁。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        methodB(); <span class="hljs-comment">// 同一个线程可以再次获取锁</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 执行其他操作</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><ul><li><strong>大粒度锁</strong>：锁定较大的代码区域或整个方法，简单但可能导致更多的线程等待，影响并发性能。</li><li><strong>小粒度锁</strong>：锁定较小的代码段，减少锁的持有时间，提高并发度，但增加了实现的复杂性。</li></ul><h3 id="锁的竞争"><a href="#锁的竞争" class="headerlink" title="锁的竞争"></a>锁的竞争</h3><p>高竞争环境下，多个线程争夺同一锁，可能导致频繁的上下文切换和性能下降。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li><strong>减少锁的持有时间</strong>：尽量缩小 <code>synchronized</code> 代码块的范围，仅包含必要的同步操作。</li><li><strong>使用更高效的锁机制</strong>：在高并发场景下，考虑使用 <code>ReentrantLock</code> 或 <code>Atomic</code> 类提供的原子操作（后续章节会提及）。</li><li><strong>避免死锁</strong>：设计合理的锁获取顺序，避免多个锁的循环依赖。</li></ul><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>两个线程对初始值为 0 的变量分别做 10000 次的自增和自减操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyModifyTestClient</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一个简单的计数器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCounter</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>            count++;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyCounter counter = <span class="hljs-keyword">new</span> MyCounter();<br><br>        <span class="hljs-comment">// 开启两个线程，对共享变量进行修改</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                counter.increase();<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                counter.decrease();<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        <span class="hljs-comment">// 等待两个线程执行结束后，输出最终的计数结果</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.join();<br>            t2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;最终计数结果: &#123;&#125;&quot;</span>, counter.getCount());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，发现控制台每次输出的结果是不确定的，0、正数、负数都可能出现。</p><h3 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h3><p>查看 <code>MyCounter</code> 方法的字节码</p><p><code>increase</code></p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"> <span class="hljs-selector-tag">0</span> <span class="hljs-selector-tag">aload_0</span><br> <span class="hljs-selector-tag">1</span> <span class="hljs-selector-tag">dup</span><br> <span class="hljs-selector-tag">2</span> <span class="hljs-selector-tag">getfield</span> <span class="hljs-selector-id">#3</span> &lt;<span class="hljs-selector-tag">space</span>/<span class="hljs-selector-tag">yangtao</span>/<span class="hljs-selector-tag">monitor</span>/<span class="hljs-selector-tag">problem</span>/<span class="hljs-selector-tag">ConcurrencyModifyTestClient</span>$<span class="hljs-selector-tag">MyCounter</span><span class="hljs-selector-class">.count</span> : <span class="hljs-selector-tag">I</span>&gt;<br> <span class="hljs-selector-tag">5</span> <span class="hljs-selector-tag">iconst_1</span><br> <span class="hljs-selector-tag">6</span> <span class="hljs-selector-tag">iadd</span><br> <span class="hljs-selector-tag">7</span> <span class="hljs-selector-tag">putfield</span> <span class="hljs-selector-id">#3</span> &lt;<span class="hljs-selector-tag">space</span>/<span class="hljs-selector-tag">yangtao</span>/<span class="hljs-selector-tag">monitor</span>/<span class="hljs-selector-tag">problem</span>/<span class="hljs-selector-tag">ConcurrencyModifyTestClient</span>$<span class="hljs-selector-tag">MyCounter</span><span class="hljs-selector-class">.count</span> : <span class="hljs-selector-tag">I</span>&gt;<br><span class="hljs-selector-tag">10</span> <span class="hljs-selector-tag">return</span><br></code></pre></div></td></tr></table></figure><p><code>decrease</code></p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">0</span> <span class="hljs-selector-tag">aload_0</span><br> <span class="hljs-selector-tag">1</span> <span class="hljs-selector-tag">dup</span><br> <span class="hljs-selector-tag">2</span> <span class="hljs-selector-tag">getfield</span> <span class="hljs-selector-id">#3</span> &lt;<span class="hljs-selector-tag">space</span>/<span class="hljs-selector-tag">yangtao</span>/<span class="hljs-selector-tag">monitor</span>/<span class="hljs-selector-tag">problem</span>/<span class="hljs-selector-tag">ConcurrencyModifyTestClient</span>$<span class="hljs-selector-tag">MyCounter</span><span class="hljs-selector-class">.count</span> : <span class="hljs-selector-tag">I</span>&gt;<br> <span class="hljs-selector-tag">5</span> <span class="hljs-selector-tag">iconst_1</span><br> <span class="hljs-selector-tag">6</span> <span class="hljs-selector-tag">isub</span><br> <span class="hljs-selector-tag">7</span> <span class="hljs-selector-tag">putfield</span> <span class="hljs-selector-id">#3</span> &lt;<span class="hljs-selector-tag">space</span>/<span class="hljs-selector-tag">yangtao</span>/<span class="hljs-selector-tag">monitor</span>/<span class="hljs-selector-tag">problem</span>/<span class="hljs-selector-tag">ConcurrencyModifyTestClient</span>$<span class="hljs-selector-tag">MyCounter</span><span class="hljs-selector-class">.count</span> : <span class="hljs-selector-tag">I</span>&gt;<br><span class="hljs-selector-tag">10</span> <span class="hljs-selector-tag">return</span><br></code></pre></div></td></tr></table></figure><p><strong>解读</strong>：</p><ol><li><strong>aload_0（0）</strong>：将当前对象 (<code>this</code>) 压入操作栈。</li><li><strong>dup（1）</strong>：复制栈顶的对象引用，确保后续操作仍能引用 <code>this</code>。</li><li><strong>getfield #3（2）</strong>：获取 <code>this.count</code> 的当前值，并压入栈。</li><li><strong>iconst_1（5）</strong>：将整数1压入栈。</li><li><strong>iadd（6）</strong>：将栈顶的两个整数相加（<code>count + 1</code>），结果压入栈。</li><li><strong>isub（6）</strong>：将栈顶的两个整数相减（<code>count - 1</code>），结果压入栈。</li><li><strong>putfield #3（7）</strong>：将相加后的结果存回 <code>this.count</code>。</li><li><strong>return（10）</strong>：方法返回。</li></ol><h3 id="运行结果分析"><a href="#运行结果分析" class="headerlink" title="运行结果分析"></a>运行结果分析</h3><h4 id="结果不确定性原因分析"><a href="#结果不确定性原因分析" class="headerlink" title="结果不确定性原因分析"></a>结果不确定性原因分析</h4><ol><li><strong>非原子性操作</strong>：<code>increase</code> 和 <code>decrease</code> 方法中的操作并不是原子性的，它们涉及多个步骤（加载、计算、存储）。</li><li><strong>多线程交叉执行</strong>：在多线程环境下，这些步骤可能被不同线程交叉打断，导致某些操作未被正确执行或被覆盖，最终结果不符合预期。</li></ol><p>总结：<code>count</code> 是共享资源，而 <code>increase</code> 和 <code>decrease</code> 方法包含对 <code>count</code> 的非原子性操作，同时也并非作为临界区，当两个线程 <code>t1</code> 和 <code>t2</code> 并发执行时，可能导致竞态条件，最终导致了程序结果的不确定性。</p><h4 id="预想情况-0"><a href="#预想情况-0" class="headerlink" title="预想情况 0"></a>预想情况 0</h4><ol><li>t1 获取 count</li><li>t1 将 count 自增</li><li>t1 将 count 写回内存</li><li>上下文切换</li><li>t2 获取 count</li><li>t2 将 count 自减</li><li>t2 将 count 写回内存</li><li>主线程获取最终结果为 0</li></ol><pre><code class=" mermaid">sequenceDiagram    participant 主线程    participant t1    participant t2    participant MyCounter    %% t1 自增操作    t1-&gt;&gt;MyCounter: get count (0)    t1-&gt;&gt;t1: count = count + 1    t1-&gt;&gt;MyCounter: set count = 1    %% t2 自减操作    t2-&gt;&gt;MyCounter: get count (1)    t2-&gt;&gt;t2: count = count - 1    t2-&gt;&gt;MyCounter: set count = 0    %% 主线程获取最终结果    主线程-&gt;&gt;MyCounter: get count (0)    主线程-&gt;&gt;主线程: 打印 &quot;最终计数结果: 0&quot;</code></pre><h4 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h4><ol><li>t1 获取 count</li><li>t1 将 count 自增</li><li>上下文切换</li><li>t2 获取 count</li><li>t2 将 count 自减</li><li>t2 将 count 写回内存</li><li>上下文切换</li><li>t1 将 count 写回内存</li><li>主线程获取最终结果为正数</li></ol><pre><code class=" mermaid">sequenceDiagram    participant 主线程    participant t1    participant t2    participant MyCounter    %% t1 自增操作    t1-&gt;&gt;MyCounter: get count (0)    t1-&gt;&gt;t1: count = count + 1    %% t2 自减操作    t2-&gt;&gt;MyCounter: get count (0)    t2-&gt;&gt;t2: count = count - 1    t2-&gt;&gt;MyCounter: set count = -1    %% t1 写回操作    t1-&gt;&gt;MyCounter: set count = 1    %% 主线程获取最终结果    主线程-&gt;&gt;MyCounter: get count (1)    主线程-&gt;&gt;主线程: 打印 &quot;最终计数结果: 正数&quot;</code></pre><h4 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h4><ol><li>t1 获取 count</li><li>t1 将 count 自增</li><li>上下文切换</li><li>t2 获取 count</li><li>t2 将 count 自减</li><li>上下文切换</li><li>t1 将 count 写回内存</li><li>上下文切换</li><li>t2 将 count 写回 内存</li><li>主线程获取最终结果为负数</li></ol><pre><code class=" mermaid">sequenceDiagram    participant 主线程    participant t1    participant t2    participant MyCounter    %% t1 自增操作    t1-&gt;&gt;MyCounter: get count (0)    t1-&gt;&gt;t1: count = count + 1    %% t2 自减操作    t2-&gt;&gt;MyCounter: get count (0)    t2-&gt;&gt;t2: count = count - 1    %% t1 写回操作    t1-&gt;&gt;MyCounter: set count = 1    %% t2 写回操作    t2-&gt;&gt;MyCounter: set count = -1    %% 主线程获取最终结果    主线程-&gt;&gt;MyCounter: get count (-1)    主线程-&gt;&gt;主线程: 打印 &quot;最终计数结果: 负数&quot;</code></pre><p>上述代码中，<code>increase</code> 和 <code>decrease</code> 方法中包含对共享资源 <code>count</code> 的修改操作（即 <code>count++</code> 和 <code>count--</code>），这些操作应该被置为临界区中的操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>    count++;<span class="hljs-comment">// 临界区</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>    count--;<span class="hljs-comment">// 临界区</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在多线程环境中，多个线程可能会同时访问和修改共享资源（如变量、对象）。如果不加以控制，这可能导致数据不一致或程序行为不可预测。为了确保线程安全，必须控制线程对共享资源的访问顺序和方式。下面将介绍如何控制多线程管理共享资源的正确方式。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>下面将通过 <code>synchronized</code> 解决上面提出的同步问题，有以下两种方式：</p><h3 id="对象锁-1"><a href="#对象锁-1" class="headerlink" title="对象锁"></a>对象锁</h3><p>在方法中使用 <code>synchronized</code> 修饰符，或显示地增加锁对象，让所有线程对同个 <code>MyCounter</code> 示例的 <code>count</code> 操作都是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>        count--;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            count--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="类锁-1"><a href="#类锁-1" class="headerlink" title="类锁"></a>类锁</h3><p>对象锁升级为类锁，让所有线程对所有 <code>MyCounter</code> 示例的 <code>count</code> 操作都是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (MyCounter.class) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (MyCounter.class) &#123;<br>            count--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类锁的粒度过大，不推荐使用。</p><h2 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h2><p>当两个或多个线程互相等待对方持有的锁时，导致所有线程都无法继续执行。</p><h3 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a>预防策略</h3><ul><li><strong>锁顺序</strong>：所有线程以相同的顺序获取多个锁。</li><li><strong>锁超时</strong>：使用 <code>ReentrantLock</code> 的 <code>tryLock</code> 方法，设置获取锁的超时时间。</li><li><strong>最小化锁持有时间</strong>：尽量减少同步代码块内的操作，避免长时间持有锁。</li></ul><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadlockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lockA = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lockB = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>            <span class="hljs-comment">// 做一些操作</span><br>            <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>                <span class="hljs-comment">// 做一些操作</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>            <span class="hljs-comment">// 做一些操作</span><br>            <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>                <span class="hljs-comment">// 做一些操作</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述示例中，如果线程1执行<code>method1</code>并持有<code>lockA</code>，同时线程2执行<code>method2</code>并持有<code>lockB</code>，然后都尝试获取对方的锁，将导致死锁。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于死锁的其他内容，会在后续章节中提及。</p><h2 id="注意事项及最佳实践"><a href="#注意事项及最佳实践" class="headerlink" title="注意事项及最佳实践"></a>注意事项及最佳实践</h2><ol><li><strong>锁范围尽量小</strong>：使用代码块同步而不是整个方法，减少锁的持有时间。</li><li><strong>避免死锁</strong>：避免线程间相互持有对方需要的锁，谨慎使用多个锁，保持锁获取顺序一致。</li><li><strong>避免不必要的同步</strong>：对于只读操作或线程安全的类（如 <code>ConcurrentHashMap</code>），无需使用同步，后续章节会详细说明。</li><li><strong>使用合适的锁机制</strong>：对于复杂同步需求，优先考虑 <code>ReentrantLock</code> 或 <code>java.util.concurrent</code> 包中的工具类，后续章节会详细说明。</li><li><strong>锁对象应明确</strong>：使用私有的锁对象而非 <code>this</code>，避免外部代码干扰。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>synchronized</code> 是 Java 并发编程中最基础的同步工具之一，它通过互斥性和内存可见性两个方面保证了多线程访问共享资源的安全。开发者可以使用同步方法或同步代码块来灵活控制锁的粒度，减少竞态条件带来的不确定性。在选择锁的类型时，需要充分评估应用场景并综合考虑性能和安全性。</p><p>此外，还需警惕死锁和不必要的锁竞争，通过控制锁的持有时间、合理的锁粒度以及一致的锁获取顺序来预防同步隐患。充分理解 <code>synchronized</code> 的特性并结合具体业务需求选择合适的并发工具，才能编写出安全、稳定且高效的多线程程序。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——线程</title>
    <link href="/2021/08/01/javase-cp-thread/"/>
    <url>/2021/08/01/javase-cp-thread/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代软件开发中，如何充分利用多核 CPU 并行执行能力并确保高并发下的程序正确性，是开发者必须掌握的核心技能。Java 语言自诞生之初便在语言层面提供了线程支持，并不断完善其并发工具库。本文将带领读者从进程与线程的基本概念出发，逐步探讨并发与并行的区别以及 Java 中多线程的创建方式；随后介绍 JVM 线程结构、常用的并发 API 和线程状态转换；最后结合竞态条件、临界区等概念，为读者理解和应用并发编程奠定坚实基础。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><ul><li>进程拥有独立的地址空间，一个进程崩溃后，在保护模式下不会影响到其他进程。</li><li>进程间通信（IPC）需要依靠操作系统提供的机制（如管道、信号、套接字等）来实现。</li><li>比线程拥有更高的创建和管理开销。</li></ul><h3 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h3><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。在 Java 中，线程由 <code>Thread</code> 类及其实现的 <code>Runnable</code> 接口来表示和控制。</p><ul><li>线程共享其父进程的数据段（变量和堆空间）使得线程之间的通信更容易。</li><li>每个线程拥有自己的程序计数器（PC）、栈和局部变量。</li><li>线程切换的开销比进程小得多。</li></ul><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/java-process.png" alt="进程与线程"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>进程</th><th><strong>线程</strong></th></tr></thead><tbody><tr><td><strong>内存和资源</strong></td><td>各自独立的内存地址空间，资源不共享，安全性更高但通信更复杂。</td><td>共享同一进程中的内存和资源，通信更为方便。</td></tr><tr><td><strong>开销</strong></td><td>创建和销毁进程的开销较大，上下文切换比线程慢。</td><td>创建和销毁线程的开销较小，上下文切换速度快。</td></tr><tr><td><strong>安全性</strong></td><td>一个进程崩溃不会直接影响到其他进程。</td><td>一个线程崩溃可能影响同一进程内的其他线程。</td></tr><tr><td><strong>适用场景</strong></td><td>适合执行相对独立、需要隔离的任务。</td><td>适合执行相互间需要频繁通信或共享大量数据的任务。</td></tr></tbody></table><p>在 Java 程序设计中，线程的使用远比进程常见，因为 Java 自身并不直接支持进程的创建，而是通过操作系统的功能（如通过 <code>Runtime</code> 或 <code>ProcessBuilder</code> 类）间接处理。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h3><p>并发是指系统能够处理多个任务的能力，这些任务可能不会实际上同时执行，但从宏观上看，它们似乎是同时进行的。在并发模型中，一个处理器在同一时间点只执行一个任务，但由于任务之间频繁切换，给用户留下了多个任务同时进行的印象。</p><ul><li>并发通常用于单核或少核心的处理器。</li><li>任务可以共享相同的资源，如 CPU 或内存。</li><li>更多地侧重于任务切换。</li></ul><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/java-concurrency.png" alt="并发运行"></p><h3 id="并行（Parallelism）"><a href="#并行（Parallelism）" class="headerlink" title="并行（Parallelism）"></a>并行（Parallelism）</h3><p>并行是指多个任务在多个处理器上实际同时执行。在并行模型中，每个核心在同一时间处理不同的任务，从而实现真正的同时处理。</p><ul><li>并行需要多核处理器才能实现。</li><li>每个任务运行在自己的处理器上，可以减少资源竞争。</li><li>更多地侧重于真正的同时执行。</li></ul><p><img src="https://blog-1304850123.cos.ap-guangzhou.myqcloud.com/java-parallelism.png" alt="并行运行"></p><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th><strong>并发</strong></th><th><strong>并行</strong></th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>单核执行多任务，通过任务切换实现多任务处理。</td><td>多核同时执行多任务，每个核心处理不同任务。</td></tr><tr><td><strong>资源需求</strong></td><td>可以在资源有限的情况下实现，因为它不依赖于物理核心数。</td><td>需要足够的处理器核心，适用于资源充足的情况。</td></tr><tr><td><strong>效率</strong></td><td>效率受限于任务切换和单核处理能力。</td><td>能够显著提高处理效率，尤其是在大规模数据处理和计算密集型任务中。</td></tr><tr><td><strong>使用场景</strong></td><td>适用于响应多任务的服务器或应用，如 Web 服务器处理多个请求。</td><td>适用于大规模科学计算、图像处理、大数据分析等需要高度计算资源的场景。</td></tr></tbody></table><p>在软件开发和系统设计中，选择并行或并发取决于应用需求、硬件资源和预期的性能目标。在多核心处理器普及的今天，开发者经常会将并发和并行结合使用，以获得最佳的性能优势。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>通过继承 <code>Thread</code> 类来创建线程是实现多线程的一种基本方式。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><strong>继承 Thread 类</strong>：定义一个类继承自 <code>Thread</code>  类。<code>Thread</code> 类本身实现 <code>Runnable</code>接口，因此继承 <code>Thread</code> 类意味着该子类也是一个 <code>Thread</code>。</li><li><strong>重写 run() 方法</strong>：线程的任务是在 <code>run()</code> 方法中指定的。当线程启动时，它将执行这个方法中的代码。因此，需要在类中重写 <code>run()</code> 方法，将任务逻辑放在这里。</li><li><strong>创建和启动线程</strong>：创建 <code>Thread</code> 子类的线程对象，调用线程对象的 <code>start()</code> 方法来启动线程，这将导致线程的 <code>run()</code> 方法被执行。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTestClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            MyThread t = <span class="hljs-keyword">new</span> MyThread();<br>            t.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            log.info(<span class="hljs-string">&quot;Thread name: &#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>优点</strong>：</p><ul><li><strong>简单直观</strong>：直接继承 <code>Thread</code> 类，代码易于理解。</li><li><strong>控制直接</strong>：因为直接操作线程对象，对线程类的方法和行为控制更为直接。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>灵活性较差</strong>：Java 不支持多重继承，如果类已经继承了另一个类，就不能再继承 <code>Thread</code> 类。</li><li><strong>耦合性高</strong>：线程与任务逻辑耦合，设计不灵活。</li></ul><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>通过实现 <code>Runnable</code> 接口来创建线程是一种非常常见且灵活的方式。这种方法使得线程的任务可以与线程的控制分离开来，提高了代码的复用性和灵活性。</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li><strong>实现 Runnable 接口</strong>：定义一个类实现 <code>Runnable</code> 接口。该接口只有一个方法 <code>run()</code>，需要在类中实现这个方法。<code>run()</code> 方法将包含线程执行时需要完成的任务。</li><li><strong>定义 run() 方法</strong>：在类中重写 <code>run()</code> 方法，并在此方法中定义具体的任务。当线程启动时，它会执行这个方法中的代码。</li><li><strong>创建 Thread 对象</strong>：<code>Runnable</code> 是一个接口，不能直接创建线程，因此需要创建一个 <code>Thread</code> 类的实例，并将 <code>Runnable</code> 类的实例作为参数传给 <code>Thread</code> 的构造器。</li><li><strong>启动线程</strong>：使用 <code>Thread</code> 类的实例调用 <code>start()</code> 方法来启动线程。这会创建一个新的线程，并在这个新线程中调用 <code>Runnable</code> 对象的 <code>run()</code> 方法。</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableTestClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);<br>        thread.start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            log.info(<span class="hljs-string">&quot;Thread name: &#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><strong>优点</strong>：</p><ul><li><strong>灵活性高</strong>：因为 <code>Runnable</code> 可以被多个线程共享，所以多个线程可以执行相同的任务。</li><li><strong>避免 Java 单继承限制</strong>：实现 <code>Runnable</code> 接口的类还可以继承其他类，更符合面向对象设计原则。</li><li><strong>适合资源共享</strong>：多个线程可以操作相同的 <code>Runnable</code> 实例上的资源，便于管理共享数据。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>直接控制线程能力较弱</strong>：因为 <code>Runnable</code> 接口只定义了 <code>run()</code> 方法，对线程本身的控制能力不如直接继承 <code>Thread</code> 类。</li><li><strong>资源消耗更多</strong>：启动线程需要额外创建 <code>Thread</code> 对象。</li></ul><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>通过实现 <code>Callable</code> 接口并结合使用 <code>Future</code>，可以创建有返回结果并能抛出异常的任务。这种方式相比于使用 <code>Runnable</code> 接口，提供了更大的灵活性和功能，特别是在需要任务执行后有返回值的场景中。</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li><strong>实现 Callable 接口</strong>：首先，定义一个类实现 <code>Callable</code> 接口。</li><li><strong>定义 call() 方法</strong>：类中实现 <code>call()</code> 方法，在此方法中定义具体的任务。<code>call()</code> 方法是有返回值的且可以抛出异常，其类型由 <code>Callable</code> 接口的泛型参数指定。</li><li><strong>创建 FutureTask 对象</strong>：以自定义类的实例对象为参数，构造 <code>FutureTask</code> 对象。</li><li><strong>创建 Thread 对象</strong>：创建一个 <code>Thread</code> 类的实例，并将 <code>FutureTask</code> 类的实例作为参数传给 <code>Thread</code> 的构造器（<code>FutureTask</code> 继承自 <code>Runnable</code> 接口）。</li><li><strong>启动线程</strong>：使用 <code>Thread</code> 类的实例调用 <code>start()</code> 方法来启动线程。</li><li><strong>获取结果</strong>：通过调用 <code>FutureTask</code> 的 <code>get()</code> 方法来获取执行结果，需要注意的是这个方法会导致线程阻塞，直至任务完成。</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTestClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyCallable myCallable = <span class="hljs-keyword">new</span> MyCallable();<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myCallable);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);<br>        thread.start();<br>        log.info(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, futureTask.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Callable!&quot;</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong></p><ul><li><strong>可获取结果</strong>：<code>call()</code> 方法可以返回异步线程的执行结果，并支持抛出异常。适合需要获取执行结果的任务。</li><li><strong>继承自 Runnable</strong>：可享有实现 Runnable 接口创建线程的全部优点。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>实现复杂</strong>：代码实现比较复杂。</li></ul><h2 id="JVM线程简述"><a href="#JVM线程简述" class="headerlink" title="JVM线程简述"></a>JVM线程简述</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>JVM 由堆（Heap）、栈（Stack） 和方法区（Method Area，现已演化为元空间 Metaspace） 组成。其中栈的全称为 <code>Java Virtual Machine Stacks</code>（Java 虚拟机栈），其内存是线程私有的，每个线程启动时，虚拟机会为其分配一块独立的栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。</li><li>栈的作用是存储方法调用的相关信息，包括局部变量表、操作数栈、动态链接、方法返回地址等。</li><li>栈帧是栈中的最小单位，随着方法的调用和结束，栈帧会被依次压入或弹出栈。</li><li>当前线程的栈帧中，只有最顶部的栈帧是活动的，代表当前正在执行的方法，其余栈帧处于等待状态。</li><li>方法调用结束后，其对应的栈帧会从栈中弹出，不再占用内存。</li><li>栈内存的<strong>特点</strong>：<ul><li><strong>线程安全</strong>：由于栈是线程私有的，不存在数据竞争。</li><li><strong>生命周期短暂</strong>：与线程的生命周期一致，线程结束时栈也会销毁。</li></ul></li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable()).start();<br>        method1();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        method2();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread name: &quot;</span> + Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在程序中添加断点，运行后可查看线程及线程内部的栈帧如下：</p><p>主线程含有的栈帧</p><p><img src="assets/image-20241229194033974-1738227381118-1.png" alt="image-20241229194033974"></p><p>异步线程含有的栈帧</p><p><img src="assets/image-20241229194203104-1738227381118-2.png" alt="image-20241229194203104"></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为一些原因导致 CPU 不再执行当前线程，转而执行另一个线程，这种现象称为<strong>线程上下文切换</strong>。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>因为以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码：</p><ul><li><strong>CPU时间片用完</strong>：操作系统基于时间片轮转机制（Time Slicing）进行线程调度，时间片用完会触发上下文切换。</li><li><strong>垃圾回收</strong>：当 JVM 的 GC 线程执行垃圾回收时，可能会暂停其他线程。</li><li><strong>锁竞争</strong>：当多个线程竞争同一个锁时，线程可能进入阻塞状态，等待锁释放。</li><li><strong>线程方法调用</strong>：如 <code>sleep</code>、<code>wait</code> 等方法会主动让出 CPU，触发上下文切换。</li></ul><h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><ol><li><strong>保存当前线程状态</strong>：包括程序计数器（PC）、寄存器、栈指针等信息。</li><li><strong>调度下一线程</strong>：选择一个可运行的线程。</li><li><strong>恢复新线程状态</strong>：将被调度线程的上下文信息加载到 CPU。</li></ol><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>程序计数器（PC Register）：</strong></p><ul><li>是线程私有的，记录线程当前执行的字节码指令地址。</li><li>在线程切换时，程序计数器保存当前线程的执行位置，确保恢复后从正确的位置继续执行。</li></ul><p><strong>虚拟机栈中的信息：</strong></p><ul><li>局部变量表：保存方法局部变量，包括基本数据类型、对象引用等。</li><li>操作数栈：用于执行计算操作的中间结果存储。</li><li>方法返回地址：记录方法结束后返回调用点的地址。</li></ul><h4 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h4><ul><li>上下文切换会导致 CPU 缓存失效（Cache Miss），增加内存访问的时间。</li><li>上下文切换的操作（保存和恢复状态）本身也需要消耗 CPU 资源。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><table><thead><tr><th>方法名</th><th>功能</th><th>注意事项</th></tr></thead><tbody><tr><td>start()</td><td>启动线程并调用其 <code>run()</code> 方法，线程进入就绪状态。</td><td>不能多次调用同一线程对象的 <code>start()</code>，否则抛出 <code>IllegalThreadStateException</code>。</td></tr><tr><td>run()</td><td>定义线程执行的具体任务。</td><td>直接调用 <code>run()</code> 不会启动新线程，而是作为普通方法运行。</td></tr><tr><td>wait() / wait(long n)</td><td>使当前线程等待（指定时间）。</td><td></td></tr><tr><td>notify() / notifyAll()</td><td>唤醒正在等待该对象监视器的单个/所有线程。</td><td></td></tr><tr><td>join() / join(long n)</td><td>当前线程等待目标线程执行完成（或等待指定时间）。</td><td>可用于线程同步，避免并发问题。</td></tr><tr><td>getId()</td><td>返回线程的唯一标识符（由 JVM 分配）。</td><td></td></tr><tr><td>getName() / setName(String n)</td><td>获取/设置线程的名称。</td><td>设置名称有助于调试和日志记录。</td></tr><tr><td>getPriority() / setPriority(int p)</td><td>获取/设置线程的优先级（范围<code>1~10</code>，默认<code>5</code>）。</td><td>优先级只是建议，实际调度由操作系统决定。</td></tr><tr><td>getState()</td><td>获取线程的当前状态，如 <code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code> 等。</td><td></td></tr><tr><td>isAlive()</td><td>判断线程是否还存活（已经启动且未终止）。</td><td></td></tr><tr><td>interrupt()</td><td>中断线程，设置中断标志位。</td><td>不会直接停止线程，但阻塞状态下可能抛出 <code>InterruptedException</code>。</td></tr><tr><td>isInterrupted()</td><td>判断线程是否被中断（中断标志位）</td><td>不清除中断标志。</td></tr><tr><td>interrupted()</td><td>判断当前线程是否被中断，并清除中断标志位。</td><td></td></tr><tr><td>currentThread()</td><td>返回对当前正在执行线程的引用。</td><td></td></tr><tr><td>sleep(long n)</td><td>使当前线程休眠指定时间（毫秒）。</td><td>不释放锁，但会抛出 <code>InterruptedException</code>。</td></tr><tr><td>yield()</td><td>让出当前线程的CPU资源，尝试让其他线程运行。</td><td>调用后可能立即重新获取 CPU 执行权。</td></tr><tr><td>setDaemon(boolean on)</td><td>设置线程为守护线程（后台运行，JVM退出时自动停止）。</td><td>必须在 <code>start()</code> 之前调用。</td></tr><tr><td>checkAccess()</td><td>检查当前线程是否允许修改目标线程。</td><td></td></tr><tr><td>activeCount()</td><td>获取当前线程组中活动线程的估计数。</td><td></td></tr><tr><td>enumerate(Thread[] tarray)</td><td>将当前线程组中所有活动线程复制到指定数组中。</td><td></td></tr><tr><td>stop()</td><td>停止线程运行。</td><td>官方标记过时，不再推荐使用。</td></tr><tr><td>suspend()</td><td>暂停线程运行。</td><td>官方标记过时，不再推荐使用。</td></tr><tr><td>resume()</td><td>恢复线程运行。</td><td>官方标记过时，不再推荐使用。</td></tr></tbody></table><h2 id="Java-线程状态"><a href="#Java-线程状态" class="headerlink" title="Java 线程状态"></a>Java 线程状态</h2><h3 id="状态枚举"><a href="#状态枚举" class="headerlink" title="状态枚举"></a>状态枚举</h3><ol><li><strong>NEW（新建）</strong>：线程已创建，但尚未启动，即线程对象已经实例化，但尚未分配系统资源用于执行。</li><li><strong>RUNNABLE（可运行）</strong>：线程正在 Java 虚拟机中执行（RUNNING），或处于操作系统中的就绪队列中（READY）等待分配 CPU 时间。</li><li><strong>BLOCKED（阻塞）</strong>：线程因等待监视器锁（monitor lock）而阻塞，无法继续执行，此过程不消耗 CPU 资源。</li><li><strong>WAITING（等待）</strong>：线程无限期等待另一个线程的特定操作（如<code>Object.wait()</code>、<code>Thread.join()</code>），此过程不消耗 CPU 资源。</li><li><strong>TIMED_WAITING（超时等待）</strong>：线程等待另一个线程的特定操作，且有时间限制（如<code>Thread.sleep(long)</code>、<code>Object.wait(long)</code>），此过程不消耗 CPU 资源。</li><li><strong>TERMINATED（终止）</strong>：线程已完成执行或因异常终止。</li></ol><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><pre><code class=" mermaid">stateDiagram-v2    [*] --&gt; NEW    NEW --&gt; RUNNABLE : start()    RUNNABLE --&gt; BLOCKED : 请求锁被占用    RUNNABLE --&gt; WAITING : 调用wait()/join()    RUNNABLE --&gt; TIMED_WAITING : 调用sleep()/wait(long)/join(long)    RUNNABLE --&gt; TERMINATED : run()结束或异常    BLOCKED --&gt; RUNNABLE : 获取到锁    WAITING --&gt; RUNNABLE : 被notify()/notifyAll()/中断    TIMED_WAITING --&gt; RUNNABLE : 超时或被notify()/notifyAll()/中断    TERMINATED --&gt; [*]</code></pre><h2 id="竞态条件（Race-Conditions）"><a href="#竞态条件（Race-Conditions）" class="headerlink" title="竞态条件（Race Conditions）"></a>竞态条件（Race Conditions）</h2><p>在多线程环境下，多个线程同时访问和修改共享资源时，如果没有适当的同步机制，就会产生竞态条件。竞态条件的出现导致多个线程对共享变量的操作交叉执行，从而引发数据不一致的问题。</p><p><strong>关键点</strong>：</p><ol><li><strong>共享资源</strong>：线程共同访问的变量或对象。</li><li><strong>操作交叉</strong>：线程对共享资源的访问顺序不是确定的，可能导致不可预测的结果。</li></ol><h2 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h2><p>临界区是指一段代码，它在多线程环境中需要独占访问共享资源，以确保数据的完整性和一致性。同一时间，只有一个线程能够进入临界区执行这段代码，其他线程需要等待，直到当前线程完成操作并退出临界区。</p><p><strong>关键特点</strong>：</p><ol><li><strong>共享资源</strong>：临界区内的代码会访问或修改共享资源，这些资源在多线程环境下容易引发数据竞争问题。</li><li><strong>互斥性</strong>：临界区保证在某个时间点，只有一个线程能执行该段代码，避免线程之间的冲突。</li><li><strong>同步机制</strong>：通过锁或其他同步工具（如 <code>synchronized</code>、<code>ReentrantLock</code>）来实现对临界区的保护。</li></ol><h2 id="关键API"><a href="#关键API" class="headerlink" title="关键API"></a>关键API</h2><h3 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start() 与 run()"></a>start() 与 run()</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>start() 方法</strong></th><th><strong>run() 方法</strong></th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td>启动一个新线程，导致 JVM 调用该线程的 <code>run()</code> 方法。</td><td>定义线程执行的具体任务，当通过  <code>start()</code>  启动线程时被自动调用。</td></tr><tr><td><strong>线程创建</strong></td><td>是的，调用 <code>start()</code> 会在 JVM 中创建一个新的线程。</td><td>否，直接调用 <code>run()</code> 只是作为普通方法在当前线程中同步执行。</td></tr><tr><td><strong>并发执行</strong></td><td>是，<code>start()</code> 启动的新线程与调用线程并发执行。</td><td>否，直接调用 <code>run()</code> 方法不会启动新线程，而是在当前线程中顺序执行。</td></tr><tr><td><strong>方法执行顺序</strong></td><td>异步执行，<code>start()</code> 方法立即返回，新线程开始独立执行。</td><td>同步执行，调用线程会等待 <code>run()</code> 方法执行完毕后再继续。</td></tr><tr><td><strong>线程状态转换</strong></td><td><code>NEW</code> → <code>READY</code> → <code>RUNNING</code> 。</td><td>不涉及线程状态转换，因为 <code>run()</code> 在当前线程中执行。</td></tr><tr><td><strong>异常处理</strong></td><td>异常在新线程中抛出，不会影响调用 <code>start()</code> 的线程。</td><td>异常在当前线程中抛出，可能影响调用 <code>run()</code> 方法的线程。</td></tr><tr><td><strong>调用频率</strong></td><td>每个 <code>Thread</code> 实例只能调用一次 <code>start()</code>，再次调用会抛出 <code>IllegalThreadStateException</code>。</td><td>可以多次调用 <code>run()</code>，但每次都是在当前线程中同步执行。</td></tr></tbody></table><p><strong>关键区别总结：</strong></p><ul><li><strong>并发性：</strong> <code>start()</code> 方法启动的新线程与调用线程并发执行，而直接调用 <code>run()</code> 方法则在当前线程中同步执行，不会启动新线程。</li><li><strong>线程生命周期：</strong> <code>start()</code> 会改变线程的生命周期状态，而 <code>run()</code> 方法的调用不会影响线程状态。</li><li><strong>一次性启动：</strong> <code>start()</code> 方法只能被调用一次，一个 <code>Thread</code> 实例只能启动一次；而 <code>run()</code> 方法可以被多次调用，但每次都是在当前线程中执行。</li></ul><h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a>sleep() 与 yield()</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Thread.sleep(long millis)</strong></th><th><strong>Thread.yield()</strong></th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td>暂停当前线程执行指定时间，进入 <code>TIMED_WAITING</code> 状态。</td><td>提示调度器当前线程愿意让出CPU资源，以执行其他线程。</td></tr><tr><td><strong>线程状态变化</strong></td><td><code>RUNNABLE</code> → <code>TIMED_WAITING</code> → <code>RUNNABLE</code>。</td><td>可能保持在 <code>RUNNABLE</code> 状态。</td></tr><tr><td><strong>CPU使用权</strong></td><td>让出 CPU 使用权给其他线程。</td><td>可能会让出 CPU 使用权给其他线程。</td></tr><tr><td><strong>是否释放锁</strong></td><td>不释放任何锁，线程在休眠期间仍持有所有锁。</td><td>不释放任何锁，线程继续持有所有锁。</td></tr><tr><td><strong>异常处理</strong></td><td>抛出 <code>InterruptedException</code>，需要处理。</td><td>不抛出异常。</td></tr><tr><td><strong>执行时机</strong></td><td>立即进入休眠状态，等待指定时间后恢复。</td><td>在当前执行点提示调度器让出 CPU，具体行为由调度器决定。</td></tr><tr><td><strong>可控性</strong></td><td>高，通过指定具体的休眠时间控制暂停长度。</td><td>低，只是一个提示，无法控制具体的暂停时间或哪个线程被调度执行。</td></tr><tr><td><strong>适用场景</strong></td><td>需要明确暂停线程的执行，控制执行节奏或模拟延时。</td><td>希望提高线程间的协作性，允许其他线程有机会执行，但不需要具体控制暂停时间。</td></tr><tr><td><strong>性能影响</strong></td><td>适度影响，根据休眠时间长度决定。</td><td>取决于调度器实现，可能带来较小的性能影响。</td></tr><tr><td><strong>可预测性</strong></td><td>高，线程会在指定时间后恢复，但实际休眠时间可能略有偏差。</td><td>低，行为依赖调度器，不可预测。</td></tr><tr><td><strong>示例用法</strong></td><td>延时任务执行，等待资源准备，控制循环频率。</td><td>简单的线程礼让，非关键的协作场景。</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>使用 <code>sleep()</code> 当你需要明确地暂停线程一段时间，控制线程执行节奏或模拟延时操作时，但不应作为线程同步或等待条件的主要手段。</li><li>使用 <code>yield()</code> 时，要了解其行为的不确定性，仅在非关键的线程协作场景下考虑使用，高负载环境下使用可能会让线程长时间得不到执行机会。</li></ul><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() / notify() / notifyAll()"></a>wait() / notify() / notifyAll()</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>wait()</code> 是 <code>Object</code> 类的一个实例方法，用于使当前线程等待，直到被其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒，或者在指定的时间后自动恢复执行。具体过程如下：</p><ol><li>调用 <code>wait()</code> 方法，释放当前持有的对象监视器锁，使当前线程进入 <code>WAITING</code> 状态（无超时）或 <code>TIMED_WAITING</code> 状态（有超时）。</li><li>调用 <code>notify() / notifyAll()</code> 方法，唤醒一个/所有正在等待该对象监视器的线程，唤醒的线程将从 <code>WAITING</code> 或 <code>TIMED_WAITING</code> 状态恢复为 <code>RUNNABLE</code> 状态，等待竞争锁。</li><li>获得锁的线程继续执行。</li></ol><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"># 使线程进入等待状态，无超时时间<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br><br># 使线程进入等待状态，最多等待指定的毫秒数<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br><br># 使线程进入等待状态，最多等待指定的毫秒数加纳秒数<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>实现一个经典的“生产者-消费者模型”，生产者生产数据，消费者消费数据，通过 <code>wait()</code> 和 <code>notifyAll()</code> 实现线程间通信。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerTestClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasData = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            <span class="hljs-keyword">while</span> (hasData) &#123;<br>                lock.wait(); <span class="hljs-comment">// 线程进入 WAITING 状态，等待消费者消费数据</span><br>            &#125;<br>            data = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>            hasData = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;生产者生产数据: &quot;</span> + data);<br>            lock.notifyAll(); <span class="hljs-comment">// 通知消费者线程</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            <span class="hljs-keyword">while</span> (!hasData) &#123;<br>                lock.wait(); <span class="hljs-comment">// 线程进入 WAITING 状态，等待生产者生产数据</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;消费者消费数据: &quot;</span> + data);<br>            hasData = <span class="hljs-keyword">false</span>;<br>            lock.notifyAll(); <span class="hljs-comment">// 通知生产者线程</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ProducerConsumerTestClient pc = <span class="hljs-keyword">new</span> ProducerConsumerTestClient();<br><br>        Thread producer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    pc.produce();<br>                    Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟生产时间</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    pc.consume();<br>                    Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟消费时间</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br><br>        <span class="hljs-comment">// 等待生产者线程和消费者线程执行完毕</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            producer.join();<br>            consumer.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;主线程退出&quot;</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>始终在同步块或同步方法中调用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>，这些方法必须在持有对象的监视器锁的情况下调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li><li>使用 <code>while</code> 循环而非 <code>if</code> 判断条件，防止“虚假唤醒（Spurious Wakeup）”。即使线程被唤醒，也需要重新检查条件是否满足。</li><li>谨慎处理中断请求，捕获 <code>InterruptedException</code> 后，恢复中断状态（调用 <code>Thread.currentThread().interrupt()</code>）。</li><li>优先使用高级并发工具，<code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 是低级同步机制，易出错且难以维护。优先使用更高级的并发工具，如 <code>java.util.concurrent</code> 包中的类。</li><li>避免不必要的等待和唤醒，仅在确实需要线程进入等待状态时才调用 <code>wait()</code>，并在适当的位置调用 <code>notify()</code> 或 <code>notifyAll()</code> 以唤醒等待线程，避免过度同步导致性能下降。</li><li>避免死锁，确保所有线程以相同的顺序获取多个锁，同时尽量使用带超时的锁获取方法，尽量避免多个锁的嵌套使用，降低复杂性。</li><li>使用线程监控工具（如 jstack、VisualVM、Java Mission Control 等）分析线程状态，识别潜在的性能瓶颈和线程协作问题。</li></ol><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>线程的实例方法，用于使当前线程等待另一个线程完成执行。<code>join()</code> 方法内部实际上调用了被调用线程的 <code>wait()</code> 方法。具体过程如下：</p><ol><li>当前线程调用 <code>join()</code> 方法，进入 <code>WAITING</code> 或 <code>TIMED_WAITING</code> 状态。</li><li>被调用线程执行完毕，进入 <code>TERMINATED</code> 状态。</li><li>JVM 唤醒等待的线程，当前线程从 <code>WAITING</code> 或 <code>TIMED_WAITING</code> 状态恢复为 <code>RUNNABLE</code> 状态，继续执行后续代码。</li></ol><h4 id="方法重载-1"><a href="#方法重载-1" class="headerlink" title="方法重载"></a>方法重载</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"># 等待被调用线程完成执行，无时间限制。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br><br># 等待被调用线程完成执行，最多等待指定的毫秒数。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br><br># 等待被调用线程完成执行，最多等待指定的毫秒数加纳秒数。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><p>在主线程调用线程的 <code>join</code> 方法实现线程同步</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;t1 执行结束&quot;</span>));<br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;t2 执行结束&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;);<br>t1.start();<br>t2.start();<br><br><span class="hljs-comment">// 等待 t1 和 t2 执行结束</span><br><span class="hljs-keyword">try</span> &#123;<br>    t1.join();<br>    t2.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    Thread.currentThread().interrupt();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span> 执行结束<br><span class="hljs-built_in">t2</span> 执行结束<br>主线程结束<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>确保在调用 <code>join()</code> 方法之前已经启动了被调用线程，否则当前线程可能会无限期等待。</li><li>被调用线程可能因某种原因无法正常终止，使用带超时的 <code>join()</code> 方法可以避免当前线程无限期等待。</li><li>在多线程环境中，线程可能会被其他线程中断，使用 <code>join()</code> 方法时应妥善处理 <code>InterruptedException</code>（恢复中断状态）。</li><li>避免调用自身 <code>join()</code>，否则将导致线程永久等待，形成死锁。</li></ol><h3 id="interrupt-isInterrupted-interrupted"><a href="#interrupt-isInterrupted-interrupted" class="headerlink" title="interrupt() / isInterrupted() / interrupted()"></a>interrupt() / isInterrupted() / interrupted()</h3><h4 id="线程中断概述"><a href="#线程中断概述" class="headerlink" title="线程中断概述"></a>线程中断概述</h4><p>线程中断是 Java 中一种协作式的线程控制机制，允许一个线程请求另一个线程停止其当前的执行。中断并不强制线程立即停止，而是设置线程的中断状态，线程本身需要定期检查并响应中断请求，从而实现安全、优雅的终止。</p><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><ul><li><code>interrupt()</code> 是 <code>Thread</code> 类中的一个实例方法，可设置线程的中断状态为 <code>true</code>，用于中断线程，但并不直接停止线程的执行。当调用 <code>interrupt()</code> 方法时，以下两种情况会发生：<ol><li><strong>线程处于阻塞状态</strong>: 如果线程正在执行阻塞操作（例如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>），这些方法会立即抛出 <code>InterruptedException</code>，并且线程的中断状态会被清除（即设置为 <code>false</code>）。</li><li><strong>线程处于运行状态</strong>: 如果线程不在阻塞状态，调用 <code>interrupt()</code> 仅仅设置线程的中断状态为 <code>true</code>，线程需要自行检查中断状态并决定如何响应。</li></ol></li><li><code>isInterrupted()</code> 是 <code>Thread</code> 类中的一个实例方法，用于检查线程是否被中断，但不清除中断状态。</li><li><code>interrupted()</code> 是 <code>Thread</code> 类中的一个静态方法，用于检查当前线程是否被中断，并清除中断状态，使得之后的检查无法检测到先前的中断。</li></ul><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>通过中断机制实现线程的终止，确保资源的正确释放</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptTestClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread worker = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;工作线程开始执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果当前线程未被中断，则执行循环</span><br>                <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-comment">// 模拟工作</span><br>                    System.out.println(<span class="hljs-string">&quot;工作线程正在处理任务...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠1秒</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;   <span class="hljs-comment">// 捕获到异常后中断状态会被自动清除</span><br>                System.out.println(Thread.currentThread().isInterrupted()); <span class="hljs-comment">// false</span><br>                System.out.println(<span class="hljs-string">&quot;工作线程在休眠中被中断&quot;</span>);<br>                <span class="hljs-comment">// 恢复中断状态</span><br>                Thread.currentThread().interrupt();<br>                System.out.println(Thread.currentThread().isInterrupted()); <span class="hljs-comment">// true</span><br>            &#125;<br>            <span class="hljs-comment">// 如果未恢复中断状态，则会导致无法中断线程（条件判断为 true，重新进入循环）</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;工作线程又在处理任务...&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 释放资源</span><br>            System.out.println(<span class="hljs-string">&quot;工作线程进行资源清理...&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;工作线程终止。&quot;</span>);<br>        &#125;);<br><br>        worker.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 主线程休眠3秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;主线程请求工作线程中断&quot;</span>);<br>        worker.interrupt(); <span class="hljs-comment">// 中断工作线程</span><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>步骤</strong>：</p><ol><li>工作线程启动并进入循环，每秒打印一次 “工作线程正在处理任务…”。</li><li>主线程休眠3秒后请求工作线程中断。</li><li>工作线程在 <code>sleep()</code> 方法中被中断，抛出 <code>InterruptedException</code>，进入 <code>catch</code> 块，打印中断信息并恢复中断状态。</li><li>工作线程退出循环，进行资源清理并终止。</li></ol><p>运行程序，控制台打印如下：</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">工作线程开始执行<br>工作线程正在处理任务...<br>工作线程正在处理任务...<br>工作线程正在处理任务...<br>主线程请求工作线程中断<br><span class="hljs-literal">false</span><br>工作线程在休眠中被中断<br><span class="hljs-literal">true</span><br>工作线程进行资源清理...<br>工作线程终止。<br></code></pre></div></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>为什么要在捕获 <code>InterruptedException</code> 异常后，使用 <code>interrupt()</code> 方法恢复中断状态？</p><ul><li>抛出 <code>InterruptedException</code> 异常时，中断状态会被自动清除（中断标志重置为 <code>false</code>），如果不显示地恢复中断状态，线程后续的代码无法感知到中断信号。</li><li>恢复中断状态可以让调用者或上层逻辑知道线程曾经被请求中断，便于统一处理或记录。</li><li>某些代码逻辑可能依赖中断状态进行特定的行为，例如安全终止或资源清理。</li><li>对于框架或工具类代码，恢复中断状态是种约定，允许调用者决定如何处理中断，而不是工具类隐式地吞掉中断。</li></ul></li><li><p><code>interrupted()</code> 方法的应用场景是什么？</p><p>用于检查并清除中断状态，适合一次性处理中断请求或需要主动清理中断信号的场景。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptedExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123; <span class="hljs-comment">// 检测并清除中断状态</span><br>                    System.out.println(<span class="hljs-string">&quot;线程被中断，退出循环&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 执行其他任务</span><br>                System.out.println(<span class="hljs-string">&quot;执行任务...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt(); <span class="hljs-comment">// 恢复中断状态</span><br>                    System.out.println(<span class="hljs-string">&quot;任务被中断&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 主线程休眠3秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        thread.interrupt(); <span class="hljs-comment">// 中断线程</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">执行任务...<br>执行任务...<br>执行任务...<br>任务被中断<br>线程被中断，退出循环<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程组（<code>Thread Group</code>）是 Java 提供的一种机制，用于将多个线程组织在一起，便于统一管理和控制。它允许开发者对一组相关的线程进行批量操作，如中断、设置优先级等。</p><p>在线程数量庞大且关系复杂的应用程序中，管理各个线程可能变得困难。线程组提供了一种层次化的管理方式，使得开发者可以按照功能或模块将线程进行分组，简化管理过程。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>集中管理</strong>：便于对相关线程进行统一控制，如中断、设置优先级等。</li><li><strong>层次化组织</strong>：支持线程组的嵌套，可以构建线程的层次结构，增强组织性。</li><li><strong>简化操作</strong>：一次性操作线程组中的所有线程，减少代码复杂性。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>线程组的过时性</strong>：从Java 2开始，官方建议优先使用<code>java.util.concurrent</code>包中的并发工具类，如<code>ExecutorService</code>、<code>Future</code>、<code>CountDownLatch</code>等，线程组的使用逐渐减少。</li><li><strong>功能有限</strong>：线程组提供的功能相对基础，难以满足复杂的并发需求。</li><li><strong>不支持动态调整</strong>：线程组一旦创建，其结构较为固定，不易动态调整。</li><li><strong>安全性问题</strong>：线程组允许外部线程访问和操作线程组中的线程，可能引发安全隐患。</li><li><strong>监控与调试困难</strong>：线程组的层次结构复杂时，监控和调试变得困难，尤其是在大型应用中。</li></ul><h3 id="创建与管理"><a href="#创建与管理" class="headerlink" title="创建与管理"></a>创建与管理</h3><h4 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h4><ul><li><p><strong>默认线程组</strong>：所有线程都属于一个默认的线程组，称为 <code>main</code> 线程组。</p></li><li><p><strong>自定义线程组</strong>：可以通过构造方法创建新的线程组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个名为&quot;MyGroup&quot;的新线程组，父线程组为当前线程的线程组</span><br>ThreadGroup myGroup = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;MyGroup&quot;</span>);<br><br><span class="hljs-comment">// 创建一个名为&quot;ChildGroup&quot;的子线程组，父线程组为myGroup</span><br>ThreadGroup childGroup = <span class="hljs-keyword">new</span> ThreadGroup(myGroup, <span class="hljs-string">&quot;ChildGroup&quot;</span>);<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="将线程加入线程组"><a href="#将线程加入线程组" class="headerlink" title="将线程加入线程组"></a>将线程加入线程组</h4><p>在创建<code>Thread</code>对象时，可以指定所属的线程组：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个线程，并指定线程组为myGroup</span><br>Thread thread = <span class="hljs-keyword">new</span> Thread(myGroup, () -&gt; &#123; <br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p><code>ThreadGroup</code>类提供了多种方法，用于管理和查询线程组中的线程和子线程组：</p><h4 id="线程组信息"><a href="#线程组信息" class="headerlink" title="线程组信息"></a>线程组信息</h4><ul><li>**getName()**：返回线程组的名称。</li><li>**getMaxPriority()**：获取线程组中允许的最大线程优先级。</li><li>**setMaxPriority(int newPriority)**：设置线程组中允许的最大线程优先级。</li></ul><h4 id="线程状态查询"><a href="#线程状态查询" class="headerlink" title="线程状态查询"></a>线程状态查询</h4><ul><li>**activeCount()**：返回线程组中当前活动线程的估计数。</li><li>**activeGroupCount()**：返回线程组中当前活动子线程组的估计数。</li><li>**enumerate(Thread[] list, boolean recurse)**：将线程组中的所有线程拷贝到指定的数组中。</li><li>**enumerate(ThreadGroup[] list, boolean recurse)**：将线程组中的所有子线程组拷贝到指定的数组中。</li></ul><h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><ul><li>**interrupt()**：中断线程组中的所有线程。</li><li>**destroy()**：销毁线程组。线程组必须为空（即没有活跃线程和子线程组），否则会抛出<code>IllegalThreadStateException</code>。</li><li>**isDestroyed()**：检查线程组是否已被销毁。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>**parentOf(ThreadGroup g)**：判断当前线程组是否是指定线程组的父线程组。</li><li>**uncaughtException(Thread t, Throwable e)**：处理线程组中线程的未捕获异常。</li></ul><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建和管理线程组。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGroupExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个新的线程组</span><br>        ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;MyGroup&quot;</span>);<br><br>        <span class="hljs-comment">// 创建并启动多个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(group, () -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                        log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在执行任务...&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; 被中断&quot;</span>);<br>                    Thread.currentThread().interrupt(); <span class="hljs-comment">// 恢复中断状态</span><br>                &#125;<br>                log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; 终止&quot;</span>);<br>            &#125;, <span class="hljs-string">&quot;Thread-&quot;</span> + i);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待3秒后中断线程组中的所有线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;主线程中断线程组中的所有线程&quot;</span>);<br>        group.interrupt();<br><br>        <span class="hljs-comment">// 等待线程组中的所有线程终止</span><br>        <span class="hljs-keyword">int</span> activeCount = group.activeCount();<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[activeCount];<br>        group.enumerate(threads);<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;所有线程已终止&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行程序，控制台输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">11.148</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">2</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">11.148</span> <span class="hljs-selector-attr">[Thread-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">3</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">11.148</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">1</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">12.157</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">2</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">12.157</span> <span class="hljs-selector-attr">[Thread-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">3</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">12.157</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">1</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">13.170</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">2</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">13.170</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">1</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">13.170</span> <span class="hljs-selector-attr">[Thread-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">3</span> 正在执行任务...<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - 主线程中断线程组中的所有线程<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">2</span> 被中断<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-2]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">2</span> 终止<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">3</span> 被中断<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">1</span> 被中断<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-3]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">3</span> 终止<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[Thread-1]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - Thread-<span class="hljs-number">1</span> 终止<br><span class="hljs-number">22</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14.153</span> <span class="hljs-selector-attr">[main]</span> INFO  s<span class="hljs-selector-class">.yangtao</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.ThreadGroupExample</span> - 所有线程已终止<br></code></pre></div></td></tr></table></figure><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><strong>优先使用高级并发工具</strong>：尽量使用 <code>java.util.concurrent</code> 包中的工具类，简化并发控制逻辑。</li><li><strong>避免过度使用线程组</strong>：仅在特定需求下，或为维护旧有代码时，才考虑使用线程组。</li><li><strong>设计合理的线程管理策略</strong>：结合线程池、任务提交与控制，确保线程的高效利用与安全终止。</li><li><strong>监控与调试</strong>：定期使用线程监控工具分析线程状态，优化并发性能。</li><li><strong>线程安全设计</strong>：无论使用何种并发工具，始终遵循线程安全的设计原则，避免数据竞争与死锁。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 并发编程的关键在于对线程的正确使用和对共享数据的安全访问。通过了解进程与线程的区别，我们明白了线程在同一进程内共享资源、切换开销小但安全性相对较低；并通过并发与并行的比较，认识到编写并行程序需要配合底层硬件资源。对于如何创建线程，Java 提供了继承 <code>Thread</code>、实现 <code>Runnable</code>、以及实现 <code>Callable</code> 等多种方式，分别在灵活性、返回值、异常处理能力等方面各有侧重。围绕线程生命周期和常用 API 的阐述，则让我们对线程状态、方法调用和上下文切换机制有了直观理解。</p><p>同时，本文也提示了线程安全的重要性：多个线程共同访问或修改共享资源时需要使用适当的同步或锁机制来避免竞态条件。在实践中，掌握 <code>wait()/notify()</code>、<code>synchronized</code>、<code>Lock</code> 以及更高级的并发容器和原子类库，才能编写出高质量、高并发且安全的 Java 程序。希望本文能帮助读者打下良好的并发编程基础，并在后续深入学习中更好地理解 Java 并发模型的设计理念与实战技巧。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java并发编程</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL命令详解</title>
    <link href="/2021/07/07/mysql-commands/"/>
    <url>/2021/07/07/mysql-commands/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在日常使用 MySQL 数据库时，我们会频繁接触到不同类别的 SQL 命令，如增删改查（<code>DML</code>）、定义和管理数据库对象（<code>DDL</code>）、控制权限（<code>DCL</code>）以及管理事务（<code>TCL</code>）等。除了这些通用的 SQL 语法，MySQL 还提供了一系列针对自身特性的命令和工具，用于执行数据库的优化、备份、恢复、用户管理、数据导入导出以及性能监控等操作。本文将按照常见分类，对 MySQL 中的各类命令进行详细的介绍与示例说明。</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>数据定义语言。</p><h3 id="CREATE-DATABASE-创建数据库"><a href="#CREATE-DATABASE-创建数据库" class="headerlink" title="CREATE DATABASE - 创建数据库"></a>CREATE DATABASE - 创建数据库</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE DATABASE [IF NOT EXISTS] database_name<br>    [DEFAULT CHARACTER SET charset_name]<br>    [COLLATE collation_name];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF NOT EXISTS</strong>：如果数据库已存在，则不报错。</li><li><strong>DEFAULT CHARACTER SET</strong>：指定数据库默认字符集。</li><li><strong>COLLATE</strong>：指定字符集对应的校对规则。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS mydb<br>    DEFAULT CHARACTER SET utf8mb4<br>    COLLATE utf8mb4_general_ci;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>数据库名不能与已有的数据库重复（使用 <code>IF NOT EXISTS</code> 可避免错误）。</li><li>修改数据库默认字符集和校对规则只影响新建的数据表，已存在的表不会更改。</li><li>执行该命令需要相应的权限（如 <code>CREATE</code> 权限）。</li></ul><h3 id="DROP-DATABASE-删除数据库"><a href="#DROP-DATABASE-删除数据库" class="headerlink" title="DROP DATABASE - 删除数据库"></a>DROP DATABASE - 删除数据库</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP DATABASE [IF EXISTS] database_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a><strong>常见参数</strong></h4><ul><li><strong>IF EXISTS</strong>：如果数据库不存在，则不报错。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP DATABASE IF EXISTS mydb;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>删除数据库会同时删除该数据库中的所有数据和对象，操作不可逆。</li><li>建议在删除前先备份数据，避免误删。</li><li>执行该命令需要相应的权限（如 <code>DROP</code> 权限）。</li></ul><h3 id="ALTER-DATABASE-修改数据库属性"><a href="#ALTER-DATABASE-修改数据库属性" class="headerlink" title="ALTER DATABASE - 修改数据库属性"></a>ALTER DATABASE - 修改数据库属性</h3><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER DATABASE database_name<br>    [DEFAULT CHARACTER SET charset_name]<br>    [COLLATE collation_name];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-2"><a href="#常见参数-2" class="headerlink" title="常见参数"></a><strong>常见参数</strong></h4><ul><li><strong>DEFAULT CHARACTER SET</strong>：修改数据库的默认字符集。</li><li><strong>COLLATE</strong>：修改数据库的校对规则。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER DATABASE mydb<br>    DEFAULT CHARACTER SET utf8<br>    COLLATE utf8_general_ci;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>该命令主要用于修改数据库的默认设置，对已存在的表不会产生直接影响。</li><li>修改字符集和校对规则时需谨慎，避免数据出现编码问题。</li><li>执行该命令需要相应的权限。</li></ul><h3 id="CREATE-TABLE-创建数据表"><a href="#CREATE-TABLE-创建数据表" class="headerlink" title="CREATE TABLE - 创建数据表"></a>CREATE TABLE - 创建数据表</h3><h4 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] table_name (<br>    column1 datatype [column_constraint],<br>    column2 datatype [column_constraint],<br>    ...<br>    [table_constraint]<br>) [table_options];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-3"><a href="#常见参数-3" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF NOT EXISTS</strong>：如果表已存在，则不报错。</li><li><strong>datatype、constraint</strong>：数据类型和约束。</li><li><strong>table_options</strong>：如 <code>ENGINE</code>、<code>DEFAULT CHARSET</code> 等选项。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS users (<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    name VARCHAR(50) NOT NULL,<br>    age INT,<br>    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>表名和字段名建议遵循命名规范，避免使用 <code>MySQL</code> 保留关键字。</li><li>选择合适的数据类型和存储引擎，能提高性能。</li><li>确保设计的主键、索引满足查询需求。</li></ul><h3 id="DROP-TABLE-删除数据表"><a href="#DROP-TABLE-删除数据表" class="headerlink" title="DROP TABLE - 删除数据表"></a>DROP TABLE - 删除数据表</h3><h4 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] table_name [, table_name2, ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-4"><a href="#常见参数-4" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果表不存在，则不报错。</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP TABLE IF EXISTS users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除表会同时删除表中的所有数据和结构，操作不可逆。</li><li>建议在删除前备份重要数据。</li><li>执行该命令需要有 <code>DROP</code> 权限。</li></ul><h3 id="ALTER-TABLE-修改表结构"><a href="#ALTER-TABLE-修改表结构" class="headerlink" title="ALTER TABLE - 修改表结构"></a>ALTER TABLE - 修改表结构</h3><h4 id="语法格式-5"><a href="#语法格式-5" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name<br>    alteration_action [, alteration_action2, ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数及操作"><a href="#常见参数及操作" class="headerlink" title="常见参数及操作"></a>常见参数及操作</h4><ul><li><p><strong>ADD COLUMN</strong>：添加新列</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD COLUMN column_name datatype [constraint];<br></code></pre></div></td></tr></table></figure></li><li><p><strong>DROP COLUMN</strong>：删除已有列</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name DROP COLUMN column_name;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>MODIFY COLUMN</strong>：修改列的数据类型或约束</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name MODIFY COLUMN column_name new_datatype [new_constraint];<br></code></pre></div></td></tr></table></figure></li><li><p><strong>CHANGE COLUMN</strong>：重命名列并修改数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name CHANGE COLUMN old_name new_name new_datatype [constraint];<br></code></pre></div></td></tr></table></figure></li><li><p><strong>ADD INDEX/PRIMARY KEY</strong>：添加索引或主键</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name ADD INDEX IDX_X;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>DROP INDEX/PRIMARY KEY</strong>：删除索引或主键</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name DROP INDEX IDX_X;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>RENAME INDEX</strong>：重命名索引（MySQL 8.0 及以上）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER TABLE table_name RENAME INDEX old_index_name TO new_index_name;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 添加新列<br>ALTER TABLE users ADD COLUMN email VARCHAR(100) NOT NULL;<br><br># 修改列数据类型<br>ALTER TABLE users MODIFY COLUMN age SMALLINT;<br><br># 重命名列并修改类型<br>ALTER TABLE users CHANGE COLUMN name username VARCHAR(60) NOT NULL;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>ALTER</code> 操作可能会锁定表，影响并发性能，建议在低峰期操作。</li><li>修改列的类型时要确保新数据类型兼容已有数据，避免数据丢失。</li><li>某些 <code>ALTER</code> 操作可能无法撤销，操作前建议备份数据。</li><li>若需要修改索引的列或类型，建议先 <code>DROP</code> 索引，再重新 <code>CREATE</code> 新索引。</li></ul><h3 id="TRUNCATE-TABLE-清空表数据"><a href="#TRUNCATE-TABLE-清空表数据" class="headerlink" title="TRUNCATE TABLE - 清空表数据"></a>TRUNCATE TABLE - 清空表数据</h3><h4 id="语法格式-6"><a href="#语法格式-6" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">TRUNCATE TABLE table_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-5"><a href="#常见参数-5" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>该命令没有其他参数，直接指定需要清空数据的表。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">TRUNCATE TABLE users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li><code>TRUNCATE TABLE</code> 会快速删除所有记录，并重置 <code>AUTO_INCREMENT</code> 计数器。</li><li>与 <code>DELETE</code> 不同，<code>TRUNCATE</code> 通常不能被回滚（依赖存储引擎），操作不可逆。</li><li>执行该命令需要相应的权限，同时要谨慎使用以免误删数据。</li></ul><h3 id="CREATE-INDEX-创建索引"><a href="#CREATE-INDEX-创建索引" class="headerlink" title="CREATE INDEX - 创建索引"></a>CREATE INDEX - 创建索引</h3><h4 id="语法格式-7"><a href="#语法格式-7" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE [UNIQUE] INDEX index_name<br>ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-6"><a href="#常见参数-6" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>UNIQUE</strong>：创建唯一索引，保证索引列中所有值唯一。</li><li><strong>ASC/DESC</strong>：指定列的排序顺序（默认通常为 <code>ASC</code>）。</li><li><strong>USING BTREE/FULLTEXT/HASH</strong>：指定索引类型，可根据存储引擎支持情况决定。</li></ul><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE INDEX idx_username ON users (username);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>索引能提高查询性能，但过多或不合理的索引会影响写操作（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的效率。</li><li>在创建唯一索引时，要确保数据中没有重复值，否则会导致创建失败。</li><li>部分存储引擎支持的索引类型有限，需参考具体引擎文档。</li></ul><h3 id="DROP-INDEX-删除索引"><a href="#DROP-INDEX-删除索引" class="headerlink" title="DROP INDEX - 删除索引"></a>DROP INDEX - 删除索引</h3><h4 id="语法格式-8"><a href="#语法格式-8" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP INDEX index_name ON table_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-7"><a href="#常见参数-7" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>需要指定 <code>index_name</code> 及其所在的 <code>table_name</code>。</li></ul><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP INDEX idx_username ON users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除索引会影响查询优化计划，操作前应评估索引对系统性能的影响。</li><li>删除索引不会影响表中实际数据，但可能影响外键约束（如涉及唯一性要求时）。</li></ul><h3 id="CREATE-VIEW-创建视图"><a href="#CREATE-VIEW-创建视图" class="headerlink" title="CREATE VIEW - 创建视图"></a>CREATE VIEW - 创建视图</h3><h4 id="语法格式-9"><a href="#语法格式-9" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]<br>VIEW view_name [(column_list)]<br>AS select_statement<br>[WITH [CASCADED | LOCAL] CHECK OPTION];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-8"><a href="#常见参数-8" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>OR REPLACE</strong>：如果视图已存在，则替换原视图定义。</li><li><strong>ALGORITHM</strong>：指定视图处理算法，常用值包括 MERGE（将视图查询合并到主查询中）和 <code>TEMPTABLE</code>（使用临时表存储中间结果）。</li><li><strong>column_list</strong>：定义视图中各列的名称（可选，如果不指定则使用查询中返回的列名）。</li><li><strong>WITH [CASCADED | LOCAL] CHECK OPTION</strong>：用于限制通过视图插入或更新数据时，必须满足视图定义的条件。</li></ul><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE VIEW user_view AS<br>SELECT id, username, email<br>FROM users<br>WHERE status = &#x27;active&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>视图本质上是存储的查询语句，不存储实际数据，修改视图后，查询结果会实时反映最新数据。</li><li>使用 <code>CHECK OPTION</code> 可防止插入不符合视图条件的数据，但要注意级联（<code>CASCADED</code>）和本地（<code>LOCAL</code>）选项的差异。</li><li>部分复杂视图（如包含聚合、子查询、联接等）可能会受到更新限制。</li></ul><h3 id="DROP-VIEW-删除视图"><a href="#DROP-VIEW-删除视图" class="headerlink" title="DROP VIEW - 删除视图"></a>DROP VIEW - 删除视图</h3><h4 id="语法格式-10"><a href="#语法格式-10" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP VIEW [IF EXISTS] view_name [, view_name2, ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-9"><a href="#常见参数-9" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果视图不存在，则不报错，可同时删除多个视图。</li></ul><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP VIEW IF EXISTS user_view;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除视图只会移除视图定义，不会删除视图所引用的底层数据表。</li><li>视图被其他对象（如存储过程）引用时，删除前需评估可能带来的影响。</li></ul><h3 id="ALTER-VIEW-修改视图"><a href="#ALTER-VIEW-修改视图" class="headerlink" title="ALTER VIEW - 修改视图"></a>ALTER VIEW - 修改视图</h3><h4 id="语法格式-11"><a href="#语法格式-11" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER VIEW view_name<br>AS select_statement<br>[WITH [CASCADED | LOCAL] CHECK OPTION];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-10"><a href="#常见参数-10" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>参数基本与 <code>CREATE VIEW</code> 类似，主要用于修改视图的查询定义。</li><li>可使用 <code>WITH CHECK OPTION</code> 限制通过视图进行数据操作时的数据有效性。</li></ul><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALTER VIEW user_view AS<br>SELECT id, username, email, created_at<br>FROM users<br>WHERE status = &#x27;active&#x27;<br>WITH CHECK OPTION;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>ALTER VIEW</code> 会完全替换原有的视图定义，因此修改时应确保新定义与业务逻辑一致。</li><li>对于某些复杂视图，修改后可能导致权限、依赖关系或更新限制等问题，需要额外验证。</li><li>视图的更新性受限于其查询定义，若包含多表联接、聚合等，可能会导致视图不可更新。</li></ul><h3 id="CREATE-TRIGGER-创建触发器"><a href="#CREATE-TRIGGER-创建触发器" class="headerlink" title="CREATE TRIGGER - 创建触发器"></a>CREATE TRIGGER - 创建触发器</h3><h4 id="语法格式-12"><a href="#语法格式-12" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TRIGGER trigger_name<br>    &#123;BEFORE | AFTER&#125; &#123;INSERT | UPDATE | DELETE&#125;<br>    ON table_name<br>    FOR EACH ROW<br>    trigger_body<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-11"><a href="#常见参数-11" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>触发时间</strong>：<code>BEFORE</code> 或 <code>AFTER</code>，决定触发器在操作前还是操作后执行。</li><li><strong>触发事件</strong>：<code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>，指定触发器响应的数据修改操作。</li><li><strong>FOR EACH ROW</strong>：<code>MySQL</code> 只支持逐行触发器，必须为每一行操作执行触发器体。</li><li><strong>trigger_body</strong>：可以是一个简单的 SQL 语句或一个包含多条 SQL 语句的 <code>BEGIN...END</code> 块。</li></ul><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TRIGGER before_insert_users<br>BEFORE INSERT ON users<br>FOR EACH ROW<br>SET NEW.created_at = NOW();<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>每个表每个操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）只能有一个触发器。</li><li>触发器中的操作要尽量保持简单，以免影响数据修改性能。</li><li>触发器在执行过程中出现错误会导致原始操作失败，需谨慎调试和使用。</li></ul><h3 id="DROP-TRIGGER-删除触发器"><a href="#DROP-TRIGGER-删除触发器" class="headerlink" title="DROP TRIGGER - 删除触发器"></a>DROP TRIGGER - 删除触发器</h3><h4 id="语法格式-13"><a href="#语法格式-13" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-12"><a href="#常见参数-12" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果触发器不存在则不报错。</li><li>可通过指定 <code>schema_name</code> 来明确触发器所属的数据库。</li></ul><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP TRIGGER IF EXISTS before_insert_users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除触发器将移除与之绑定的自动执行逻辑，操作不可逆。</li><li>执行该命令需要相应的权限。</li></ul><h3 id="CREATE-PROCEDURE-创建存储过程"><a href="#CREATE-PROCEDURE-创建存储过程" class="headerlink" title="CREATE PROCEDURE - 创建存储过程"></a>CREATE PROCEDURE - 创建存储过程</h3><h4 id="语法格式-14"><a href="#语法格式-14" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE procedure_name ([IN|OUT|INOUT] param1 datatype, ...)<br>BEGIN<br>    -- SQL 语句块<br>    statement;<br>    ...<br>END //<br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-13"><a href="#常见参数-13" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>参数类型</strong>：<code>IN</code>（输入参数）、<code>OUT</code>（输出参数）、<code>INOUT</code>（输入输出参数）。</li><li><strong>语句块</strong>：通常使用 <code>BEGIN ... END</code> 包含多条 <code>SQL</code> 语句。</li><li>需更改定界符（<code>DELIMITER</code>）以避免与存储过程内的语句结束符冲突。</li></ul><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE sp_get_users()<br>BEGIN<br>    SELECT * FROM users;<br>END //<br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>存储过程不会直接返回结果集，而是通过 <code>SELECT</code> 语句或输出参数传递数据。</li><li>调用时需要使用 <code>CALL procedure_name();</code>。</li><li>需要确保过程内的逻辑正确，避免影响事务和并发性能。</li></ul><h3 id="DROP-PROCEDURE-删除存储过程"><a href="#DROP-PROCEDURE-删除存储过程" class="headerlink" title="DROP PROCEDURE - 删除存储过程"></a>DROP PROCEDURE - 删除存储过程</h3><h4 id="语法格式-15"><a href="#语法格式-15" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP PROCEDURE [IF EXISTS] procedure_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-14"><a href="#常见参数-14" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果存储过程不存在，则不报错。</li></ul><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP PROCEDURE IF EXISTS sp_get_users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-15"><a href="#注意事项-15" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除存储过程后，依赖该过程的业务逻辑将失效，操作前应确认。</li><li>需要相应的权限才能删除存储过程。</li></ul><h3 id="CREATE-FUNCTION-创建用户自定义函数"><a href="#CREATE-FUNCTION-创建用户自定义函数" class="headerlink" title="CREATE FUNCTION - 创建用户自定义函数"></a>CREATE FUNCTION - 创建用户自定义函数</h3><h4 id="语法格式-16"><a href="#语法格式-16" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER //<br>CREATE FUNCTION function_name ([IN] param1 datatype, ...)<br>RETURNS return_data_type<br>    [characteristic ...]<br>BEGIN<br>    -- SQL 语句块<br>    RETURN expression;<br>END //<br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-15"><a href="#常见参数-15" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>参数</strong>：函数通常只支持 <code>IN</code> 参数。</li><li><strong>RETURNS</strong>：必须定义返回值的数据类型。</li><li><strong>characteristic</strong>：可选特性如 <code>DETERMINISTIC</code>、<code>NO SQL</code>、<code>READS SQL DATA</code> 等，用以描述函数的行为和优化器提示。</li></ul><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER //<br>CREATE FUNCTION get_full_name(first_name VARCHAR(50), last_name VARCHAR(50))<br>RETURNS VARCHAR(101)<br>DETERMINISTIC<br>BEGIN<br>    RETURN CONCAT(first_name, &#x27; &#x27;, last_name);<br>END //<br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-16"><a href="#注意事项-16" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>用户自定义函数（<code>UDF</code>）可以在 SQL 语句中调用，但需保证逻辑简单且执行效率高。</li><li>函数必须返回一个值，且返回类型不可省略。</li><li>权限要求较高，需确保用户有创建函数的权限。</li></ul><h3 id="DROP-FUNCTION-删除用户自定义函数"><a href="#DROP-FUNCTION-删除用户自定义函数" class="headerlink" title="DROP FUNCTION - 删除用户自定义函数"></a>DROP FUNCTION - 删除用户自定义函数</h3><h4 id="语法格式-17"><a href="#语法格式-17" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP FUNCTION [IF EXISTS] function_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-16"><a href="#常见参数-16" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果函数不存在，则不报错。</li></ul><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP FUNCTION IF EXISTS get_full_name;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-17"><a href="#注意事项-17" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除函数后，所有调用该函数的 SQL 语句可能会失效。</li><li>需确认无业务依赖后再执行删除操作。</li></ul><h3 id="CREATE-EVENT-创建事件"><a href="#CREATE-EVENT-创建事件" class="headerlink" title="CREATE EVENT - 创建事件"></a>CREATE EVENT - 创建事件</h3><h4 id="语法格式-18"><a href="#语法格式-18" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE EVENT [IF NOT EXISTS] event_name<br>ON SCHEDULE &#123;AT timestamp | EVERY interval [STARTS timestamp] [ENDS timestamp]&#125;<br>[ON COMPLETION [NOT] PRESERVE]<br>[ENABLE | DISABLE]<br>DO<br>event_body;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-17"><a href="#常见参数-17" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>ON SCHEDULE</strong>：指定事件的调度方式，可以是单次执行（<code>AT</code>）或周期性执行（<code>EVERY</code>）。</li><li><strong>STARTS/ENDS</strong>：定义周期性事件的起始和结束时间。</li><li><strong>ON COMPLETION [NOT] PRESERVE</strong>：决定事件执行完毕后是否保留事件信息（默认一次性事件在执行后会被删除）。</li><li><strong>ENABLE/DISABLE</strong>：控制事件是否启用。</li></ul><h4 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE EVENT IF NOT EXISTS cleanup_event<br>ON SCHEDULE EVERY 1 DAY<br>DO<br>DELETE FROM logs WHERE log_date &lt; NOW() - INTERVAL 30 DAY;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-18"><a href="#注意事项-18" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>必须启用事件调度器（<code>SET GLOBAL event_scheduler = ON;</code>）才能使事件生效。</li><li>周期性事件需要合理设置时间范围和间隔，避免对系统性能造成过大影响。</li><li>事件执行后可能影响数据，建议在生产环境前充分测试。</li></ul><h3 id="DROP-EVENT-删除事件"><a href="#DROP-EVENT-删除事件" class="headerlink" title="DROP EVENT - 删除事件"></a>DROP EVENT - 删除事件</h3><h4 id="语法格式-19"><a href="#语法格式-19" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP EVENT [IF EXISTS] event_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-18"><a href="#常见参数-18" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IF EXISTS</strong>：如果事件不存在则不报错。</li></ul><h4 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP EVENT IF EXISTS cleanup_event;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-19"><a href="#注意事项-19" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除事件将停止定时任务，不再自动执行预定操作。</li><li>操作前应确认事件不再需要或已迁移至其他机制中。</li></ul><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>数据库操作语言，主要用于操作数据表。</p><h3 id="INSERT-INTO-插入数据"><a href="#INSERT-INTO-插入数据" class="headerlink" title="INSERT INTO - 插入数据"></a>INSERT INTO - 插入数据</h3><h4 id="语法格式-20"><a href="#语法格式-20" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 单条插入<br>INSERT [LOW_PRIORITY | DELAYED] [IGNORE]<br>INTO table_name<br>SET column1 = value1[, (column2 = value2), ...];<br><br># 批量插入<br>INSERT [LOW_PRIORITY | DELAYED] [IGNORE]<br>INTO table_name [(column1, column2, ...)]<br>VALUES (value1, value2, ...)[, (value1, value2, ...)], ...;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-19"><a href="#常见参数-19" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>LOW_PRIORITY</strong>：在没有其他读取操作时再执行插入。</li><li><strong>DELAYED</strong>：将插入操作延迟执行（注意：该选项在新版本中已不推荐使用）。</li><li><strong>IGNORE</strong>：在遇到错误（如主键冲突）时跳过出错的行，而非终止整个操作。</li></ul><h4 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT INTO users<br>SET username = &#x27;alice&#x27;, email = &#x27;alice@example.com&#x27;, age = 25;<br><br>INSERT INTO users (username, email, age)<br>VALUES (&#x27;alice&#x27;, &#x27;alice@example.com&#x27;, 25),<br>       (&#x27;bob&#x27;, &#x27;bob@example.com&#x27;, 30);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-20"><a href="#注意事项-20" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果不指定列名，则要求所有列都必须按表的列顺序提供值。</li><li>使用 <code>IGNORE</code> 可避免因重复键值导致整个语句失败，但也可能隐藏数据异常。</li><li>插入大量数据时，可采用批量插入以提高效率。</li></ul><h3 id="UPDATE-修改数据"><a href="#UPDATE-修改数据" class="headerlink" title="UPDATE - 修改数据"></a>UPDATE - 修改数据</h3><h4 id="语法格式-21"><a href="#语法格式-21" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE [LOW_PRIORITY] table_name<br>SET column1 = value1, column2 = value2, ...<br>[WHERE condition]<br>[ORDER BY ...]<br>[LIMIT row_count];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-20"><a href="#常见参数-20" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>LOW_PRIORITY</strong>：延迟更新，待没有读取操作时再执行。</li><li><strong>WHERE</strong>：指定更新条件，避免对所有记录进行修改。</li><li><strong>ORDER BY</strong> 与 <strong>LIMIT</strong>：配合使用时可限制更新的行数及更新顺序。</li></ul><h4 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE users<br>SET age = age + 1<br>WHERE username = &#x27;alice&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-21"><a href="#注意事项-21" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>未加 <code>WHERE</code> 条件时，<code>UPDATE</code> 会作用于所有记录，可能造成数据错误。</li><li>更新过程中建议使用事务管理，确保数据一致性。</li><li>同一表上同时有多个更新操作时，要注意锁机制对并发性能的影响。</li></ul><h3 id="DELETE-FROM-删除数据"><a href="#DELETE-FROM-删除数据" class="headerlink" title="DELETE FROM - 删除数据"></a>DELETE FROM - 删除数据</h3><h4 id="语法格式-22"><a href="#语法格式-22" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELETE [LOW_PRIORITY] FROM table_name<br>[WHERE condition]<br>[ORDER BY ...]<br>[LIMIT row_count];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-21"><a href="#常见参数-21" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>LOW_PRIORITY</strong>：延迟删除操作，待没有读取操作时再执行。</li><li><strong>WHERE</strong>：指定删除条件，避免误删所有记录。</li><li><strong>ORDER BY</strong> 与 <strong>LIMIT</strong>：用于限定删除的记录数及顺序。</li></ul><h4 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELETE FROM users<br>WHERE age &lt; 18;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-22"><a href="#注意事项-22" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>同 <code>UPDATE</code> 一样，缺少 <code>WHERE</code> 条件会删除表中所有记录。</li><li>对大表执行 <code>DELETE</code> 操作时，可能会锁表或导致性能问题，必要时可分批删除。</li><li>删除操作建议做好数据备份以防误删。</li></ul><h3 id="REPLACE-INTO-插入数据"><a href="#REPLACE-INTO-插入数据" class="headerlink" title="REPLACE INTO - 插入数据"></a>REPLACE INTO - 插入数据</h3><h4 id="语法格式-23"><a href="#语法格式-23" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REPLACE [LOW_PRIORITY] INTO table_name [(column1, column2, ...)]<br>VALUES (value1, value2, ...)[, (value1, value2, ...)], ...;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-22"><a href="#常见参数-22" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>与 <code>INSERT</code> 类似，但 <code>REPLACE</code> 语句在遇到主键或唯一索引冲突时会先删除旧记录，再插入新记录。</li></ul><h4 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REPLACE INTO users (id, username, email)<br>VALUES (1, &#x27;alice&#x27;, &#x27;alice_new@example.com&#x27;);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-23"><a href="#注意事项-23" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>REPLACE</code> 的执行过程先执行删除操作，再插入新记录，因此可能引起触发器执行、外键约束及自动递增值重置等问题。</li><li>对于需要更新部分字段的场景，推荐使用 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 语法以减少副作用。</li><li><code>REPLACE</code> 操作可能导致删除记录的副作用（例如级联删除）。</li></ul><h3 id="INSERT-INTO-…-SELECT-查询并插入"><a href="#INSERT-INTO-…-SELECT-查询并插入" class="headerlink" title="INSERT INTO … SELECT - 查询并插入"></a>INSERT INTO … SELECT - 查询并插入</h3><h4 id="语法格式-24"><a href="#语法格式-24" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT [LOW_PRIORITY | IGNORE] INTO target_table [(column1, column2, ...)]<br>SELECT expression1, expression2, ...<br>FROM source_table<br>[WHERE condition];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-23"><a href="#常见参数-23" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>IGNORE</strong>：忽略因数据冲突引起的错误。</li><li><strong>WHERE</strong>：筛选需要插入的数据行。</li></ul><h4 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT INTO backup_users (username, email, age)<br>SELECT username, email, age<br>FROM users<br>WHERE created_at &lt; &#x27;2022-01-01&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-24"><a href="#注意事项-24" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>源表和目标表的字段对应和数据类型要匹配。</li><li><code>INSERT INTO ... SELECT</code> 常用于数据迁移和备份，操作前建议确认数据一致性。</li><li>如果目标表存在约束（如唯一性约束），可能导致部分行插入失败。</li></ul><h3 id="LOAD-DATA-INFILE-批量导入数据"><a href="#LOAD-DATA-INFILE-批量导入数据" class="headerlink" title="LOAD DATA INFILE - 批量导入数据"></a>LOAD DATA INFILE - 批量导入数据</h3><h4 id="语法格式-25"><a href="#语法格式-25" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#x27;file_name&#x27;<br>[REPLACE | IGNORE]<br>INTO TABLE table_name<br>[CHARACTER SET charset_name]<br>[FIELDS<br>    [TERMINATED BY &#x27;string&#x27;]<br>    [OPTIONALLY] ENCLOSED BY &#x27;char&#x27;<br>    [ESCAPED BY &#x27;char&#x27;]<br>]<br>[LINES<br>    [STARTING BY &#x27;string&#x27;]<br>    [TERMINATED BY &#x27;string&#x27;]<br>]<br>[IGNORE number LINES]<br>[(column1, column2, ...)];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-24"><a href="#常见参数-24" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>LOCAL</strong>：文件位于客户端而非服务器。</li><li><strong>REPLACE/IGNORE</strong>：指定遇到重复记录时的处理方式。</li><li><strong>CHARACTER SET</strong>：指定文件的字符集。</li><li><strong>FIELDS 和 LINES</strong>：定义字段和行的分隔符、包围符及转义字符。</li><li><strong>IGNORE n LINES</strong>：跳过文件开头的 n 行数据（如标题行）。</li></ul><h4 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">LOAD DATA LOCAL INFILE &#x27;/path/to/data.csv&#x27;<br>INTO TABLE users<br>CHARACTER SET utf8mb4<br>FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;<br>LINES TERMINATED BY &#x27;\n&#x27;<br>IGNORE 1 LINES;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-25"><a href="#注意事项-25" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用 <code>LOAD DATA INFILE</code> 时需确认文件权限及路径正确，MySQL 服务器需要有读取该文件的权限。</li><li>不同平台的换行符可能不同，需根据实际情况调整 <code>LINES TERMINATED BY</code> 的参数。</li><li>若数据中含有特殊字符，注意转义设置，确保数据正确导入。</li></ul><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>数据查询语言。</p><h3 id="SELECT-查询数据"><a href="#SELECT-查询数据" class="headerlink" title="SELECT - 查询数据"></a>SELECT - 查询数据</h3><h4 id="语法格式-26"><a href="#语法格式-26" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT [ALL | DISTINCT] select_expr [, select_expr ...]<br>FROM table_reference<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-25"><a href="#常见参数-25" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>ALL</strong>：默认，返回所有记录（包括重复值）。</li><li><strong>DISTINCT</strong>：用于去除重复行（见下一部分说明）。</li><li><strong>select_expr</strong>：可以是一个或多个列、表达式，甚至是函数计算的结果。</li><li>可选的 FROM，用于进一步限定结果。</li></ul><h4 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT id, username, email<br>FROM users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-26"><a href="#注意事项-26" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果省略 <code>FROM</code> 子句，MySQL 允许从表达式（如 <code>SELECT 1+1;</code>）中返回结果。</li><li>根据实际业务需要选择合适的列和子句，避免返回不必要的数据。</li><li>大型查询时注意优化（如使用索引、合理拆分子查询等）。</li></ul><h3 id="DISTINCT-去重查询"><a href="#DISTINCT-去重查询" class="headerlink" title="DISTINCT - 去重查询"></a>DISTINCT - 去重查询</h3><h4 id="语法格式-27"><a href="#语法格式-27" class="headerlink" title="语法格式"></a>语法格式</h4><p>在 <code>SELECT</code> 语句中使用，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT select_expr [, select_expr ...]<br>FROM table_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-26"><a href="#常见参数-26" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>DISTINCT</strong>：放在 <code>SELECT</code> 后，用于剔除结果集中的重复记录。</li></ul><h4 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT country<br>FROM users;<br></code></pre></div></td></tr></table></figure><p>（返回 <code>users</code> 表中不同的 <code>country</code> 值。）</p><h4 id="注意事项-27"><a href="#注意事项-27" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>DISTINCT</code> 会对整个结果行进行判断，相比普通 <code>SELECT</code> 会增加额外的排序或去重开销。</li><li>对性能有一定影响，尤其在大数据量查询中，建议仅在必要时使用。</li></ul><h3 id="WHERE-过滤查询条件"><a href="#WHERE-过滤查询条件" class="headerlink" title="WHERE - 过滤查询条件"></a>WHERE - 过滤查询条件</h3><h4 id="语法格式-28"><a href="#语法格式-28" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>WHERE condition;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-27"><a href="#常见参数-27" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>condition</strong>：可以包含比较运算符（<code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>）、逻辑运算符（<code>AND</code>、<code>OR</code>、<code>NOT</code>）、<code>BETWEEN</code>、<code>LIKE</code>、<code>IN</code>、<code>IS NULL</code> 等，用于限定返回的行。</li></ul><h4 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT id, username, email<br>FROM users<br>WHERE age &gt;= 18 AND status = &#x27;active&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-28"><a href="#注意事项-28" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>WHERE</code> 子句过滤的是行数据，在分组（<code>GROUP BY</code>）前执行。</li><li>对涉及大量数据的列，应考虑建立索引以提高过滤效率。</li><li>注意条件中数据类型的匹配和空值的处理。</li></ul><h3 id="ORDER-BY-对查询结果排序"><a href="#ORDER-BY-对查询结果排序" class="headerlink" title="ORDER BY - 对查询结果排序"></a>ORDER BY - 对查询结果排序</h3><h4 id="语法格式-29"><a href="#语法格式-29" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>ORDER BY expression [ASC | DESC] [, expression [ASC | DESC] ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-28"><a href="#常见参数-28" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>expression</strong>：可以是列名、表达式或列的别名。</li><li><strong>ASC</strong>（默认）或 <strong>DESC</strong>：指定升序或降序排序。</li></ul><h4 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT id, username, created_at<br>FROM users<br>ORDER BY created_at DESC, username ASC;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-29"><a href="#注意事项-29" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>排序会增加额外的处理开销，尤其当数据量大且没有合适的索引时。</li><li>在使用 <code>ORDER BY</code> 时，建议对排序字段建立索引以提高性能。</li><li>排序顺序可以混合使用升序和降序，但要确保逻辑清晰。</li></ul><h3 id="GROUP-BY-对查询结果分组"><a href="#GROUP-BY-对查询结果分组" class="headerlink" title="GROUP BY - 对查询结果分组"></a>GROUP BY - 对查询结果分组</h3><h4 id="语法格式-30"><a href="#语法格式-30" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns, aggregate_function(column)<br>FROM table_name<br>WHERE condition<br>GROUP BY expression [, expression ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-29"><a href="#常见参数-29" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>expression</strong>：通常为分组依据的列，可以是单个列或多个列。</li><li>常用聚合函数：如 <code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等，用于对每个分组进行统计计算。</li></ul><h4 id="示例-30"><a href="#示例-30" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT country, COUNT(*) AS user_count<br>FROM users<br>GROUP BY country;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-30"><a href="#注意事项-30" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>GROUP BY</code> 在 <code>WHERE</code> 过滤之后、<code>HAVING</code> 过滤之前执行。</li><li><code>SELECT</code> 中的非聚合列必须出现在 <code>GROUP BY</code> 子句中（或者依赖于 MySQL 的扩展特性，但建议遵守标准写法）。</li><li>对分组结果进行排序时，可结合 <code>ORDER BY</code> 使用。</li></ul><h3 id="HAVING-过滤分组后的数据"><a href="#HAVING-过滤分组后的数据" class="headerlink" title="HAVING - 过滤分组后的数据"></a>HAVING - 过滤分组后的数据</h3><h4 id="语法格式-31"><a href="#语法格式-31" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns, aggregate_function(column)<br>FROM table_name<br>GROUP BY expression<br>HAVING aggregate_function(column) condition;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-30"><a href="#常见参数-30" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>condition</strong>：用于对分组后的结果进行过滤，通常基于聚合函数的计算结果（如 <code>COUNT</code>、<code>SUM</code> 等）。</li></ul><h4 id="示例-31"><a href="#示例-31" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT country, COUNT(*) AS user_count<br>FROM users<br>GROUP BY country<br>HAVING COUNT(*) &gt; 10;<br></code></pre></div></td></tr></table></figure><p>（返回用户数大于 <code>10</code> 的各 <code>country</code> 分组）</p><h4 id="注意事项-31"><a href="#注意事项-31" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>HAVING</code> 子句用于过滤经过 <code>GROUP BY</code> 分组后的数据，与 <code>WHERE</code> 子句作用的层次不同。</li><li>当不使用聚合函数时，<code>HAVING</code> 也可用于过滤，但建议使用 <code>WHERE</code>，一般情况下，<code>HAVING</code> 应仅用于聚合数据的过滤。</li><li><code>HAVING</code> 会在分组计算后执行，故相对 <code>WHERE</code> 有额外的性能开销，尽量将非聚合的过滤条件放到 <code>WHERE</code> 子句中。</li></ul><h3 id="LIMIT-限制查询结果的条数"><a href="#LIMIT-限制查询结果的条数" class="headerlink" title="LIMIT - 限制查询结果的条数"></a>LIMIT - 限制查询结果的条数</h3><h4 id="语法格式-32"><a href="#语法格式-32" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>LIMIT [offset,] row_count;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-31"><a href="#常见参数-31" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>row_count</strong>：返回记录的最大行数。</li><li><strong>offset</strong>：可选参数，表示从结果集的第几行开始返回数据（注意：<code>offset</code> 从 <code>0</code> 开始计数）。</li></ul><h4 id="示例-32"><a href="#示例-32" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM users<br>LIMIT 10;  -- 返回前 10 行记录<br><br>SELECT * FROM users<br>LIMIT 5, 10;  -- 从第 6 行开始返回 10 行记录<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-32"><a href="#注意事项-32" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在大数据量查询中，使用较大的 <code>offset</code> 会影响性能，因为 MySQL 需要扫描并丢弃 <code>offset</code> 之前的记录。</li><li>对结果顺序有要求时应配合 <code>ORDER BY</code> 子句使用。</li></ul><h3 id="JOIN-连接多个表进行查询"><a href="#JOIN-连接多个表进行查询" class="headerlink" title="JOIN - 连接多个表进行查询"></a>JOIN - 连接多个表进行查询</h3><h4 id="语法格式-33"><a href="#语法格式-33" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table1<br>[INNER | LEFT | RIGHT | CROSS] JOIN table2<br>ON join_condition;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-32"><a href="#常见参数-32" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>INNER JOIN</strong>：返回两个表中满足联接条件的交集记录，也可以直接写 <code>JOIN</code>，默认即为 <code>INNER JOIN</code>。</li><li>**LEFT JOIN (LEFT OUTER JOIN)**：返回左表的所有记录及右表中满足联接条件的记录，右表无匹配时返回 <code>NULL</code>。</li><li>**RIGHT JOIN (RIGHT OUTER JOIN)**：返回右表的所有记录及左表中满足联接条件的记录，左表无匹配时返回 <code>NULL</code>。</li><li><strong>CROSS JOIN</strong>：返回两个表的笛卡尔积。</li></ul><h4 id="示例-33"><a href="#示例-33" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT u.username, o.order_date<br>FROM users u<br>INNER JOIN orders o<br>ON u.id = o.user_id;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-33"><a href="#注意事项-33" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>联接条件（<code>ON</code> 子句）必须正确指定，否则可能导致数据重复或返回不正确结果。</li><li>不同的 <code>JOIN</code> 类型会影响结果集内容和性能，选择时应根据业务逻辑和数据量进行判断。</li><li>多表联接时建议为关联字段建立索引，以提高查询效率。</li></ul><h3 id="UNION-合并多个查询结果集"><a href="#UNION-合并多个查询结果集" class="headerlink" title="UNION - 合并多个查询结果集"></a>UNION - 合并多个查询结果集</h3><h4 id="语法格式-34"><a href="#语法格式-34" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns FROM table1<br>UNION [ALL]<br>SELECT columns FROM table2;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-33"><a href="#常见参数-33" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>UNION ALL</strong>：返回所有记录，包括重复数据，不进行去重操作。默认 <code>UNION</code> 会自动去重，即返回不重复的记录集。</li></ul><h4 id="示例-34"><a href="#示例-34" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username FROM users<br>UNION<br>SELECT username FROM admins;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-34"><a href="#注意事项-34" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>联合的各个 <code>SELECT</code> 语句的字段数及对应数据类型必须一致。</li><li>使用 <code>UNION</code> 时，默认进行去重处理，可能会增加额外的排序开销，若允许重复可使用 <code>UNION ALL</code>。</li><li><code>UNION</code> 适用于合并来自不同表或查询的结果，但不支持 <code>ORDER BY</code> 用于每个子查询，只能在最外层使用。</li></ul><h3 id="EXISTS-判断子查询是否返回结果"><a href="#EXISTS-判断子查询是否返回结果" class="headerlink" title="EXISTS - 判断子查询是否返回结果"></a>EXISTS - 判断子查询是否返回结果</h3><h4 id="语法格式-35"><a href="#语法格式-35" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>WHERE EXISTS (subquery);<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-34"><a href="#常见参数-34" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>subquery</strong>：子查询，通常返回一列数据，用于检查是否存在满足条件的记录。<code>EXISTS</code> 子句返回布尔值，如果子查询至少返回一行数据，则为 <code>TRUE</code>，否则为 <code>FALSE</code>。</li><li><strong>NOT EXISTS</strong>：子查询逻辑取反。</li></ul><h4 id="示例-35"><a href="#示例-35" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username<br>FROM users<br>WHERE EXISTS (<br>    SELECT 1<br>    FROM orders<br>    WHERE orders.user_id = users.id<br>);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-35"><a href="#注意事项-35" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>EXISTS</code> 子查询通常用于相关子查询，能在检查条件时较快返回结果。</li><li>与 <code>IN</code> 子查询相比，<code>EXISTS</code> 在处理大量数据时可能更高效，尤其当子查询结果集较大时。</li><li>子查询中的 <code>SELECT</code> 子句一般不需要返回具体数据，常用 <code>SELECT 1</code> 或 <code>SELECT *</code>。</li></ul><h3 id="IN-判断值是否属于某个集合"><a href="#IN-判断值是否属于某个集合" class="headerlink" title="IN - 判断值是否属于某个集合"></a>IN - 判断值是否属于某个集合</h3><h4 id="语法格式-36"><a href="#语法格式-36" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>WHERE column IN (value1, value2, ...);<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-35"><a href="#常见参数-35" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>NOT IN</strong>：判断逻辑取反。</li><li>列表中的值可以是常量列表，也可以是子查询返回的结果集，支持嵌套使用，与 <code>NOT IN</code> 类似用于排除指定值。</li></ul><h4 id="示例-36"><a href="#示例-36" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username<br>FROM users<br>WHERE country IN (&#x27;USA&#x27;, &#x27;Canada&#x27;, &#x27;UK&#x27;);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-36"><a href="#注意事项-36" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用 <code>IN</code> (子查询) 时，子查询返回的值应与外层比较字段数据类型一致。</li><li>对于较大的常量列表，IN 子句可能影响查询效率，此时可以考虑将数据存储到临时表中进行联接查询。</li><li>当子查询返回 <code>NULL</code> 时，需注意与 <code>NOT IN</code> 的区别可能引发意外结果。</li></ul><h3 id="LIKE-模糊匹配查询"><a href="#LIKE-模糊匹配查询" class="headerlink" title="LIKE - 模糊匹配查询"></a>LIKE - 模糊匹配查询</h3><h4 id="语法格式-37"><a href="#语法格式-37" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>WHERE column LIKE pattern;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-36"><a href="#常见参数-36" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>NOT LIKE</strong>：模糊匹配逻辑取反。</li><li><strong>pattern</strong>：指定匹配模式，可以包含通配符<ul><li>**%**：匹配任意数量（零个或多个）任意字符</li><li>**_**：匹配单个任意字符</li></ul></li></ul><h4 id="示例-37"><a href="#示例-37" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username<br>FROM users<br>WHERE username LIKE &#x27;A%&#x27;;  -- 匹配以 A 开头的用户名<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-37"><a href="#注意事项-37" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>LIKE</code> 匹配是大小写敏感或不敏感取决于字符集和校对规则。</li><li>使用通配符开头（如 <code>%abc</code>）可能导致全表扫描，影响查询性能。</li><li>对需要频繁模糊查询的字段可考虑建立全文索引。</li></ul><h3 id="AS-为字段或表设置别名"><a href="#AS-为字段或表设置别名" class="headerlink" title="AS - 为字段或表设置别名"></a>AS - 为字段或表设置别名</h3><h4 id="语法格式-38"><a href="#语法格式-38" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT expression AS alias_name<br>FROM table_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-37"><a href="#常见参数-37" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>alias_name</strong>：指定给列或表的别名，便于结果集阅读或简化查询语句。别名可以用于列、表达式，甚至表名，便于后续引用。</li></ul><h4 id="示例-38"><a href="#示例-38" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username AS user, email AS contact_email<br>FROM users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-38"><a href="#注意事项-38" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>AS</code> 是可选关键字，可以直接用空格分隔表达式和别名。</li><li>在复杂查询中使用别名能提高 SQL 的可读性和维护性。</li><li>别名应避免与表中字段名冲突，且尽量采用易于理解的命名。</li></ul><h3 id="SUBQUERY（子查询）-在查询中嵌套其他查询"><a href="#SUBQUERY（子查询）-在查询中嵌套其他查询" class="headerlink" title="SUBQUERY（子查询） - 在查询中嵌套其他查询"></a>SUBQUERY（子查询） - 在查询中嵌套其他查询</h3><h4 id="语法格式-39"><a href="#语法格式-39" class="headerlink" title="语法格式"></a>语法格式</h4><p>子查询可以出现在 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>HAVING</code> 等子句中，基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>WHERE column operator (SELECT sub_columns FROM sub_table WHERE condition);<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-38"><a href="#常见参数-38" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><p><strong>相关子查询</strong>：子查询中引用外层查询的列。</p></li><li><p><strong>非相关子查询</strong>：子查询独立执行，与外层无直接关联。</p><p>（子查询可用于 <code>EXISTS</code>、<code>IN</code>、比较运算符等上下文中。）</p></li></ul><h4 id="示例-39"><a href="#示例-39" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">-- 非相关子查询示例<br>SELECT username, email<br>FROM users<br>WHERE id IN (SELECT user_id FROM orders WHERE order_date &gt; &#x27;2023-01-01&#x27;);<br><br>-- 相关子查询示例<br>SELECT username,<br>       (SELECT COUNT(*) FROM orders WHERE orders.user_id = users.id) AS order_count<br>FROM users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-39"><a href="#注意事项-39" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>子查询应尽量避免返回大量数据，以免影响整体查询性能。</li><li>当子查询中使用相关列时，每行外层数据都需执行一次子查询，可能导致效率问题。</li><li>可使用 <code>JOIN</code> 或 <code>EXISTS</code> 等方式重构子查询以提高性能和可维护性。</li><li>复杂子查询可以先通过临时表或视图分解，降低调试难度和提高执行效率。</li></ul><h2 id="TCL"><a href="#TCL" class="headerlink" title="TCL"></a>TCL</h2><p>事务控制语言。</p><h3 id="START-TRANSACTION-开启事务"><a href="#START-TRANSACTION-开启事务" class="headerlink" title="START TRANSACTION - 开启事务"></a>START TRANSACTION - 开启事务</h3><h4 id="语法格式-40"><a href="#语法格式-40" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-39"><a href="#常见参数-39" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>与 <code>BEGIN</code> 作用相同，用于标识事务的开始。</li><li>可与 <code>SET TRANSACTION</code> 结合使用，指定事务的隔离级别及读写属性（须在事务开始后立即设置）。</li></ul><h4 id="示例-40"><a href="#示例-40" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-40"><a href="#注意事项-40" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>事务一旦启动，后续的修改操作不会立即生效，只有提交（<code>COMMIT</code>）后才会永久保存，若出现错误可使用 <code>ROLLBACK</code> 进行回滚。</li><li>请确保使用的存储引擎（如 <code>InnoDB</code>）支持事务操作。</li><li>长事务可能占用资源和锁定数据，建议尽快提交或回滚。</li></ul><h3 id="COMMIT-提交事务"><a href="#COMMIT-提交事务" class="headerlink" title="COMMIT - 提交事务"></a>COMMIT - 提交事务</h3><h4 id="语法格式-41"><a href="#语法格式-41" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-40"><a href="#常见参数-40" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>无额外参数，直接提交当前事务中所有已执行的修改操作。</li></ul><h4 id="示例-41"><a href="#示例-41" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-41"><a href="#注意事项-41" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>COMMIT</code> 会使当前事务中的所有修改永久生效，无法回退，在执行前请确保数据正确性。</li><li>对于长事务，建议及时提交以减少锁等待和资源占用。</li><li>某些存储引擎（如 <code>InnoDB</code>）支持事务，而其他（如 <code>MyISAM</code>）则不支持，使用前请确认存储引擎类型。</li></ul><h3 id="ROLLBACK-回滚事务"><a href="#ROLLBACK-回滚事务" class="headerlink" title="ROLLBACK - 回滚事务"></a>ROLLBACK - 回滚事务</h3><h4 id="语法格式-42"><a href="#语法格式-42" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ROLLBACK;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-41"><a href="#常见参数-41" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>无额外参数，用于撤销当前事务中自上次 <code>COMMIT</code> 或事务开始以来的所有修改。</li></ul><h4 id="示例-42"><a href="#示例-42" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>-- 发现错误或业务逻辑有问题，执行回滚<br>ROLLBACK;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-42"><a href="#注意事项-42" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>ROLLBACK</code> 只能撤销当前事务内尚未提交的操作，一旦 <code>COMMIT</code> 后，无法使用 <code>ROLLBACK</code> 恢复。</li><li>在使用事务时，应结合应用逻辑判断错误场景，及时执行 <code>ROLLBACK</code> 以保持数据一致性。</li><li>某些复杂操作（例如涉及外部系统的数据同步）可能无法简单回滚，需谨慎设计事务边界。</li></ul><h3 id="SAVEPOINT-设置事务保存点"><a href="#SAVEPOINT-设置事务保存点" class="headerlink" title="SAVEPOINT - 设置事务保存点"></a>SAVEPOINT - 设置事务保存点</h3><h4 id="语法格式-43"><a href="#语法格式-43" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-42"><a href="#常见参数-42" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>savepoint_name</strong>：自定义的保存点名称，用于标识当前事务中一个中间状态。</li></ul><h4 id="示例-43"><a href="#示例-43" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;<br>SAVEPOINT sp1;<br>UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;<br>-- 若后续操作出错，只回滚到保存点 sp1<br>ROLLBACK TO SAVEPOINT sp1;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-43"><a href="#注意事项-43" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SAVEPOINT</code> 允许在事务中设置多个回滚点，便于部分撤销操作而非整个事务回滚。</li><li>保存点只在当前事务有效，事务结束后自动失效。</li><li><code>SAVEPOINT</code> 操作会增加事务管理的复杂度，使用时应明确各保存点对应的业务逻辑阶段。</li></ul><h3 id="RELEASE-SAVEPOINT-删除指定的保存点"><a href="#RELEASE-SAVEPOINT-删除指定的保存点" class="headerlink" title="RELEASE SAVEPOINT - 删除指定的保存点"></a>RELEASE SAVEPOINT - 删除指定的保存点</h3><h4 id="语法格式-44"><a href="#语法格式-44" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">RELEASE SAVEPOINT savepoint_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-43"><a href="#常见参数-43" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>savepoint_name</strong>：指定需要删除的保存点名称。</li></ul><h4 id="示例-44"><a href="#示例-44" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">START TRANSACTION;<br>UPDATE orders SET status = &#x27;processing&#x27; WHERE order_id = 123;<br>SAVEPOINT sp_order;<br>-- 执行部分操作后，确认不需要再回滚到该保存点时，释放它<br>RELEASE SAVEPOINT sp_order;<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-44"><a href="#注意事项-44" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>RELEASE SAVEPOINT</code> 会删除指定保存点，释放与该保存点相关的资源，一旦释放，不能再回滚到该保存点。</li><li>删除保存点对事务后续操作没有影响，但应在确定不需要部分回滚后再执行。</li><li>释放保存点后，事务依然处于原来的状态，不会自动提交或回滚。</li></ul><h3 id="SET-TRANSACTION-设置事务隔离级别"><a href="#SET-TRANSACTION-设置事务隔离级别" class="headerlink" title="SET TRANSACTION - 设置事务隔离级别"></a>SET TRANSACTION - 设置事务隔离级别</h3><h4 id="语法格式-45"><a href="#语法格式-45" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION [transaction_option [, transaction_option] ...];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-44"><a href="#常见参数-44" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>transaction_option 主要包括</strong>：<ul><li><strong>ISOLATION LEVEL level</strong>：设置事务的隔离级别（如 <code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>、<code>SERIALIZABLE</code>）。</li><li><strong>READ WRITE 或 READ ONLY</strong>：指定事务是否允许写操作。</li></ul></li><li><code>SET TRANSACTION</code> 必须在事务开始之前（即在 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 之后立即执行，否则不会生效）。</li></ul><h4 id="示例-45"><a href="#示例-45" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE;<br>START TRANSACTION;<br>-- 执行事务操作...<br>COMMIT;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-45"><a href="#注意事项-45" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SET TRANSACTION</code> 的设置仅影响当前事务，事务结束后恢复默认设置。</li><li>不同隔离级别对并发控制、锁策略及性能有较大影响，选择时应根据业务需求权衡一致性和性能。</li><li>一般建议在事务开始后立即设置事务属性，以确保整个事务按照预期运行，否则可能需要重启事务。</li></ul><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p>数据控制语言。</p><h3 id="GRANT-授予用户权限"><a href="#GRANT-授予用户权限" class="headerlink" title="GRANT - 授予用户权限"></a>GRANT - 授予用户权限</h3><h4 id="语法格式-46"><a href="#语法格式-46" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT privilege_list ON object TO &#x27;username&#x27;@&#x27;host&#x27; [IDENTIFIED BY &#x27;password&#x27;] [WITH GRANT OPTION];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-45"><a href="#常见参数-45" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>privilege_list</strong>：可以是单个权限（如 <code>SELECT</code>、<code>INSERT</code> 等）或 <code>ALL PRIVILEGES</code>。</li><li><strong>object</strong>：通常指定数据库对象，如 <code>.</code> 表示所有数据库的所有对象，<code>db_name.*</code> 表示某个数据库。</li><li><strong>WITH GRANT OPTION</strong>：允许被授权用户将其拥有的权限继续授权给其他用户。</li><li>可在创建用户时同时设置密码（<code>IDENTIFIED BY</code>）。</li></ul><h4 id="示例-46"><a href="#示例-46" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT SELECT, INSERT, UPDATE ON mydb.* TO &#x27;alice&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;securePwd&#x27; WITH GRANT OPTION;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-46"><a href="#注意事项-46" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>GRANT</code> 命令不仅分配权限，还可能隐式创建用户（视 MySQL 版本而定）。</li><li>授予权限时要注意最小权限原则，避免授予不必要的高级权限。</li><li>授权后若修改了权限表，建议使用 <code>FLUSH PRIVILEGES</code> 使更改生效（某些情况下系统自动刷新）。</li></ul><h3 id="REVOKE-撤销用户权限"><a href="#REVOKE-撤销用户权限" class="headerlink" title="REVOKE - 撤销用户权限"></a>REVOKE - 撤销用户权限</h3><h4 id="语法格式-47"><a href="#语法格式-47" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE privilege_list ON object FROM &#x27;username&#x27;@&#x27;host&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-46"><a href="#常见参数-46" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>privilege_list</strong>：需要撤销的权限列表。</li><li><strong>object</strong>：权限对应的数据库或表。</li><li>指定用户时要与 <code>GRANT</code> 命令中一致。</li></ul><h4 id="示例-47"><a href="#示例-47" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE INSERT, UPDATE ON mydb.* FROM &#x27;alice&#x27;@&#x27;localhost&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-47"><a href="#注意事项-47" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>撤销权限后，用户相应的操作将被禁止。</li><li>若用户同时拥有多个权限来源（如继承或通过角色），撤销时需核查各个来源的权限。</li><li>撤销权限后若有权限缓存，可能需要 <code>FLUSH PRIVILEGES</code> 来刷新。</li></ul><h3 id="CREATE-USER-创建新用户"><a href="#CREATE-USER-创建新用户" class="headerlink" title="CREATE USER - 创建新用户"></a>CREATE USER - 创建新用户</h3><h4 id="语法格式-48"><a href="#语法格式-48" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-47"><a href="#常见参数-47" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>**‘username‘@’host’**：用户名及允许登录的主机，如 <code>&#39;bob&#39;@&#39;localhost&#39;</code> 或 <code>&#39;bob&#39;@&#39;%&#39;</code>（允许任意主机）。</li><li>**IDENTIFIED BY ‘password’**：指定用户的登录密码，部分版本支持更多认证插件设置。</li></ul><h4 id="示例-48"><a href="#示例-48" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;bob&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;bobPwd&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-48"><a href="#注意事项-48" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>用户名和主机名共同决定了一个唯一用户。</li><li>密码应足够复杂，保障安全性。</li><li>MySQL 8.0 及以上版本推荐使用更加灵活的认证插件设置。</li></ul><h3 id="DROP-USER-删除用户"><a href="#DROP-USER-删除用户" class="headerlink" title="DROP USER - 删除用户"></a>DROP USER - 删除用户</h3><h4 id="语法格式-49"><a href="#语法格式-49" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP USER &#x27;username&#x27;@&#x27;host&#x27;[, &#x27;username&#x27;@&#x27;host&#x27;];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-48"><a href="#常见参数-48" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>指定要删除的用户，必须与创建时的用户名及主机名匹配。</li></ul><h4 id="示例-49"><a href="#示例-49" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP USER &#x27;bob&#x27;@&#x27;localhost&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-49"><a href="#注意事项-49" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>删除用户会移除该用户所有的登录权限，注意核查是否有依赖关系（如定时任务、存储过程中的调用等）。</li><li>若用户不存在，建议使用 <code>IF EXISTS</code>（部分 MySQL 版本支持）以避免错误。</li><li>删除用户操作不可逆，需谨慎操作。</li></ul><h3 id="SET-PASSWORD-设置或修改用户密码"><a href="#SET-PASSWORD-设置或修改用户密码" class="headerlink" title="SET PASSWORD - 设置或修改用户密码"></a>SET PASSWORD - 设置或修改用户密码</h3><h4 id="语法格式-50"><a href="#语法格式-50" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET PASSWORD FOR &#x27;username&#x27;@&#x27;host&#x27; = PASSWORD(&#x27;new_password&#x27;);<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-49"><a href="#常见参数-49" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>**‘username‘@’host’**：指定要修改密码的用户。</li><li>**PASSWORD(‘new_password’)**：对新密码进行加密，MySQL 早期版本常用该函数。</li></ul><h4 id="示例-50"><a href="#示例-50" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SET PASSWORD FOR &#x27;alice&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;newSecurePwd&#x27;);<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-50"><a href="#注意事项-50" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>旧版本中使用 <code>PASSWORD()</code> 函数，但在 MySQL 8.0 中已弃用，建议使用 <code>ALTER USER … IDENTIFIED BY …</code>。</li><li>修改密码后用户需要使用新密码登录。</li><li>修改密码操作应确保安全传输，避免泄露。</li></ul><h3 id="SHOW-GRANTS-查看用户的权限"><a href="#SHOW-GRANTS-查看用户的权限" class="headerlink" title="SHOW GRANTS - 查看用户的权限"></a>SHOW GRANTS - 查看用户的权限</h3><h4 id="语法格式-51"><a href="#语法格式-51" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW GRANTS FOR &#x27;username&#x27;@&#x27;host&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-50"><a href="#常见参数-50" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>指定用户及主机，如 <code>&#39;alice&#39;@&#39;localhost&#39;</code>。若省略 <code>FOR</code> 子句，则显示当前登录用户的权限。</li></ul><h4 id="示例-51"><a href="#示例-51" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW GRANTS FOR &#x27;alice&#x27;@&#x27;localhost&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-51"><a href="#注意事项-51" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>显示的权限信息包括所有通过 <code>GRANT</code> 命令赋予用户的权限。</li><li>该命令用于审核和确认用户权限，便于安全管理。</li><li>不同版本显示格式可能略有差异。</li></ul><h3 id="FLUSH-PRIVILEGES-刷新权限，使修改生效"><a href="#FLUSH-PRIVILEGES-刷新权限，使修改生效" class="headerlink" title="FLUSH PRIVILEGES - 刷新权限，使修改生效"></a>FLUSH PRIVILEGES - 刷新权限，使修改生效</h3><h4 id="语法格式-52"><a href="#语法格式-52" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">FLUSH PRIVILEGES;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-51"><a href="#常见参数-51" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>无其他参数，直接执行命令使权限表的更改在内存中生效。</li></ul><h4 id="示例-52"><a href="#示例-52" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">FLUSH PRIVILEGES;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-52"><a href="#注意事项-52" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在直接修改 MySQL 权限表后，必须执行 <code>FLUSH PRIVILEGES</code> 才能使修改生效。</li><li>通过 <code>GRANT</code>、<code>REVOKE</code>、<code>CREATE USER</code> 等命令修改权限时，系统通常会自动刷新。</li><li>若修改权限文件后遇到权限不一致问题，可尝试执行此命令解决。</li></ul><h2 id="SCL"><a href="#SCL" class="headerlink" title="SCL"></a>SCL</h2><p>会话控制语言。</p><h3 id="SET-设置会话变量"><a href="#SET-设置会话变量" class="headerlink" title="SET - 设置会话变量"></a>SET - 设置会话变量</h3><h4 id="语法格式-53"><a href="#语法格式-53" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 设置单个变量<br>SET variable_name = value;<br><br># 设置多个变量<br>SET var1 = value1, var2 = value2, ...;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-52"><a href="#常见参数-52" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>系统变量</strong>：如 <code>autocommit</code>、<code>sql_mode</code>、<code>character_set_server</code> 等。</li><li><strong>用户变量</strong>：前面加 <code>@</code> 符号，例如 <code>SET @var = 10;</code>。</li></ul><h4 id="示例-53"><a href="#示例-53" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 设置系统变量<br>SET autocommit = 0;<br>SET sql_mode = &#x27;STRICT_TRANS_TABLES&#x27;;<br><br># 设置用户变量<br>SET @counter = 100;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-53"><a href="#注意事项-53" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SET</code> 语句用于配置会话或全局级别的变量，影响当前连接的行为。</li><li>对于系统变量，若要全局生效，可使用 <code>SET GLOBAL variable_name = value;</code>（需要相应权限）。</li><li>设置用户变量时，变量作用域仅限当前会话，不会在多个连接间共享。</li></ul><h3 id="SHOW-显示变量信息"><a href="#SHOW-显示变量信息" class="headerlink" title="SHOW - 显示变量信息"></a>SHOW - 显示变量信息</h3><h4 id="语法格式-54"><a href="#语法格式-54" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW [FULL] &#123;DATABASES | TABLES | COLUMNS FROM table_name | WARNINGS | ...&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-53"><a href="#常见参数-53" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>DATABASES</strong>：显示所有数据库。</li><li><strong>TABLES</strong>：显示当前数据库中的所有表。</li><li><strong>COLUMNS/FIELDS</strong>：显示指定表的列信息。</li><li><strong>其他</strong>：还包括 <code>SHOW INDEX</code>、<code>SHOW CREATE TABLE</code>、<code>SHOW ENGINE</code> 等。</li></ul><h4 id="示例-54"><a href="#示例-54" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 显示所有数据库<br>SHOW DATABASES;<br><br># 显示当前数据库中的所有表<br>SHOW TABLES;<br><br># 显示指定表的字段信息<br>SHOW COLUMNS FROM users;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-54"><a href="#注意事项-54" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>SHOW</code> 命令主要用于查看数据库的元数据和运行状态。</li><li>具体支持的选项和显示内容可能会因 MySQL 版本而有所不同。</li><li>加上 <code>FULL</code> 关键字可获得更详细的信息（如在 <code>SHOW PROCESSLIST FULL</code> 中显示完整查询）。</li></ul><h3 id="USE-选择数据库"><a href="#USE-选择数据库" class="headerlink" title="USE - 选择数据库"></a>USE - 选择数据库</h3><h4 id="语法格式-55"><a href="#语法格式-55" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">USE database_name;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-54"><a href="#常见参数-54" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>仅需指定目标数据库的名称，切换当前会话的默认数据库。</li></ul><h4 id="示例-55"><a href="#示例-55" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">USE mydb;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-55"><a href="#注意事项-55" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>执行 <code>USE</code> 命令后，后续的 SQL 语句若不指定数据库名，则默认在该数据库中执行。</li><li>在多数据库环境中，确保在操作前已切换至正确的数据库。</li><li>若指定的数据库不存在，会返回错误信息。</li></ul><h2 id="DTL"><a href="#DTL" class="headerlink" title="DTL"></a>DTL</h2><p>用于导入、导出数据。</p><h3 id="LOAD-DATA-INFILE-从文件导入数据"><a href="#LOAD-DATA-INFILE-从文件导入数据" class="headerlink" title="LOAD DATA INFILE - 从文件导入数据"></a>LOAD DATA INFILE - 从文件导入数据</h3><h4 id="语法格式-56"><a href="#语法格式-56" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#x27;file_path&#x27;<br>[REPLACE | IGNORE]<br>INTO TABLE table_name<br>[CHARACTER SET charset_name]<br>[FIELDS<br>    [TERMINATED BY &#x27;string&#x27;]<br>    [OPTIONALLY] ENCLOSED BY &#x27;char&#x27;]<br>[LINES<br>    [STARTING BY &#x27;string&#x27;]<br>    [TERMINATED BY &#x27;string&#x27;]]<br>[IGNORE number LINES]<br>[(column1, column2, ...)];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-55"><a href="#常见参数-55" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>LOCAL</strong>：指定文件位于客户端。</li><li><strong>REPLACE/IGNORE</strong>：定义遇到重复记录时的处理策略。</li><li><strong>CHARACTER SET</strong>：设置文件字符集。</li><li><strong>FIELDS</strong> 与 <strong>LINES</strong>：指定字段与行的分隔符、包围符和换行符。</li><li><strong>IGNORE n LINES</strong>：跳过文件开头的 n 行（通常用于忽略标题行）。</li></ul><h4 id="示例-56"><a href="#示例-56" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">LOAD DATA LOCAL INFILE &#x27;/path/to/data.csv&#x27;<br>INTO TABLE users<br>CHARACTER SET utf8mb4<br>FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;<br>LINES TERMINATED BY &#x27;\n&#x27;<br>IGNORE 1 LINES;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-56"><a href="#注意事项-56" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>MySQL 服务器或客户端需要有相应的文件读取权限。</li><li>文件路径是基于服务器或客户端（加 <code>LOCAL</code> 时）的文件系统。</li><li>参数设置应与文件实际格式保持一致，否则可能导致数据导入错误。</li><li>大量数据导入时，注意事务控制和错误处理。</li></ul><h3 id="SELECT-INTO-OUTFILE-导出数据到文件"><a href="#SELECT-INTO-OUTFILE-导出数据到文件" class="headerlink" title="SELECT INTO OUTFILE - 导出数据到文件"></a>SELECT INTO OUTFILE - 导出数据到文件</h3><h4 id="语法格式-57"><a href="#语法格式-57" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT columns<br>FROM table_name<br>[WHERE condition]<br>[ORDER BY ...]<br>INTO OUTFILE &#x27;file_path&#x27;<br>[FIELDS<br>    [TERMINATED BY &#x27;string&#x27;]<br>    [OPTIONALLY] ENCLOSED BY &#x27;char&#x27;]<br>[LINES<br>    [STARTING BY &#x27;string&#x27;]<br>    [TERMINATED BY &#x27;string&#x27;];<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-56"><a href="#常见参数-56" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>INTO OUTFILE</strong>：指定导出文件的完整路径（服务器端路径）。</li><li><strong>FIELDS 与 LINES</strong>：用于定义导出文件中字段和行的格式、分隔符和换行符。</li></ul><h4 id="示例-57"><a href="#示例-57" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT username, email<br>FROM users<br>WHERE status = &#x27;active&#x27;<br>ORDER BY username<br>INTO OUTFILE &#x27;/tmp/active_users.csv&#x27;<br>FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;<br>LINES TERMINATED BY &#x27;\n&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-57"><a href="#注意事项-57" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>文件将被写入服务器所在的文件系统，因此必须保证服务器对指定路径有写权限。</li><li>文件路径必须不存在，否则会报错。</li><li>导出时要确保字段分隔符、行终止符等与目标格式相符。</li><li>适用于数据备份和离线分析，但要注意文件安全性。</li></ul><h2 id="系统环境命令"><a href="#系统环境命令" class="headerlink" title="系统环境命令"></a>系统环境命令</h2><p>用于管理 MySQL 服务器的状态、性能等。</p><h3 id="SHOW-PROCESSLIST-查看当前正在执行的查询"><a href="#SHOW-PROCESSLIST-查看当前正在执行的查询" class="headerlink" title="SHOW PROCESSLIST - 查看当前正在执行的查询"></a>SHOW PROCESSLIST - 查看当前正在执行的查询</h3><h4 id="语法格式-58"><a href="#语法格式-58" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW [FULL] PROCESSLIST;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-57"><a href="#常见参数-57" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>FULL</strong>：显示完整的查询信息（不截断长查询语句）。</li></ul><h4 id="示例-58"><a href="#示例-58" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW PROCESSLIST;<br><br>SHOW FULL PROCESSLIST;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-58"><a href="#注意事项-58" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>此命令用于查看当前 MySQL 服务器正在执行的线程和查询，便于诊断性能问题或死锁。</li><li>普通用户只能查看自己的线程信息，管理员用户可以查看所有线程。</li><li>监控信息中包括每个线程的 ID、用户、主机、数据库、命令、时间、状态和当前执行的 SQL 语句。</li><li>频繁执行可能会对性能产生轻微影响，建议合理使用。</li></ul><h3 id="SHOW-STATUS-查看服务器状态信息"><a href="#SHOW-STATUS-查看服务器状态信息" class="headerlink" title="SHOW STATUS - 查看服务器状态信息"></a>SHOW STATUS - 查看服务器状态信息</h3><h4 id="语法格式-59"><a href="#语法格式-59" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] STATUS;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-58"><a href="#常见参数-58" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>GLOBAL</strong>：显示服务器级别的状态信息。</li><li><strong>SESSION</strong>：显示当前会话的状态信息（默认）。</li></ul><h4 id="示例-59"><a href="#示例-59" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 查看全局状态<br>SHOW GLOBAL STATUS;<br><br># 查看当前会话状态<br>SHOW SESSION STATUS;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-59"><a href="#注意事项-59" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>状态信息包括连接数、查询数、缓存命中率、慢查询等指标，有助于性能调优。</p></li><li><p>全局状态反映整个服务器的运行情况，<code>SESSION</code> 状态仅涉及当前连接。</p></li><li><p>数据较多时，可结合 <code>LIKE</code> 子句过滤关键字，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW GLOBAL STATUS LIKE &#x27;Connections&#x27;;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="SHOW-VARIABLES-查看服务器系统变量"><a href="#SHOW-VARIABLES-查看服务器系统变量" class="headerlink" title="SHOW VARIABLES - 查看服务器系统变量"></a>SHOW VARIABLES - 查看服务器系统变量</h3><h4 id="语法格式-60"><a href="#语法格式-60" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] VARIABLES;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-59"><a href="#常见参数-59" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><p><strong>GLOBAL</strong>：显示服务器全局变量。</p></li><li><p><strong>SESSION</strong>：显示当前会话变量（默认）。</p></li><li><p>可结合 <code>LIKE</code> 子句筛选变量名，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;max_connections&#x27;;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="示例-60"><a href="#示例-60" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br><br># 查看特定变量<br>SHOW SESSION VARIABLES LIKE &#x27;character_set%&#x27;;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-60"><a href="#注意事项-60" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>变量用于控制 MySQL 的行为和配置，调整前建议详细了解含义。</li><li><code>GLOBAL</code> 变量修改后需重启或执行相应命令使新值生效，<code>SESSION</code> 变量仅影响当前连接。</li><li>查看变量可以帮助确认当前服务器配置及诊断性能问题。</li></ul><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><h3 id="mysql-连接-MySQL"><a href="#mysql-连接-MySQL" class="headerlink" title="mysql - 连接 MySQL"></a>mysql - 连接 MySQL</h3><h4 id="语法格式-61"><a href="#语法格式-61" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysql -u username -p [options] [database_name]<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-60"><a href="#常见参数-60" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>-u username</strong>：指定登录用户名。</li><li><strong>-p</strong>：提示输入密码。</li><li><strong>-h host</strong>：指定服务器地址，默认 <code>localhost</code>。</li><li><strong>-P port</strong>：指定端口号，默认 <code>3306</code>。</li><li>**-e “SQL语句”**：执行 “SQL 语句” 后退出。</li><li><strong>–default-character-set</strong>：指定连接使用的字符集。</li></ul><h4 id="示例-61"><a href="#示例-61" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 交互式登录并切换到数据库</span><br>mysql -u root -p mydb<br><br><span class="hljs-comment"># 直接执行 SQL 语句</span><br>mysql -u root -p -e <span class="hljs-string">&quot;SHOW DATABASES;&quot;</span><br></code></pre></div></td></tr></table></figure><h4 id="注意事项-61"><a href="#注意事项-61" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>确保使用正确的用户名、密码和服务器地址。</li><li>使用 <code>-e</code> 参数时，执行后会自动退出客户端，适合脚本调用。</li><li>登录后可以使用 <code>USE database_name;</code> 切换数据库。</li></ul><h3 id="mysqladmin-服务器管理"><a href="#mysqladmin-服务器管理" class="headerlink" title="mysqladmin - 服务器管理"></a>mysqladmin - 服务器管理</h3><h4 id="语法格式-62"><a href="#语法格式-62" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqladmin -u username -p [options] <span class="hljs-built_in">command</span><br></code></pre></div></td></tr></table></figure><h4 id="常见参数及命令"><a href="#常见参数及命令" class="headerlink" title="常见参数及命令"></a>常见参数及命令</h4><ul><li><strong>status</strong>：显示服务器当前状态（连接数、查询数等）。</li><li><strong>processlist</strong>：显示当前活动进程列表（类似 <code>SHOW PROCESSLIST</code>）。</li><li><strong>variables</strong>：显示服务器变量信息。</li><li><strong>shutdown</strong>：关闭 MySQL 服务器。</li><li><strong>flush-hosts</strong>：刷新主机缓存，解除因连接过多引起的阻塞。</li><li><strong>kill id</strong>：终止指定线程（<code>id</code> 为进程 ID）。</li></ul><h4 id="示例-62"><a href="#示例-62" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 查看服务器状态</span><br>mysqladmin -u root -p status<br><br><span class="hljs-comment"># 关闭服务器</span><br>mysqladmin -u root -p shutdown<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-62"><a href="#注意事项-62" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>执行某些命令（如 <code>shutdown</code>）需要管理员权限。</li><li>普通用户通常只能查看自己的进程信息。</li><li>使用 <code>kill</code> 命令时请谨慎，误杀进程可能影响业务运行。</li></ul><h3 id="mysqlcheck-检查与修复"><a href="#mysqlcheck-检查与修复" class="headerlink" title="mysqlcheck -  检查与修复"></a>mysqlcheck -  检查与修复</h3><h4 id="语法格式-63"><a href="#语法格式-63" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqlcheck -u username -p [options] database_name [table_name ...]<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-61"><a href="#常见参数-61" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>–check</strong>：检查表是否损坏（默认操作）。</li><li><strong>–repair</strong>：修复损坏的表（适用于 <code>MyISAM</code> 表）。</li><li><strong>–optimize</strong>：优化表，重建索引。</li><li><strong>–analyze</strong>：分析表数据，帮助优化查询计划。</li><li><strong>–all-databases</strong>：对所有数据库执行操作。</li></ul><h4 id="示例-63"><a href="#示例-63" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 优化 mydb 数据库中所有表</span><br>mysqlcheck -u root -p --optimize mydb<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-63"><a href="#注意事项-63" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>对于 <code>InnoDB</code> 表，通常建议使用在线 <code>ALTER TABLE</code> 操作。</li><li>运行 <code>mysqlcheck</code> 时建议在低峰期执行，避免对业务造成影响。</li><li>部分操作可能会加锁表，注意影响并发访问。</li></ul><h3 id="mysqlbinlog-查看二进制日志"><a href="#mysqlbinlog-查看二进制日志" class="headerlink" title="mysqlbinlog - 查看二进制日志"></a>mysqlbinlog - 查看二进制日志</h3><h4 id="语法格式-64"><a href="#语法格式-64" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqlbinlog [options] binlog_file ...<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-62"><a href="#常见参数-62" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li>**–start-datetime=”YYYY-MM-DD HH:MM:SS”**：指定起始时间。</li><li>**–stop-datetime=”YYYY-MM-DD HH:MM:SS”**：指定终止时间。</li><li><strong>–start-position=pos</strong>、**–stop-position=pos**：以日志文件中的位置范围过滤。</li><li><strong>–database=dbname</strong>：只解析指定数据库的日志记录。</li></ul><h4 id="示例-64"><a href="#示例-64" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 查看指定时间段内的 binlog 内容</span><br>mysqlbinlog --start-datetime=<span class="hljs-string">&quot;2024-06-01 10:00:00&quot;</span> --stop-datetime=<span class="hljs-string">&quot;2024-06-01 12:00:00&quot;</span> /var/lib/mysql/binlog.000001<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-64"><a href="#注意事项-64" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>必须在 MySQL 配置中启用了 <code>binlog</code>（如在 <code>my.cnf</code> 中设置 <code>log_bin</code>）。</li><li><code>binlog</code> 文件可能较大，解析时需注意系统资源。</li><li>输出的日志内容包含敏感操作，管理时注意权限控制。</li></ul><h3 id="mysqldump-数据库备份"><a href="#mysqldump-数据库备份" class="headerlink" title="mysqldump - 数据库备份"></a>mysqldump - 数据库备份</h3><h4 id="语法格式-65"><a href="#语法格式-65" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqldump -u username -p [options] database_name [table_name ...] &gt; backup.sql<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-63"><a href="#常见参数-63" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>–databases</strong>：导出一个或多个数据库（包括 <code>CREATE DATABASE</code> 语句）。</li><li><strong>–all-databases</strong>：导出所有数据库。</li><li><strong>–no-data</strong>：只导出表结构，不包含数据。</li><li><strong>–single-transaction</strong>：针对 <code>InnoDB</code> 表的事务性备份，保证数据一致性。</li><li><strong>–routines</strong>：包含存储过程和函数。</li><li><strong>–triggers</strong>：导出触发器（默认包含）。</li></ul><h4 id="示例-65"><a href="#示例-65" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 备份单个数据库 mydb</span><br>mysqldump -u root -p mydb &gt; mydb_backup.sql<br><br><span class="hljs-comment"># 备份所有数据库</span><br>mysqldump -u root -p --all-databases &gt; all_backup.sql<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-65"><a href="#注意事项-65" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>mysqldump</code> 适合逻辑备份，对于数据量较大时，可能备份速度较慢。</li><li>使用 <code>--single-transaction</code> 时，适用于 <code>InnoDB</code> 表，确保备份数据一致。</li><li>备份文件中包含敏感信息（如数据和结构），请注意文件权限和传输安全。</li></ul><h3 id="myisamchk-MyISAM-表维护"><a href="#myisamchk-MyISAM-表维护" class="headerlink" title="myisamchk - MyISAM 表维护"></a>myisamchk - MyISAM 表维护</h3><h4 id="语法格式-66"><a href="#语法格式-66" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">myisamchk [options] /path/to/database/table_name.MYI<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-64"><a href="#常见参数-64" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>-c 或 –check</strong>：检查表是否损坏。</li><li><strong>-r 或 –recover</strong>：修复损坏的表。</li><li><strong>-o 或 –optimize</strong>：优化表，提高查询速度。</li><li><strong>-q</strong>：快速检查，速度较快但详细性较低。</li></ul><h4 id="示例-66"><a href="#示例-66" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 检查表是否有错误</span><br>myisamchk -c /var/lib/mysql/mydb/users.MYI<br><br><span class="hljs-comment"># 修复损坏的表</span><br>myisamchk -r /var/lib/mysql/mydb/users.MYI<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-66"><a href="#注意事项-66" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用 <code>myisamchk</code> 前建议停止 MySQL 服务或确保表处于离线状态，否则可能引起数据不一致。</li><li>仅适用于 <code>MyISAM</code> 表，不适用于 <code>InnoDB</code> 表。</li><li>修复过程中请先备份数据，以免操作不当造成数据丢失。</li></ul><h3 id="mysqld-safe-安全启动-MySQL"><a href="#mysqld-safe-安全启动-MySQL" class="headerlink" title="mysqld_safe - 安全启动 MySQL"></a>mysqld_safe - 安全启动 MySQL</h3><h4 id="语法格式-67"><a href="#语法格式-67" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqld_safe [options] &amp;<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-65"><a href="#常见参数-65" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>–skip-grant-tables</strong>：跳过权限表验证，常用于忘记密码时恢复。</li><li><strong>–log-error=/path/to/error.log</strong>：指定错误日志文件。</li><li><strong>–port=port_number</strong>：指定 MySQL 服务监听的端口。</li><li><strong>–datadir</strong>：指定数据目录路径。</li></ul><h4 id="示例-67"><a href="#示例-67" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 以安全模式启动并跳过权限验证（仅用于故障排查）</span><br>mysqld_safe --skip-grant-tables &amp;<br></code></pre></div></td></tr></table></figure><h4 id="注意事项-67"><a href="#注意事项-67" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用 <code>--skip-grant-tables</code> 会使数据库在无权限保护状态下运行，应在维护期间短暂使用。</li><li><code>mysqld_safe</code> 通常用作后台进程，确保使用合适的日志文件路径。</li><li>启动后建议检查错误日志，确认服务器运行正常。</li></ul><h3 id="mysqlslap-压力测试"><a href="#mysqlslap-压力测试" class="headerlink" title="mysqlslap - 压力测试"></a>mysqlslap - 压力测试</h3><h4 id="语法格式-68"><a href="#语法格式-68" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">mysqlslap [options]<br></code></pre></div></td></tr></table></figure><h4 id="常见参数-66"><a href="#常见参数-66" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><strong>–user, –password</strong>：指定测试的数据库用户和密码。</li><li><strong>–concurrency</strong>：模拟的并发连接数。</li><li><strong>–iterations</strong>：测试运行的次数。</li><li><strong>–query</strong>：指定要执行的 SQL 语句。</li><li><strong>–create-schema</strong>：指定测试使用的数据库名称。</li><li><strong>–engine</strong>：指定使用的存储引擎。</li></ul><h4 id="示例-68"><a href="#示例-68" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 对查询 “SELECT COUNT(*) FROM orders;” 进行压力测试，模拟 50 个并发连接，执行 10 次</span><br>mysqlslap --user=root --password=root --concurrency=50 --iterations=10 --query=<span class="hljs-string">&quot;SELECT COUNT(*) FROM orders;&quot;</span><br></code></pre></div></td></tr></table></figure><h4 id="注意事项-68"><a href="#注意事项-68" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>mysqlslap</code> 适用于测试环境，不建议在生产数据库上直接运行。</li><li>压力测试时可能对数据库性能产生较大影响，应在低峰期或专用测试服务器上执行。</li><li>调整 <code>--concurrency</code> 和 <code>--iterations</code> 参数以模拟不同的负载场景，并综合分析结果来定位性能瓶颈。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="字符集及其校对规则"><a href="#字符集及其校对规则" class="headerlink" title="字符集及其校对规则"></a>字符集及其校对规则</h3><h4 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h4><ul><li><strong>字符集</strong>：是一组字符编码方案，用于存储文本数据，确保不同语言文字能正确编码和解码。</li><li><strong>校对规则</strong>：定义了字符的比较、排序和匹配规则，比如是否区分大小写或重音符号。</li><li><strong>作用</strong>：保证数据的存储、比较和排序遵循统一的编码标准，支持多语言环境，并影响查询时的排序和过滤行为。</li></ul><h4 id="常见的字符集及适用场景"><a href="#常见的字符集及适用场景" class="headerlink" title="常见的字符集及适用场景"></a>常见的字符集及适用场景</h4><ul><li><strong>latin1</strong>：适用于主要使用西欧语言（如英语、法语等）的场景，占用空间较小，但不支持中文。</li><li><strong>utf8</strong>：支持 <code>Unicode</code> 字符，适用于多种语言，但最多支持 3 字节编码，对部分特殊字符（如部分表情）支持有限。</li><li><strong>utf8mb4</strong>：完全支持 <code>Unicode</code> 字符集（4 字节编码），适用于需要存储表情符号、特殊字符或多语言内容的场景，是目前推荐的选择。</li></ul><h4 id="常见校对规则"><a href="#常见校对规则" class="headerlink" title="常见校对规则"></a>常见校对规则</h4><ul><li>如 <code>utf8mb4_general_ci</code>（通用、不区分大小写）和 <code>utf8mb4_bin</code>（按二进制比较，区分大小写），可根据具体业务对排序和比较规则的要求进行选择。</li></ul><h3 id="数据类型和约束"><a href="#数据类型和约束" class="headerlink" title="数据类型和约束"></a>数据类型和约束</h3><h4 id="定义与作用-1"><a href="#定义与作用-1" class="headerlink" title="定义与作用"></a>定义与作用</h4><ul><li><strong>数据类型</strong>：指定字段存储的数据种类和存储空间，确保数据的格式和范围。</li><li><strong>约束</strong>：对数据输入施加限制，保证数据的完整性和正确性，避免不合法或重复数据。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><ul><li><strong>数值类型</strong><ul><li><strong>INT</strong>：常用于存储整数。4 个字节长度。</li><li><strong>BIGINT</strong>：能存放更大范围的整数，常用于存储主键 ID。8 个字节长度。</li><li>**DECIMAL(M, D)**：适合存储精确数值，如货币金额。M取值 1-65，D取值 0-30。</li><li><strong>FLOAT/DOUBLE</strong>：用于存储浮点数，但存在精度问题，适用于对精度要求不高的场景。<code>FLOAT</code> 为 4 个字节长度，<code>DOUBLE</code> 为 8 个字节长度。</li><li><strong>其他</strong>：<code>BIT</code>（0 或 1，长度为 1 比特）、<code>TINYINT</code>（整数，长度为 1 个字节）、<code>SMALLINT</code>（整数，长度为 2 个字节）、<code>MEDIUMINT</code>（整数，长度为 3 个字节）。</li></ul></li><li><strong>字符串类型</strong><ul><li><strong>CHAR</strong>：固定长度字符串，适用于存储固定格式的数据（如国家代码）。最大 256 个字节长度。</li><li><strong>VARCHAR</strong>：可变长度字符串，适合存储长度不定的文本，如用户名、电子邮件。最大 65535 个字节长度。</li><li><strong>TEXT</strong>：用于存储大量文本数据，如文章内容。最大 65535 个字节长度。</li><li><strong>其他</strong>：<code>TINYTEXT</code>（最大 256 个字节长度）、<code>MEDIUMTEXT</code>（最大 16MB）、<code>LONGTEXT</code>（最大 4GB）。</li></ul></li><li><strong>日期和时间类型</strong><ul><li><strong>YEAR、MONTH、DATE、TIME、DATETIME、TIMESTAMP</strong>：用于存储年、月、日期、时间或时间戳，适合记录事件发生时间等。</li></ul></li><li><strong>其他</strong><ul><li><strong>枚举型</strong>：<code>ENUM</code>。</li><li><strong>集合型</strong>：<code>SET</code>。</li><li><strong>二进制</strong>：<code>BINARY</code>、<code>VARBINARY</code>、<code>TINYBLOG</code>、<code>BLOG</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>。</li></ul></li></ul><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><strong>NOT NULL</strong>：确保字段必须有值，防止出现空数据。</li><li><strong>DEFAULT</strong>：为字段设定默认值，保证插入数据时若未指定字段值时使用预设值。</li><li><strong>PRIMARY KEY</strong>：定义主键，确保每条记录唯一，并常用于建立聚集索引以加速查询。</li><li><strong>UNIQUE</strong>：确保字段值唯一，避免重复数据。</li><li><strong>FOREIGN KEY</strong>：确保数据之间的参照完整性，维护表与表之间的关联关系。</li><li><strong>AUTO_INCREMENT</strong>：自动生成唯一递增的数值，常用于主键字段。</li><li><strong>CHECK</strong>（在部分版本中支持）：用来限制字段可接受的值范围或格式。</li><li><strong>UNSIGNED</strong>：无符号约束，限制列的取值范围只能是非负数。</li><li><strong>CHARACTER SET</strong>：字符集约束，用于定义值的字符集。</li></ul><h3 id="创建表选项"><a href="#创建表选项" class="headerlink" title="创建表选项"></a>创建表选项</h3><h4 id="定义与作用-2"><a href="#定义与作用-2" class="headerlink" title="定义与作用"></a>定义与作用</h4><ul><li><strong>table_options</strong>：是在创建数据表时附加的选项，用来设定表级别的特性和属性，直接影响表的存储方式、性能及维护性。</li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p><strong>ENGINE</strong></p><ul><li><p>如 <code>InnoDB</code>（支持事务、行级锁、外键约束）适合高并发和数据一致性要求较高的应用。</p></li><li><p><code>MyISAM</code>（读性能较好，但不支持事务）适用于只读或对事务要求不高的场景。</p></li></ul></li><li><p><strong>DEFAULT CHARSET 和 COLLATE</strong></p><ul><li>决定表中字符数据的编码方式和比较规则，适用于确保数据在多语言环境下正确存储和排序。</li></ul></li><li><p><strong>AUTO_INCREMENT</strong></p><ul><li>定义自增字段的起始值和增长方式，常用于主键字段。</li></ul></li><li><p><strong>COMMENT</strong></p><ul><li>用于对表进行注释，说明表的用途，便于维护和团队协作。</li></ul></li><li><p><strong>ROW_FORMAT</strong></p><ul><li>如 <code>COMPACT</code>、<code>DYNAMIC</code> 等，可调整数据行的存储格式，影响空间利用率和 I/O 性能，通常根据实际存储需求选择。</li></ul></li></ul><h3 id="常见变量"><a href="#常见变量" class="headerlink" title="常见变量"></a>常见变量</h3><h4 id="连接与会话相关"><a href="#连接与会话相关" class="headerlink" title="连接与会话相关"></a>连接与会话相关</h4><ul><li><strong>max_connections</strong>：控制允许同时连接 MySQL 的最大客户端数量。</li><li><strong>wait_timeout</strong>：非交互式连接空闲超时时间，超过该时间未有活动，连接将被关闭。</li><li><strong>interactive_timeout</strong>：交互式连接的超时时间，主要影响使用命令行客户端的连接。</li></ul><h4 id="SQL-模式和行为控制"><a href="#SQL-模式和行为控制" class="headerlink" title="SQL 模式和行为控制"></a>SQL 模式和行为控制</h4><ul><li><strong>sql_mode</strong>：指定 SQL 的行为模式，如严格模式（<code>STRICT_TRANS_TABLES</code>）、<code>ANSI</code> 模式等，决定数据验证、错误处理等细节。</li></ul><h4 id="字符集与排序规则"><a href="#字符集与排序规则" class="headerlink" title="字符集与排序规则"></a>字符集与排序规则</h4><ul><li><strong>character_set_server</strong>：服务器默认的字符集，决定新建数据库、表的默认编码。</li><li><strong>collation_server</strong>：服务器默认的排序规则，与字符集配合决定字符串比较和排序行为。</li></ul><h4 id="InnoDB-存储引擎相关"><a href="#InnoDB-存储引擎相关" class="headerlink" title="InnoDB 存储引擎相关"></a>InnoDB 存储引擎相关</h4><ul><li><strong>innodb_buffer_pool_size</strong>：<code>InnoDB</code> 缓冲池大小，用于缓存数据和索引，直接影响性能。</li><li><strong>innodb_log_file_size</strong>：<code>InnoDB</code> 日志文件的大小，影响事务日志的写入和恢复性能。</li></ul><h4 id="内存与缓存设置"><a href="#内存与缓存设置" class="headerlink" title="内存与缓存设置"></a>内存与缓存设置</h4><ul><li><strong>max_allowed_packet</strong>：单个数据包的最大允许大小，影响大数据传输和 <code>BLOB</code> 数据处理。</li><li><strong>tmp_table_size</strong> 与 <strong>max_heap_table_size</strong>：控制临时表的大小，影响复杂查询（如排序、分组）时使用内存表的容量。</li><li><strong>query_cache_size</strong>（在部分 MySQL 版本中有效）：指定查询缓存的大小，有助于加快相同查询的响应速度（注意 MySQL 8.0 已移除该功能）。</li></ul><h4 id="复制和服务器标识"><a href="#复制和服务器标识" class="headerlink" title="复制和服务器标识"></a>复制和服务器标识</h4><ul><li><strong>server_id</strong>：在主从复制环境中，每个服务器的唯一标识符。</li></ul><h4 id="其他常见变量"><a href="#其他常见变量" class="headerlink" title="其他常见变量"></a>其他常见变量</h4><ul><li><strong>port</strong>：MySQL 监听的端口号（通常为 <code>3306</code>）。</li><li><strong>log_error</strong>：指定错误日志的存储位置，用于排查问题。</li><li><strong>version</strong>：显示 MySQL 的版本信息。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文将常见的 MySQL 命令按照 <code>DDL</code>、<code>DML</code>、<code>DQL</code>、<code>DCL</code>、<code>TCL</code>、<code>SCL</code>、<code>DTL</code> 等类别进行了系统梳理，每部分都包含语法、参数、示例和注意事项，方便读者检索和记忆。另一方面，本文从基本的数据表操作（<code>CREATE TABLE</code>, <code>ALTER TABLE</code> 等）到高级的存储过程、触发器，再到服务器管理和备份恢复工具（<code>mysqldump</code>、<code>mysqladmin</code> 等），涵盖面全面，直接适用于日常开发和运维场景。通过深入了解并熟练运用本文所述命令，读者能够更高效地进行数据库建模、数据操作、性能调优以及安全管理。无论是开发还是运维层面，这些命令都是 MySQL 使用中不可或缺的基础工具。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo+GitHub的博客搭建</title>
    <link href="/2021/07/01/blog-personal-blog-build-power-by-hexo/"/>
    <url>/2021/07/01/blog-personal-blog-build-power-by-hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在数字时代，个人博客已成为展示创意、分享知识和技术的重要平台。Hexo，作为一个轻量级的博客框架，结合GitHub Pages提供了一个简单而强大的解决方案，让开发者可以快速搭建并维护自己的个人博客。本文详细介绍了如何使用Hexo加上GitHub Pages搭建个人博客，涵盖从环境设置到发布的完整流程。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li>让JavaScript也可以成为服务端语言，官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>版本控制、管理工具，官网：<a href="https://git-scm.com/">https://git-scm.com/</a></li></ul><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><ul><li><p>npm全局安装</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm install hexo<span class="hljs-literal">-cli</span> <span class="hljs-literal">-g</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="远程仓库配置"><a href="#远程仓库配置" class="headerlink" title="远程仓库配置"></a>远程仓库配置</h2><p><em>这里使用GitHub，Gitee也大同小异，只是在pages需要实名认证以及自定义域名时需要收费</em></p><h3 id="仓库名"><a href="#仓库名" class="headerlink" title="仓库名"></a>仓库名</h3><p><code>仓库名一定要是 &#123;用户名&#125;.github.io，仓库权限为public</code></p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215012947.png"> </p><h3 id="SSH绑定"><a href="#SSH绑定" class="headerlink" title="SSH绑定"></a>SSH绑定</h3><p><em>使用SSH关联本地环境与远程仓库</em></p><ol><li><p>创建密钥对</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;&#123;GitHub注册邮箱&#125;&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>一路确认，在用户目录下的.ssh目录下有两个文件，其中id_rsa.pub为公钥，需要复制里面全部的内容</p></li><li><p>回到==GitHub==，进入==settings==，目录找到==SSH and GPG keys==，==new SSH==，将复制的公钥内容复制到==Key==框中，==Add SSH Key==即可</p></li><li><p>回到本地验证，看到成功绑定即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh -T git@github.com<br>Hi yangtao8453! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="本地博客"><a href="#本地博客" class="headerlink" title="本地博客"></a>本地博客</h2><p><em>创建一个本地文件夹作为博客的根目录，用于存放需要推送到github仓库的博客静态文件</em></p><ol><li><p>初始化（将hexo项目克隆到本地）</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init<br></code></pre></div></td></tr></table></figure></li><li><p>启动本地服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo s<br></code></pre></div></td></tr></table></figure></li><li><p>访问<a href="http://localhost:4000/">http://localhost:4000</a> ，可以看到博客页面，默认有一篇《Hello World》</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215020496.png"></p></li></ol><h2 id="部署远程"><a href="#部署远程" class="headerlink" title="部署远程"></a>部署远程</h2><ol><li><p>来到博客根目录，编辑文件 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span> <br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> &#123;<span class="hljs-string">仓库的地址</span>&#125;   <span class="hljs-comment"># 推荐使用SSH的地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></div></td></tr></table></figure></li><li><p>安装hexo部署工具</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure></li><li><p><code>博客根目录 \ source \ _posts</code>下新建markdown文件，这个就是博客正文内容</p></li><li><p>编辑完正文内容后，回到根目录，清理缓存、生成html、再部署即可</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></div></td></tr></table></figure></li><li><p>等待提交完成后，过一会就可以通过 <a href="https://xxxxx.github.io/">https://xxxxx.github.io/</a> (xxxxx为github用户名)看到博客首页及内容了</p></li></ol><h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><h3 id="fluid"><a href="#fluid" class="headerlink" title="fluid"></a>fluid</h3><ul><li><p>github地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p></li><li><p>使用教程：<a href="https://hexo.fluid-dev.com/docs/start/">https://hexo.fluid-dev.com/docs/start/</a></p></li><li><p>个人效果图：</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215028644.png"></p></li></ul><h2 id="集成评论"><a href="#集成评论" class="headerlink" title="集成评论"></a>集成评论</h2><ol><li><p>访问<a href="https://github.com/apps/utterances/">https://github.com/apps/utterances/</a> ，授权</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215040680.png"> </p></li><li><p>前往<a href="https://utteranc.es/">https://utteranc.es/</a> 进行配置</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215048597.png"> </p></li><li><p>选择主题，网页中添加如下js代码即可集成评论（github登录），一般hexo主题都可以在 <code>_config.yml</code>中配置是否启用评论，集成的插件类型，无需手动添加js代码</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215055220.png"> </p></li></ol><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><ol><li><p>配置域名指向存放博客静态文件的github仓库</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215101319.png"></p></li><li><p>GitHub设置</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925215106456.png"></p></li><li><p>博客根目录 \ source 目录下添加一个 CNAME 文件，内容为个人域名，重新部署；或者仓库直接添加一个 CNAME文件，防止每次重新部署后都要手动在github的pages重新保存域名。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，读者应能完整地掌握使用Hexo和GitHub Pages搭建和部署个人博客的方法。文章不仅涵盖了基础的搭建步骤，还介绍了如何通过配置文件、主题定制和插件集成来丰富博客的功能和提升视觉效果。此外，集成评论功能和绑定个人域名的高级配置也能进一步提升博客的专业度和个性化。随着对Hexo功能的深入理解和应用，开发者将能更自如地管理和创新自己的博客平台。</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>环境搭建</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现对象的比较</title>
    <link href="/2021/05/11/javase-comparator/"/>
    <url>/2021/05/11/javase-comparator/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java中的基本数据类型，如<code>int</code>、<code>long</code>等基本数据类型，可以使用比较运算符 <code>&gt;</code> <code>&lt;</code> <code>=</code> 进行比较大小，但是对于对象数据类型，则不能简单地这样进行比较，需要对象的类实现<code>Comparable</code>接口重写排序规则或通过<code>Comparator</code>进行定制排序，这两种方式都允许开发者自定义排序逻辑，而不是仅依赖于对象的自然顺序。                                                                                                                                                                                                                                                                                         </p><h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>含有方法<code>compareTo(obj)</code>，</p><ul><li>如果当前对象<code>this</code>大于形参<code>obj</code>，则返回正数</li><li>如果当前对象<code>this</code>小于形参<code>obj</code>，则返回负数</li><li>如果当前对象<code>this</code>等于形参<code>obj</code>，则返回零</li></ul><h2 id="自定义类实现Comparable接口"><a href="#自定义类实现Comparable接口" class="headerlink" title="自定义类实现Comparable接口"></a>自定义类实现Comparable接口</h2><p>自定义<code>Person</code>类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Person</code>类如果需要比较大小，需要实现<code>Comparable</code>接口，重写<code>compareTo</code>方法，给定具体的排序规则，如<code>Person</code>对象按年龄从小到大进行排序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Person)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;不能进行比较&quot;</span>);<br>        &#125;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; p.age) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age == p.age) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 还可以再次定义排序规则</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><p>可以将<code>Comparator</code>这个接口作为参数传递给排序方法（如<code>Collections.sort</code>或<code>Arrays.sort</code>），重写方法<code>compare(Object obj1, Object obj2)</code>，比较<code>obj1</code>和<code>obj2</code></p><ul><li><code>obj1</code>大于<code>obj2</code>，则返回正数</li><li><code>obj1</code>小于<code>obj2</code>，则返回负数</li><li><code>obj1</code>等于<code>obj2</code>，则返回零</li></ul><p>适用于对象没有实现<code>java.lang.Comparable</code>接口、或实现了<code>Comparable</code>接口但想重新定义排序规则的情况，如对<code>person</code>列表进行排序，规则为年龄相同，按id从小到大排序，年龄不同，按年龄从小到大进行排序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o1.getAge() != o2.getAge()) &#123;<br>            <span class="hljs-comment">// 年龄相同</span><br>            <span class="hljs-keyword">return</span> Integer.compare(o1.getAge(), o2.getAge());<br>        &#125;<br>        <span class="hljs-keyword">return</span> Long.compare(o1.getId(), o2.getId());<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>Java8中<code>Lambda</code>表达式对<code>Comparator</code>实现可以进行简化，减少匿名类的冗余代码，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.sort((o1, o2) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (o1.getAge() != o2.getAge()) &#123;<br>        <span class="hljs-comment">// 年龄相同</span><br>        <span class="hljs-keyword">return</span> Integer.compare(o1.getAge(), o2.getAge());<br>    &#125;<br>    <span class="hljs-keyword">return</span> Long.compare(o1.getId(), o2.getId());<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><code>Comparable</code></p><ul><li>通过类实现接口、重写比较方法，这样在每次使用的时候就不用重写排序方法，方便、但灵活性较差</li><li>当需要定义对象的自然排序时，例如数据库实体通常需要一种自然的排序方式</li></ul><p><code>Comparator</code></p><ul><li>在排序时重写排序方法，每次进行排序比较时需要重写比较方法，麻烦、但灵活性较高</li><li>当需要多种排序方式或者排序方式需要频繁更改时，例如根据不同场景进行数据展示时的排序</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过实现<code>Comparator</code>接口，开发者可以控制集合的排序行为，从而使代码更加灵活和强大。无论是对数据库查询结果进行排序，还是对复杂数据结构进行管理，<code>Comparator</code>都是一个非常有用的工具。在使用时，考虑到性能和可读性，选择正确的比较逻辑和排序策略至关重要。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java常用API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BigDecimal</title>
    <link href="/2021/04/09/javase-bigdecimal/"/>
    <url>/2021/04/09/javase-bigdecimal/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在进行精确计算时，Java的基本浮点类型（如float和double）无法避免精度损失，这对于财务、科学等需要高精度计算的应用是不可接受的。<code>BigDecimal</code>类提供了精确的浮点数计算功能，能够处理这类问题。                                                                                                                                                                </p><h2 id="精度丢失"><a href="#精度丢失" class="headerlink" title="精度丢失"></a>精度丢失</h2><p>浮点数进行计算会产生丢失精度的现象，这种舍入误差的主要原因是<strong>浮点数值采用二进制系统表示</strong>，而在<strong>二进制系统中无法精确地表示分数 1/10</strong>，从而导致计算误差。</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-number">2.0</span> - <span class="hljs-number">1.9</span>);<br></code></pre></div></td></tr></table></figure><p>以上程序运行，控制台打印结果为<code>0.10000000000000009</code>，而不是<code>0.1</code>。</p><p>为解决以上问题，Java专门提供了一个类<code>BigDecimal</code>，用于需要高精度计算的场景。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h3 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><ul><li><code>BigDecimal(int val)</code></li><li><code>BigDecimal(long val)</code></li><li><code>BigDecimal(String val)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal bd1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">1</span>);<br>BigDecimal bd3 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">3L</span>);<br>BigDecimal bd4 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;4.5&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>不推荐使用<code>double</code>类型进行构造，因为浮点数无法准确的表示一个数，如1/10，前面已经说过，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal bigDecimal = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0.1</span>);<br>System.out.println(bigDecimal);<br></code></pre></div></td></tr></table></figure><p>输出结果为<code>0.1000000000000000055511151231257827021181583404541015625</code></p><p>如果需要使用浮点数构造<code>BigDecimal</code>，则需要使用另一个构造方法</p><ul><li><code>BigDecimal valueOf(double val)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jva">BigDecimal bd5 = BigDecimal.valueOf(0.1);<br>System.out.println(bd5);<br></code></pre></div></td></tr></table></figure><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><p>对于<code>BigDecimal</code>对象，一般使用<code>compareTo</code>方法比较两个数的大小</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal bd1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1&quot;</span>);<br>BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;2&quot;</span>);<br>BigDecimal bd3 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(bd1.compareTo(bd2));     <span class="hljs-comment">// -1：小于</span><br>System.out.println(bd2.compareTo(bd1));     <span class="hljs-comment">// 1 ：大于</span><br>System.out.println(bd2.compareTo(bd3));     <span class="hljs-comment">// 0 ：等于</span><br></code></pre></div></td></tr></table></figure><h3 id="常用计算"><a href="#常用计算" class="headerlink" title="常用计算"></a>常用计算</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal bd1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;4.000&quot;</span>);<br>BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;3&quot;</span>);<br><span class="hljs-comment">// +</span><br>BigDecimal addRes = bd1.add(bd2);<br><span class="hljs-comment">// -</span><br>BigDecimal subRes = bd1.subtract(bd2);<br><span class="hljs-comment">// ×</span><br>BigDecimal mulRes = bd1.multiply(bd2);<br><span class="hljs-comment">// ÷</span><br>BigDecimal divRes = bd1.divide(bd2, RoundingMode.HALF_DOWN);<br><br>System.out.println(addRes);     <span class="hljs-comment">// 7.000</span><br>System.out.println(subRes);     <span class="hljs-comment">// 1.000</span><br>System.out.println(mulRes);     <span class="hljs-comment">// 12.000</span><br>System.out.println(divRes);     <span class="hljs-comment">// 1.333</span><br></code></pre></div></td></tr></table></figure><p>注意除法较为特殊，需要指定另外一个参数“舍入规则”，如向正无穷大靠近、向负无穷大靠近、四舍五入，否则遇到无限循环小数时会抛出异常</p><p>其他加减乘方法可指定可不指定舍入规则</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;Non-terminating decimal expansion; &quot;</span> +<br>                                              <span class="hljs-string">&quot;no exact representable decimal result.&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="转换结果"><a href="#转换结果" class="headerlink" title="转换结果"></a>转换结果</h3><p><code>BigDecimal</code>对象可以转换为字符串、整形、浮点型，如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.1&quot;</span>);<br><span class="hljs-keyword">int</span> i = bd.intValue();<br><span class="hljs-keyword">long</span> l = bd.longValue();<br><span class="hljs-keyword">double</span> v = bd.doubleValue();<br>String s = bd.toString();<br><br>System.out.println(i);      <span class="hljs-comment">// 0</span><br>System.out.println(l);      <span class="hljs-comment">// 0</span><br>System.out.println(v);      <span class="hljs-comment">// 0.1</span><br>System.out.println(s);      <span class="hljs-comment">// 0.1</span><br></code></pre></div></td></tr></table></figure><p>注意：浮点型转换为整形时会出现精度损失！</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>可使用类 <code>DecimalFormat</code> 对 <code>BigDecimal</code> 对象进行格式化以及设置舍入规则</p><p>占位符 <code>0</code> 与占位符 <code>#</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">DecimalFormat df1 = <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;00.00&quot;</span>);<br>DecimalFormat df2 = <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.00&quot;</span>);<br>DecimalFormat df3 = <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;##.##&quot;</span>);<br><br>BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.3&quot;</span>);<br>System.out.println(df1.format(bd));<span class="hljs-comment">// 00.30</span><br>System.out.println(df2.format(bd));<span class="hljs-comment">// .30</span><br>System.out.println(df3.format(bd));<span class="hljs-comment">// 0.3</span><br></code></pre></div></td></tr></table></figure><p>从以上可以看出，占位符<code>0</code>有多少个，最后的结果就有多少位，而<code>#</code>则只保留有效数字</p><h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><p><strong>金钱格式化</strong>：小数点左边3为分隔，只保留有效数字，但最少为一位，右边则是保留两位数字</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">DecimalFormat df4 = <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;,##0.00&quot;</span>);<br>df4.setRoundingMode(RoundingMode.UP);<br>BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1233.230&quot;</span>);<br>BigDecimal bd3 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;13.232&quot;</span>);<br>BigDecimal bd4 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.232&quot;</span>);<br>System.out.println(df4.format(bd2));        <span class="hljs-comment">// 1,233.23</span><br>System.out.println(df4.format(bd3));        <span class="hljs-comment">// 13.23</span><br>System.out.println(df4.format(bd4));        <span class="hljs-comment">// 0.23</span><br></code></pre></div></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>性能考虑</strong>：虽然 <code>BigDecimal</code> 提供了高精度，但其运算速度慢于原始类型。在不需要极高精度的场景下，考虑性能和需求之间的平衡。</li><li><strong>内存使用</strong>：<code>BigDecimal</code> 由于其复杂性，相比原始类型会占用更多内存。适当时进行优化，例如在进行大量计算时复用对象。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>BigDecimal</code>是处理需要高度精确数值的理想选择。通过其各种方法，可以进行精确的数学运算，避免了常规浮点类型的局限。虽然<code>BigDecimal</code>的操作相比原生类型更为复杂和耗时，但在精确度至关重要的情况下，这种性能的牺牲是合理的。使用时需要特别注意其与<code>BigInteger</code>的不同，以及如何选择合适的数学运算方法来满足具体需求。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>常用API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2021/03/23/linux-commands/"/>
    <url>/2021/03/23/linux-commands/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Linux系统是许多IT专业人士和爱好者必须掌握的关键技能之一。本文详细介绍了多种Linux命令，旨在帮助用户有效地管理和操作Linux系统。从文件管理到系统监控，从网络配置到用户管理，每个部分都为读者提供了必要的命令及其选项。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p><strong>命令说明</strong>：<code>sync</code> 命令用于将内存缓冲区中的数据同步到磁盘中。这个命令通常在执行重启或关机之前运行，以确保所有暂存的文件系统写入都被写入到相应的存储设备上，从而防止数据丢失。</p><p><strong>常用选项</strong></p><ul><li><code>-f</code>：强制同步，即使文件系统不认为需要。</li><li><code>-d</code>：只同步文件数据，不同步元数据。</li></ul><p><strong>注意事项</strong>：</p><ul><li>在大多数现代Linux系统中，<code>sync</code> 通常是在系统关机或重启时自动执行的，因此手动运行此命令并不总是必要的。</li><li>尽管如此，如果在进行大量文件写入操作后，需要确保数据的安全性，手动执行 <code>sync</code> 命令依然是一个好习惯。</li><li>在使用 <code>sync</code> 命令时，需要有一定的耐心等待命令执行完毕，特别是在数据量大或存储设备较慢的情况下。</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p><strong>命令说明</strong>：<code>shutdown</code> 命令用于安全地关闭或重启系统。它允许管理员指定关机时间并向所有登录的用户发送通知消息，确保系统按预期方式停止所有服务并关闭。</p><p><strong>常用选项</strong></p><ul><li><code>-r</code>：重启计算机。</li><li><code>-h</code>：关机后关闭电源。</li><li><code>-h now</code>：立即关机。</li><li><code>-h +m</code>：在m分钟后关机。</li><li><code>-h hh:mm</code>：在指定时间（24小时制）关机。</li></ul><p><strong>注意事项</strong>：</p><ul><li>使用 <code>shutdown</code> 命令时，应确保所有重要数据已保存，因为该命令将关闭所有运行的程序。</li><li>如果系统中有其他用户正在活动，最好提前通知他们关机或重启的计划，避免数据丢失或工作中断。</li><li>在多用户系统中，执行 <code>shutdown</code> 命令通常需要管理员权限。</li><li>使用 <code>shutdown</code> 命令代替直接断电可以防止文件系统损坏和数据丢失，因为它会先关闭所有服务和程序。</li></ul><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p><strong>命令说明</strong>：<code>poweroff</code> 命令用于安全地关闭系统并完全断电。这个命令在保证不会损坏文件系统或丢失数据的前提下，逐步关闭所有进程，然后断开电源。</p><p><strong>常用选项</strong></p><ul><li><code>-f</code>：强制立即关机，跳过标准的关机流程。使用此选项可能导致未保存的数据丢失或文件系统损坏。</li><li><code>-p</code>：在关机后断电，这通常是默认行为。</li><li><code>-h</code>：等同于 <code>-p</code>，用于旧版系统兼容性，确保关机后硬件断电。</li><li><code>-d</code>：关机但不断电，这主要用于测试。</li></ul><p><strong>注意事项</strong></p><ul><li>在执行 <code>poweroff</code> 之前，应确保所有重要数据已经保存，特别是在使用 <code>-f</code> 强制关机选项时。</li><li>由于 <code>poweroff</code> 会彻底断电，确认硬件支持安全断电是必要的，以避免硬件损坏。</li><li>在多用户环境中，执行 <code>poweroff</code> 之前通知所有用户是一个良好的实践，以避免突然断电造成的工作丢失或其他不便。</li><li>通常，执行 <code>poweroff</code> 命令需要管理员权限，因为它涉及到整个系统的操作。</li></ul><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p><strong>命令说明</strong>：<code>halt</code> 命令用于停止所有CPU函数，通常用于系统维护或当系统需要物理检修时。它关闭所有运行的程序并停止操作系统，但不一定断电。</p><p><strong>常用选项</strong></p><ul><li><code>-p</code>：通常与 <code>poweroff</code> 命令的功能相同，用于关机并断电。</li><li><code>-f</code>：强制立即停止，跳过常规的关机流程，这可能会导致未保存的数据丢失。</li><li><code>-w</code>：只写入记录到 <code>wtmp</code> 文件（记录关机的日志）中，而不实际关机。</li><li><code>-d</code>：关机但不写入 <code>wtmp</code> 和 <code>utmp</code> 日志。</li></ul><p><strong>注意事项</strong></p><ul><li><code>halt</code> 通常不应该用于日常关机，因为它不保证完全断电。日常关机推荐使用 <code>poweroff</code> 或 <code>shutdown</code> 命令。</li><li>使用 <code>halt</code> 命令时，应确保系统处于安全状态，特别是在强制停止时，以避免文件系统损坏或数据丢失。</li><li>由于 <code>halt</code> 直接停止所有硬件活动，而非逐步关闭进程，因此应谨慎使用，以防止对系统或硬件造成不可逆损害。</li><li>在多用户系统中，最好在执行 <code>halt</code> 之前通知所有用户，以防止数据丢失或工作中断。</li></ul><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><strong>命令说明</strong>：<code>init</code> 命令用于控制运行级别（runlevel）的变更。在传统的Unix和Linux系统中，<code>init</code> 是所有进程的祖先（PID为1），负责系统的启动、运行和关闭。使用 <code>init</code> 命令，管理员可以更改系统的运行级别，例如从多用户模式切换到单用户模式，或者反过来。</p><p><strong>常用选项</strong></p><ul><li><code>0</code>：关机。</li><li><code>1</code>：单用户模式，主要用于维护。</li><li><code>3</code>：多用户文本模式，没有图形界面。</li><li><code>5</code>：多用户图形模式。</li><li><code>6</code>：重启。</li></ul><p><strong>注意事项</strong></p><ul><li><code>init</code> 命令在不同的Linux发行版中可能表现不同，尤其是在许多现代Linux发行版（如使用systemd的系统）中，<code>init</code> 命令已被 <code>systemctl</code> 替代。</li><li>使用 <code>init</code> 命令改变运行级别时，需要管理员权限，并且必须确保系统处于可以安全改变运行级别的状态。</li><li>在多用户系统中，更改运行级别前应通知所有用户，以避免突然的运行级别变更导致的数据丢失或工作中断。</li><li>考虑到 <code>init</code> 命令的强大功能和潜在的系统影响，使用时应格外谨慎。</li></ul><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p><strong>命令说明</strong>： <code>reboot</code> 命令用于重新启动计算机。它通常在系统更新或需要重启以应用配置变更时使用。该命令会关闭所有运行的程序，然后重新启动系统。</p><p>：<strong>常用选项</strong></p><ul><li><code>-p</code>：当与 <code>reboot</code> 命令一起使用时，此选项将关闭系统电源。</li><li><code>-f</code>：强制立即重启，绕过常规的关闭过程。这种方式可能会导致未保存的数据丢失。</li><li><code>-h</code>：同 <code>-p</code>，用于关机并断电。</li><li><code>-i</code>：在重启前关闭所有网络接口。</li></ul><p><strong>注意事项</strong>：</p><ul><li>使用 <code>reboot</code> 命令前，应确保已保存所有工作和重要数据，以避免数据丢失。</li><li><code>reboot</code> 命令在多用户系统中执行时，最好通知所有用户即将重启，以防他们有正在进行的任务。</li><li>在不支持热重启的硬件上，频繁使用 <code>reboot</code> 命令可能会对硬件造成额外压力。</li><li>使用 <code>-f</code> 选项可以快速重启系统，但这应该谨慎使用，因为它会跳过许多正常的关闭步骤，可能导致系统不稳定或数据损坏。</li></ul><h3 id="logout"><a href="#logout" class="headerlink" title="logout"></a>logout</h3><p><strong>命令说明</strong>：<code>logout</code> 命令用于从当前登录的会话中退出。它常用在命令行界面，特别是在远程登录会话（如SSH）中。使用此命令可以安全地结束会话，并关闭对应的终端。</p><p><strong>常用选项</strong><br><code>logout</code> 命令通常不需要任何选项，直接输入 <code>logout</code> 即可执行。</p><p><strong>注意事项</strong></p><ul><li><code>logout</code> 命令只能在登录的shell会话中使用。例如，如果你是通过图形界面启动的终端，直接使用 <code>logout</code> 可能不会有任何作用，或者会显示错误消息。</li><li>在使用远程终端或多用户环境时，使用 <code>logout</code> 来结束会话是一个良好的安全实践，可以防止未授权的访问。</li><li>如果尝试在脚本中使用 <code>logout</code> 命令，可能不会产生预期效果，因为它只对交互式登录会话有效。</li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p><strong>命令说明</strong>：<code>uname</code> 命令用于打印当前系统的详细信息，包括操作系统、内核版本、硬件名称等。这个命令对于快速了解正在使用的系统环境非常有用。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：显示所有可用的系统信息（all），包括内核名称、节点名称、内核版本、机器、处理器、硬件平台和操作系统。</li><li><code>-r</code>：显示内核版本（release）。</li><li><code>-s</code>：显示内核名称（system），这通常是默认操作。</li><li><code>-m</code>：显示机器硬件名称（machine），通常是指CPU类型。</li><li><code>-p</code>：显示处理器类型（processor）。</li><li><code>-o</code>：显示操作系统名（operating system）。</li></ul><p><strong>注意事项</strong></p><ul><li><code>uname</code> 命令是只读的，即它不会修改系统设置或配置，只提供信息。</li><li>该命令在所有主要的Linux发行版和Unix系统中都可用，是跨平台兼容的。</li><li>使用 <code>-a</code> 选项可以快速获取系统的综合信息，这在进行故障排查或系统性能分析时特别有用。</li><li><code>uname</code> 的输出对系统管理员和开发人员来说非常重要，因为它帮助他们确认软件和驱动程序的兼容性问题。</li></ul><h3 id="arch"><a href="#arch" class="headerlink" title="arch"></a>arch</h3><p><strong>命令说明</strong>：<code>arch</code> 命令用于显示当前机器的处理器架构。它是 <code>uname -m</code> 命令的简化版，提供了快速查看系统架构信息的途径，如 x86_64、i686、arm等。</p><p><strong>常用选项</strong><br><code>arch</code> 命令通常没有额外的选项，直接执行 <code>arch</code> 即可显示结果。</p><p><strong>注意事项</strong></p><ul><li><code>arch</code> 命令输出的信息比较简单，主要用于快速确认系统的硬件架构。</li><li>在编写跨平台兼容的脚本或程序时，使用 <code>arch</code> 可以帮助开发者判断运行环境，从而作出相应的处理。</li><li>由于输出信息较少，<code>arch</code> 命令常被用作其他脚本和命令的一部分，以提供必要的系统架构信息。</li></ul><h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p><strong>命令说明</strong>：<code>lsusb</code> 是一个用于显示本机的 USB 设备的列表的命令。这个命令对于诊断和管理 USB 设备特别有用，可以查看挂载的设备信息，包括设备厂商、设备ID等。</p><p><strong>常用选项</strong></p><ul><li><code>-v</code>：显示详细信息。输出包括关于USB设备的所有可用信息。</li><li><code>-t</code>：显示USB设备的树状结构，帮助理解设备之间的连接关系。</li><li><code>-s [bus]:[devnum]</code>：显示指定USB总线和设备编号的设备详情。</li><li><code>-d [vendor]:[product]</code>：显示指定厂商和产品ID的设备信息。</li></ul><p><strong>注意事项</strong></p><ul><li>运行 <code>lsusb</code> 命令可能需要管理员权限，尤其是在使用 <code>-v</code> 选项显示详细信息时。</li><li>对于系统中连接的USB设备较多的情况，使用 <code>-t</code> 选项可以更清晰地查看设备的层级和依赖关系。</li><li>在使用 <code>-d</code> 选项时，厂商ID和产品ID应以16进制形式提供，这些信息可以通过简单的 <code>lsusb</code> 命令得到。</li><li>由于 <code>lsusb</code> 主要用于查看信息，所以它不会对系统或USB设备产生任何更改或影响。</li></ul><h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p><strong>命令说明</strong>：<code>lspci</code> 是一个用于显示当前主机的所有PCI总线信息及所有已连接的PCI设备信息的命令。这个命令非常有用，可以帮助用户了解主机的硬件配置，尤其是与PCI设备相关的配置，包括显卡、声卡、网卡等。</p><p><strong>常用选项</strong></p><ul><li><code>-v</code>：显示详细信息。输出包括设备的详细信息，较基本输出更全面。</li><li><code>-t</code>：以树状格式显示PCI设备，帮助用户理解设备之间的层级关系。</li><li><code>-n</code>：显示PCI设备的厂商和设备代码，而不是其名称，这有助于快速识别设备。</li><li><code>-s [bus]:[device]:[function]</code>：显示指定位置的PCI设备详情，这些位置参数需要精确指定。</li></ul><p><strong>注意事项</strong></p><ul><li>在使用 <code>-v</code> 选项时，可能需要超级用户权限，以获取更详细的信息。</li><li><code>lspci</code> 命令输出的信息量可能很大，特别是在设备较多的系统上，使用管道命令如 <code>grep</code> 可以帮助过滤并找到感兴趣的信息。</li><li>使用 <code>-t</code> 选项可以帮助新手更好地理解PCI设备的物理或逻辑排列。</li><li>这个命令主要用于信息检索，不会修改任何设备设置或系统配置。</li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p><strong>命令说明</strong><br><code>hostname</code> 命令用于显示或设置系统的主机名。主机名是识别网络中设备的一个标识符，它在网络通信中非常重要，例如在使用SSH远程登录时。</p><p><strong>常用选项</strong></p><ul><li><code>-f</code>：显示完全限定域名（FQDN），即包括域的完整主机名。</li><li><code>-i</code>：显示主机的网络地址（IP地址）。</li><li><code>-s</code>：显示短主机名，即不包括域名的部分。</li><li><code>新主机名</code>：直接跟在命令后的新主机名，用于设置系统的主机名。</li></ul><p><strong>注意事项</strong></p><ul><li>改变主机名时，需要管理员权限，并且改变会即刻生效，但在某些系统中，重启后才会永久生效。</li><li>主机名应避免使用特殊字符或过长的名称，以免造成网络通信中的问题。</li><li>在网络中，应确保每个设备的主机名是唯一的，以避免网络服务错误。</li><li>使用 <code>-f</code> 和 <code>-i</code> 选项可以帮助诊断网络问题，了解主机在网络中的标识。</li></ul><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p><strong>命令说明</strong>：<code>who</code> 命令用于显示当前登录系统的所有用户信息。它提供了用户的登录名、所用的终端、登录时间等信息，有助于系统管理员监控和管理系统使用情况。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：显示所有信息，包括用户、终端、登录时间、空闲时间、进程号等。</li><li><code>-H</code>：在输出的信息中包含列标题，使得信息更易于理解。</li><li><code>-q</code>：显示登录用户的名称和总数，快速查看当前登录的用户数量。</li><li><code>-u</code>：显示用户登录以及空闲时间，有助于了解用户的活跃程度。</li></ul><p><strong>注意事项</strong></p><ul><li><code>who</code> 命令非常适合用来快速检查系统中活跃的用户，特别是在多用户环境中。</li><li>输出信息中的终端名可以帮助识别用户是从物理终端登录还是通过网络。</li><li>使用 <code>who</code> 命令时，应注意隐私和安全问题，因为它显示了当前系统中所有用户的登录信息。</li><li>在脚本中使用 <code>who</code> 命令可以自动化某些基于用户活动的任务，如自动注销长时间空闲的用户。</li></ul><h3 id="who-am-i"><a href="#who-am-i" class="headerlink" title="who am i"></a>who am i</h3><p><strong>命令说明</strong>：<code>who am i</code> 命令用于显示当前用户的登录信息，包括用户名、终端号以及登录时间。这个命令实际上是 <code>who</code> 命令的一个特定用法，常用来确认当前会话的用户身份。</p><p><strong>常用选项</strong><br>这个命令通常不带额外选项，直接输入 <code>who am i</code> 就可以返回当前会话的登录信息。</p><p><strong>注意事项</strong></p><ul><li><code>who am i</code> 与 <code>whoami</code> 命令不同。<code>whoami</code> 只返回当前用户的用户名，而 <code>who am i</code> 返回的是完整的登录会话信息。</li><li>在使用远程登录（如SSH）时，<code>who am i</code> 可以显示从哪个终端和IP地址登录的信息，对于检查和确认用户身份非常有用。</li><li>有时在脚本中使用 <code>who am i</code> 命令来确定脚本是以何种用户身份运行，尤其是在权限敏感的操作中。</li><li>在某些环境中，如图形终端会话或某些配置的SSH环境下，<code>who am i</code> 命令可能不返回任何输出，这取决于系统如何记录会话信息。</li></ul><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p><strong>命令说明</strong>：<code>uptime</code> 命令用于显示系统自上次启动以来已运行的时间，包括当前时间、系统运行时间、登录用户数以及平均负载。这个命令可以快速提供系统的活动概况，对于监控系统健康状态非常有用。</p><p><strong>常用选项</strong><br><code>uptime</code> 命令通常不带额外的选项，直接执行 <code>uptime</code> 即可显示系统运行时间和当前的负载信息。</p><p><strong>注意事项</strong></p><ul><li><code>uptime</code> 命令提供的负载平均数表示过去1分钟、5分钟和15分钟的时间内，系统等待运行的进程平均数量。这些数字有助于评估系统的当前负载情况。</li><li>在多用户系统中，<code>uptime</code> 可以快速显示当前的活跃用户数量，有助于管理员了解系统的使用情况。</li><li>该命令非常适合用于监控和报告脚本中，尤其是在需要定期检查系统运行状态的自动化任务中。</li><li>虽然<code>uptime</code>命令输出简洁，但提供的信息对于判断系统是否正常运行非常关键。</li></ul><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p><strong>命令说明</strong>：<code>env</code> 命令用于显示当前用户的环境变量或在修改后的环境中执行指定命令。它可以列出所有的环境变量，包括用户的路径（PATH）、使用的外壳（SHELL）等，或者在特定的环境设置下运行程序。</p><p><strong>常用选项</strong></p><ul><li><code>-i</code> 或 <code>--ignore-environment</code>：在一个空的环境中启动指定的命令。</li><li><code>-u</code> 或 <code>--unset</code>：删除指定的环境变量后执行命令。</li><li><code>变量=值</code>：在环境中设置一个变量后执行命令。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>env</code> 命令可以在不改变当前环境变量的情况下，临时修改环境变量来运行程序，这在开发和测试中非常有用。</li><li><code>env</code> 命令也常用于脚本中，确保脚本在预定的环境变量设置下运行。</li><li>在使用 <code>-i</code> 选项时，因为所有环境变量都被忽略，所以执行命令可能需要手动设置一些必需的环境变量，比如 <code>PATH</code>，以避免找不到基本的命令。</li><li><code>env</code> 命令非常适合用来查看当前的环境设置，特别是在复杂的开发环境中，了解当前设置的环境变量可以帮助排查问题。</li></ul><h3 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h3><p><strong>命令说明</strong>：<code>lsmod</code> 命令用于显示当前加载的内核模块的状态。它从 <code>/proc/modules</code> 读取信息，提供了关于各个模块的名称、大小、被使用的次数以及依赖关系等详细信息。这个命令对于系统管理员来说是理解和管理Linux内核模块非常重要的工具。</p><p><strong>常用选项</strong><br><code>lsmod</code> 命令本身不带额外的选项，直接执行 <code>lsmod</code> 即可获得当前系统所有活动的内核模块列表。</p><p><strong>注意事项</strong></p><ul><li>在使用 <code>lsmod</code> 命令时，输出列表中的“Used by”列非常重要，它显示了每个模块被其他模块依赖的情况，有助于确定模块之间的依赖性。</li><li>当需要卸载或故障排查某个模块时，<code>lsmod</code> 提供的信息可以帮助判断是否可以安全地卸载该模块，或者哪些模块可能因依赖问题而受到影响。</li><li>对于新手或不熟悉内核模块的用户，<code>lsmod</code> 的输出可能显得复杂。在这种情况下，结合使用 <code>modinfo</code> 命令来获取有关特定模块的更多信息会更有帮助。</li><li>由于 <code>lsmod</code> 命令显示的是内核模块的实时状态，所以在进行系统维护或调优时，这个命令是不可或缺的工具。</li></ul><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p><strong>命令说明</strong>：<code>date</code> 命令用于显示或设置系统日期和时间。这个命令可以格式化输出日期和时间信息，也可以用来修改系统的当前日期和时间，是系统管理中常用的工具。</p><p><strong>常用选项</strong></p><ul><li><code>+%Y-%m-%d %H:%M:%S</code>：使用指定的格式显示当前日期和时间，例如 <code>%Y</code> 表示四位年份，<code>%m</code> 表示两位月份，等等。</li><li><code>-u</code> 或 <code>--utc</code> 或 <code>--universal</code>：显示或设置协调世界时（UTC）。</li><li><code>-s</code> 或 <code>--set</code>：设置系统日期和时间，格式通常跟随日期字符串，例如 <code>date -s &quot;2024-05-25 20:00:00&quot;</code>。</li></ul><p><strong>注意事项</strong></p><ul><li>修改系统日期和时间通常需要管理员权限。</li><li>在脚本中使用 <code>date</code> 命令来记录事件发生的时间或作为日志文件的时间戳非常有用。</li><li>使用 <code>date</code> 命令时应注意系统的时间区设置，尤其是在处理跨时区的操作时。</li><li>如果系统配置了网络时间协议（NTP），手动更改系统时间后可能会被自动校正回网络时间。这在配置系统或进行故障排查时需特别注意。</li></ul><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p><strong>命令说明</strong>：<code>cal</code> 命令用于在终端显示公历日历。这个命令可以快速查看月历或年历，支持查看过去、现在和未来的日期信息。</p><p><strong>常用选项</strong></p><ul><li><code>年份</code>：显示指定年份的完整年历。</li><li><code>月份 年份</code>：显示指定年份和月份的日历，例如 <code>cal 5 2024</code> 显示2024年5月的日历。</li><li><code>-3</code>：显示当前月及其前后各一个月的日历。</li><li><code>-m</code>：以星期一作为一周的开始。</li></ul><p><strong>注意事项</strong></p><ul><li><code>cal</code> 命令默认显示当前月份的日历，其中周日作为一周的第一天。这可以通过 <code>-m</code> 选项改变，以符合国际标准。</li><li>在进行日期相关的计划或回顾时，使用 <code>cal</code> 命令可以快速获取日期信息，特别是在需要确定某一天是周几时。</li><li><code>cal</code> 命令是只读的，不能用来设置或更改日期，只用于查看。</li><li>对于简单的日期查看需求，<code>cal</code> 命令是一个轻量级且即时的选择，不需要复杂的图形界面支持。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><strong>命令说明</strong><br><code>top</code> 命令用于动态显示运行中的系统进程和资源使用情况，包括CPU使用率、内存占用、以及进程状态等。这是系统管理员和用户监控系统性能的重要工具。</p><p><strong>常用选项</strong></p><ul><li><code>-n</code>：指定更新次数，用于控制 <code>top</code> 命令自动退出前的屏幕更新次数。</li><li><code>-d</code>：指定屏幕刷新的时间间隔（秒），控制查看实时数据的速度。</li><li><code>-u</code>：显示指定用户的进程。</li><li><code>-p</code>：指定监控的进程ID，这样可以更专注于某些特定的进程。</li></ul><p><strong>注意事项</strong></p><ul><li><code>top</code> 命令在使用时可以交互式操作，比如按 <code>%</code> 可以按 CPU 使用率排序，按 <code>M</code> 可以按内存使用率排序。</li><li>在使用 <code>top</code> 时，按 <code>q</code> 可以随时退出。</li><li>这个命令可以帮助及时发现资源使用异常的进程，是优化系统性能的一个重要步骤。</li><li>虽然 <code>top</code> 提供了丰富的信息，但在输出信息量极大时可能会显得复杂难懂，特别是对初学者而言。使用帮助命令（按 <code>h</code>）可以获得关于如何操作和理解 <code>top</code> 的更多指导。</li></ul><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p><strong>命令说明</strong>：<code>vmstat</code> (Virtual Memory Statistics) 命令用于显示关于系统虚拟内存、进程、CPU活动以及I/O块设备的统计信息。这个命令可以帮助诊断系统性能问题，提供实时系统性能监控的能力。</p><p><strong>常用选项</strong></p><ul><li><code>1</code>：运行 <code>vmstat 1</code> 会每秒刷新一次输出，提供实时更新的系统性能数据。</li><li><code>-a</code>：显示活动和非活动内存信息。</li><li><code>-d</code>：显示磁盘相关的统计数据。</li><li><code>-s</code>：显示内存使用统计汇总。</li><li><code>-t</code>：在报告中包含时间戳信息，有助于日志记录和长期性能分析。</li></ul><p><strong>注意事项</strong></p><ul><li>在高负载系统中，频繁运行 <code>vmstat</code> 可能会对性能产生轻微的影响，尤其是在短时间间隔的情况下。</li><li><code>vmstat</code> 输出的某些列可能需要一些系统知识来正确理解，例如 <code>si</code> (交换进) 和 <code>so</code> (交换出) 指示的是内存与交换空间的活动情况。</li><li><code>vmstat</code> 提供的数据可以帮助确定系统的瓶颈，如CPU、内存或I/O，但可能需要结合其他工具进行深入分析。</li><li>使用 <code>vmstat</code> 监控系统时，观察一段时间的趋势通常比单次的快照更有信息量，尤其是在解决性能问题时。</li></ul><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p><strong>命令说明</strong>：<code>iostat</code> 命令用于显示系统的输入/输出统计信息，帮助监控系统的存储设备和分区的性能。该命令可以报告CPU利用率和每个物理磁盘的读写详细信息，非常适合分析性能问题和系统的瓶颈。</p><p><strong>常用选项</strong></p><ul><li><code>-x</code>：显示扩展统计信息，包括每个设备的详细性能数据。</li><li><code>-c</code>：仅显示CPU使用率。</li><li><code>-d</code>：仅显示磁盘统计信息。</li><li><code>-m</code>：显示统计信息的单位为MB/s。</li><li><code>-t</code>：显示时间戳，帮助追踪每次报告的具体时间。</li></ul><p><strong>注意事项</strong></p><ul><li><code>iostat</code> 命令通常用于定期监控系统性能，可与 <code>cron</code> 等工具结合使用，定时收集和记录数据。</li><li>在分析输出数据时，高的等待时间和低的利用率可能表明存储性能存在问题。</li><li>运行 <code>iostat</code> 可能需要一些基础的系统和硬件知识，特别是对于解释复杂的磁盘IO数据。</li><li>这个命令对于诊断系统延迟和磁盘使用效率非常有用，尤其是在处理大量数据读写的环境中。</li></ul><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><p><strong>命令说明</strong>：<code>sar</code> 命令用于收集、报告或保存系统活动信息（System Activity Report），是系统性能分析工具sysstat的一部分。它可以显示关于CPU使用率、内存使用、磁盘I/O、网络性能等的数据，非常适合用于系统性能的长期监控和历史数据分析。</p><p><strong>常用选项</strong></p><ul><li><code>-u</code>：报告CPU使用情况，包括用户空间、系统空间和空闲时间的使用比例。</li><li><code>-r</code>：报告内存使用情况，包括物理和虚拟内存的统计数据。</li><li><code>-b</code>：报告I/O和传输速率统计。</li><li><code>-n DEV</code>：报告网络设备的活动。</li><li><code>-f [文件名]</code>：从指定的文件中读取历史数据，而不是实时数据。</li></ul><p><strong>注意事项</strong></p><ul><li>使用<code>sar</code>命令前可能需要安装sysstat包，具体取决于系统发行版。</li><li><code>sar</code>可以配置为定期收集系统性能数据，通常与cron作业结合使用，将数据保存到日志文件中。</li><li>分析<code>sar</code>输出时需要一定的系统和性能分析知识，以正确解读各项指标的含义。</li><li><code>sar</code>命令的输出可以非常详细，使用过滤和排序工具（如 <code>grep</code>、<code>awk</code>）可以帮助提取和查看关键数据。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><strong>命令说明</strong>：<code>free</code> 命令用于显示系统的内存使用情况，包括物理内存、交换空间和缓存的详细信息。这个命令可以帮助用户快速了解系统当前的内存状况和资源利用率。</p><p><strong>常用选项</strong></p><ul><li><code>-m</code>：以兆字节（MB）为单位显示内存使用情况。</li><li><code>-g</code>：以千兆字节（GB）为单位显示内存使用情况。</li><li><code>-h</code>：显示易于阅读的格式，自动为输出选择合适的单位（KB、MB、GB）。</li><li><code>-t</code>：添加一行显示物理内存和交换空间的总计。</li><li><code>-s &lt;间隔&gt;</code>：持续显示内存状态，间隔为指定的秒数。</li></ul><p><strong>注意事项</strong></p><ul><li><code>free</code> 命令提供的是瞬时内存使用情况，对于动态变化的内存状况，建议多次运行或使用 <code>-s</code> 选项进行定期监控。</li><li>输出中的“buffer”和“cache”显示的是Linux内核用于缓冲和高速缓存的内存，这部分内存是可以被回收的，用于新的内存请求。</li><li>在评估系统的内存不足问题时，应关注“available”列，它提供了当前可用于新应用程序的内存估计值。</li><li><code>free</code> 是查看内存使用情况的快速工具，但对于更详细的分析，可能需要结合其他工具，如 <code>vmstat</code> 或 <code>top</code>。</li></ul><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p><strong>命令说明</strong>：<code>fdisk</code> 是一个用于磁盘分区的命令行工具。它允许用户创建、删除、调整和查看磁盘分区表。</p><p><strong>常用选项</strong></p><ul><li><code>-l</code>：列出所有磁盘及其分区信息。</li><li><code>-u</code>：以扇区为单位显示分区大小。</li><li><code>/dev/sdx</code>：指定要操作的磁盘设备，例如 <code>/dev/sda</code>。</li></ul><p><strong>交互式命令</strong><br>进入 <code>fdisk</code> 交互模式后，可以使用以下命令进行分区操作：</p><ul><li><code>m</code>：显示帮助菜单。</li><li><code>n</code>：新建一个分区。</li><li><code>d</code>：删除一个分区。</li><li><code>p</code>：显示当前分区表。</li><li><code>w</code>：将修改写入磁盘并退出。</li><li><code>q</code>：不保存修改并退出。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>fdisk</code> 修改分区表时，需要有管理员权限。</li><li>在对磁盘进行分区操作之前，建议备份重要数据，因为分区操作可能会导致数据丢失。</li><li><code>fdisk</code> 适用于MBR（主引导记录）分区表，对于GPT（GUID分区表），建议使用 <code>gdisk</code> 或 <code>parted</code>。</li><li>操作分区后，可能需要重新启动系统或使用 <code>partprobe</code> 命令来通知内核更新分区表。</li></ul><h3 id="swapon"><a href="#swapon" class="headerlink" title="swapon"></a>swapon</h3><p><strong>命令说明</strong>：<code>swapon</code> 命令用于启用交换空间（swap），它可以是一个交换分区或交换文件。这有助于系统在物理内存不足时使用磁盘空间作为虚拟内存。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：启用 <code>/etc/fstab</code> 文件中定义的所有交换设备。</li><li><code>-s</code>：显示当前已启用的交换空间信息，类似于 <code>cat /proc/swaps</code>。</li><li><code>-d</code>：禁用指定的交换设备。</li><li><code>-v</code>：显示详细操作信息。</li><li><code>--show</code>：显示交换空间信息，等同于 <code>-s</code> 选项。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>swapon</code> 命令启用交换空间需要管理员权限，通常通过 <code>sudo</code> 运行。</li><li>交换空间的配置通常在 <code>/etc/fstab</code> 文件中定义，可以使用 <code>swapon -a</code> 启用所有配置的交换设备。</li><li>启用交换文件时，确保文件具有合适的权限和大小，并且使用 <code>mkswap</code> 命令正确格式化过。</li><li>交换空间有助于系统在高负载情况下维持性能，但频繁使用交换空间可能会导致系统性能下降，因为磁盘I/O速度远低于内存访问速度。</li></ul><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p><strong>命令说明</strong>：<code>df</code>（disk free）命令用于显示文件系统的磁盘空间使用情况。它可以帮助用户了解磁盘分区的总空间、已用空间和剩余空间。</p><p><strong>常用选项</strong></p><ul><li><code>-h</code>：以人类可读的格式显示磁盘空间（例如，使用KB、MB、GB等单位）。</li><li><code>-T</code>：显示文件系统的类型。</li><li><code>-i</code>：显示inode的信息而不是块使用信息。</li><li><code>-a</code>：显示所有文件系统，包括大小为0的伪文件系统。</li><li><code>-l</code>：仅显示本地文件系统，不显示网络文件系统。</li><li><code>-t fstype</code>：仅显示指定类型的文件系统。</li><li><code>-x fstype</code>：排除指定类型的文件系统。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>df -h</code> 可以更直观地查看磁盘空间使用情况，因为它会自动选择合适的单位（如MB、GB）。</li><li><code>df -T</code> 可以帮助了解文件系统类型，有助于进行针对特定文件系统的维护操作。</li><li><code>df</code> 显示的是块设备的使用情况，不包括内存文件系统（如 tmpfs）或交换分区的使用情况，除非使用 <code>-a</code> 选项。</li><li>对于监控磁盘空间的自动化脚本，可以使用 <code>df</code> 命令结合 <code>grep</code> 和 <code>awk</code> 等工具，提取和处理所需的磁盘空间数据。</li></ul><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><strong>命令说明</strong>：<code>du</code>（disk usage）命令用于估算文件和目录的磁盘空间使用情况。它可以帮助用户了解哪些文件或目录占用了磁盘空间。</p><p><strong>常用选项</strong></p><ul><li><code>-h</code>：以人类可读的格式显示磁盘使用情况（例如，使用KB、MB、GB等单位）。</li><li><code>-s</code>：只显示每个参数的总计，而不显示其子目录的使用情况。</li><li><code>-a</code>：显示目录中每个文件的磁盘使用情况，而不仅仅是目录。</li><li><code>-c</code>：最后再加上一个总计行。</li><li><code>-d N</code>：仅显示深度为 N 的目录的磁盘使用情况。</li><li><code>-k</code>：以KB为单位显示磁盘使用情况（默认单位）。</li><li><code>-m</code>：以MB为单位显示磁盘使用情况。</li><li><code>--max-depth=N</code>：与 <code>-d N</code> 类似，仅显示深度为 N 的目录的磁盘使用情况。</li><li><code>--exclude=PATTERN</code>：排除匹配PATTERN的文件和目录。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>du -h</code> 可以更直观地查看磁盘使用情况，因为它会自动选择合适的单位（如MB、GB）。</li><li>使用 <code>du -s</code> 可以快速获取某个目录或文件的总磁盘使用情况，而无需查看详细的子目录信息。</li><li><code>du -a</code> 可以帮助识别具体的文件占用了多少磁盘空间，适合详细分析磁盘空间占用情况。</li><li>在大目录上运行 <code>du</code> 可能需要较长时间，可以通过限制深度（例如 <code>--max-depth</code>）来加快执行速度。</li></ul><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p><strong>命令说明</strong>：<code>mount</code> 命令用于挂载文件系统。它将设备（如硬盘分区、光驱、网络共享等）连接到目录树中的一个目录，使该目录成为访问该设备内容的入口。</p><p><strong>常用选项</strong></p><ul><li><code>-t type</code>：指定文件系统的类型，例如 <code>ext4</code>, <code>ntfs</code>, <code>vfat</code>, <code>iso9660</code> 等。</li><li><code>-o options</code>：指定挂载选项，例如 <code>ro</code>（只读）, <code>rw</code>（读写）, <code>noexec</code>, <code>nosuid</code> 等。多个选项用逗号分隔。</li><li><code>-a</code>：挂载 <code>/etc/fstab</code> 文件中定义的所有文件系统。</li><li><code>-r</code>：以只读方式挂载设备。</li><li><code>-v</code>：显示详细信息。</li><li><code>-L label</code>：按照文件系统标签挂载设备。</li><li><code>-U uuid</code>：按照文件系统的 UUID 挂载设备。</li></ul><p><strong>注意事项</strong></p><ul><li>挂载操作通常需要管理员权限，使用 <code>sudo</code> 命令。</li><li>挂载时要确保目标挂载点（目录）存在，如果不存在可以先创建目录，例如 <code>sudo mkdir /mnt/mydisk</code>。</li><li>在进行写操作之前，确保以读写模式（<code>rw</code>）挂载设备。</li><li>文件系统类型需要正确指定，否则挂载可能失败。</li><li>修改 <code>/etc/fstab</code> 文件可以设置文件系统在系统启动时自动挂载。</li></ul><h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p><strong>命令说明</strong>：<code>umount</code> 命令用于卸载已经挂载的文件系统。它将文件系统从目录树中分离，使设备不再被访问。</p><p><strong>常用选项</strong></p><ul><li><code>-f</code>：强制卸载文件系统，即使设备繁忙（仅适用于某些文件系统类型）。</li><li><code>-l</code>：延迟卸载文件系统，直到文件系统不再被使用时才实际卸载。</li><li><code>-v</code>：显示详细信息。</li><li><code>-r</code>：在无法卸载时尝试以只读方式重新挂载文件系统。</li></ul><p><strong>注意事项</strong></p><ul><li>卸载文件系统通常需要管理员权限，使用 <code>sudo</code> 命令。</li><li>在卸载之前，确保没有任何进程正在使用该文件系统，以避免数据丢失或文件系统损坏。可以使用 <code>lsof</code> 或 <code>fuser</code> 命令检查是否有进程在使用该文件系统。</li><li>强制卸载（<code>-f</code> 选项）可能导致数据丢失或文件系统不一致，应谨慎使用。</li><li>延迟卸载（<code>-l</code> 选项）在某些情况下非常有用，例如当设备被网络文件系统占用时。</li></ul><h3 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h3><p><strong>命令说明</strong>：<code>fuser</code> 命令用于显示使用指定文件、目录或文件系统的所有进程的标识符。它可以帮助系统管理员找出哪些进程正在使用特定的资源，从而执行进一步的操作（如终止进程或卸载文件系统）。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：显示所有指定文件的进程。</li><li><code>-k</code>：杀死访问指定文件的所有进程。</li><li><code>-i</code>：在杀死进程前进行交互确认，与 <code>-k</code> 选项一起使用。</li><li><code>-l</code>：列出所有已知的信号名称。</li><li><code>-m</code>：显示正在使用指定文件系统或挂载点的所有进程。</li><li><code>-n space</code>：指定命名空间（file, udp, tcp）进行操作。</li><li><code>-s</code>：显示简洁输出，不显示进程标识符。</li><li><code>-u</code>：显示进程所属的用户。</li><li><code>-v</code>：显示详细信息。</li><li><code>-V</code>：显示版本信息。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>fuser</code> 命令时需要有管理员权限，特别是使用 <code>-k</code> 选项终止进程时。</li><li>在终止进程之前，应确保不会对系统或用户造成不良影响。使用 <code>-i</code> 选项可以在终止进程前进行确认。</li><li><code>fuser</code> 命令可以与 <code>umount</code> 命令配合使用，找出导致文件系统繁忙的进程，以便安全地卸载文件系统。</li><li>显示的进程标识符可以用于进一步的管理操作，例如通过 <code>kill</code> 命令终止进程。</li></ul><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p><strong>命令说明</strong><br><code>useradd</code> 是一个用于创建新用户账户的命令。它是Linux系统管理员用来设置新用户和其属性的基本工具。</p><p><strong>常用选项</strong></p><ul><li><code>-m</code>：创建用户的同时创建用户的主目录。</li><li><code>-d /path/to/home</code>：指定用户的主目录。</li><li><code>-s /path/to/shell</code>：指定用户的登录shell。</li><li><code>-g group</code>：指定用户的初始登录组。</li><li><code>-G group1,group2</code>：指定用户的附加组。</li><li><code>-u UID</code>：指定用户的唯一用户ID。</li></ul><p><strong>注意事项</strong></p><ul><li>在没有 <code>-m</code> 选项的情况下，默认可能不会为新用户创建家目录，这取决于系统的配置。</li><li>使用 <code>-s</code> 选项为用户指定的登录shell应当是 <code>/etc/shells</code> 文件中列出的有效shell。</li><li>为用户指定的UID应该是唯一的，不应与系统中已存在的其他用户ID冲突。</li><li>在添加用户时，确保了解并设置了适当的权限和组，以防止安全问题。</li></ul><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p><strong>命令说明</strong>：<code>userdel</code> 是一个用于删除用户账户及其相关文件的命令。这个命令允许系统管理员从系统中移除用户的登陆能力和相关信息。</p><p><strong>常用选项</strong></p><ul><li><code>-r</code>：删除用户的同时，也删除用户的主目录以及邮件目录，这包括所有的文件和子目录。</li><li><code>-f</code>：强制删除用户，即使用户当前正在登录。</li></ul><p><strong>注意事项</strong></p><ul><li>删除用户时使用 <code>-r</code> 选项要非常小心，因为这将连同用户的个人数据一起删除，无法恢复。</li><li>在执行 <code>userdel</code> 命令时，确保用户没有正在运行的进程。可以使用 <code>pkill -u username</code> 命令来杀掉所有属于该用户的进程。</li><li>如果用户正在系统中登录或有活动的进程，直接删除可能会失败。在这种情况下，可能需要首先杀掉这些进程或从系统中注销该用户。</li><li>使用 <code>-f</code> 选项可以强制删除账户，即使用户还有活动进程也会进行删除。这个选项应谨慎使用，因为它可能导致未预期的问题，比如数据丢失或系统不稳定。</li><li><code>userdel</code> 命令通常需要管理员权限执行，通常通过 <code>sudo</code> 来运行。</li></ul><p>在进行用户删除操作之前，最好检查并确认是否有备份用户的重要数据，特别是如果使用了 <code>-r</code> 选项。这样可以避免因操作不当造成的数据丢失。</p><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p><strong>命令说明</strong>：<code>usermod</code> 命令用于修改已存在的用户账户的设置。它允许管理员更改用户的登录名、家目录、登录Shell、用户组等属性。</p><p><strong>常用选项</strong></p><ul><li><code>-l new_name</code>：更改用户的登录名。</li><li><code>-d /new/home</code>：更改用户的主目录，并使用 <code>-m</code> 选项同时移动所有内容到新目录。</li><li><code>-s /new/shell</code>：更改用户的默认登录Shell。</li><li><code>-g group</code>：更改用户的主组。</li><li><code>-G group1,group2</code>：更改用户的附加组列表，没有指定 <code>-a</code> 时会覆盖原有的附加组。</li><li><code>-a</code>：与 <code>-G</code> 一起使用，向用户的附加组列表添加新组而不移除现有组。</li><li><code>-u UID</code>：更改用户的用户ID (UID)。</li></ul><p><strong>注意事项</strong></p><ul><li>通常需要管理员权限执行。</li><li>修改用户登录名或用户ID时，确保新的名称或ID不与系统中其他用户冲突。</li><li>在更改主目录时，使用 <code>-m</code> 选项来确保用户的数据被正确迁移。</li><li>更改用户的Shell时，应确保新Shell在 <code>/etc/shells</code> 文件中被列出为有效。</li><li>修改用户组信息时，确保新的用户组已经存在。如果需要创建新组，可以使用 <code>groupadd</code> 命令。</li><li>使用 <code>-G</code> 选项时，如果不加 <code>-a</code>，原有的附加组信息将被新指定的信息覆盖。要添加而不是替换组，需同时使用 <code>-a</code> 选项。</li></ul><h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p><strong>命令说明</strong>：<code>groups</code> 命令用于显示指定用户所属的所有用户组。如果没有指定用户，它会显示当前用户的用户组。</p><p><strong>常用选项</strong></p><ul><li>通常不需要特别的选项，直接使用 <code>groups [username]</code> 即可显示用户的组信息。</li></ul><p><strong>注意事项</strong></p><ul><li>如果命令后不接任何用户名，<code>groups</code> 将显示当前登录用户的所有组信息。</li><li>此命令对于快速检查用户权限和组成员资格非常有用，尤其是在配置文件权限或调试访问问题时。</li><li>在多用户系统中，了解用户的组成员资格对于管理文件和目录的访问权限至关重要。</li></ul><p>使用 <code>groups</code> 命令是一个简单而有效的方法来验证用户的组信息，特别是在处理文件系统权限和用户权限管理时，了解这些信息非常关键。</p><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p><strong>命令说明</strong>：<code>groupadd</code> 命令用于创建一个新的用户组。它是系统管理员用来设置和管理系统用户组的基本工具。</p><p><strong>常用选项</strong></p><ul><li><code>-g GID</code>：指定新用户组的组ID（GID）。如果不指定，系统将自动分配下一个可用的GID。</li><li><code>-r</code>：创建一个系统组，系统组的GID通常小于1000（具体值取决于发行版）。</li></ul><p><strong>注意事项</strong></p><ul><li>通常需要管理员权限执行。</li><li>创建新组之前应确保组名唯一，避免与现有组名冲突。</li><li>确保使用的GID不与系统中现有的GID冲突，尤其是当手动指定GID时。</li><li>系统组通常用于系统服务和进程，而非普通用户使用，因此在创建系统组时应谨慎考虑其用途和安全性。</li></ul><h3 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h3><p><strong>命令说明</strong>：<code>groupdel</code> 命令用于删除现有的用户组。这允许系统管理员移除不再需要的用户组。</p><p><strong>常用选项</strong></p><ul><li>此命令通常没有特殊选项，直接使用 <code>groupdel groupname</code> 即可删除指定的组。</li></ul><p><strong>注意事项</strong></p><ul><li>在删除用户组之前，确保没有任何用户仍然属于该组。如果尝试删除一个仍有成员的组，此命令可能会失败。</li><li>删除用户组可能会影响依赖该组权限设置的系统服务和应用，因此在执行删除操作之前应仔细考虑其可能带来的影响。</li><li>此命令不会删除组目录，如有需要，需要手动删除相关文件和目录。</li><li>使用此命令需要具有管理员权限，通常需要通过 <code>sudo</code> 进行。</li></ul><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p><strong>命令说明</strong><br><code>groupmod</code> 命令用于修改现有用户组的属性。这包括更改用户组的名称或组ID（GID）。</p><p><strong>常用选项</strong></p><ul><li><code>-n new_name</code>：更改用户组的名称。</li><li><code>-g GID</code>：更改用户组的GID。当指定新的GID时，应确保它不与现有的GID冲突。</li></ul><p><strong>注意事项</strong></p><ul><li>通常需要管理员权限执行。</li><li>更改用户组名称时，应确保新名称不与系统中任何现有的用户组或用户名冲突。</li><li>更改GID时，应检查系统中是否有文件或目录仍然引用旧的GID，因为这些文件的权限可能需要相应更新。</li><li>在更改用户组信息之前，通知所有可能受影响的系统用户和服务是一个好习惯，以避免潜在的访问问题。</li></ul><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p><strong>命令说明</strong>：<code>su</code>（switch user 或 substitute user）命令用于在同一个登录会话中切换不同用户的身份，通常用于获取超级用户（root）权限或切换到其他用户。</p><p><strong>常用选项</strong></p><ul><li>无参数：默认切换到超级用户（root）。</li><li><code>-</code>：切换到指定用户的登录环境，包括环境变量和工作目录，如 <code>su - username</code>。</li><li><code>username</code>：直接跟在 <code>su</code> 后的用户名，切换到该用户，但不加载用户的完整环境。</li><li><code>-c command</code>：以指定用户的身份执行一个命令，然后返回到原用户。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>su</code> 命令时通常需要输入目标用户的密码，除非是root用户切换到其他用户。</li><li>频繁使用 <code>su</code> 切换到root用户可能带来安全风险，建议仅在必要时使用。</li><li>在使用 <code>-c</code> 选项执行命令后，会立即返回原始用户，这对于脚本中执行单个命令很有用。</li><li>使用带 <code>-</code> 的 <code>su</code>（如 <code>su -</code> 或 <code>su - username</code>）会启动一个登录shell，这意味着会读取用户的配置文件（如<code>.bash_profile</code>），设置一个与直接登录该用户相似的环境。</li></ul><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p><strong>命令说明</strong>：<code>passwd</code> 命令用于修改用户的登录密码。它是用户和系统管理员管理账户安全的基本工具。</p><p><strong>常用选项</strong></p><ul><li>无参数：默认修改当前用户的密码。</li><li><code>username</code>：指定一个用户，修改该用户的密码（需要管理员权限）。</li><li><code>--status</code>：显示用户的密码状态信息。</li><li><code>-e</code> 或 <code>--expire</code>：强制用户在下次登录时修改密码。</li><li><code>-l</code> 或 <code>--lock</code>：锁定用户密码，禁止用户登录。</li><li><code>-u</code> 或 <code>--unlock</code>：解锁用户密码，允许用户登录。</li></ul><p><strong>注意事项</strong></p><ul><li>修改密码时，系统通常会要求输入当前密码作为验证。</li><li>为其他用户重设密码时需要具有管理员权限，通常通过使用 <code>sudo</code> 执行。</li><li>使用 <code>passwd</code> 修改密码时，建议遵循强密码原则，包括使用混合大小写字母、数字和特殊字符。</li><li>锁定或解锁账户时，只是禁止通过密码登录，用户可能仍然可以通过其他认证方式登录（如SSH密钥）。</li></ul><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p><strong>命令说明</strong>：<code>w</code> 命令用于显示当前登录系统的用户信息以及他们正在执行的命令。它提供了一个快照，显示了系统的活动用户和他们的活动状态。</p><p><strong>常用选项</strong></p><ul><li><code>-h</code>：不显示标题行。</li><li><code>-u</code>：忽略用户名，显示以用户登录的方式。</li><li><code>-s</code>：使用短格式输出，不显示登录时间和JCPU（对终端的累积CPU时间）。</li></ul><p><strong>注意事项</strong></p><ul><li><code>w</code> 命令显示的信息包括用户名、终端、从哪里登录的远程主机、登录时间、空闲时间、JCPU时间、PCPU时间（当前进程所使用的CPU时间）和用户当前正在执行的命令。</li><li>输出中的 “WHAT” 列显示用户正在执行的命令，这可以用来监控系统中的活动和诊断问题。</li><li>此命令对于系统管理员监控系统使用情况和用户活动非常有用，特别是在多用户环境中。</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><strong>命令说明</strong>：<code>id</code> 命令用于显示关于用户的身份信息，包括用户的UID（用户ID）、GID（组ID）以及所属的所有用户组。</p><p><strong>常用选项</strong></p><ul><li><code>-u</code>：仅显示用户的UID。</li><li><code>-g</code>：仅显示用户的主组GID。</li><li><code>-G</code>：显示用户所属的所有组的GID。</li><li><code>-n</code>：与 <code>-u</code>, <code>-g</code>, 或 <code>-G</code> 选项结合使用时，显示名称而非数字ID。</li><li><code>username</code>：显示指定用户的身份信息。</li></ul><p><strong>注意事项</strong></p><ul><li><code>id</code> 命令非常有用，尤其是在编写脚本时，需要确定运行环境的用户权限和组成员身份。</li><li>输出的UID和GID是重要的安全属性，因为它们决定了用户对系统资源的访问权限。</li><li>常用于诊断权限问题或验证配置变更的影响。</li></ul><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p><strong>命令说明</strong>：<code>last</code> 命令用于显示系统登录记录，特别是用户登录和注销的信息。它读取 <code>/var/log/wtmp</code> 文件的内容来报告每个会话的开始和结束。</p><p><strong>常用选项</strong></p><ul><li><code>-n number</code>：限制显示的行数，显示最近的 <code>number</code> 行记录。</li><li><code>-a</code>：在最后一列显示登录的主机名。</li><li><code>-x</code>：显示系统关机和系统运行级别改变的信息。</li><li><code>-w</code>：显示完整的用户域名。</li></ul><p><strong>注意事项</strong></p><ul><li><code>last</code> 命令提供的信息对于诊断系统问题、检查非授权访问或理解用户登录模式非常有用。</li><li>记录可能会随时间增长非常大，使用 <code>-n</code> 选项可以帮助限制输出的长度，使查找更加高效。</li><li><code>last</code> 命令输出的信息包括用户名、终端、IP地址或主机名、登录和注销时间，以及会话持续时间。</li><li>考虑到隐私和安全，访问这些登录记录通常需要管理员权限。</li></ul><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p><strong>命令说明</strong>：<code>crontab</code> 命令用于创建、编辑、列出或删除定时任务（cron jobs）。这些任务是在后台自动执行的计划任务，由cron守护进程管理。</p><p><strong>常用选项</strong></p><ul><li><code>-e</code>：编辑当前用户的crontab文件。</li><li><code>-l</code>：列出当前用户的crontab文件内容。</li><li><code>-r</code>：删除当前用户的crontab文件。</li><li><code>-u username</code>：指定一个用户，用于编辑、列出或删除指定用户的crontab（需要管理员权限）。</li></ul><p><strong>注意事项</strong></p><ul><li>编辑 <code>crontab</code> 时，应注意正确设置时间和日期字段，格式错误可能导致任务无法按预期执行。</li><li>使用 <code>crontab -e</code> 时，默认使用系统设置的编辑器，可以通过设置 <code>EDITOR</code> 环境变量来改变默认编辑器。</li><li>删除 <code>crontab</code> 时务必小心，因为一旦删除，所有相关定时任务将不再执行。</li><li>考虑到系统安全和维护的便捷性，合理地组织和注释crontab中的任务非常重要。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p><strong>命令说明</strong>：<code>cut</code> 命令用于从文件或标准输入中提取文本的指定部分。通常用于处理和解析数据文件中的列。</p><p><strong>常用选项</strong></p><ul><li><code>-b list</code>：仅显示指定的字节。</li><li><code>-c list</code>：仅显示指定的字符。</li><li><code>-d delim</code>：使用指定的分隔符（默认是TAB）。</li><li><code>-f list</code>：显示指定的字段（列），使用 <code>-d</code> 选项指定分隔符。</li><li><code>--complement</code>：显示除指定范围之外的部分。</li><li><code>-s</code>：当行中不包含分隔符时，不输出该行。</li></ul><p><strong>注意事项</strong></p><ul><li><code>list</code> 的格式可以是单个数字、逗号分隔的数字列表或数字范围（如1-4,7）。</li><li><code>cut</code> 命令通常与其他文本处理命令（如 <code>grep</code>、<code>sort</code>、<code>awk</code> 等）一起使用，以实现更复杂的数据处理任务。</li><li>处理多字符分隔符时，<code>cut</code> 可能不适用，建议使用 <code>awk</code> 或 <code>perl</code>。</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="hostname-1"><a href="#hostname-1" class="headerlink" title="hostname"></a>hostname</h3><p><strong>命令说明</strong>：<code>hostname</code> 命令用于显示或设置系统的主机名。主机名是系统在网络中的标识。</p><p><strong>常用选项</strong></p><ul><li><code>-s</code>：显示短主机名，即主机名的第一个部分。</li><li><code>-f</code>：显示FQDN（完全限定域名）。</li><li><code>-d</code>：显示域名部分。</li><li><code>-i</code>：显示主机名的IP地址。</li><li><code>-I</code>：显示所有网络接口的IP地址。</li><li><code>-b</code>：仅当设置主机名失败时才会返回错误。</li><li><code>-V</code>：显示版本信息。</li></ul><p><strong>设置主机名</strong></p><ul><li>直接使用 <code>hostname new_hostname</code> 命令设置新主机名（需要管理员权限）。</li><li>永久设置主机名可以通过编辑 <code>/etc/hostname</code> 文件实现，并使用 <code>systemctl restart systemd-hostnamed</code> 命令或重启系统使其生效。</li></ul><p><strong>注意事项</strong></p><ul><li>设置主机名需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>修改主机名时，应确保新主机名符合网络命名规则，并且在网络中唯一，以避免冲突。</li><li>修改主机名后，相关的网络服务和应用可能需要重新启动，以识别新的主机名。</li><li>对于分布式系统或集群，确保主机名和DNS配置的一致性，以保证系统通信的正常进行。</li></ul><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><strong>命令说明</strong>：<code>host</code> 命令用于执行DNS查找，获取域名对应的IP地址，或反向查找IP地址对应的域名。它是一个简单的DNS查询工具。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：执行全面的查询，相当于查询所有类型的DNS记录。</li><li><code>-t type</code>：指定查询的记录类型，例如 A（地址记录）、MX（邮件交换记录）、NS（名称服务器记录）、TXT（文本记录）等。</li><li><code>-v</code>：显示详细查询信息。</li><li><code>-c class</code>：指定查询的DNS类，默认是 IN（Internet）。</li><li><code>-W wait</code>：设置等待DNS服务器响应的超时时间（以秒为单位）。</li><li><code>-R retries</code>：设置重试次数。</li><li><code>-4</code>：强制使用IPv4查询。</li><li><code>-6</code>：强制使用IPv6查询.</li></ul><p><strong>注意事项</strong></p><ul><li><code>host</code> 命令是一个简单而快速的DNS查询工具，适用于故障排查和验证DNS配置。</li><li>在查询特定类型的DNS记录时，使用 <code>-t</code> 选项可以获得更精确的结果。</li><li>在网络环境复杂或DNS服务器响应缓慢时，可以调整超时时间和重试次数，以确保查询成功。</li></ul><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p><strong>命令说明</strong>：<code>nslookup</code> 命令用于查询DNS（域名系统）记录。它可以用于查找域名对应的IP地址或从IP地址查找对应的域名，是一个交互式的DNS查询工具。</p><p><strong>常用选项</strong></p><ul><li><code>-type=record_type</code>：指定查询的DNS记录类型，例如 A、MX、NS、TXT 等。</li><li><code>-timeout=seconds</code>：设置等待DNS服务器响应的超时时间（以秒为单位）。</li><li><code>-retry=number</code>：设置重试次数。</li><li><code>-debug</code>：显示详细的调试信息。</li><li><code>-query=record_type</code>：同 <code>-type</code> 选项，指定查询的DNS记录类型。</li><li><code>-vc</code>：使用TCP连接而不是UDP进行查询。</li><li><code>-port=port_number</code>：指定DNS服务器的端口号。</li><li><code>-class=class</code>：指定查询的DNS类，默认是 IN（Internet）。</li></ul><p><strong>注意事项</strong></p><ul><li><code>nslookup</code> 命令在交互模式下使用时，可以输入多个查询命令，使用 <code>exit</code> 或 <code>Ctrl+C</code> 退出交互模式。</li><li>查询特定类型的DNS记录时，使用 <code>-type</code> 选项可以获得更精确的结果。</li><li><code>nslookup</code> 是一个较老的工具，在某些情况下可能会被 <code>dig</code> 命令替代，<code>dig</code> 提供了更强大的功能和更详细的输出信息。</li></ul><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p><strong>命令说明</strong>：<code>ifconfig</code>（interface configuration）命令用于配置、控制和查询网络接口。它是传统的网络配置工具，在现代系统中逐渐被 <code>ip</code> 命令取代，但仍然广泛用于诊断和管理网络接口。</p><p><strong>常用选项</strong></p><ul><li><code>ifconfig</code>：不带选项时，显示所有网络接口的当前配置。</li><li><code>interface</code>：指定网络接口名称，例如 <code>eth0</code>, <code>wlan0</code>。</li><li><code>up</code>：启用指定网络接口。</li><li><code>down</code>：禁用指定网络接口。</li><li><code>inet addr</code>：设置指定接口的IP地址。</li><li><code>netmask</code>：设置指定接口的子网掩码。</li><li><code>broadcast</code>：设置指定接口的广播地址。</li><li><code>mtu N</code>：设置指定接口的最大传输单元（MTU）。</li><li><code>hw ether</code>：设置指定接口的MAC地址。</li></ul><p><strong>注意事项</strong></p><ul><li>配置网络接口时需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>临时配置的网络设置在系统重启后会丢失，需要将配置写入网络配置文件（如 <code>/etc/network/interfaces</code> 或 <code>/etc/sysconfig/network-scripts/</code>）以便永久生效。</li><li>使用 <code>ifconfig</code> 可以快速查看网络接口的状态和流量统计信息。</li><li>在现代Linux系统中，推荐使用 <code>ip</code> 命令（如 <code>ip addr</code> 和 <code>ip link</code>）进行更高级和灵活的网络配置。</li></ul><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p><strong>命令说明</strong>：<code>route</code> 命令用于显示和修改IP路由表。它可以设置静态路由，决定网络流量的转发路径。</p><p><strong>常用选项</strong></p><ul><li><code>-n</code>：以数字格式显示IP地址和网关地址，避免DNS查找延迟。</li><li><code>add</code>：添加一条新的路由。</li><li><code>del</code>：删除一条路由。</li><li><code>default</code>：设置默认路由。</li><li><code>gw</code>：指定路由的网关。</li><li><code>metric</code>：设置路由的度量值（优先级）。</li><li><code>netmask</code>：指定路由的子网掩码。</li></ul><p><strong>注意事项</strong></p><ul><li>配置路由表时需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>临时配置的路由设置在系统重启后会丢失，需要将配置写入网络配置文件以便永久生效。</li><li>在现代Linux系统中，推荐使用 <code>ip route</code> 命令进行更高级和灵活的路由配置。</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p><strong>命令说明</strong>：<code>netstat</code> 命令用于显示网络相关的信息，例如网络连接、路由表、接口状态、网络协议统计等。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：显示所有连接中的套接字，包括监听和非监听状态。</li><li><code>-t</code>：仅显示TCP连接。</li><li><code>-u</code>：仅显示UDP连接。</li><li><code>-l</code>：仅显示监听的连接。</li><li><code>-n</code>：以数字形式显示地址和端口号，避免DNS解析。</li><li><code>-p</code>：显示每个连接所属的进程ID和进程名称（需要管理员权限）。</li><li><code>-r</code>：显示路由表。</li><li><code>-i</code>：显示网络接口的统计信息。</li><li><code>-s</code>：显示各个协议的统计信息。</li></ul><p><strong>注意事项</strong></p><ul><li>配置网络信息时需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li><code>netstat</code> 命令提供的输出信息可以帮助诊断网络问题，监控网络活动和安全性。</li><li>在现代Linux系统中，<code>netstat</code> 已被 <code>ss</code> 命令取代，但仍广泛使用。</li></ul><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p><strong>命令说明</strong>：<code>ss</code>（socket statistics）命令是一个用于查看系统上的网络连接、路由表、接口统计等网络信息的实用工具，它是 <code>netstat</code> 命令的现代替代品。<code>ss</code> 提供了更快的数据获取方式，并能显示更多的网络连接信息。</p><p><strong>常用选项</strong></p><ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-a</code>：显示所有连接（包括监听和非监听状态）。</li><li><code>-l</code>：仅显示处于监听状态的套接字。</li><li><code>-p</code>：显示每个套接字关联的进程。</li><li><code>-n</code>：不解析服务名称，显示端口号。</li><li><code>-r</code>：尝试解析网络和主机名。</li><li><code>-s</code>：输出套接字使用概要。</li><li><code>-4</code>：仅显示 IPv4 的套接字。</li><li><code>-6</code>：仅显示 IPv6 的套接字。</li><li><code>-e</code>：显示扩展信息，这会提供更详细的套接字信息。</li><li><code>-o</code>：显示计时器信息。</li></ul><p><strong>注意事项</strong></p><ul><li>某些 <code>ss</code> 的用法（尤其是那些涉及进程信息的 <code>-p</code> 选项）可能需要超级用户权限来完全执行。</li></ul><h3 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h3><p><strong>命令说明</strong>：<code>ifup</code> 命令用于启用网络接口。它读取网络配置文件中的配置并将指定的网络接口激活，使其可以发送和接收数据。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：启用所有在配置文件中定义的网络接口。</li><li><code>--force</code>：即使接口已经启用，仍然强制重新启用。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>ifup</code> 命令需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>网络接口的配置文件通常位于 <code>/etc/network/interfaces</code> 或 <code>/etc/sysconfig/network-scripts/</code> 目录中，具体路径取决于Linux发行版。</li><li>在配置文件中正确设置网络接口的参数（如IP地址、子网掩码、网关等）是确保 <code>ifup</code> 命令成功启用网络接口的关键。</li><li><code>ifup</code> 和 <code>ifdown</code> 命令通常成对使用，<code>ifdown</code> 用于禁用网络接口。</li></ul><h3 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a>ifdown</h3><p><strong>命令说明</strong>：<code>ifdown</code> 命令用于禁用网络接口。它读取网络配置文件中的配置并将指定的网络接口关闭，停止其发送和接收数据。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：禁用所有在配置文件中定义的网络接口。</li><li><code>--force</code>：即使接口已经禁用，仍然强制重新禁用。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>ifdown</code> 命令需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>禁用网络接口后，所有依赖该接口的网络连接将断开。</li><li><code>ifup</code> 和 <code>ifdown</code> 命令的配置文件路径和格式依赖于具体的Linux发行版。</li><li>在执行 <code>ifdown</code> 命令前，确保禁用该接口不会对系统造成不良影响，特别是在远程管理时。</li></ul><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p><strong>命令说明</strong>：<code>iptables</code> 命令用于配置IPv4的包过滤规则、NAT和端口转发。它是Linux系统中防火墙和网络流量控制的重要工具。</p><p><strong>常用选项</strong></p><ul><li><code>-A chain rule-specification</code>：在指定链的末尾添加规则。</li><li><code>-D chain rule-specification</code>：删除指定链中的规则。</li><li><code>-I chain rule-number rule-specification</code>：在指定链的指定位置插入规则。</li><li><code>-R chain rule-number rule-specification</code>：替换指定链中的指定规则。</li><li><code>-L [chain]</code>：列出指定链的所有规则，如果未指定链，则列出所有链的规则。</li><li><code>-F [chain]</code>：清空指定链的所有规则，如果未指定链，则清空所有链的规则。</li><li><code>-N chain</code>：创建一个新的用户定义链。</li><li><code>-X [chain]</code>：删除用户定义链，如果未指定链，则删除所有用户定义链。</li><li><code>-P chain target</code>：设置指定链的默认策略。</li><li><code>-p protocol</code>：指定协议（如 <code>tcp</code>、<code>udp</code>、<code>icmp</code>）。</li><li><code>-s source</code>：指定源地址。</li><li><code>-d destination</code>：指定目标地址。</li><li><code>-j target</code>：指定目标动作（如 <code>ACCEPT</code>、<code>DROP</code>、<code>REJECT</code>、<code>LOG</code>）。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>iptables</code> 命令需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>配置防火墙规则时，应确保规则的顺序，因为iptables会按顺序处理规则，直到找到匹配的规则为止。</li><li>在对 <code>iptables</code> 进行更改之前，建议备份当前的规则集，可以使用 <code>iptables-save</code> 命令保存当前配置。</li><li>配置完成后，可以使用 <code>iptables-save &gt; /etc/iptables/rules.v4</code> 命令保存配置，以便在系统重启时自动加载。</li><li>可以通过 <code>iptables-restore</code> 命令恢复之前保存的规则集。</li><li>在现代Linux系统中，<code>iptables</code> 已经逐渐被 <code>nftables</code> 所取代，但仍然是许多系统管理员的重要工具。</li></ul><h3 id="dhclient"><a href="#dhclient" class="headerlink" title="dhclient"></a>dhclient</h3><p><strong>命令说明</strong>：<code>dhclient</code> 命令用于配置和管理DHCP（动态主机配置协议）客户端。它请求和获取网络参数（如IP地址、子网掩码、网关和DNS服务器）并配置网络接口。</p><p><strong>常用选项</strong></p><ul><li><code>-v</code>：显示详细操作信息。</li><li><code>-r</code>：释放当前的DHCP租约并停止dhclient。</li><li><code>-x</code>：释放所有接口上的DHCP租约并退出。</li><li><code>-1</code>：仅发送一次DHCP请求，不进行重试。</li><li><code>-4</code>：强制使用IPv4。</li><li><code>-6</code>：强制使用IPv6。</li><li><code>-cf file</code>：指定客户端配置文件。</li><li><code>-lf file</code>：指定租约文件。</li><li><code>-pf file</code>：指定保存进程ID的文件。</li><li><code>-sf script-file</code>：指定脚本文件，用于配置网络接口。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>dhclient</code> 命令通常需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>默认情况下，<code>dhclient</code> 会读取 <code>/etc/dhcp/dhclient.conf</code> 配置文件，但可以使用 <code>-cf</code> 选项指定其他配置文件。</li><li>释放DHCP租约（使用 <code>-r</code> 选项）会使当前IP地址失效，可能导致网络连接中断。</li><li><code>dhclient</code> 会在后台运行，并定期向DHCP服务器续租，以确保IP地址和其他网络参数的持续有效。</li><li><code>dhclient</code> 日志通常存储在系统日志文件中，可以通过查看 <code>/var/log/messages</code> 或 <code>journalctl</code> 获取详细信息。</li></ul><h3 id="route-1"><a href="#route-1" class="headerlink" title="route"></a>route</h3><p><strong>命令说明</strong>：<code>route</code> 命令用于显示和修改IP路由表。它可以设置静态路由，决定网络流量的转发路径。</p><p><strong>常用选项</strong></p><ul><li><code>-n</code>：以数字格式显示IP地址和网关地址，避免DNS查找延迟。</li><li><code>add</code>：添加一条新的路由。</li><li><code>del</code>：删除一条路由。</li><li><code>default</code>：设置默认路由。</li><li><code>gw</code>：指定路由的网关。</li><li><code>metric</code>：设置路由的度量值（优先级）。</li><li><code>netmask</code>：指定路由的子网掩码。</li></ul><p><strong>注意事项</strong></p><ul><li>配置路由表时需要有管理员权限，通常通过 <code>sudo</code> 运行。</li><li>临时配置的路由设置在系统重启后会丢失，需要将配置写入网络配置文件（如 <code>/etc/network/interfaces</code> 或 <code>/etc/sysconfig/network-scripts/</code>）以便永久生效。</li><li>设置默认路由时，要确保网关可达，否则会导致网络连接问题。</li><li>可以通过 <code>route -n</code> 查看当前的路由表，检查配置是否正确。</li></ul><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p><strong>命令说明</strong>：<code>traceroute</code> 命令用于显示数据包到达目标主机所经过的路径。它可以帮助诊断网络故障、确定网络延迟的位置和检查路由路径。</p><p><strong>常用选项</strong></p><ul><li><code>-m max_ttl</code>：设置最大TTL（生存时间）值，默认是30。</li><li><code>-p port</code>：设置目的端口，默认是33434。</li><li><code>-q nqueries</code>：对每个跳进行查询的次数，默认是3。</li><li><code>-w wait</code>：设置等待每次回复的超时时间（以秒为单位）。</li><li><code>-I</code>：使用ICMP ECHO代替UDP数据包。</li><li><code>-T</code>：使用TCP SYN数据包代替UDP数据包。</li><li><code>-4</code>：强制使用IPv4。</li><li><code>-6</code>：强制使用IPv6。</li></ul><p><strong>注意事项</strong></p><ul><li>需要管理员权限才能执行某些类型的 <code>traceroute</code> 命令，例如使用ICMP或TCP包。</li><li>运行 <code>traceroute</code> 命令可能会被某些防火墙或网络设备阻止，导致部分或全部路径无法显示。</li><li><code>traceroute</code> 显示的是数据包通过的路由器的IP地址和延迟时间，有时可能无法解析某些IP地址的主机名。</li><li>路由路径的变化可能导致 <code>traceroute</code> 的结果不一致，这是正常现象，尤其是在复杂的网络环境中。</li></ul><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><strong>命令说明</strong>：<code>ping</code> 命令用于测试网络连通性。它通过发送ICMP ECHO请求数据包并等待响应，来检测目标主机的可达性和网络延迟。</p><p><strong>常用选项</strong></p><ul><li><code>-c count</code>：发送指定数量的请求数据包，然后停止。</li><li><code>-i interval</code>：设置发送每个数据包的间隔时间（以秒为单位），默认是1秒。</li><li><code>-s packetsize</code>：设置每个请求数据包的大小（以字节为单位），默认是56字节。</li><li><code>-t ttl</code>：设置数据包的TTL（生存时间），默认是64。</li><li><code>-W timeout</code>：设置等待每个响应的超时时间（以秒为单位），默认是1秒。</li><li><code>-q</code>：静默模式，只显示开始和统计信息。</li><li><code>-v</code>：显示详细输出，包括每个数据包的发送和接收信息。</li><li><code>-4</code>：强制使用IPv4。</li><li><code>-6</code>：强制使用IPv6。</li></ul><p><strong>注意事项</strong></p><ul><li><code>ping</code> 命令的结果可以帮助诊断网络连接问题，例如网络延迟、数据包丢失和主机不可达等问题。</li><li>使用 <code>ping</code> 命令时，目标主机需要启用ICMP ECHO响应，否则即使主机可达，也不会收到响应。</li><li>发送大量的 <code>ping</code> 请求可能会对网络和目标主机造成负载，因此在测试时应适当控制请求的数量和频率。</li><li>某些网络设备或防火墙可能会限制或阻止ICMP ECHO请求，因此在这些情况下可能无法获得正确的结果。</li></ul><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p><strong>命令说明</strong>：<code>telnet</code> 命令用于通过TELNET协议与远程主机建立连接。它可以用于远程登录、测试端口连通性和诊断网络服务。</p><p><strong>常用选项</strong></p><ul><li><code>host</code>：连接的远程主机名或IP地址。</li><li><code>port</code>：连接的远程端口号，默认是23。</li><li><code>-l user</code>：以指定的用户名登录远程主机。</li><li><code>-a</code>：自动登录，使用当前用户名。</li><li><code>-e escape_char</code>：设置脱离字符，默认是 <code>Ctrl+]</code>。</li><li><code>-E</code>：禁用脱离字符功能。</li><li><code>-8</code>：允许使用8位字符数据，禁用8位字符的转义。</li><li><code>-L</code>：使用8位数据路径进行输出。</li></ul><p><strong>注意事项</strong></p><ul><li><code>telnet</code> 传输的数据是明文的，不安全，因此在生产环境中建议使用更安全的协议，如SSH（Secure Shell）。</li><li>使用 <code>telnet</code> 命令连接远程主机时，需要确保TELNET服务在远程主机上运行，并且防火墙允许相应端口的通信。</li><li><code>telnet</code> 可以用于测试特定端口的连通性，例如 <code>telnet host 80</code> 用于测试HTTP服务的连通性。</li><li>在连接到远程主机后，可以使用 <code>Ctrl+]</code> 进入 <code>telnet</code> 命令模式，输入 <code>quit</code> 断开连接。</li></ul><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p><strong>命令说明</strong>：<code>curl</code> 命令用于在命令行中进行网络请求和数据传输。它支持多种协议，包括HTTP、HTTPS、FTP、SMTP等，是一个强大的网络工具。</p><p><strong>常用选项</strong></p><ul><li><code>-X, --request</code>：指定请求方法，如 GET、POST、PUT、DELETE 等。</li><li><code>-d, --data</code>：发送指定的数据，适用于 POST 请求。</li><li><code>-H, --header</code>：添加请求头。</li><li><code>-o, --output</code>：将输出写入到指定文件。</li><li><code>-O, --remote-name</code>：将远程文件下载到本地，保持远程文件名。</li><li><code>-u, --user</code>：指定用户名和密码进行服务器认证。</li><li><code>-I, --head</code>：只请求头信息。</li><li><code>-L, --location</code>：跟随重定向。</li><li><code>-k, --insecure</code>：允许不安全的 SSL 连接。</li><li><code>-v, --verbose</code>：显示详细的请求和响应信息。</li><li><code>-s, --silent</code>：静默模式，不显示进度和错误信息。</li><li><code>-w, --write-out</code>：输出额外的信息。</li></ul><p><strong>注意事项</strong></p><ul><li><code>curl</code> 是一个非常灵活的工具，可以与多种协议和认证机制配合使用。</li><li>使用 <code>-d</code> 选项发送数据时，默认的请求方法是 POST，可以通过 <code>-X</code> 指定其他方法。</li><li>当下载大文件时，使用 <code>-O</code> 选项可以方便地保存文件，并保持远程文件的名称。</li><li>为了安全性，处理敏感数据时应小心使用 <code>-k</code> 选项。</li><li>使用 <code>-v</code> 选项可以帮助调试网络请求，显示详细的请求和响应头信息。</li><li><code>curl</code> 的功能非常强大，建议结合使用不同选项和参数，以实现所需的网络请求和数据传输任务。</li></ul><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p><strong>命令说明</strong>：<code>scp</code> 使用 SSH 来传输数据，提供与 SSH 相同的认证和同样的安全保障。它可以复制文件到主机之间或从一个主机到另一个主机。</p><p><strong>常用选项</strong></p><ul><li><code>-P &lt;端口&gt;</code>：指定 SSH 连接的端口。注意是大写的 <code>P</code>，因为小写的 <code>-p</code> 被用于保留文件的修改和访问时间。</li><li><code>-p</code>：保留原文件的修改时间，访问时间和访问权限。</li><li><code>-r</code>：递归复制整个目录。</li><li><code>-i &lt;密钥文件&gt;</code>：用指定的 SSH 私钥文件进行认证，这在自动化脚本中非常有用。</li><li><code>-C</code>：启用压缩。如果要传输的文件未压缩，这会提高传输速度。</li><li><code>-q</code>：静默模式，不显示进度条和错误消息。</li></ul><p><strong>注意事项</strong></p><ul><li>尽管 <code>scp</code> 使用 SSH 进行安全传输，用户仍应注意确保使用强密码或密钥认证，并且定期更新。</li><li>在网络连接慢或不稳定时，大文件传输可能会中断，且不支持断点续传。</li></ul><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><strong>命令说明</strong>：<code>rsync</code> 可以用于本地文件复制、目录树的完整备份，以及与其他计算机之间的同步。它支持多种选项来控制其行为和输出，包括数据压缩和差异比较，确保网络传输的效率和速度。</p><p><strong>常用选项</strong></p><ul><li><code>-v</code>（verbose）：详细模式，显示正在执行的操作。</li><li><code>-r</code>（recursive）：递归到目录，即包含子目录。</li><li><code>-a</code>（archive）：归档模式，等同于 <code>-rlptgoD</code>，它保留符号链接、设备、属性、权限、所有权等。</li><li><code>-z</code>（compress）：在发送时压缩数据。</li><li><code>-h</code>（human-readable）：输出易读的格式，例如使用 K, M, G 等单位。</li><li><code>--delete</code>：删除目的地中源端已经删除的文件。</li><li><code>--progress</code>：在传输时显示进度条。</li><li><code>--exclude</code>：排除不需要同步的文件或目录。</li><li><code>-e</code>（ssh）：指定使用 SSH 作为数据传输的通道，提高安全性。</li></ul><p><strong>注意事项</strong></p><ul><li><code>rsync</code> 是处理大文件和大量文件的理想工具，因为它只传输变更部分。</li><li>使用 <code>--delete</code> 选项时要格外小心，因为它会删除目标目录中不存在于源目录的文件。</li></ul><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p><strong>命令说明</strong>：<code>wget</code> 具有众多功能，包括但不限于文件下载、网站镜像、断点续传和带宽限制。它可以处理大量的下载任务，非常适合自动化的脚本和定时任务。</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-O &lt;文件名&gt;</code>：将下载的文件保存为指定的文件名。</li><li><code>-c</code>：继续执行部分下载的文件，实现断点续传。</li><li><code>-r</code> 或 <code>--recursive</code>：递归下载，常用于下载整个网站。</li><li><code>-l &lt;深度&gt;</code> 或 <code>--level=&lt;深度&gt;</code>：递归下载时的最大深度。</li><li><code>--limit-rate=&lt;速率&gt;</code>：限制下载速度，例如 <code>--limit-rate=100k</code> 限制为每秒100KB。</li><li><code>--no-clobber</code>：不覆盖已存在的文件或链接。</li><li><code>-i &lt;文件&gt;</code> 或 <code>--input-file=&lt;文件&gt;</code>：从指定文件读取要下载的URL列表。</li><li><code>--http-user=&lt;用户名&gt;</code> 和 <code>--http-password=&lt;密码&gt;</code>：指定 HTTP 认证所需的用户名和密码。</li><li><code>--mirror</code>：开启镜像下载，等同于 <code>-r -N -l inf --no-remove-listing</code>。</li><li><code>--convert-links</code>：下载完成后，将文档中的链接转换为本地链接，适用于离线浏览。</li><li><code>--no-parent</code>：在递归下载时，不下载父目录中的链接。</li></ul><p><strong>注意事项</strong></p><ul><li><code>wget</code> 常用于脚本中自动化下载任务，设置适当的重试参数和失败后的行为可以提高脚本的鲁棒性。</li><li>在使用 <code>wget</code> 进行大规模下载（如镜像网站）时，要注意对目标服务器和你的网络带宽的影响。</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p><strong>命令说明</strong>：<code>ps</code> 命令用于显示当前系统上的进程信息。它是一个用于查看系统运行状态和诊断问题的基础工具。</p><p><strong>常用选项</strong></p><ul><li><code>-A</code>：显示所有进程。</li><li><code>-a</code>：显示所有终端上的进程，不包括会话领导者。</li><li><code>-u</code>：显示与指定用户相关的进程。</li><li><code>-x</code>：显示没有控制终端的进程。</li><li><code>-e</code>：显示所有进程，效果与 <code>-A</code> 相同。</li><li><code>-f</code>：全格式列表显示进程信息。</li><li><code>-l</code>：长格式列表显示进程信息。</li><li><code>-p</code>：按进程ID过滤。</li><li><code>-t</code>：按终端过滤。</li><li><code>-o</code>：自定义输出格式。</li></ul><p><strong>注意事项</strong></p><ul><li><code>ps</code> 命令的输出可以通过管道传递给其他命令（如 <code>grep</code>）以进行进一步处理或筛选。</li><li>使用 <code>-f</code> 或 <code>-l</code> 选项可以获取更详细的进程信息，如进程的父进程ID（PPID）、启动时间、CPU和内存使用情况等。</li><li><code>ps</code> 命令显示的是命令执行时的快照，要监控进程的动态变化，可以结合 <code>watch</code> 命令使用，或者使用 <code>top</code> 或 <code>htop</code> 等命令进行实时监控。</li><li>自定义输出格式（使用 <code>-o</code> 选项）可以根据需要选择显示特定的字段，如 <code>ps -o pid,ppid,cmd,%mem,%cpu</code>。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><strong>命令说明</strong>：<code>kill</code> 命令用于向进程发送信号，通常用于终止进程。默认情况下，<code>kill</code> 发送 <code>SIGTERM</code> 信号，这将请求进程正常终止。</p><p><strong>常用选项</strong></p><ul><li><code>-l [signum]</code>：列出所有信号的名称，或者按信号编号显示信号名称。</li><li><code>-s signal</code>：发送指定的信号，而不是默认的 <code>SIGTERM</code>。</li><li><code>-n signum</code>：通过信号编号发送信号，而不是信号名称。</li><li><code>-p</code>：不发送信号，只显示指定进程的PID。</li><li><code>-SIGKILL</code> 或 <code>-9</code>：强制终止进程，不执行清理操作。</li></ul><p><strong>注意事项</strong></p><ul><li>发送信号需要相应的权限，通常需要通过 <code>sudo</code> 提升权限。</li><li>使用 <code>kill -9</code> 发送 <code>SIGKILL</code> 信号会立即终止进程，不进行任何清理操作（如释放资源、保存数据等），应谨慎使用。</li><li>可以通过 <code>ps</code> 或 <code>top</code> 等命令获取进程ID（PID），然后使用 <code>kill</code> 命令终止进程。</li><li><code>kill</code> 命令只能向当前用户拥有的进程或由根用户拥有的进程发送信号。</li></ul><p><strong>常见信号</strong></p><ul><li><code>SIGTERM</code> (15)：请求进程正常终止（默认信号）。</li><li><code>SIGKILL</code> (9)：强制终止进程，不能被捕获或忽略。</li><li><code>SIGINT</code> (2)：终止进程，通常由 <code>Ctrl+C</code> 触发。</li><li><code>SIGHUP</code> (1)：挂起信号，通常在终端断开时发送。</li><li><code>SIGSTOP</code> (19)：停止进程执行，不能被捕获或忽略。</li><li><code>SIGCONT</code> (18)：继续执行被停止的进程。</li></ul><h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p><strong>命令说明</strong>：<code>chkconfig</code> 命令用于管理系统服务的启动和停止。它主要在基于SysV init的Linux系统上使用，用以设置服务在各个运行级别中的启动和停止状态。</p><p><strong>常用选项</strong></p><ul><li><code>--list</code>：列出所有服务的启动和停止状态。</li><li><code>--add</code>：添加服务到管理列表中。</li><li><code>--del</code>：从管理列表中删除服务。</li><li><code>service name on/off</code>：启用或禁用指定服务在各个运行级别中的启动。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>chkconfig</code> 修改服务状态需要管理员权限。</li><li>只有那些包含适当的初始化脚本（通常位于 <code>/etc/init.d/</code> 目录）的服务才能使用 <code>chkconfig</code> 管理。</li><li><code>chkconfig</code> 不会立即启动或停止服务，它仅修改服务在指定运行级别中的启动和停止设置。要立即启动或停止服务，需要使用 <code>service</code> 命令。</li><li>在现代基于systemd的系统中，<code>chkconfig</code> 已被 <code>systemctl</code> 所取代，因此在这些系统上应使用 <code>systemctl</code> 管理服务。</li></ul><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p><strong>命令说明</strong>：<code>service</code> 命令用于控制系统服务的启动、停止、重启和查看状态。它主要用于基于SysV init的Linux系统上，调用位于 <code>/etc/init.d/</code> 目录下的脚本。</p><p><strong>常用选项</strong></p><ul><li><code>service service_name start</code>：启动指定服务。</li><li><code>service service_name stop</code>：停止指定服务。</li><li><code>service service_name restart</code>：重启指定服务。</li><li><code>service service_name status</code>：查看指定服务的状态。</li><li><code>service --status-all</code>：显示所有服务的状态。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>service</code> 命令需要管理员权限。</li><li><code>service</code> 命令的操作是即时生效的，与 <code>chkconfig</code> 命令不同，<code>service</code> 直接影响服务的当前状态。</li><li>在现代基于systemd的系统中，<code>service</code> 命令通常是 <code>systemctl</code> 的一个兼容层。因此在这些系统上应使用 <code>systemctl</code> 命令进行服务管理，以获得更全面和现代化的服务控制功能。</li></ul><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p><strong>命令说明</strong>：<code>systemctl</code> 命令用于控制和管理systemd系统中的系统和服务管理器。它提供了启动、停止、重启和查看服务状态的功能，并能管理服务的启用和禁用。</p><p><strong>常用选项</strong></p><ul><li><code>systemctl start service_name</code>：启动指定服务。</li><li><code>systemctl stop service_name</code>：停止指定服务。</li><li><code>systemctl restart service_name</code>：重启指定服务。</li><li><code>systemctl status service_name</code>：查看指定服务的状态。</li><li><code>systemctl enable service_name</code>：启用指定服务，使其在系统启动时自动启动。</li><li><code>systemctl disable service_name</code>：禁用指定服务，使其在系统启动时不自动启动。</li><li><code>systemctl is-enabled service_name</code>：检查服务是否已启用。</li><li><code>systemctl daemon-reload</code>：重新加载systemd管理的配置文件。</li><li><code>systemctl list-units --type=service</code>：列出所有系统服务的状态。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>systemctl</code> 命令需要管理员权限。</li><li><code>systemctl</code> 是 <code>systemd</code> 系统中的核心工具，替代了 <code>service</code> 和 <code>chkconfig</code> 等旧有命令。</li><li>在更改服务配置文件后，通常需要运行 <code>systemctl daemon-reload</code> 来使更改生效。</li><li><code>systemctl</code> 提供了广泛的功能，不仅可以管理服务，还可以管理挂载点、设备、时间同步等其他systemd单元。熟练掌握 <code>systemctl</code> 对于管理现代Linux系统至关重要。</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p><strong>命令说明</strong>：<code>file</code> 命令读取一个或多个文件的头部数据，并基于魔术数字、文件头部信息和其他启发式测试来分析和确定文件类型。</p><p><strong>常用选项</strong></p><ul><li><code>-b</code> 或 <code>--brief</code>：不显示文件名，只显示文件类型信息。</li><li><code>-i</code> 或 <code>--mime</code>：输出 MIME 类型字符串，而非可读描述，适用于自动化处理。</li><li><code>-f &lt;文件列表&gt;</code> 或 <code>--files-from=&lt;文件列表&gt;</code>：从文件读取要检查的文件名列表。</li><li><code>-z</code> 或 <code>--uncompress</code>：尝试去解压任何压缩文件，然后再检查其类型。</li><li><code>-L</code> 或 <code>--dereference</code>：跟踪符号链接，检查链接指向的实际文件。</li><li><code>-e &lt;测试类型&gt;</code>：指定进行何种测试，比如 <code>ascii</code>, <code>compress</code>, <code>tar</code> 等，以优化性能或增加精确度。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>file</code> 命令需要有读取目标文件的权限。如果没有适当的权限，命令可能无法正确执行。</li><li>对于二进制文件，<code>file</code> 命令可能只能显示基本的信息，如 “ELF 64-bit LSB executable”，而不会详细描述文件的用途或来源。</li><li>有些文件可能会显示为 “data” 或其他不具体的描述，这通常表示 <code>file</code> 无法准确识别文件内容。</li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><strong>命令说明</strong>：<code>grep</code> 是一种强大的文本搜索工具，用于在文件中搜索包含指定模式的行。</p><p><strong>常用选项</strong></p><ul><li><code>-i</code>：忽略大小写（即无论是大写还是小写都视为相同）。</li><li><code>-v</code>：反转匹配，显示不匹配的行。</li><li><code>-c</code>：计算找到的匹配行数而不是显示匹配行。</li><li><code>-n</code>：显示匹配的行号。</li><li><code>-r</code> 或 <code>-R</code>：递归查找文件目录。</li><li><code>-l</code>：仅列出包含匹配项的文件名，不显示具体匹配的行。</li><li><code>-o</code>：仅显示匹配到的部分，而非整行内容。</li><li><code>-E</code>：启用扩展正则表达式（相当于使用 <code>egrep</code>）。</li><li><code>-F</code>：将模式作为固定字符串处理，而不是正则表达式（相当于使用 <code>fgrep</code>）。</li><li><code>-A n</code>：打印匹配行及其后的<code>n</code>行。</li><li><code>-B n</code>：打印匹配行及其前的<code>n</code>行。</li><li><code>-C n</code> 或 <code>--context=n</code>：打印匹配行及其前后的<code>n</code>行。</li><li> <code>-q</code> ：使 <code>grep</code> 静默执行，仅通过退出状态码来表明是否找到匹配项</li></ul><p><strong>注意事项</strong></p><ul><li>特殊字符（如 <code>*</code> <code>.</code> <code>?</code> <code>[]</code>）在正则表达式中有特定的意义，如果要按字面意义搜索这些字符，需要使用反斜杠 <code>\</code> 进行转义。</li><li>通过 <code>--exclude</code> 或 <code>--include</code> 参数可以排除递归搜索中不必要的目录或文件类型</li><li>确保处理的文本文件和 <code>grep</code> 使用的编码一致（如 UTF-8, ASCII 等）。如果编码不匹配，可能导致搜索结果不准确或漏掉某些匹配项。</li><li>在处理包含多种语言或特殊字符的文本时，使用 <code>-a</code> 选项将二进制文件视为文本，可以帮助避免因编码问题而导致的错误。</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><strong>命令说明</strong>：<code>cat</code>（concatenate）命令是 Unix 和类 Unix 系统中用来读取、创建和合并文件的常用工具。<code>cat</code> 呸首先是被设计用来将几个文件的内容合并并输出，但它也经常被用来简单地显示文件内容。</p><p><strong>常用选项</strong></p><ul><li>**<code>-n</code>**：在输出的每行前面加上行号。</li><li>**<code>-b</code>**：和 <code>-n</code> 类似，但不为空白行编号。</li><li>**<code>-s</code>**：压缩连续的多个空白行为一个空白行。</li><li>**<code>-E</code>**：在每行结束处显示 <code>$</code> 字符，可以明显看到行结束符和空行。</li><li>**<code>-T</code>**：显示制表符（tab）为 <code>^I</code>。</li></ul><p><strong>注意事项</strong></p><ul><li>直接使用 <code>cat</code> 命令查看大文件可能会导致终端瞬间被大量数据刷新而难以查看，对于查看大文件内容建议使用 <code>less</code> 或 <code>more</code> 命令。</li><li>在处理大量小文件时，合并这些文件的输出再处理比单独处理每个文件要效率低。</li></ul><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p><strong>命令说明</strong>：<code>tac</code> 主要用于将文本文件的行逆序输出。这在需要查看日志文件的最新条目（通常位于文件底部）时特别有用，而不必读取整个文件。</p><p><strong>常用选项</strong></p><ul><li><code>tac</code> 命令的选项相对较少，因为它的主要任务非常单一。它通常没有必要的选项，直接使用即可达到反向显示文件内容的效果。</li></ul><p><strong>注意事项</strong></p><ul><li>一次性读取整个文件内容到内存中再进行输出，所以对于非常大的文件，可能会消耗大量内存资源</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p><strong>命令说明</strong>：<code>head</code> 命令用于输出文件的开始部分到标准输出。默认情况下，它显示文件的前10行。</p><p><strong>常用选项</strong></p><ul><li><code>-n &lt;数值&gt;</code> 或 <code>--lines=&lt;数值&gt;</code>：指定显示文件开始的行数。例如，<code>head -n 5 file.txt</code> 会显示文件 <code>file.txt</code> 的前5行。</li><li><code>-c &lt;数值&gt;</code> 或 <code>--bytes=&lt;数值&gt;</code>：指定显示文件的前多少字节。</li></ul><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p><strong>命令说明</strong>：<code>tail</code> 命令用于输出文件的末尾部分到标准输出。默认情况下，它显示文件的最后10行。</p><p><strong>常用选项</strong></p><ul><li><code>-n &lt;数值&gt;</code> 或 <code>--lines=&lt;数值&gt;</code>：指定显示文件末尾的行数。例如，<code>tail -n 5 file.txt</code> 会显示文件 <code>file.txt</code> 的最后5行。</li><li><code>-c &lt;数值&gt;</code> 或 <code>--bytes=&lt;数值&gt;</code>：指定显示文件末尾的多少字节。</li><li><code>-f</code> 或 <code>--follow</code>：实时输出文件的新增内容。这在监视实时更新的日志文件时非常有用。例如，<code>tail -f access.log</code> 会持续显示 <code>access.log</code> 文件末尾的内容，并实时更新。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p><strong>命令说明</strong>：<code>less</code> 命令是一个强大的文本查看工具，常用于在 Unix 和类 Unix 系统中查看（但不修改）大文本文件。它允许用户以逐行或逐页的方式滚动浏览文件，而不必一次加载整个文件。</p><p><strong>常用选项</strong></p><ul><li><code>-N</code> 或 <code>--LINE-NUMBERS</code>：显示每行的行号。</li><li><code>-S</code> 或 <code>--chop-long-lines</code>：单行超出屏幕宽度时，不自动折行显示，而是允许用户左右滚动查看。</li><li><code>-i</code>：在搜索时忽略大小写，除非搜索字符串包含大写字母。</li><li><code>-R</code>：解析文件内容中的颜色代码，使彩色输出（如日志文件中的颜色）正确显示。</li><li><code>-F</code>：如果文件内容可以在一个屏幕内显示完毕，则不进入 <code>less</code>，直接显示文件内容后退出。</li><li><code>-m</code>：显示更详细的提示，包括文件的百分比位置和当前显示的行范围。</li><li><code>-X</code>：不发送清屏指令到终端。退出 <code>less</code> 时，屏幕内容不会被清除。</li><li><code>-g</code>：只高亮第一个搜索匹配，而不是高亮所有匹配项。</li></ul><p><strong>快捷键</strong></p><ul><li>导航快捷键<ul><li><code>空格键</code>：向下翻一页。</li><li><code>b</code>：向上翻一页。</li><li><code>d</code>：向下滚动半页。</li><li><code>u</code>：向上滚动半页。</li><li><code>回车键（Enter）</code>：向下滚动一行。</li><li><code>y</code> 或 <code>k</code>：向上滚动一行。</li><li><code>Ctrl+F</code>：向下滚动一页（与空格键相同）。</li><li><code>Ctrl+B</code>：向上滚动一页（与 b 键相同）。</li><li><code>g</code>：跳到文件的开始。</li><li><code>G</code>：跳到文件的末尾。</li><li><code>p</code> 或 **%**：跳到文件中的某个百分比位置。</li></ul></li><li>搜索快捷键<ul><li><code>/</code>：向下搜索一个字符串。</li><li><code>?</code>：向上搜索一个字符串。</li><li><code>n</code>：重复前一个搜索（按照相同方向）。</li><li><code>N</code>：重复前一个搜索（按照相反方向）</li></ul></li><li>其他<ul><li><code>h</code>：显示帮助屏幕，列出所有的命令。</li><li><code>q</code>：退出 <code>less</code>。</li><li><code>R</code>：刷新屏幕和清除缓存中的文件内容，适用于查看动态生成或更新的日志文件。</li><li><code>m</code> 加上一个字母：标记当前位置，你可以用单个字母（例如 a）标记多个位置。</li><li><code>&#39;</code> 加上一个之前设置的标记字母：跳转到该标记位置。</li><li><code>=</code>：显示当前行的行号和文件名。</li><li><code>F</code>：实时跟踪最新添加到文件的内容，类似于 <code>tail -f</code>。使用 Ctrl+C 退出此模式。</li><li><code>v</code>：在当前位置启动默认的文本编辑器编辑当前文件。</li><li><code>V</code>：查看版本和版权信息。</li></ul></li><li>显示调整<ul><li><code>-S</code>：切换折行和截断长行的显示模式。在长行模式下，可以使用左右箭头键水平滚动。</li><li><code>z</code>：按当前屏幕大小向下翻页。</li><li><code>w</code>：按当前屏幕大小向上翻页。</li><li><code>Ctrl+L</code>：重新绘制屏幕。</li></ul></li></ul><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><strong>命令说明</strong>：<code>cd</code>（change directory）命令用于更改当前工作目录。它是用户在文件系统中导航的基本命令。</p><p><strong>常用选项</strong></p><ul><li>无特别选项：直接使用 <code>cd</code> 后跟目标目录路径来更改目录。</li><li><code>cd ~</code>：进入当前用户的主目录。</li><li><code>cd ..</code>：返回上一级目录。</li><li><code>cd -</code>：返回到上一个工作目录。</li><li><code>cd /path/to/directory</code>：进入指定路径的目录。</li></ul><p><strong>注意事项</strong></p><ul><li>路径可以是相对路径或绝对路径。相对路径是相对于当前工作目录的路径，绝对路径是从根目录开始的完整路径。</li><li>使用 <code>cd</code> 命令时，确保目标目录存在，否则会返回 “No such file or directory” 错误。</li><li>可以结合环境变量使用，如 <code>cd $HOME</code> 进入当前用户的主目录。</li><li><code>cd ..</code> 命令对于逐步向上导航目录层次结构非常有用。</li><li>切换目录时，当前工作目录会在环境变量 <code>PWD</code> 中反映出来。</li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p><strong>命令说明</strong>：<code>pwd</code>（print working directory）命令用于显示当前工作目录的完整路径。它可以帮助用户确认当前所处的目录位置。</p><p><strong>常用选项</strong></p><ul><li>无特别选项：直接使用 <code>pwd</code> 命令即可显示当前工作目录的路径。</li></ul><p><strong>注意事项</strong></p><ul><li><code>pwd</code> 命令显示的是绝对路径，这有助于用户在文件系统中导航和操作时确认自己的位置。</li><li>在脚本中使用 <code>pwd</code> 可以获取当前工作目录路径，用于需要基于当前目录进行文件操作的场景。</li><li>不同的shell（如bash、zsh）默认提供内置的 <code>pwd</code> 命令，效果与独立的 <code>pwd</code> 程序相同。</li><li><code>pwd</code> 命令没有参数，因此非常简单直接，可以随时使用来确认当前目录。</li></ul><p><code>pwd</code> 是一个简单而实用的命令，特别是在复杂的目录结构中进行导航时，可以帮助用户始终了解自己所在的位置。</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p><strong>命令说明</strong>：<code>ls</code> 命令用于列出指定目录中的文件和目录。它是Linux系统中最常用的命令之一，用于查看目录内容。</p><p><strong>常用选项</strong></p><ul><li><code>-l</code>：使用长格式列出文件信息，包括权限、所有者、文件大小和修改时间。</li><li><code>-a</code>：显示所有文件，包括隐藏文件（以<code>.</code>开头的文件）。</li><li><code>-h</code>：与 <code>-l</code> 结合使用，以人类可读的格式显示文件大小（例如 KB、MB）。</li><li><code>-R</code>：递归列出子目录中的内容。</li><li><code>-t</code>：按修改时间排序。</li><li><code>-r</code>：逆序排列。</li><li><code>-S</code>：按文件大小排序。</li></ul><p><strong>注意事项</strong></p><ul><li><code>ls</code> 命令的输出可以通过管道传递给其他命令（如 <code>grep</code>）以进行进一步处理或筛选。</li><li><code>ls -l</code> 提供的详细信息对于检查文件权限和所有者非常有用。</li><li>使用 <code>ls -a</code> 可以查看包括隐藏文件在内的所有文件，适合在需要检查配置文件或隐藏目录时使用。</li><li><code>ls</code> 命令的输出在不同的终端和环境下可能会有所不同，可以通过别名或配置文件自定义输出格式。</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><strong>命令说明</strong>：<code>mkdir</code>（make directory）命令用于创建新的目录。</p><p><strong>常用选项</strong></p><ul><li><code>-p</code>：递归创建目录。如果上级目录不存在，会自动创建上级目录。</li><li><code>-v</code>：显示创建目录的详细信息。</li><li><code>-m mode</code>：设置新建目录的权限，使用八进制数表示，如 <code>mkdir -m 755 newdir</code>。</li></ul><p><strong>注意事项</strong></p><ul><li>确保指定的路径和目录名称是有效的，并且没有与现有文件或目录冲突。</li><li>使用 <code>-p</code> 选项创建目录时，可以一次创建多层目录，而无需手动逐层创建。</li><li>目录权限可以在创建时通过 <code>-m</code> 选项设置，也可以使用 <code>chmod</code> 命令在创建后进行修改。</li><li>在受限权限的环境中执行 <code>mkdir</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>命令说明</strong>：<code>rm</code>（remove）命令用于删除文件和目录。</p><p><strong>常用选项</strong></p><ul><li><code>-r</code> 或 <code>-R</code>：递归删除目录及其内容。</li><li><code>-f</code>：强制删除，不提示确认。</li><li><code>-i</code>：交互式删除，每次删除前询问确认。</li><li><code>-v</code>：显示删除过程的详细信息。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>-r</code> 或 <code>-R</code> 选项删除目录时，要特别小心，因为它会递归删除目录及其所有内容。</li><li><code>-f</code> 选项可以忽略不存在的文件错误，并强制删除文件，不建议随意使用以免误删重要文件。</li><li><code>-i</code> 选项在删除多个文件或目录时非常有用，可以防止意外删除重要文件。</li><li>删除操作是不可逆的，被删除的文件无法通过 <code>rm</code> 命令恢复，因此操作前应仔细确认。</li><li>在受限权限的环境中执行 <code>rm</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p><strong>命令说明</strong>：<code>rmdir</code> 命令用于删除空目录。与 <code>rm -r</code> 不同，<code>rmdir</code> 只能删除空目录，如果目录非空则会报错。</p><p><strong>常用选项</strong></p><ul><li><code>--ignore-fail-on-non-empty</code>：忽略非空目录的错误信息。</li><li><code>-p</code>：递归删除目录及其上级空目录。如果上级目录变为空目录，也会被删除。</li><li><code>-v</code>：显示删除过程的详细信息。</li></ul><p><strong>注意事项</strong></p><ul><li><code>rmdir</code> 只能删除空目录，尝试删除非空目录时会失败并报错。</li><li>使用 <code>-p</code> 选项时，可以方便地删除多个嵌套的空目录。</li><li>删除目录的操作是不可逆的，因此在执行删除操作前，务必确认目录内容和删除需求。</li><li>在需要删除非空目录时，应该使用 <code>rm -r</code> 命令而不是 <code>rmdir</code>。</li><li>在受限权限的环境中执行 <code>rmdir</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>命令说明</strong>：<code>mv</code>（move）命令用于移动或重命名文件和目录。</p><p><strong>常用选项</strong></p><ul><li><code>-i</code>：交互式操作，如果目标文件已存在，提示用户确认是否覆盖。</li><li><code>-f</code>：强制操作，如果目标文件已存在，直接覆盖而不提示。</li><li><code>-n</code>：不覆盖任何已存在的文件。</li><li><code>-v</code>：显示移动或重命名过程的详细信息。</li><li><code>-u</code>：仅在源文件比目标文件新或目标文件不存在时执行移动或重命名。</li></ul><p><strong>注意事项</strong></p><ul><li><code>mv</code> 命令可以用于重命名文件和目录，也可以用于在不同位置之间移动文件和目录。</li><li>使用 <code>-i</code> 选项可以避免意外覆盖文件，特别是在移动或重命名多个文件时。</li><li><code>-f</code> 选项会直接覆盖目标文件，因此使用时需要特别小心，以免丢失重要数据。</li><li>移动文件或目录时，<code>mv</code> 命令会保留原始文件的权限和属性。</li><li>在受限权限的环境中执行 <code>mv</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>命令说明</strong>：<code>cp</code>（copy）命令用于复制文件和目录。</p><p><strong>常用选项</strong></p><ul><li><code>-r</code> 或 <code>-R</code>：递归复制目录及其内容。</li><li><code>-i</code>：交互式操作，如果目标文件已存在，提示用户确认是否覆盖。</li><li><code>-f</code>：强制操作，如果目标文件已存在，直接覆盖而不提示。</li><li><code>-v</code>：显示复制过程的详细信息。</li><li><code>-u</code>：仅在源文件比目标文件新或目标文件不存在时执行复制。</li><li><code>-a</code>：归档模式，递归复制并保持所有文件属性，相当于 <code>-dR --preserve=all</code>。</li><li><code>-p</code>：保留文件的属性，如修改时间、访问权限等。</li><li><code>-n</code>：不覆盖任何已存在的文件。</li></ul><p><strong>注意事项</strong></p><ul><li><code>cp</code> 命令默认情况下只复制文件，如果要复制目录，需要使用 <code>-r</code> 或 <code>-R</code> 选项。</li><li>使用 <code>-i</code> 选项可以避免意外覆盖文件，特别是在复制多个文件时。</li><li><code>-f</code> 选项会直接覆盖目标文件，因此使用时需要特别小心，以免丢失重要数据。</li><li>复制文件或目录时，<code>cp</code> 命令会尝试保留原始文件的权限和属性，但可以使用 <code>-p</code> 选项来显式保留这些属性。</li><li>在受限权限的环境中执行 <code>cp</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p><strong>命令说明</strong>：<code>ln</code>（link）命令用于创建硬链接或符号链接（软链接）。</p><p><strong>常用选项</strong></p><ul><li><code>-s</code>：创建符号链接而不是硬链接。</li><li><code>-f</code>：强制创建链接，覆盖已存在的同名文件。</li><li><code>-v</code>：显示创建链接的详细信息。</li><li><code>-n</code>：在符号链接上创建链接而不是链接指向的文件。</li></ul><p><strong>注意事项</strong></p><ul><li>硬链接（默认）与符号链接（软链接）的区别：<ul><li>硬链接是文件在文件系统中的另一个名字，共享相同的inode，不能跨文件系统。</li><li>符号链接是一个指向文件或目录的路径名，可以跨文件系统，但如果目标文件被删除，符号链接会失效。</li></ul></li><li>使用 <code>-s</code> 选项可以创建符号链接，常用于快捷方式或引用文件。</li><li>使用 <code>-f</code> 选项时需要特别小心，以免覆盖重要文件。</li><li>创建链接时要确保目标文件或目录存在，否则会创建一个指向不存在路径的符号链接。</li><li>在受限权限的环境中执行 <code>ln</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><strong>命令说明</strong>：<code>find</code> 命令用于在指定目录及其子目录中搜索文件和目录，并执行指定的操作。它是功能非常强大的搜索工具。</p><p><strong>常用选项</strong></p><ul><li><code>-name pattern</code>：根据文件名搜索。</li><li><code>-iname pattern</code>：根据文件名搜索（忽略大小写）。</li><li><code>-type type</code>：根据文件类型搜索，例如 <code>-type f</code> 表示搜索普通文件，<code>-type d</code> 表示搜索目录。</li><li><code>-size n</code>：根据文件大小搜索，n 的格式可以是 +n、-n、n，其中 + 表示大于，- 表示小于，n 表示等于。</li><li><code>-mtime n</code>：根据文件的修改时间搜索，n 的格式与 <code>-size</code> 类似。</li><li><code>-user name</code>：根据文件所有者搜索。</li><li><code>-group name</code>：根据文件所属组搜索。</li><li><code>-exec command &#123;&#125; \;</code>：对搜索到的文件执行指定的命令，<code>&#123;&#125;</code> 代表当前文件。</li><li><code>-delete</code>：删除搜索到的文件（使用时要小心）。</li></ul><p><strong>注意事项</strong></p><ul><li>搜索范围可以通过在 <code>find</code> 命令后指定目录来限定，默认为当前目录及其子目录。</li><li>使用 <code>-exec</code> 选项时，确保命令末尾的 <code>\;</code> 不被漏掉，这是命令的结束标志。</li><li><code>find</code> 命令支持多种条件组合，可以通过逻辑操作符 <code>-and</code>、<code>-or</code>、<code>-not</code> 来组合复杂的搜索条件。</li><li>在大文件系统上执行 <code>find</code> 命令可能会比较慢，可以结合 <code>-maxdepth</code> 和 <code>-mindepth</code> 限制搜索深度以提高性能。</li><li>删除文件时，使用 <code>-delete</code> 选项需要特别小心，最好先通过其他选项确认要删除的文件列表。</li></ul><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p><strong>命令说明</strong>：<code>locate</code> 命令用于快速查找文件系统中的文件，基于一个预先构建的数据库来进行搜索。</p><p><strong>常用选项</strong></p><ul><li><code>-i</code>：忽略大小写进行搜索。</li><li><code>-r pattern</code>：使用正则表达式模式进行搜索。</li><li><code>-n number</code>：限制输出结果的数量。</li><li><code>-c</code>：仅显示匹配的条目数，而不显示实际条目。</li><li><code>-e</code>：只显示存在的文件，忽略已删除但数据库中仍有记录的文件。</li></ul><p><strong>注意事项</strong></p><ul><li><code>locate</code> 命令依赖于一个定期更新的数据库，该数据库通常由 <code>updatedb</code> 命令维护。默认情况下，这个数据库每天更新一次。</li><li>如果文件系统中的文件发生了变化，但数据库尚未更新，则 <code>locate</code> 可能会返回过时的结果。可以手动运行 <code>updatedb</code> 命令来更新数据库。</li><li><code>locate</code> 命令比 <code>find</code> 命令更快，因为它搜索的是预先索引的数据库，而不是实时遍历文件系统。</li><li><code>locate</code> 的搜索速度非常快，适用于快速查找文件路径，但不适合需要实时精确结果的场景。</li></ul><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p><strong>命令说明</strong>：<code>whereis</code> 命令用于查找系统中可执行文件、源代码文件和手册页的路径。</p><p><strong>常用选项</strong></p><ul><li><code>-b</code>：只查找二进制文件。</li><li><code>-m</code>：只查找手册页文件。</li><li><code>-s</code>：只查找源代码文件。</li><li><code>-B paths</code>：指定二进制文件的搜索路径。</li><li><code>-M paths</code>：指定手册页文件的搜索路径。</li><li><code>-S paths</code>：指定源代码文件的搜索路径。</li></ul><p><strong>注意事项</strong></p><ul><li><code>whereis</code> 命令的结果依赖于系统的目录结构和环境变量设置，特别是 <code>PATH</code> 环境变量。</li><li>在默认配置下，<code>whereis</code> 只查找标准位置的文件。如果某个文件被放在非标准目录中，可能需要使用 <code>-B</code>, <code>-M</code>, <code>-S</code> 等选项来指定搜索路径。</li><li><code>whereis</code> 命令适用于快速查找程序的二进制文件和关联的手册页、源代码路径，有助于系统管理员和开发者定位程序文件。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><strong>命令说明</strong>：<code>chmod</code>（change mode）命令用于更改文件或目录的访问权限。</p><p><strong>常用选项</strong></p><ul><li><code>-R</code>：递归更改目录及其内容的权限。</li><li><code>-v</code>：显示每个文件权限更改的详细信息。</li><li><code>-c</code>：仅在权限发生更改时显示信息。</li><li><code>--reference=FILE</code>：使用指定文件的权限设置来更改目标文件的权限。</li></ul><p><strong>注意事项</strong></p><ul><li>权限表示方式有两种：符号模式（如 u+r）和八进制模式（如 755）。<ul><li>符号模式：<code>u</code> 表示用户，<code>g</code> 表示组，<code>o</code> 表示其他，<code>a</code> 表示所有；<code>+</code> 添加权限，<code>-</code> 移除权限，<code>=</code> 设置权限。</li><li>八进制模式：每个数字分别表示用户、组和其他用户的权限，总共有三个数字，每个数字由读（4）、写（2）、执行（1）的和组成。</li></ul></li><li>在递归更改目录权限时，使用 <code>-R</code> 选项需要特别小心，以免误改不应更改的文件或目录权限。</li><li>修改权限时，应确保不会无意中授予过高权限，特别是在公共或多用户系统中，避免安全隐患。</li><li>可以使用 <code>ls -l</code> 命令查看文件和目录的当前权限，以确认修改结果。</li><li>在受限权限的环境中执行 <code>chmod</code> 可能需要管理员权限或特定用户权限。</li></ul><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><strong>命令说明</strong>：<code>chown</code>（change owner）命令用于更改文件或目录的所有者和/或所属组。</p><p><strong>常用选项</strong></p><ul><li><code>-R</code>：递归更改目录及其内容的所有者和/或组。</li><li><code>-v</code>：显示每个文件所有者和/或组更改的详细信息。</li><li><code>-c</code>：仅在所有者和/或组发生更改时显示信息。</li><li><code>--reference=RFILE</code>：使用指定文件的所有者和/或组来更改目标文件的所有者和/或组。</li><li><code>--preserve-root</code>：避免递归操作更改根目录 <code>/</code>。</li><li><code>--no-dereference</code>：只修改符号链接本身，而不修改其指向的目标文件。</li></ul><p><strong>注意事项</strong></p><ul><li>需要管理员权限（如使用 <code>sudo</code>）才能更改文件和目录的所有者和组。</li><li>格式：<code>chown [OPTION]... [OWNER][:[GROUP]] FILE...</code>。例如，<code>chown user:group file</code> 将文件的所有者更改为 <code>user</code>，所属组更改为 <code>group</code>。</li><li>可以单独更改所有者或组，如果只指定所有者（如 <code>chown user file</code>），则只更改所有者而不更改组。</li><li>使用 <code>-R</code> 选项递归更改目录及其内容时，需要特别小心，以免误改大量文件和目录的所有者和/或组。</li><li>确认所有者和组的变更可以使用 <code>ls -l</code> 命令查看文件和目录的当前所有者和组。</li></ul><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p><strong>命令说明</strong>：<code>chgrp</code>（change group）命令用于更改文件或目录的所属组。</p><p><strong>常用选项</strong></p><ul><li><code>-R</code>：递归更改目录及其内容的所属组。</li><li><code>-v</code>：显示每个文件所属组更改的详细信息。</li><li><code>-c</code>：仅在所属组发生更改时显示信息。</li><li><code>--reference=RFILE</code>：使用指定文件的所属组来更改目标文件的所属组。</li><li><code>--preserve-root</code>：避免递归操作更改根目录 <code>/</code>。</li></ul><p><strong>注意事项</strong></p><ul><li>更改文件和目录的所属组需要相应的权限，通常需要管理员权限（如使用 <code>sudo</code>）。</li><li>格式：<code>chgrp [OPTION]... GROUP FILE...</code>。例如，<code>chgrp group file</code> 将文件的所属组更改为 <code>group</code>。</li><li>使用 <code>-R</code> 选项递归更改目录及其内容时，需要特别小心，以免误改大量文件和目录的所属组。</li><li>确认所属组的变更可以使用 <code>ls -l</code> 命令查看文件和目录的当前组。</li><li>在更改所属组时，要确保目标组存在，否则命令会失败。</li></ul><h2 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><strong>命令说明</strong>：<code>zip</code> 命令用于压缩文件或目录，将其打包成 <code>.zip</code> 格式的压缩文件。</p><p><strong>常用选项</strong></p><ul><li><code>-r</code>：递归压缩目录及其内容。</li><li><code>-u</code>：更新已有的 <code>.zip</code> 文件，只压缩修改过或新增的文件。</li><li><code>-m</code>：将文件移动到 <code>.zip</code> 文件中，即压缩后删除原始文件。</li><li><code>-d</code>：从 <code>.zip</code> 文件中删除指定的文件。</li><li><code>-x</code>：排除指定的文件或目录。</li><li><code>-q</code>：静默模式，不显示压缩过程的详细信息。</li><li><code>-v</code>：显示压缩过程的详细信息。</li></ul><p><strong>注意事项</strong></p><ul><li>压缩文件时，<code>zip</code> 命令默认不会保留目录结构，使用 <code>-r</code> 选项可以递归压缩整个目录。</li><li>使用 <code>-m</code> 选项时，文件会在压缩后删除，使用时需谨慎，以免误删重要文件。</li><li>可以通过 <code>-x</code> 选项排除不需要压缩的文件或目录，例如：<code>zip -r archive.zip folder -x &quot;*.log&quot;</code> 排除所有 <code>.log</code> 文件。</li><li><code>zip</code> 命令支持对压缩包添加注释，可以使用 <code>-c</code> 选项来添加注释。</li><li><code>.zip</code> 文件可以跨平台使用，适用于不同操作系统间的文件传输。</li></ul><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p><strong>命令说明</strong>：<code>unzip</code> 命令用于解压缩 <code>.zip</code> 格式的压缩文件。</p><p><strong>常用选项</strong></p><ul><li><code>-d directory</code>：指定解压缩的目标目录。</li><li><code>-l</code>：列出 <code>.zip</code> 文件的内容，而不实际解压。</li><li><code>-t</code>：测试 <code>.zip</code> 文件的完整性，不进行解压。</li><li><code>-o</code>：覆盖已存在的文件而不提示。</li><li><code>-n</code>：不覆盖已存在的文件。</li><li><code>-j</code>：解压时不创建目录，将所有文件解压到当前目录。</li><li><code>-q</code>：静默模式，不显示解压过程的详细信息。</li><li><code>-v</code>：显示解压过程的详细信息。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>-d</code> 选项可以指定解压缩的目标目录，否则文件将解压到当前目录。</li><li><code>-l</code> 和 <code>-t</code> 选项非常有用，可以在实际解压前检查 <code>.zip</code> 文件的内容和完整性。</li><li>使用 <code>-o</code> 选项时要小心，因为它会覆盖现有文件，可能导致数据丢失。</li><li>使用 <code>-j</code> 选项时，所有文件将解压到一个目录中，可能会导致文件名冲突。</li><li>确保有足够的磁盘空间进行解压操作，特别是当解压大文件时。</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>命令说明</strong>：<code>tar</code>（tape archive）命令用于创建、维护、修改和提取文件存档。它是Unix和Linux系统中用于备份和分发文件的常用工具。</p><p><strong>常用选项</strong></p><ul><li><code>-c</code>：创建一个新的存档文件。</li><li><code>-x</code>：从存档文件中提取文件。</li><li><code>-f</code>：指定存档文件的名称，通常与 <code>-c</code> 或 <code>-x</code> 选项一起使用。</li><li><code>-v</code>：显示详细的操作过程。</li><li><code>-t</code>：列出存档文件的内容。</li><li><code>-z</code>：使用gzip压缩或解压缩存档文件。</li><li><code>-j</code>：使用bzip2压缩或解压缩存档文件。</li><li><code>-J</code>：使用xz压缩或解压缩存档文件。</li><li><code>-r</code>：向已有存档文件中追加文件。</li><li><code>-u</code>：仅将比存档中副本新的文件追加到存档中。</li><li><code>-C</code>：切换到指定目录再处理文件。</li></ul><p><strong>注意事项</strong></p><ul><li><code>tar</code> 命令常与压缩选项结合使用，例如 <code>-czf</code> 创建一个gzip压缩的存档文件，或 <code>-xzf</code> 提取一个gzip压缩的存档文件。</li><li>使用 <code>-v</code> 选项可以查看详细的操作过程，适用于确认哪些文件被处理。</li><li>提取文件时，使用 <code>-C</code> 选项可以指定解压后的目标目录，以避免解压文件散乱在当前目录中。</li><li>创建存档文件时，建议使用 <code>.tar.gz</code>、<code>.tar.bz2</code> 或 <code>.tar.xz</code> 扩展名，以指明使用的压缩方法。</li><li>操作大型存档文件时，确保有足够的磁盘空间和计算资源，以避免操作失败。</li></ul><h3 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h3><p><strong>命令说明</strong>：<code>bunzip2</code> 命令用于解压缩 <code>.bz2</code> 格式的文件。它是 <code>bzip2</code> 压缩格式的解压工具。</p><p><strong>常用选项</strong></p><ul><li><code>-c</code>：将解压后的内容输出到标准输出，而不是文件。</li><li><code>-k</code>：解压后保留原始的压缩文件。</li><li><code>-f</code>：强制解压文件，即使目标文件已存在也会覆盖。</li><li><code>-v</code>：显示解压缩过程的详细信息。</li><li><code>-q</code>：静默模式，不显示任何警告信息。</li><li><code>-t</code>：测试文件的完整性，而不解压。</li></ul><p><strong>注意事项</strong></p><ul><li>默认情况下，<code>bunzip2</code> 会删除原始的 <code>.bz2</code> 文件。如果希望保留原文件，请使用 <code>-k</code> 选项。</li><li>使用 <code>-f</code> 选项时要小心，因为它会覆盖现有的文件，可能导致数据丢失。</li><li>可以使用 <code>-c</code> 选项将解压后的内容重定向到其他文件或进行进一步处理，例如 <code>bunzip2 -c file.bz2 &gt; file</code>。</li><li><code>bunzip2</code> 只能处理单个文件，如果需要解压缩包含多个文件的归档，应先使用 <code>tar</code> 等工具将其提取。</li></ul><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p><strong>命令说明</strong>：<code>bzip2</code> 命令用于压缩文件，使用Burrows-Wheeler算法，生成 <code>.bz2</code> 格式的压缩文件。它通常用于高效地压缩单个文件。</p><p><strong>常用选项</strong></p><ul><li><code>-k</code>：压缩后保留原始文件。</li><li><code>-f</code>：强制压缩，即使目标文件已存在也会覆盖。</li><li><code>-v</code>：显示压缩过程的详细信息。</li><li><code>-q</code>：静默模式，不显示任何警告信息。</li><li><code>-t</code>：测试文件的完整性，而不压缩。</li><li><code>-d</code>：解压缩文件，相当于 <code>bunzip2</code>。</li><li><code>-z</code>：强制压缩，默认行为。</li><li><code>-1</code> 至 <code>-9</code>：设置压缩级别，<code>-1</code> 为最快速、最低压缩率，<code>-9</code> 为最慢速、最高压缩率（默认是 <code>-9</code>）。</li></ul><p><strong>注意事项</strong></p><ul><li>默认情况下，<code>bzip2</code> 会删除原始文件，并生成 <code>.bz2</code> 压缩文件。如果希望保留原文件，请使用 <code>-k</code> 选项。</li><li>使用 <code>-f</code> 选项时要小心，因为它会覆盖现有的文件，可能导致数据丢失。</li><li><code>bzip2</code> 主要用于压缩单个文件，如果需要压缩多个文件或目录，可以先使用 <code>tar</code> 创建归档，然后使用 <code>bzip2</code> 压缩，例如：<code>tar -cvf archive.tar folder &amp;&amp; bzip2 archive.tar</code>。</li><li>压缩和解压缩较大的文件时，确保有足够的磁盘空间和计算资源，以避免操作失败。</li></ul><h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p><strong>命令说明</strong>：<code>gunzip</code> 命令用于解压缩 <code>.gz</code> 格式的文件。它是 <code>gzip</code> 压缩格式的解压工具。</p><p><strong>常用选项</strong></p><ul><li><code>-c</code>：将解压后的内容输出到标准输出，而不是文件。</li><li><code>-k</code>：解压后保留原始的压缩文件。</li><li><code>-f</code>：强制解压文件，即使目标文件已存在也会覆盖。</li><li><code>-l</code>：列出 <code>.gz</code> 文件的压缩信息。</li><li><code>-r</code>：递归解压目录中的所有文件。</li><li><code>-v</code>：显示解压缩过程的详细信息。</li><li><code>-q</code>：静默模式，不显示任何警告信息。</li><li><code>-t</code>：测试文件的完整性，而不解压。</li></ul><p><strong>注意事项</strong></p><ul><li>默认情况下，<code>gunzip</code> 会删除原始的 <code>.gz</code> 文件。如果希望保留原文件，请使用 <code>-k</code> 选项。</li><li>使用 <code>-f</code> 选项时要小心，因为它会覆盖现有的文件，可能导致数据丢失。</li><li>可以使用 <code>-c</code> 选项将解压后的内容重定向到其他文件或进行进一步处理，例如 <code>gunzip -c file.gz &gt; file</code>。</li><li><code>gunzip</code> 只能处理单个文件，如果需要解压缩包含多个文件的归档，应先使用 <code>tar</code> 等工具将其提取。</li><li>对于较大的压缩文件，确保有足够的磁盘空间和计算资源，以避免解压过程失败。</li></ul><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>命令说明</strong>：<code>gzip</code> 命令用于压缩文件，生成 <code>.gz</code> 格式的压缩文件。它使用 Lempel-Ziv (LZ77) 压缩算法。</p><p><strong>常用选项</strong></p><ul><li><code>-c</code>：将压缩后的内容输出到标准输出，而不是文件。</li><li><code>-k</code>：压缩后保留原始文件。</li><li><code>-f</code>：强制压缩，即使目标文件已存在也会覆盖。</li><li><code>-l</code>：显示 <code>.gz</code> 文件的压缩信息。</li><li><code>-r</code>：递归压缩目录中的所有文件。</li><li><code>-v</code>：显示压缩过程的详细信息。</li><li><code>-q</code>：静默模式，不显示任何警告信息。</li><li><code>-t</code>：测试文件的完整性，而不压缩。</li><li><code>-d</code>：解压缩文件，相当于 <code>gunzip</code>。</li><li><code>-1</code> 至 <code>-9</code>：设置压缩级别，<code>-1</code> 为最快速、最低压缩率，<code>-9</code> 为最慢速、最高压缩率（默认是 <code>-6</code>）。</li></ul><p><strong>注意事项</strong></p><ul><li>默认情况下，<code>gzip</code> 会删除原始文件，并生成 <code>.gz</code> 压缩文件。如果希望保留原文件，请使用 <code>-k</code> 选项。</li><li>使用 <code>-f</code> 选项时要小心，因为它会覆盖现有的文件，可能导致数据丢失。</li><li><code>gzip</code> 主要用于压缩单个文件，如果需要压缩多个文件或目录，可以先使用 <code>tar</code> 创建归档，然后使用 <code>gzip</code> 压缩，例如：<code>tar -cvf archive.tar folder &amp;&amp; gzip archive.tar</code>。</li><li>压缩和解压缩较大的文件时，确保有足够的磁盘空间和计算资源，以避免操作失败。</li><li>使用 <code>-r</code> 选项递归压缩目录时，需要特别小心，以免误压缩大量文件和目录。</li></ul><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><p><strong>命令说明</strong>：<code>rpm</code>（Red Hat Package Manager）命令用于管理RPM包，提供安装、卸载、查询、验证和更新软件包的功能。它是Red Hat系Linux发行版的包管理工具。</p><p><strong>常用选项</strong></p><ul><li><code>-i</code>：安装一个新的RPM包。</li><li><code>-e</code>：卸载一个已安装的RPM包。</li><li><code>-U</code>：升级一个已有的RPM包，若未安装则进行安装。</li><li><code>-F</code>：仅升级已安装的RPM包。</li><li><code>-q</code>：查询已安装的RPM包。</li><li><code>-qa</code>：查询所有已安装的RPM包。</li><li><code>-ql</code>：列出一个已安装包中的文件列表。</li><li><code>-qf</code>：查询指定文件属于哪个RPM包。</li><li><code>-V</code>：验证一个已安装的RPM包。</li><li><code>-h</code>：显示安装或升级过程的进度条。</li><li><code>--prefix</code>：指定安装位置。</li></ul><p><strong>注意事项</strong></p><ul><li>安装或卸载RPM包时需要管理员权限，通常通过 <code>sudo</code> 运行。</li><li>使用 <code>-U</code> 选项升级包时，如果包不存在会进行安装，因此对于升级和安装通用。</li><li><code>-q</code> 选项可以结合其他选项使用，查询特定包的信息，例如 <code>rpm -q package_name</code> 查询包是否已安装。</li><li>使用 <code>-V</code> 选项验证包时，可以检查包中的文件是否被修改或损坏。</li><li>安装和卸载RPM包时，需要注意包之间的依赖关系，手动安装可能会遇到依赖性问题，建议使用 <code>yum</code> 或 <code>dnf</code> 这类高层工具来自动处理依赖关系。</li><li>可以通过 <code>rpm2cpio</code> 将RPM包转换为cpio归档，然后解压以查看其内容而不进行安装。</li></ul><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p><strong>命令说明</strong>：<code>yum</code>（Yellowdog Updater, Modified）命令是基于RPM的包管理工具，用于在Red Hat系Linux发行版中自动化处理软件包的安装、更新、删除和依赖关系管理。</p><p><strong>常用选项</strong></p><ul><li><code>install</code>：安装一个或多个软件包，例如 <code>yum install package_name</code>。</li><li><code>update</code>：更新所有已安装的软件包或指定的软件包，例如 <code>yum update</code> 或 <code>yum update package_name</code>。</li><li><code>remove</code>：删除一个或多个软件包及其依赖，例如 <code>yum remove package_name</code>。</li><li><code>search</code>：搜索软件包的名称、描述和摘要中包含指定关键字的软件包，例如 <code>yum search keyword</code>。</li><li><code>info</code>：显示一个或多个软件包的详细信息，例如 <code>yum info package_name</code>。</li><li><code>list</code>：列出软件包，例如 <code>yum list installed</code> 列出已安装的软件包，<code>yum list available</code> 列出可用的软件包。</li><li><code>clean</code>：清理缓存，例如 <code>yum clean all</code> 清理所有缓存。</li><li><code>repolist</code>：列出所有启用的仓库，例如 <code>yum repolist</code>。</li></ul><p><strong>注意事项</strong></p><ul><li>使用 <code>yum</code> 命令需要管理员权限，通常通过 <code>sudo</code> 运行。</li><li><code>yum</code> 命令自动处理软件包的依赖关系，确保所需的依赖包也一并安装或删除。</li><li><code>yum</code> 的配置文件通常位于 <code>/etc/yum.conf</code>，仓库配置文件位于 <code>/etc/yum.repos.d/</code> 目录下，可以在这些文件中配置和管理软件仓库。</li><li>使用 <code>yum clean all</code> 命令清理缓存可以释放磁盘空间，特别是在进行大规模更新或安装后。</li><li><code>yum</code> 提供了插件机制，可以通过安装和配置插件扩展 <code>yum</code> 的功能。</li><li><code>yum</code> 命令的输出信息较为详细，可以通过阅读输出信息了解每个操作的具体细节。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为Linux用户提供了一个全面的命令参考，无论是新手还是有经验的系统管理员，都可以从中找到实用信息。掌握这些命令将有助于提高工作效率，优化系统性能，并确保系统安全稳定运行。未来，随着Linux系统的不断更新和命令的增加，本文也将持续更新，以提供最新最全的命令使用指南。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>命令手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>关于ArrayList循环删除元素的坑</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="ArrayList遍历删除"><a href="#ArrayList遍历删除" class="headerlink" title="ArrayList遍历删除"></a>ArrayList遍历删除</h2><p>初始化需要用到的ArrayList，<strong>注意，此处list当中有两个 2 元素</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">static</span> &#123;<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    list.add(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>ArrayList的遍历删除分为4种：</strong></p><h3 id="普通for循环删除"><a href="#普通for循环删除" class="headerlink" title="普通for循环删除"></a>普通for循环删除</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFori</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (list.get(i) == <span class="hljs-number">2</span>) &#123;<br>            list.remove(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>    System.out.println(list);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>控制台输出如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[1, 2, 3, 4, 5]<br></code></pre></div></td></tr></table></figure><p>查看remove源码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    modCount++;<br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>list当中还保留了一个元素2，因为在删除第一个2以后，list大小发生了变化，而根据索引访问的下标为2的元素时，就访问到了3，第二个2向前推进了1位，<strong>所以普通for循环不适合删除多个满足条件的元素</strong>！</p><h3 id="增强for循环删除"><a href="#增强for循环删除" class="headerlink" title="增强for循环删除"></a>增强for循环删除</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>        <span class="hljs-keyword">if</span> (integer % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) list.remove(integer);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果普通for循环会留巨坑，那么增强for循环相对好点，因为他直接给你报错了，不会留坑</p><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925214941792.png"></p><h3 id="通过迭代器删除"><a href="#通过迭代器删除" class="headerlink" title="通过迭代器删除"></a>通过迭代器删除</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;<br>    Iterator&lt;Integer&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (iterator.next() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            iterator.remove();<br>        &#125;<br>    &#125;<br>    System.out.println(list);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925214947452.png"></p><p>通过迭代器的remove方法可以正确删除满足条件的元素</p><h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf"></a>removeIf</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>    list.removeIf(integer -&gt; integer % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://picgo-1304850123.cos.ap-guangzhou.myqcloud.com/image-20220925214953642.png"></p><p>removeIf方法，传入一个判断型表达式Predicate&lt;? super E&gt;，也可以正确删除元素</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>普通for循环的原理已讲过，这里重点分析增强for循环和迭代器删除的区别</p><p>For-Each基于内部迭代器Itr的hasNext和next()，源码如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">int</span> i = cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);<br>            cursor = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br>        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; consumer)</span> </span>&#123;<br>        Objects.requireNonNull(consumer);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = ArrayList.<span class="hljs-keyword">this</span>.size;<br>        <span class="hljs-keyword">int</span> i = cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;<br>            consumer.accept((E) elementData[i++]);<br>        &#125;<br>        <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span><br>        cursor = i;<br>        lastRet = i - <span class="hljs-number">1</span>;<br>        checkForComodification();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意属性expectedModCount，初始化赋值为ArrayList的属性值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> expectedModCount = modCount;<br></code></pre></div></td></tr></table></figure><p>modCount理解为ArrayList对象的修改次数</p><p><code>每次调用next方法都会先调用checkForComodification，检查Itr内部的expectedModCount和ArrayList的modCount是否一致，不一致则抛出ConcurrentModificationException</code></p><p>再看增强for循环删除元素调用的remove方法源码，<code>注意：这里的remove为ArrayList的remove</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>fastRemove</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    modCount++;<br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>fastRemove中修改了ArrayList的属性modCount，让其自增，但是此时Itr内部的expectedModCount并没有修改，所以在执行了本次循环之后进入下一次循环（调用next），**<code>modCount != expectedModCount</code>**，即抛出了ConcurrentModificationException。</p><p>而采用迭代器删除元素，即Itr的remove方法，是不会改变ArrayList的modCount，此时expectedModCount = modCount是成立的，所以checkForComodification并不会抛出异常，<strong>这就是iterator的remove和list的remove的区别！</strong></p><p>顺便看看removeIf的内部实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> E&gt; filter)</span> </span>&#123;<br>    Objects.requireNonNull(filter);<br>    <span class="hljs-comment">// figure out which elements are to be removed</span><br>    <span class="hljs-comment">// any exception thrown from the filter predicate at this stage</span><br>    <span class="hljs-comment">// will leave the collection unmodified</span><br>    <span class="hljs-keyword">int</span> removeCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> BitSet removeSet = <span class="hljs-keyword">new</span> BitSet(size);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">final</span> E element = (E) elementData[i];<br>        <span class="hljs-keyword">if</span> (filter.test(element)) &#123;<br>            removeSet.set(i);<br>            removeCount++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br><br>    <span class="hljs-comment">// shift surviving elements left over the spaces left by removed elements</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> anyToRemove = removeCount &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (anyToRemove) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newSize = size - removeCount;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;<br>            i = removeSet.nextClearBit(i);<br>            elementData[j] = elementData[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=newSize; k &lt; size; k++) &#123;<br>            elementData[k] = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// Let gc do its work</span><br>        &#125;<br>        <span class="hljs-keyword">this</span>.size = newSize;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        &#125;<br>        modCount++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> anyToRemove;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先拿到modCount并赋值给expectedModCount，再修改ArrayList的内部数组elementData，修改期间检查expectedModCount与modCount是否相等，由此决定是否抛出ConcurrentModificationException。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>ArrayList删除元素需使用适合的方法，使用错误的方法可能会造成不必要的麻烦。<br>​</p><center>【END】</center>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul><li>一个在广州漂泊的Java程序猿</li><li>2022年毕业于广东技术师范大学</li><li>宅，是我朋友给我打的标签，散步和跑步是我为数不多的运动</li><li>平时喜欢鼓捣一些小玩意，比如这个博客网站</li><li>喜欢听周杰伦的歌</li><li>容易上头，比如你看到的这段话写于凌晨5点23分</li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul><li>打工人：目前在用友汽车工作</li><li>求知者：学习，使我快乐 ^_^</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>茫茫人海中，相见即是缘分，欢迎你的到来</li><li>希望我的文章对你有所帮助，文章的不足或错误也希望你能帮我指出，感谢 ~</li></ul>]]></content>
    
  </entry>
  
  
  
</search>
